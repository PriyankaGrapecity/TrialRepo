(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define(factory);
	else if(typeof exports === 'object')
		exports["Views"] = factory();
	else
		root["GcSpread"] = root["GcSpread"] || {}, root["GcSpread"]["Views"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	    var Event = __webpack_require__(1).Event;
	    var GridLayoutEngine = __webpack_require__(6);
	    //var collections = require('./collectionView');
	    var domUtil = __webpack_require__(2);
	    var gcUtils = __webpack_require__(3);
	    var TouchWrapper = __webpack_require__(4);
	    var editingHandler = __webpack_require__(5);
	    var MAXSCROLLABLEVERTICALOFFSET = 100;
	    var MAXFEEDBACKOFFSET = 40;
	    var touchStatus;
	    var inertialMoveStatus;
	    var inertialMovetimeSpan = 16;
	    var instancesByReactRootID = {};
	    var scrollPanelZIndexchanged = false;
	
	    var VIEWPORT = 'viewport';
	    var PINNED_VIEWPORT = 'pinnedLeftViewport';
	    var PINNED_RIGHT_VIEWPORT = 'pinnedRightViewport';
	    var GROUP_HEADER = 'groupHeader';
	    var GROUP_FOOTER = 'groupFooter';
	    var GROUP_CONTENT = 'groupContent';
	
	    var Calc = __webpack_require__(7);
	    var collections = Calc.Collections;
	    //for IE9
	    if (window && !window.requestAnimationFrame) {
	        var lastTime_ = 0;
	        window.requestAnimationFrame = function(callback) {
	            var currTime = new Date().getTime();
	            var timeToCall = Math.max(0, 16 - (currTime - lastTime_));
	            window.setTimeout(function() {
	                    callback();
	                },
	                timeToCall);
	            lastTime_ = currTime + timeToCall;
	        };
	    }
	
	    if (window && (typeof window.CustomEvent) !== 'function') {
	        window.CustomEvent = function(event, params) {
	            var evt;
	            params = params || {
	                    bubbles: false,
	                    cancelable: false,
	                    detail: undefined
	                };
	            evt = document.createEvent('CustomEvent');
	            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
	            return evt;
	        };
	    }
	
	    /**
	     * Create a new instance of grid model.
	     * @param {Element} container Container node the grid will attached
	     * @param {Array} data An array of objects for grid model.
	     * @param {Array|Object} config An array of column definitions or a JSON object used to deserilze the grid
	     * @param {(Grid.LayoutEngine|Object)} options An layoutEngine instance or options object which will be used to initialise a Grid.GridLayoutEngine instance
	     * @constructor
	     */
	    var GcGrid = function(container, data, config, options) {
	        if (!container) {
	            throw new Error('GcGrid need a valid container to host');
	        }
	
	        var self = this;
	        var uid = Math.round(1000000 * Math.random());
	        self.uid = 'gc-' + uid;
	        instancesByReactRootID[uid] = this;
	
	        self.container = container;
	
	        var jsonObject;
	        if (config && !gcUtils.isUndefined(config.version)) {
	            jsonObject = gcUtils.deserializeObject(config);
	            self.columnsConfig_ = jsonObject.columns;
	            self.columns = self.flatternColumns_(self.columnsConfig_);
	        } else {
	            self.columnsConfig_ = config;
	            //will be initialized during layout engine initialization
	            self.columns = config ? self.flatternColumns_(config) : _.map(_.keys((data && data[0]) || []), function(key) {
	                return {
	                    id: key,
	                    caption: key,
	                    dataField: key
	                };
	            });
	
	            //add remaining data properties as hidden column
	            var tempCol;
	            _.each(_.keys((data && data[0]) || []), function(key) {
	                if (!getColByDataField_.call(self, key)) {
	                    tempCol = {
	                        id: key,
	                        caption: key,
	                        dataField: key,
	                        visible: false,
	                        width: 80
	                    };
	                    self.columns.push(tempCol);
	                    if (self.columnsConfig_) {
	                        self.columnsConfig_.push(tempCol);
	                    }
	                }
	            });
	
	            if (config) {
	                self.colTree_ = {};
	                buildColumnDefTree_(config, null, self.colTree_);
	            } else {
	                self.columnsConfig_ = self.columns;
	            }
	        }
	
	        self.data = new collections.CalcCollection(data, _.map(self.columns, function(column) {
	            return {name: column.id, field: column.dataField};
	        }));
	
	        var i;
	        var length;
	        if (self.data.itemCount) {
	            var item = self.data.sourceCollection[0];
	            if (item) {
	                var cols = self.columns;
	                var col;
	                for (i = 0, length = cols.length; i < length; i++) {
	                    col = cols[i];
	                    if (!col.dataType && col.dataField) {
	                        col.dataType = gcUtils.getType(item[col.dataField]);
	                    }
	                }
	            }
	        }
	
	        self.onMouseClick = new Event();
	        self.onMouseDbClick = new Event();
	        self.onMouseDown = new Event();
	        self.onMouseUp = new Event();
	        self.onMouseMove = new Event();
	        self.onMouseWheel = new Event();
	        self.onKeyDown = new Event();
	        self.editing = new Event();
	        self.onTouchStart_ = new Event();
	        self.onTouchMove_ = new Event();
	        self.onTouchEnd_ = new Event();
	        //When I prevent mouse event while process touch event.it works well on chrome but also fire native click event on IE.
	        //so I only fire tap event on chrome. -Tim
	        self.onTap_ = new Event();
	        self.onSwipe_ = new Event();
	        //in fact,touch scroll is handled by grid.But in some case, it needs chance to clear cache data.
	        self.onTouchScroll_ = new Event();
	
	        self.onScrollOver_ = new Event();
	
	        if (jsonObject) {
	            self.layoutEngine = getLayoutEngine_(jsonObject.layoutEngine);
	        } else {
	            var name = options && options.name;
	            self.layoutEngine = (name && gcUtils.isString(name) && name.length > 12 && name.slice(-12).toLowerCase() === 'layoutengine') ? options : new GridLayoutEngine(_.defaults(options || {}, {allowEditing: false}));
	        }
	
	        self.options = self.layoutEngine.options;
	        var defaultTemplate = self.options.rowTemplate;
	        Object.defineProperty(self.options, 'rowTemplate', {
	            get: function() {
	                return defaultTemplate;
	            },
	            set: function(newValue) {
	                if (defaultTemplate !== newValue) {
	                    //it's usually change the template during layout/group strategy changed
	                    //as the result, the size of the template maybe different and column size may changed
	                    defaultTemplate = newValue;
	                    self.layoutEngine.handleTemplateChange_();
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        self.init();
	
	        self.scrollOffset = self.getInitialScrollOffset();
	
	        //create render components
	        //render each components
	        self.scrollableElements_ = [];
	        self.lastRenderedRows_ = {};
	
	        buildDomTree_.call(self);
	        //cache the event handlers since .bind will create a new function.
	        self.handleClickFn_ = handleClick.bind(self);
	        self.handleDbClickFn_ = handleDoubleClick.bind(self);
	        self.handleMouseDownFn_ = handleMouseDown.bind(self);
	        self.handleMouseMoveFn_ = handleMouseMove.bind(self);
	        self.handleMouseUpFn_ = handleMouseUp.bind(self);
	        self.handleKeyDownFn_ = handleKeyDown.bind(self);
	        self.handleWheelFn_ = handleMouseWheel.bind(self);
	        self.handleScrollFn_ = handleScroll_.bind(self);
	        self.handleWindowResizeFn_ = handleWindowResize_.bind(self);
	        self.handleTouchStartFn_ = handleTouchStart_.bind(self);
	        self.handleTouchMoveFn_ = handleTouchMove_.bind(self);
	        self.handleTouchEndFn_ = handleTouchEnd_.bind(self);
	        self.handleInertiaMoveFn_ = handleInertiaMove_.bind(self);
	        self.changeScrollPanelZIndexFn_ = changeBackScrollPanelZIndex.bind(self);
	        self.handleDebounceMouseWheelFn_ = _.debounce(self.changeScrollPanelZIndexFn_, 500);
	        self.handleScrollOverFn_ = handleScollOver_.bind(self);
	        self.handleDebounceScrollOverFn_ = _.debounce(self.handleScrollOverFn_, 200);
	        self.isTouchMode = window.PointerEvent || window.MSPointerEvent || ('ontouchstart' in document.documentElement);
	        registerEvents_.call(this);
	    };
	
	    GcGrid.prototype = {
	        init: function() {
	            var self = this;
	            //adjust self.container
	            //parse column expresion, formatters here
	
	            self.colFormatters_ = {};
	            if (!gcUtils.isUndefinedOrNull(GcGrid)) {
	                self.ExcelFormatter_ = GcGrid.Plugins && GcGrid.Plugins.Formatter && GcGrid.Plugins.Formatter.ExcelFormatter;
	            }
	            _.each(self.columns, function(col) {
	                if (col && col.format) {
	                    var formatter = col.format;
	                    var colId = col.id;
	                    if (gcUtils.isString(formatter) && self.ExcelFormatter_) {
	                        self.colFormatters_[colId] = new self.ExcelFormatter_(formatter);
	                    } else if (gcUtils.isFunction(formatter)) {
	                        self.colFormatters_[colId] = formatter;
	                    }
	                }
	            });
	
	            self.data.getDefaults = function() {
	                return {
	                    group: self.layoutEngine.getGroupInfoDefaults_()
	                };
	            };
	
	            if (self.options.filterExpression) {
	                self.data.filterExpression = self.options.filterExpression;
	            }
	
	            if (self.options.sorting) {
	                var sortDescriptors = _.clone(self.options.sorting, true);
	                _.remove(sortDescriptors, function(sortInfo) {
	                    return gcUtils.isUndefinedOrNull(sortInfo.ascending);
	                });
	                self.data.sortDescriptors = sortDescriptors;
	            }
	
	            if (self.options.grouping) {
	                self.data.groupDescriptors = self.options.grouping;
	            }
	
	            if (self.options.hierarchyDescriptor) {
	                self.data.hierarchyDescriptor = self.options.hierarchyDescriptor;
	            }
	
	            editingHandler.init(self);
	            self.editingHandler = editingHandler;
	            self.layoutEngine.init(self);
	
	            updateGroupStrategy_.call(self);
	
	            if (self.options.groupable || self.data.groups) {
	                self.groupInfos_ = [];
	                self.updateGroupInfos_();
	            }
	
	            var i;
	            var length;
	            var col;
	
	            initBuildInActions_.call(self);
	            self.columnActions_ = {};
	            for (i = 0, length = self.columns.length; i < length; i++) {
	                col = self.columns[i];
	                if (col.action) {
	                    self.columnActions_[col.id] = _.map(gcUtils.isArray(col.action) ? col.action : [col.action], createColumnAction_.bind(self));
	                }
	            }
	
	            initCE_.call(self);
	        },
	        //TODO: remove getDataItem later
	        //getDataItem2_: function(group, row) {
	        //    return this.getDataItem(group ? group.itemMappings[row] : row);
	        //},
	
	        getDataItem: function(row) {
	            var self = this;
	            var data = self.data;
	            if (!data) {
	                return null;
	            }
	            if (row === -1) {
	                return null;
	            }
	            return data.getItem(row);
	        },
	
	        getFormattedDataItem: function(row) {
	            var self = this;
	            var dataItem = self.getDataItem(row);
	            return self.formatDataItem(dataItem);
	        },
	
	        formatDataItem: function(dataItem) {
	            var self = this;
	            var result = {};
	            var i;
	            var len;
	            var col;
	            for (i = 0, len = self.columns.length; i < len; i++) {
	                col = self.columns[i];
	                if (col) {
	                    var prop;
	                    var value;
	                    var field = col.dataField;
	                    if (gcUtils.isString(field)) {
	                        if (col.isCalcColumn_) {  // calculated column
	                            prop = col.id;
	                            value = dataItem[prop];
	                        } else { // bound column
	                            if (field.split(',').length === 1) {
	                                prop = col.dataField;
	                                value = dataItem[prop];
	                            }
	                        }
	                    }
	                    if (prop) {
	                        var colFormatter = self.colFormatters_[col.id];
	                        if (colFormatter) {
	                            if (self.ExcelFormatter_ && (colFormatter instanceof self.ExcelFormatter_)) {
	                                result[prop] = colFormatter.format(value);
	                            } else if (gcUtils.isFunction(colFormatter)) {
	                                result[prop] = colFormatter({value: value, item: dataItem, colDef: col});
	                            }
	                        } else {
	                            result[prop] = value;
	                        }
	                    }
	                }
	            }
	            if (dataItem.node) {
	                result.node = dataItem.node;
	            }
	            return result;
	        },
	
	        /**
	         * get the layout info
	         */
	        getLayoutInfo: function() {
	            return this.layoutEngine.getLayoutInfo();
	        },
	
	        getRenderInfo: function(option) {
	            return this.layoutEngine.getRenderInfo(option);
	        },
	
	        showScrollPanel: function(area) {
	            return this.layoutEngine.showScrollPanel(area);
	        },
	
	        isScrollableArea_: function(area) {
	            return this.layoutEngine.isScrollableArea_(area);
	        },
	
	        getScrollPanelRenderInfo: function(area) {
	            return this.layoutEngine.getScrollPanelRenderInfo(area);
	        },
	
	        getInitialScrollOffset: function() {
	            if (this.layoutEngine.getInitialScrollOffset) {
	                return this.layoutEngine.getInitialScrollOffset();
	            } else {
	                return {
	                    top: 0,
	                    left: 0
	                };
	            }
	        },
	
	        //
	        //handleEditingKeyDown: function(e) {
	        //    var self = this;
	        //    var Key = gcUtils.Key;
	        //    switch (e.keyCode) {
	        //        case Key.Up:
	        //        case Key.Down:
	        //        case Key.Left:
	        //        case Key.Right:
	        //        case Key.PageUp:
	        //        case Key.PageDown:
	        //        case Key.Home:
	        //        case Key.End:
	        //            if (!self.isFullEdit) {
	        //                self.stopCellEditing();
	        //                return;
	        //            }
	        //            break;
	        //        default:
	        //            self.trigger_(self.cellEditing, {
	        //                row: self.activeRow,
	        //                col: self.activeColumn,
	        //                editingText: self.currentEditor.getValue()
	        //            });
	        //    }
	        //},
	        //
	        //handleActiveCellPositionChange: function() {
	        //    var self = this;
	        //    if (!self.activeCellNode) {
	        //        return;
	        //    }
	        //    if (self.currentEditor) {
	        //        if (!domUtil.contains(self.container, self.activeCellNode)) {
	        //            self.stopCellEditing();
	        //            return;
	        //        }
	        //        if (self.currentEditor.args.position) {
	        //            var cellNodeOffset = domUtil.offset(self.activeCellNode);
	        //            var gridOffset = domUtil.offset(self.container);
	        //            self.currentEditor.args.position = {
	        //                top: cellNodeOffset.top - gridOffset.top,
	        //                left: cellNodeOffset.left - gridOffset.left
	        //            };
	        //        }
	        //    }
	        //},
	
	        destroy: function() {
	            var self = this;
	
	            unRegisterEvents_.call(this);
	
	            //TODO: destroy stuffs if needed.
	            editingHandler.destroy(self);
	            if (self.layoutEngine) {
	                self.layoutEngine.destroy();
	                self.layoutEngine = null;
	            }
	
	            self.container.removeChild(document.getElementById(self.uid));
	            delete instancesByReactRootID[self.uid.slice(3)];
	            self.columnActions_ = null;
	        },
	
	        updateGroupInfos_: function() {
	            var self = this;
	            var data = self.data;
	            if (data.groups === null) {
	                self.groupInfos_ = null;
	            } else {
	                var i;
	                var len;
	                self.groupInfos_ = self.groupInfos_ || [];
	                self.groupInfos_.length = 0;
	                if (data.groups) {
	                    for (i = 0, len = data.groups.length; i < len; i++) {
	                        self.groupInfos_.push(createGroupInfo_.call(this, data.groups[i], [i]));
	                    }
	                    self.layoutEngine.initGroupInfosHeight_();
	                }
	            }
	        },
	
	        updateTemplate_: function() {
	            var layoutEngine = this.layoutEngine;
	            layoutEngine.clearRenderCache_();
	        },
	
	        /**
	         * Invalidate entire control.
	         * @param {boolean} rebuildDOMTree  rebuild entire DOM tree or not. If it's true,
	         * it will remove the old DOM tree and insert a new one, otherwise, it will update old
	         * DOM tree container and refresh each layout area.
	         * The default value is true.
	         */
	        invalidate: function(rebuildDOMTree) {
	            var self = this;
	            var scrollPanel;
	            var layoutEngine = self.layoutEngine;
	            self.containerInfo_ = null;
	            layoutEngine.clearRenderCache_();
	            updateGroupStrategy_.call(self);
	            self.updateGroupInfos_();
	
	            if (gcUtils.isUndefinedOrNull(rebuildDOMTree)) {
	                rebuildDOMTree = true;
	            }
	            rebuildDOMTree = !!rebuildDOMTree;
	
	            if (rebuildDOMTree) {
	                //clear render cache
	                self.lastRenderedRows_ = {};
	                unRegisterScrollEvent_.call(self);
	                buildDomTree_.call(self);
	                var initScrollOffset = layoutEngine.getInitialScrollOffset();
	                if (self.scrollOffset.top !== initScrollOffset.top) {
	                    scrollPanel = domUtil.getElement('#' + self.uid + ' .gc-grid-viewport-scroll-panel.scroll-top');
	                    if (scrollPanel) {
	                        scrollPanel.scrollTop = self.scrollOffset.top;
	                    }
	                }
	                if (self.scrollOffset.left !== initScrollOffset.left) {
	                    scrollPanel = domUtil.getElement('#' + self.uid + ' .gc-grid-viewport-scroll-panel.scroll-left');
	                    if (scrollPanel) {
	                        scrollPanel.scrollLeft = self.scrollOffset.left;
	                    }
	                }
	                registerScrollEvent_.call(this);
	                return;
	            }
	
	            var element;
	            var renderInfo;
	            var selector;
	            var layoutIno = self.getLayoutInfo();
	            _.keys(layoutIno).map(function(area) {
	                //update scroll container
	                if (self.showScrollPanel(area)) {
	                    selector = self.uid + '-' + area + '-scroll';
	                    element = document.getElementById(selector);
	                    renderInfo = self.getScrollPanelRenderInfo(area);
	                    if (renderInfo) {
	                        if (element) {
	                            element.style.cssText = gcUtils.createMarkupForStyles(renderInfo.outerDivStyle);
	                            if (element.childNodes.length > 0) {
	                                element.childNodes[0].style.cssText = gcUtils.createMarkupForStyles(renderInfo.innerDivStyle);
	                            }
	                        } else {
	                            var id = self.uid + '-' + area + '-scroll';
	                            self.scrollableElements_.push(id);
	                            var html = '<div id="' + id + '" class="' + renderInfo.outerDivCssClass + '"';
	                            if (renderInfo.outerDivCssClass) {
	                                html += ' style="' + gcUtils.createMarkupForStyles(renderInfo.outerDivStyle) + '"';
	                            }
	                            html += '><div';
	                            if (renderInfo.innerDivStyle) {
	                                html += ' style="' + gcUtils.createMarkupForStyles(renderInfo.innerDivStyle) + '"';
	                            }
	                            html += '></div></div>';
	                            var scrollBarElement = domUtil.createElement(html);
	                            var parentNode = document.querySelector('#' + self.uid + ' .gc-grid-container');
	                            parentNode.insertBefore(scrollBarElement, parentNode.firstElementChild);
	                        }
	                    }
	                } else {
	                    selector = self.uid + '-' + area + '-scroll';
	                    element = document.getElementById(selector);
	                    if (element) {
	                        renderInfo = self.getScrollPanelRenderInfo(area);
	                        if (renderInfo) {
	                            element.style.cssText = gcUtils.createMarkupForStyles(renderInfo.outerDivStyle);
	                            if (element.childNodes.length > 0) {
	                                element.childNodes[0].style.cssText = gcUtils.createMarkupForStyles(renderInfo.innerDivStyle);
	                            }
	                        }
	                    }
	                }
	                //update container
	                renderInfo = self.getRenderInfo({
	                    area: area,
	                    offsetTop: self.scrollOffset.top,
	                    offsetLeft: self.scrollOffset.left,
	                    includeRows: false
	                });
	                if (renderInfo) {
	                    selector = self.uid + '-' + area;
	                    element = document.getElementById(selector);
	                    element.style.cssText = gcUtils.createMarkupForStyles(renderInfo.outerDivStyle);
	                    selector += '-inner';
	                    element = document.getElementById(selector);
	                    if (element) {
	                        element.style.cssText = gcUtils.createMarkupForStyles(renderInfo.innerDivStyle);
	                    }
	                }
	            });
	            //update container and clear cached items
	            _.keys(layoutIno).map(function(area) {
	                self.refresh(area);
	            });
	        },
	
	        /**
	         * Refresh the specified part of the grid.
	         * @param {string} area Which part needs to be refresh
	         * /
	         //*/
	        refresh: function(area) {
	            var self = this;
	            var rows;
	            var i;
	            var len;
	            var renderRange = self.layoutEngine.getRenderRange_({
	                area: area,
	                offsetTop: self.scrollOffset.top,
	                offsetLeft: self.scrollOffset.left
	            });
	
	            var innerElement = document.getElementById(self.uid + '-' + area + '-inner');
	            if (renderRange) {
	                setTransform(innerElement, renderRange.left, renderRange.top);
	            }
	            if (renderRange) {
	                rows = renderRange.renderedRows || [];
	                var lastRenderedRows = self.lastRenderedRows_[area];
	                var newRenderedRows = _.pluck(rows, 'key');
	                var operations = findMinimumOperations_(lastRenderedRows, newRenderedRows);
	                var info;
	                var key;
	                //var style;
	                //var element;
	                var div = document.createElement('div');
	                var op;
	                for (i = 0, len = operations.length; i < len; i++) {
	                    op = operations[i];
	                    switch (op.operation) {
	                        case 'insert':
	                            key = findRow(rows, op.item);
	                            info = self.layoutEngine.getRenderRowInfo_(key, area);
	                            div.innerHTML = self.renderRow_(info);
	                            innerElement.appendChild(div.childNodes[0]);
	                            break;
	                        case 'delete':
	                            key = lastRenderedRows[op.index];
	                            innerElement.removeChild(document.getElementById(key));
	                            break;
	                        case 'update':
	                            key = findRow(rows, lastRenderedRows[op.index]);
	                            info = self.layoutEngine.getRenderRowInfo_(key, area);
	                            div.innerHTML = self.renderRow_(info);
	                            innerElement.replaceChild(div.childNodes[0], document.getElementById(key.key));
	                            break;
	                        case 'replace':
	                            var oldItemKey = lastRenderedRows[op.index[0]];
	                            var newItemKey = findRow(rows, newRenderedRows[op.index[1]]);
	                            info = self.layoutEngine.getRenderRowInfo_(newItemKey, area);
	                            div.innerHTML = self.renderRow_(info);
	                            innerElement.replaceChild(div.childNodes[0], document.getElementById(oldItemKey));
	                            break;
	                    }
	                }
	
	                self.lastRenderedRows_[area] = newRenderedRows;
	                div = null;
	            }
	        },
	
	        scrollRenderPart_: function(area) {
	            var self = this;
	            var rows;
	            var i;
	            var len;
	            //if (gcUtils.isUndefinedOrNull(rebuildRowContentDOMTree)) {
	            //    rebuildRowContentDOMTree = true;
	            //}
	            //rebuildRowContentDOMTree = !!rebuildRowContentDOMTree;
	
	            var renderRange = self.layoutEngine.getRenderRange_({
	                area: area,
	                offsetTop: self.scrollOffset.top,
	                offsetLeft: self.scrollOffset.left
	            });
	
	            var innerElement = document.getElementById(self.uid + '-' + area + '-inner');
	            setTransform(innerElement, renderRange.left, renderRange.top);
	
	            if (renderRange) {
	                rows = renderRange.renderedRows || [];
	                var lastRenderedRows = self.lastRenderedRows_[area];
	                var newRenderedRows = _.pluck(rows, 'key');
	                var operations = findScrollMinimumOperations(lastRenderedRows, newRenderedRows);
	                var info;
	                var key;
	                //var style;
	                //var element;
	                var div = document.createElement('div');
	                var op;
	                for (i = 0, len = operations.length; i < len; i++) {
	                    op = operations[i];
	                    switch (op.operation) {
	                        case 'insert':
	                            key = findRow(rows, op.index);
	                            info = self.layoutEngine.getRenderRowInfo_(key, area);
	                            div.innerHTML = self.renderRow_(info);
	                            innerElement.appendChild(div.childNodes[0]);
	                            break;
	                        case 'delete':
	                            key = op.index;
	                            //innerElement.removeChild(innerElement.querySelector('.' + key))
	                            innerElement.removeChild(document.getElementById(key));
	                            break;
	                        case 'replace':
	                            var oldItemKey = op.index[0];
	                            var newItemKey = findRow(rows, op.index[1]);
	                            info = self.layoutEngine.getRenderRowInfo_(newItemKey, area);
	                            div.innerHTML = self.renderRow_(info);
	                            // innerElement.replaceChild(div.childNodes[0], innerElement.querySelector('.' + oldItemKey));
	                            innerElement.replaceChild(div.childNodes[0], document.getElementById(oldItemKey));
	                            break;
	                    }
	                }
	
	                self.lastRenderedRows_[area] = newRenderedRows;
	                div = null;
	            }
	        },
	
	        //TODO: refactoring it later.
	        //TODO: By innerHTML serializition will lose canvas info. So editing sparkline formula is wrong. I'll fix it later. -Jackson
	        refreshRow_: function(area, groupPath, row) {
	            var self = this;
	            var innerElement = document.getElementById(self.uid + '-' + area + '-inner');
	            var div = document.createElement('div');
	            var info;
	            if (innerElement) {
	                var key = self.uid + '-r' + row;
	                info = self.layoutEngine.getRenderRowInfo_({
	                    key: key,
	                    index: row,
	                    height: self.options.rowHeight,
	                    path: groupPath
	                }, area);
	                div.innerHTML = self.renderRow_(info);
	                innerElement.replaceChild(div.childNodes[0], document.getElementById(key));
	            }
	        },
	
	        refreshScrollBar_: function() {
	            var self = this;
	            var layoutInfo = self.layoutEngine.getLayoutInfo();
	            var selector;
	            var element;
	            var renderInfo;
	            _.keys(layoutInfo).map(function(area) {
	                //update scroll container
	                if (self.showScrollPanel(area)) {
	                    selector = self.uid + '-' + area + '-scroll';
	                    element = document.getElementById(selector);
	                    renderInfo = self.getScrollPanelRenderInfo(area);
	                    if (renderInfo) {
	                        if (element) {
	                            element.style.cssText = gcUtils.createMarkupForStyles(renderInfo.outerDivStyle);
	                            if (element.childNodes.length > 0) {
	                                element.childNodes[0].style.cssText = gcUtils.createMarkupForStyles(renderInfo.innerDivStyle);
	                            }
	                        } else {
	                            var id = self.uid + '-' + area + '-scroll';
	                            self.scrollableElements_.push(id);
	                            var html = '<div id="' + id + '" class="' + renderInfo.outerDivCssClass + '"';
	                            if (renderInfo.outerDivCssClass) {
	                                html += ' style="' + gcUtils.createMarkupForStyles(renderInfo.outerDivStyle) + '"';
	                            }
	                            html += '><div';
	                            if (renderInfo.innerDivStyle) {
	                                html += ' style="' + gcUtils.createMarkupForStyles(renderInfo.innerDivStyle) + '"';
	                            }
	                            html += '></div></div>';
	                            var scrollBarElement = domUtil.createElement(html);
	                            var parentNode = document.querySelector('#' + self.uid + ' .gc-grid-container');
	                            parentNode.insertBefore(scrollBarElement, parentNode.firstElementChild);
	                        }
	                    }
	                } else {
	                    selector = self.uid + '-' + area + '-scroll';
	                    element = document.getElementById(selector);
	                    if (element) {
	                        renderInfo = self.getScrollPanelRenderInfo(area);
	                        if (renderInfo) {
	                            element.style.cssText = gcUtils.createMarkupForStyles(renderInfo.outerDivStyle);
	                            if (element.childNodes.length > 0) {
	                                element.childNodes[0].style.cssText = gcUtils.createMarkupForStyles(renderInfo.innerDivStyle);
	                            }
	                        }
	                    }
	                }
	            });
	        },
	
	        getRowTemplate: function() {
	            return this.layoutEngine.getRowTemplate();
	        },
	
	        toJSON: function() {
	            var self = this;
	            var jsonObj = {};
	            jsonObj.version = '0.1';
	            jsonObj.layoutEngine = self.layoutEngine.toJSON();
	            jsonObj.columns = gcUtils.serializeObject(self.columnsConfig_);
	
	            var option = {};
	            var i;
	            var length;
	            var groupDescriptors = self.data.groupDescriptors;
	            if (groupDescriptors) {
	                var groups = [];
	                for (i = 0, length = groupDescriptors.length; i < length; i++) {
	                    groups.push(gcUtils.serializeObject(groupDescriptors[i]));
	                }
	                if (groups.length > 0) {
	                    option.grouping = groups;
	                }
	            }
	            if (self.data.filterExpression) {
	                option.filter = self.data.filterExpression;
	            }
	            jsonObj.layoutEngine.options = _.defaults(option, jsonObj.layoutEngine.options);
	            return jsonObj;
	        },
	
	        getContainerInfo_: function() {
	            var self = this;
	            //Fix bug, we need consider css settings in .gc-grid class
	            self.container.className += ' gc-grid';
	
	            self.containerInfo_ = {
	                contentRect: domUtil.getContentRect(self.container)
	            };
	
	            self.container.className = self.container.className.replace('gc-grid', '');
	            return self.containerInfo_;
	        },
	
	        getGroupInfo_: function(path) {
	            var i;
	            var len;
	            var groupInfos = this.groupInfos_;
	            var currentGroup = groupInfos[path[0]];
	            for (i = 1, len = path.length; i < len; i++) {
	                currentGroup = currentGroup.children[path[i]];
	            }
	            return currentGroup;
	        },
	
	        getActionHandler_: function(columnId, name) {
	            var self = this;
	            if (self.buildInActions_[name]) {
	                if (name === 'edit' && editingHandler.isEditing_) {
	                    return function() {
	                        self.stopEditing();
	                    };
	                }
	                return self.buildInActions_[name].handler;
	            }
	            var colActions = self.columnActions_[columnId];
	            if (colActions) {
	                var action;
	                var i;
	                var length;
	                for (i = 0, length = colActions.length; i < length; i++) {
	                    action = colActions[i];
	                    if (action.name === name && action.handler) {
	                        return action.handler;
	                    }
	                }
	            }
	            return null;
	        },
	
	        startEditing: function() {
	            var self = this;
	            var hitInfo = self.layoutEngine && self.layoutEngine.hitTestInfo_;
	            if (!hitInfo) {
	                return false;
	            }
	            var uiRowIndex;
	            var groupInfo = null;
	            var hitGroupInfo = hitInfo.groupInfo;
	            if (hitGroupInfo) {
	                uiRowIndex = hitGroupInfo.row;
	                groupInfo = self.getGroupInfo_(hitGroupInfo.path);
	            } else {
	                uiRowIndex = hitInfo.row;
	            }
	            var isEditing = editingHandler.startEditing(self, groupInfo, uiRowIndex);
	            if (self.hasEditAction_ && isEditing) {
	                updateEditingButtonValue.call(self, 'save');
	            }
	            return isEditing;
	        },
	
	        stopEditing: function() {
	            var self = this;
	            if (editingHandler.isEditing_) {
	                if (self.hasEditAction_) {
	                    updateEditingButtonValue.call(self, 'edit');
	                }
	                return editingHandler.stopEditing(self);
	            }
	            return false;
	        },
	
	        cancelEditing: function() {
	            var self = this;
	            if (self.hasEditAction_) {
	                updateEditingButtonValue.call(self, 'edit');
	            }
	            editingHandler.unMountEditors(self);
	        },
	
	        getSelections: function() {
	            var self = this;
	            if (self.layoutEngine) {
	                return self.layoutEngine.getSelections();
	            }
	            return [];
	        },
	
	        renderRow_: function(row) {
	            var rowRenderInfo = row.renderInfo;
	            var serialized = '<div' + (row.key ? (' id="' + row.key + '"') : '') + (row.isRowRole ? ' role="row"' : '') + (row.selected ? ' aira-selected="true"' : '');
	            if (rowRenderInfo.style) {
	                serialized += ' style="' + gcUtils.createMarkupForStyles(rowRenderInfo.style) + '"';
	            }
	            if (rowRenderInfo.cssClass) {
	                serialized += ' class="' + rowRenderInfo.cssClass + (row.selected ? ' gc-selected' : '') + '"';
	            }
	            serialized += '>';
	            if (rowRenderInfo.renderedHTML) {
	                serialized += rowRenderInfo.renderedHTML;
	            }
	            serialized += '</div>';
	            return serialized;
	        },
	
	        getColById_: function(id) {
	            var cols = this.columns;
	            var col;
	            for (var i = 0, len = cols.length; i < len; i++) {
	                col = cols[i];
	                if (col.id === id) {
	                    return col;
	                }
	            }
	            return null;
	        },
	
	        isColVisible_: function(col, pinned) {
	            if (!col.visible || col.pinned !== pinned) {
	                return false;
	            }
	            var colTree = this.colTree_;
	            if (colTree) {
	                var parent = colTree[colTree[col.id].parent];
	                if (parent) {
	                    var status = pinned === 'left' ? parent.pinnedStatus : (pinned === 'right' ? parent.pinnedRightStatus : parent.status);
	                    if (status.isCollapsed && col.headerGroupShow === 'expanded') {
	                        return false;
	                    } else if (!status.isCollapsed && col.headerGroupShow === 'collapsed') {
	                        return false;
	                    }
	                }
	            }
	            return true;
	        },
	
	        flatternColumns_: function(colsConfig) {
	            var self = this;
	            var result = [];
	            _.each(colsConfig, function(obj) {
	                if (obj.hasOwnProperty('dataField') || obj.hasOwnProperty('action') || obj.hasOwnProperty('asyncRender')) {
	                    result.push(obj);
	                } else if (obj.hasOwnProperty('columns')) {
	                    result = result.concat(self.flatternColumns_(obj.columns));
	                }
	            });
	            return result;
	        },
	
	        insertColumns_: function(columns) {
	            var self = this;
	            var i;
	            var len;
	            var col;
	            if (!gcUtils.isArray(columns)) {
	                columns = [columns];
	            }
	            var item = self.data.sourceCollection[0];
	            for (i = 0, len = columns.length; i < len; i++) {
	                col = columns[i];
	                if (!col.columns) {
	                    col = _.defaults(col, _.defaults(self.layoutEngine.getColumnDefaults_(), {
	                        id: col.dataField,
	                        caption: col.dataField
	                    }));
	                } else {
	                    initCols_.call(self, col.columns);
	                }
	                col.visibleWidth = col.width;
	                if (!col.dataType && col.dataField) {
	                    col.dataType = gcUtils.getType(item[col.dataField]);
	                }
	                if (col.format && col.id) {
	                    var colId = col.id;
	                    var formatter = col.format;
	                    if (gcUtils.isString(formatter) && self.ExcelFormatter_) {
	                        self.colFormatters_[colId] = new self.ExcelFormatter_(formatter);
	                    } else if (gcUtils.isFunction(formatter)) {
	                        self.colFormatters_[colId] = formatter;
	                    }
	                }
	                if (col.action) {
	                    self.columnActions_[col.id] = _.map(gcUtils.isArray(col.action) ? col.action : [col.action], createColumnAction_.bind(self));
	                }
	                if (_.startsWith(_.trim(col.dataField), '=')) {
	                    col.isCalcColumn_ = true;
	                    self.data.calcSource_.addCalcColumn(col.id, col.dataField);
	                }
	                self.columnsConfig_.push(col);
	                self.columns.push(col);
	            }
	            if (self.colTree_) {
	                self.colTree_ = {};
	                buildColumnDefTree_(self.columnsConfig_, null, self.colTree_);
	            }
	
	            if (self.layoutEngine.updateStartSize_) {
	                self.layoutEngine.updateStartSize_();
	            }
	            self.invalidate();
	        }
	    };
	
	    function getColByDataField_(dataField) {
	        var cols = this.columns;
	        var col;
	        for (var i = 0, len = cols.length; i < len; i++) {
	            col = cols[i];
	            if (col.dataField === dataField) {
	                return col;
	            }
	        }
	        return null;
	    }
	
	    function initCols_(cols) {
	        var self = this;
	        var i;
	        var len;
	        var col;
	        for (i = 0, len = cols.length; i < len; i++) {
	            col = cols[i];
	            if (!col.columns) {
	                col = _.defaults(col, _.defaults(self.layoutEngine.getColumnDefaults_(), {
	                    id: col.dataField,
	                    caption: col.dataField
	                }));
	            } else {
	                initCols_.call(self, col);
	            }
	        }
	    }
	
	    function buildColumnDefTree_(colsConfig, parent, columnDefTree) {
	        _.each(colsConfig, function(obj) {
	            if (obj.hasOwnProperty('dataField') || obj.hasOwnProperty('action') || obj.hasOwnProperty('asyncRender')) {
	                columnDefTree[obj.id] = {
	                    parent: parent
	                };
	            } else if (obj.hasOwnProperty('columns')) {
	                columnDefTree[obj.caption] = {
	                    parent: parent,
	                    status: {
	                        showIcon: showCollapseIcon(obj, 'none'),
	                        isCollapsed: true
	                    },
	                    pinnedStatus: {
	                        showIcon: showCollapseIcon(obj, 'left'),
	                        isCollapsed: true
	                    },
	                    pinnedRightStatus: {
	                        showIcon: showCollapseIcon(obj, 'right'),
	                        isCollapsed: true
	                    }
	                };
	                buildColumnDefTree_(obj.columns, obj.caption, columnDefTree);
	            }
	        });
	    }
	
	    function hasPinnedOrUnpinnedColumn_(cols, pinned) {
	        var i;
	        var len;
	        var col;
	        var result = false;
	        for (i = 0, len = cols.length; i < len; i++) {
	            col = cols[i];
	            if (col.columns) {
	                result = hasPinnedOrUnpinnedColumn_(col.columns, pinned);
	            } else {
	                result = col.pinned === pinned;
	            }
	            if (result) {
	                break;
	            }
	        }
	        return result;
	    }
	
	    function showCollapseIcon(col, pinned) {
	        var cols = col.columns;
	        var len = cols.length;
	        var i;
	        var len2 = len;
	        var showCount = 0;
	        var hiddenCount = 0;
	        var len3 = 0;
	        for (i = 0; i < len2; i++) {
	            col = cols[i];
	            if (!col.columns) {
	                col.pinned = col.pinned || 'none';
	            }
	
	            if ((col.columns && hasPinnedOrUnpinnedColumn_(col.columns, pinned)) || (col.pinned === pinned && col.headerGroupShow !== 'expanded')) {
	                showCount += 1;
	                len3 += 1;
	            } else if (col.pinned === pinned && col.headerGroupShow === 'expanded') {
	                hiddenCount += 1;
	                len3 += 1;
	            }
	        }
	
	        if (showCount === len3 || hiddenCount === len3) {
	            return false;
	        }
	        return true;
	    }
	
	    //function flatternColumns_(colsConfig) {
	    //    var result = [];
	    //    _.each(colsConfig, function(obj) {
	    //        if (obj.hasOwnProperty('dataField') || obj.hasOwnProperty('action')) {
	    //            result.push(obj);
	    //        } else if (obj.hasOwnProperty('columns')) {
	    //            result = result.concat(flatternColumns_(obj.columns));
	    //        }
	    //    });
	    //    return result;
	    //}
	
	    //TODO: handle the action column in group
	    function updateEditingButtonValue(value) {
	        var editingInfo = editingHandler.editingInfo_;
	        var selectionPart = editingInfo.group ? ('-gr' + editingInfo.group.join('_') + '-r' + editingInfo.rowIndex) : ('-r' + editingInfo.rowIndex);
	        var element = document.querySelector('#' + this.uid + selectionPart + ' .gc-action-area button[data-action="edit"]');
	        if (element) {
	            element.innerHTML = value;
	        }
	    }
	
	    function createColumnAction_(item) {
	        var self = this;
	        var isStr = gcUtils.isString(item);
	        var name = isStr ? item : item.name;
	        if (!isStr && self.buildInActions_[name] && item.handler) {
	            self.buildInActions_[name].handler = item.handler;
	        }
	        if (name === 'edit') {
	            self.hasEditAction_ = true;
	        }
	        if (name === 'cancel') {
	            self.hasCancelAction_ = true;
	        }
	        return isStr ? {name: item} : item;
	    }
	
	    function findRow(rows, rowKey) {
	        return _.find(rows, function(row) {
	            return row.key === rowKey;
	        });
	    }
	
	    function setTransform(element, left, top) {
	        element.style.setProperty(getTransformProName(), getTransformProValue(left, top));
	    }
	
	    function getTransformProName() {
	        return (navigator.userAgent.indexOf('MSIE') !== -1 || navigator.appVersion.indexOf('Trident/') > 0 || navigator.userAgent.match(/Firefox/i)) ? 'transform' : '-webkit-transform';
	    }
	
	    function getTransformProValue(left, top) {
	        top = top + 'px';
	        left = left + 'px';
	        return 'translate3d(' + left + ',' + top + ', 0px)';
	    }
	
	    function getLayoutEngine_(layoutEngineInfo) {
	        var name = layoutEngineInfo.name;
	        var options = layoutEngineInfo.options;
	        if (options && options.groupStrategy) {
	            var strategy = options.groupStrategy;
	            if (gcUtils.isString(strategy.name) && GcGrid && GcGrid.Plugins && GcGrid.Plugins[strategy.name]) {
	                options.groupStrategy = new GcGrid.Plugins[strategy.name](options);
	            }
	        }
	        if (gcUtils.isString(name) && GcGrid && GcGrid.Plugins && GcGrid.Plugins[name]) {
	            return new GcGrid.Plugins[name](options);
	        }
	        return new GridLayoutEngine(options);
	    }
	
	    function trigger_(event, sender, e) {
	        e = e || {};
	        return event.raise(sender, e);
	    }
	
	    function createGroupInfo_(group, path) {
	        var self = this;
	        var r = {
	            data: group,
	            path: path,
	            isBottomLevel: group.isBottomLevel
	        };
	        if (!group.isBottomLevel) {
	            r.children = _.map(group.groups, function(subGroup, index) {
	                return createGroupInfo_.call(self, subGroup, path.concat([index]));
	            });
	        }
	        return r;
	    }
	
	    function registerEvents_() {
	        var self = this;
	        var container = self.container;
	        if (!container.tabIndex || container.tabIndex < 0) { //Only focusable element can be bound keydown event.
	            container.tabIndex = 1;
	        }
	        container.addEventListener('click', self.handleClickFn_);
	        container.addEventListener('dblclick', self.handleDbClickFn_);
	        container.addEventListener('mousedown', self.handleMouseDownFn_);
	        container.addEventListener('mouseup', self.handleMouseUpFn_);
	        container.addEventListener('mousemove', self.handleMouseMoveFn_);
	        container.addEventListener('keydown', self.handleKeyDownFn_);
	        container.addEventListener('wheel', self.handleWheelFn_);
	        container.addEventListener('wheel', self.handleDebounceMouseWheelFn_);
	
	        self.onScrollOver_.addHandler(self.handleDebounceScrollOverFn_);
	
	        window.addEventListener('resize', self.handleWindowResizeFn_);
	        registerScrollEvent_.call(self);
	        registerTouchEvent_.call(self);
	
	        self.data.collectionChanged.addHandler(handleCollectionChanged_, self);
	    }
	
	    function changeScrollPanelZindex() {
	        var self = this;
	        if (!scrollPanelZIndexchanged) {
	            var element = document.getElementById(self.uid + '-viewport-scroll');
	            if (element) {
	                element.style['z-index'] = 20000;
	                scrollPanelZIndexchanged = true;
	            }
	        }
	    }
	
	    function changeBackScrollPanelZIndex() {
	        var self = this;
	        if (scrollPanelZIndexchanged) {
	            var element = document.getElementById(self.uid + '-viewport-scroll');
	            if (element) {
	                element.style.removeProperty('z-index');
	                scrollPanelZIndexchanged = false;
	                self.scrolling_ = false;
	            }
	        }
	    }
	
	    function unRegisterEvents_() {
	        var self = this;
	        var container = self.container;
	        container.removeEventListener('click', self.handleClickFn_);
	        container.removeEventListener('dblclick', self.handleDbClickFn_);
	        container.removeEventListener('mousedown', self.handleMouseDownFn_);
	        container.removeEventListener('mouseup', self.handleMouseUpFn_);
	        container.removeEventListener('mouseMove', self.handleMouseMoveFn_);
	        container.removeEventListener('keydown', self.handleKeyDownFn_);
	        container.removeEventListener('wheel', self.handleWheelFn_);
	        container.removeEventListener('wheel', self.handleDebounceMouseWheelFn_);
	
	        self.onScrollOver_.removeHandler(self.handleDebounceScrollOverFn_);
	
	        window.removeEventListener('resize', self.handleWindowResizeFn_);
	        unRegisterScrollEvent_.call(self);
	        unRegisterTouchEvent.call(self);
	
	        self.data.collectionChanged.removeHandler(self.handleCollectionChangedFn_);
	    }
	
	    function unRegisterScrollEvent_() {
	        var self = this;
	        var element;
	        _.each(self.scrollableElements_, function(item) {
	            element = document.getElementById(item);
	            if (element) {
	                element.removeEventListener('scroll', self.handleScrollFn_);
	            }
	
	        });
	        self.scrollableElements_.length = 0;
	    }
	
	    function buildDomTree_() {
	        var self = this;
	        var renderedRows;
	        var layoutInfo = self.getLayoutInfo();
	        var html = '<div role="grid" id="' + self.uid + '"class="' + (self.options.className ? self.options.className : 'gc-grid') + '"><div class="gc-grid-container">';
	        var renderInfo;
	        var rows;
	        var innerDivStyle;
	        self.scrollableElements_.length = 0;
	        _.keys(layoutInfo).map(function(area) {
	            if (self.showScrollPanel(area)) {
	                renderInfo = self.getScrollPanelRenderInfo(area);
	                if (renderInfo) {
	                    var id = self.uid + '-' + area + '-scroll';
	                    self.scrollableElements_.push(id);
	                    html += '<div id="' + id + '" class="' + renderInfo.outerDivCssClass + '"';
	                    if (renderInfo.outerDivCssClass) {
	                        html += ' style="' + gcUtils.createMarkupForStyles(renderInfo.outerDivStyle) + '"';
	                    }
	                    html += '><div';
	                    if (renderInfo.innerDivStyle) {
	                        html += ' style="' + gcUtils.createMarkupForStyles(renderInfo.innerDivStyle) + '"';
	                    }
	                    html += '></div></div>';
	                }
	            } else {
	                //when the area does not show scroll panel,in order to show all content of area,
	                //should reset scrolloffset.
	                if (self.isScrollableArea_ && self.isScrollableArea_(area)) {
	                    if (self.layoutEngine.getInitialScrollOffset) {
	                        self.scrollOffset = self.layoutEngine.getInitialScrollOffset();
	                    } else {
	                        self.scrollOffset.top = 0;
	                        self.scrollOffset.left = 0;
	                    }
	                }
	            }
	            renderInfo = self.getRenderInfo({
	                area: area,
	                offsetTop: self.scrollOffset.top,
	                offsetLeft: self.scrollOffset.left
	            });
	            renderedRows = self.lastRenderedRows_[area] = (self.lastRenderedRows_[area] || []);
	            if (renderInfo) {
	                html += '<div id="' + self.uid + '-' + area + '"';
	                if (renderInfo.outerDivStyle) {
	                    html += ' style="' + gcUtils.createMarkupForStyles(renderInfo.outerDivStyle) + '"';
	                }
	                if (renderInfo.outerDivCssClass) {
	                    html += ' class="' + renderInfo.outerDivCssClass + '"';
	                }
	                html += '><div id="' + self.uid + '-' + area + '-inner"';
	                if (renderInfo.innerDivStyle) {
	                    innerDivStyle = gcUtils.createMarkupForStyles(renderInfo.innerDivStyle);
	                }
	
	                if (renderInfo.innerDivTranslate) {
	                    innerDivStyle += getTransformProName() + ':' + getTransformProValue(renderInfo.innerDivTranslate.left, renderInfo.innerDivTranslate.top);
	                }
	
	                if (innerDivStyle) {
	                    html += ' style="' + innerDivStyle + '"';
	                }
	
	                if (renderInfo.innerDivCssClass) {
	                    html += ' class="' + renderInfo.innerDivCssClass + '"';
	                }
	                html += '>';
	                rows = renderInfo.renderedRows || [];
	                _.each(rows, function(row) {
	                    renderedRows.push(row.key);
	                    html += self.renderRow_(row);
	                });
	
	                html += '</div></div>';
	            }
	
	        });
	        html += '</div></div>';
	
	        self.container.innerHTML = html;
	
	        startAsyncRender_.call(self);
	    }
	
	    function startAsyncRender_(scrollDirection) {
	        var self = this;
	        var columns = self.columns;
	        var columnDef;
	        var i;
	        var length;
	        var needAsynRender = false;
	        for (i = 0, length = columns.length; i < length; i++) {
	            columnDef = columns[i];
	            if (columnDef.asyncRender || hasSparkline(columnDef)) {
	                needAsynRender = true;
	                break;
	            }
	        }
	        if (!needAsynRender) {
	            return;
	        }
	        self.asynRows_ = {};
	        var renderedRows = self.lastRenderedRows_;
	        _.each([VIEWPORT, PINNED_VIEWPORT, PINNED_RIGHT_VIEWPORT], function(area) {
	            if (renderedRows[area]) {
	                self.asynRows_[area] = getGlobalIndexByID_.call(self, renderedRows[area], area);
	            }
	            //according to scroll direction to changed rendering sequence
	            if (scrollDirection === 'down' && self.asynRows_[area]) {
	                self.asynRows_[area] = self.asynRows_[area].reverse();
	            }
	        });
	
	        self.asynIndex_ = 0;
	        self.asynRenderTimer_ = setTimeout(asyncRenderRows_.bind(this), 30);
	    }
	
	    function asyncRenderRows_() {
	        var self = this;
	        var i;
	        var length;
	        var rowIndex;
	        var rowElement;
	        var container;
	        var columnDef;
	        var columns = self.columns;
	        var rows = self.asynRows_;
	        var isRunning = false;
	        var rowData = null;
	        var rowArr;
	        var rowInfo;
	        var sparklineObj;
	        var calcSource = self.data.calcSource;
	        var formula;
	        _.each([VIEWPORT, PINNED_VIEWPORT, PINNED_RIGHT_VIEWPORT], function(area) {
	            rowArr = rows[area];
	            if (rowArr && self.asynIndex_ < rowArr.length) {
	                isRunning = true;
	                rowInfo = rowArr[self.asynIndex_];
	                rowElement = getRowElement_.call(self, rowInfo, area);
	                if (rowElement) {
	                    if (rowInfo.groupArea && rowInfo.groupArea === GROUP_CONTENT) {
	                        rowIndex = self.getGroupInfo_(rowInfo.path).data.toSourceRow(rowInfo.row);
	                    } else {
	                        rowIndex = rowInfo.row;
	                    }
	                    if (!gcUtils.isUndefined(rowIndex)) {
	                        rowData = self.getDataItem(rowIndex);
	                    }
	                    for (i = 0, length = columns.length; i < length; i++) {
	                        sparklineObj = null;
	                        container = null;
	                        columnDef = columns[i];
	                        if (rowInfo.groupArea === GROUP_HEADER || rowInfo.groupArea === GROUP_FOOTER) {
	                            container = rowElement.querySelector('.gc-group-sparkline');
	                            formula = container && container.getAttribute('data-formula');
	                            if (formula) {
	                                sparklineObj = calcSource.getEvaluator().evaluateFormula(container.getAttribute('data-formula'), calcSource.getParserContext(), calcSource.getEvaluatorContext(-1, rowInfo.path));
	                                container.removeAttribute('data-formula');
	                            }
	                        } else {
	                            container = rowElement.querySelector('[data-column=' + columnDef.id + '] .gc-cell');
	                            sparklineObj = rowData[columnDef.id];
	                        }
	                        if (sparklineObj instanceof GcGrid.Plugins.Sparkline.BaseSparkline && container) {
	                            sparklineObj.paint(container);
	                        }
	                        if (columnDef.asyncRender && container) {
	                            columnDef.asyncRender(rowData, container);
	                        }
	                    }
	                }
	            }
	        });
	        if (isRunning) {
	            self.asynIndex_++;
	            self.asynRenderTimer_ = setTimeout(asyncRenderRows_.bind(this), 30);
	        }
	    }
	
	    function hasSparkline(column) {
	        var sparklineNames = [
	            'PIESPARKLINE',
	            'LINESPARKLINE',
	            'COLUMNSPARKLINE',
	            'WINLOSSSPARKLINE'
	        ];
	        var name;
	        for (var i = 0, length = sparklineNames.length; i < length; i++) {
	            name = '=' + sparklineNames[i];
	            if (column.isCalcColumn_) {
	                if (column.dataField.indexOf(name) !== -1) {
	                    return true;
	                }
	            } else if (column.groupHeader) {
	                if (column.groupHeader.indexOf(name) !== -1) {
	                    return true;
	                }
	            } else if (column.groupFooter) {
	                if (column.groupFooter.indexOf(name) !== -1) {
	                    return true;
	                }
	            }
	        }
	        return false;
	    }
	
	    function getGlobalIndexByID_(rowKeys, area) {
	        var self = this;
	        if (!rowKeys || !rowKeys.length) {
	            return;
	        }
	
	        var uid = self.uid;
	        var prefix = uid + '-' + (area === PINNED_VIEWPORT ? 'p' : (area === PINNED_RIGHT_VIEWPORT ? 'pr' : ''));
	        var hasGroup = self.data.groups && self.data.groups.length > 0;
	        var key;
	        var result = [];
	        var i;
	        var length;
	        var path;
	        var rowIndex;
	
	        if (hasGroup) {
	            var headerPrefix = prefix + 'gh';
	            var footerPrefix = prefix + 'gf';
	            var contentPrefix = prefix + 'gr';
	            var groupArea;
	            for (i = 0, length = rowKeys.length; i < length; i++) {
	                key = rowKeys[i];
	                if (key.indexOf(contentPrefix) !== -1) {
	                    path = key.substr(contentPrefix.length, key.indexOf('-r') - contentPrefix.length);
	                    rowIndex = +key.substr(key.indexOf('-r') + 2);
	                    groupArea = GROUP_CONTENT;
	                } else if (key.indexOf(headerPrefix) !== -1) {
	                    path = key.substr(headerPrefix.length);
	                    groupArea = GROUP_HEADER;
	                } else if (key.indexOf(footerPrefix) !== -1) {
	                    path = key.substr(footerPrefix.length);
	                    groupArea = GROUP_FOOTER;
	                }
	                result.push({
	                    row: rowIndex,
	                    path: path.split('_'),
	                    groupArea: groupArea
	                });
	            }
	        } else {
	            prefix = prefix + 'r';
	            for (i = 0, length = rowKeys.length; i < length; i++) {
	                key = rowKeys[i];
	                rowIndex = +key.substr(prefix.length);
	                result.push({
	                    row: rowIndex
	                });
	            }
	        }
	        return result;
	    }
	
	    function getRowElement_(rowInfo, area) {
	        var uid = this.uid;
	        var selector;
	        var prefix = area === PINNED_VIEWPORT ? 'p' : (area === PINNED_RIGHT_VIEWPORT ? 'pr' : '');
	        if (rowInfo.groupArea) {
	            if (rowInfo.groupArea === GROUP_CONTENT && rowInfo.row >= 0) {
	                selector = uid + '-' + prefix + 'gr' + rowInfo.path.join('_') + '-r' + rowInfo.row;
	            } else if (rowInfo.groupArea === GROUP_FOOTER) {
	                selector = uid + '-' + prefix + 'gf' + rowInfo.path.join('_');
	            } else if (rowInfo.groupArea === GROUP_HEADER) {
	                selector = uid + '-' + prefix + 'gh' + rowInfo.path.join('_');
	            }
	        } else {
	            if (rowInfo.row >= 0) {
	                selector = uid + '-' + prefix + 'r' + rowInfo.row;
	            }
	        }
	        return selector ? document.getElementById(selector) : null;
	    }
	
	    function registerScrollEvent_() {
	        var self = this;
	        _.each(self.scrollableElements_, function(item) {
	            document.getElementById(item).addEventListener('scroll', self.handleScrollFn_);
	        });
	    }
	
	    function registerTouchEvent_() {
	        var self = this;
	        var container = self.container;
	
	        TouchWrapper(container).on('touchstart', self.handleTouchStartFn_);
	        TouchWrapper(container).on('touchmove', self.handleTouchMoveFn_);
	        TouchWrapper(container).on('touchend', self.handleTouchEndFn_);
	        container.addEventListener('inertiamove', _.throttle(self.handleInertiaMoveFn_, inertialMovetimeSpan));
	    }
	
	    function unRegisterTouchEvent() {
	        var self = this;
	        var container = self.container;
	
	        TouchWrapper(container).off('touchstart', self.handleTouchStartFn_);
	        TouchWrapper(container).off('touchmove', self.handleTouchMoveFn_);
	        TouchWrapper(container).off('touchend', self.handleTouchEndFn_);
	        container.removeEventListener('inertiamove', self.handleInertiaMoveFn_);
	    }
	
	    function handleTouchStart_(e) {
	        var self = this;
	        resetStatus.call(self);
	        touchStatus.touchEventInfo = [{
	            timeStap: (new Date().getTime()),
	            x: e.targetTouches[0].pageX,
	            y: e.targetTouches[0].pageY
	        }];
	
	        if (e.cancelable) {
	            e.preventDefault();
	        }
	
	        touchStatus.touchStartHitInfo = self.layoutEngine.hitTest({
	            pageX: e.targetTouches[0].pageX,
	            pageY: e.targetTouches[0].pageY
	        });
	        trigger_(self.onTouchStart_, self, e);
	    }
	
	    function handleTouchMove_(e) {
	        var self = this;
	        if (e.cancelable) {
	            e.preventDefault();
	        }
	
	        trigger_(self.onTouchMove_, self, e);
	        if (e.handled) {
	            return;
	        }
	
	        if (filterMessage(e)) {
	            return;
	        }
	
	        detectTouchAction.call(self, e);
	
	        if (touchStatus.touchAction === 'pinch') {
	            return;
	        } else if (touchStatus.touchAction === 'scroll' || touchStatus.touchAction === 'swipestart' || touchStatus.touchAction === 'swipemoving') {
	            if (shouldProcessMove_()) {
	                var deltaX = touchStatus.touchEventInfo[0].x - e.targetTouches[0].pageX;
	                var deltaY = touchStatus.touchEventInfo[0].y - e.targetTouches[0].pageY;
	                var delta = touchStatus.moveDirection === 'horizontal' ? deltaX : deltaY;
	
	                if (touchStatus.touchAction === 'scroll') {
	                    if (!canScroll()) {
	                        return;
	                    }
	
	                    touchStatus.stopInertiaMove = true;
	                    trigger_(self.onTouchScroll_, self, e);
	                    if (e.handled) {
	                        return;
	                    } else {
	                        scrollGrid.call(self, e, touchStatus.startOffset.left, touchStatus.startOffset.top, delta);
	                    }
	                } else if (touchStatus.touchAction === 'swipestart' || touchStatus.touchAction === 'swipemoving') {
	                    if (!canSwipe()) {
	                        return;
	                    }
	
	                    raiseSwipeEvent_.call(self, e);
	                }
	
	                touchStatus.touchEventInfo.push(
	                    {
	                        timeStap: (new Date()).getTime(),
	                        x: e.targetTouches[0].pageX,
	                        y: e.targetTouches[0].pageY
	                    }
	                );
	            }
	        }
	    }
	
	    function handleTouchEnd_(e) {
	        var self = this;
	        if (e.cancelable) {
	            e.preventDefault();
	        }
	
	        trigger_(self.onTouchEnd_, self, e);
	        //if (e.handled) {
	        //    return;
	        //}
	
	        detectTouchAction.call(self, e, true);
	        if (touchStatus.touchAction === 'pinch') {
	            return;
	        } else if (touchStatus.touchAction === 'tap') {
	            if (TouchWrapper().shouldRaiseTapEvent()) {
	                trigger_(self.onTap_, self, {pageX: e.changedTouches[0].pageX, pageY: e.changedTouches[0].pageY});
	            } else {
	                self.tapPoint_ = e.changedTouches[0];
	            }
	        } else if (touchStatus.touchAction === 'swipeend') {
	            if (!canSwipe()) {
	                return;
	            }
	            raiseSwipeEvent_.call(self, e);
	        } else if (touchStatus.touchAction === 'scroll') {
	            if (!canScroll()) {
	                return;
	            }
	
	            touchStatus.stopInertiaMove = false;
	            inertialMoveStatus = {};
	            inertialMoveStatus.v = getInertialStartVelocity(touchStatus.moveDirection === 'horizontal' ? e.changedTouches[0].pageX : e.changedTouches[0].pageY);
	            inertialMoveStatus.deceleration = (inertialMoveStatus.v < 0 ? 1 : -1) * 0.0006;
	            inertialMoveStatus.v = Math.abs(inertialMoveStatus.v) > 2.0 ? (inertialMoveStatus.v < 0 ? -2.0 : 2.0) : inertialMoveStatus.v;
	            inertialMoveStatus.element = this.container;
	            inertialMoveStatus.moveInterval = setInterval(raiseInertiaMove, inertialMovetimeSpan);
	            inertialMoveStatus.topleftDelta = 0;
	            inertialMoveStatus.rightbottomDelta = 0;
	        }
	    }
	
	    function handleInertiaMove_(e) {
	        var self = this;
	        var rowHeight = self.options.rowHeight;
	        var nowV = inertialMoveStatus.v + inertialMovetimeSpan * inertialMoveStatus.deceleration;
	        var visZero = inertialMoveStatus.deceleration * nowV > 0;
	        var isHorizontal = touchStatus.moveDirection === 'horizontal';
	        var layoutInfo = self.layoutEngine.getLayoutInfo();
	        var viewPortInfo = layoutInfo.viewport;
	        if (!viewPortInfo) {
	            if (inertialMoveStatus.moveInterval) {
	                clearInterval(inertialMoveStatus.moveInterval);
	            }
	            return;
	        }
	
	        var leftTop = isHorizontal ? self.scrollOffset.left : self.scrollOffset.top;
	        var length = isHorizontal ? viewPortInfo.width : viewPortInfo.height;
	        var rightBottom = isHorizontal ? self.scrollOffset.left + length : self.scrollOffset.top + length;
	        var maxLeftTop = -MAXFEEDBACKOFFSET;
	        var contentlength = isHorizontal ? viewPortInfo.contentWidth : viewPortInfo.contentHeight;
	        var maxRightBottom = contentlength + MAXFEEDBACKOFFSET;
	        var scrollable = contentlength > length;
	        var baseleft = self.scrollOffset.left;
	        var basetop = self.scrollOffset.top;
	
	        if (visZero) {
	            touchStatus.stopInertiaMove = true;
	        } else if (!visZero && (leftTop < maxLeftTop || rightBottom > maxRightBottom)) {
	            touchStatus.stopInertiaMove = true;
	        }
	
	        if (touchStatus.stopInertiaMove) {
	            if (leftTop < 0 || !scrollable) {
	                baseleft = isHorizontal ? 0 : self.scrollOffset.left;
	                basetop = isHorizontal ? self.scrollOffset.top : 0;
	            } else if (rightBottom > contentlength) {
	                baseleft = isHorizontal ? contentlength - viewPortInfo.width : self.scrollOffset.left;
	                basetop = isHorizontal ? self.scrollOffset.top : contentlength - viewPortInfo.height;
	            }
	            scrollGrid.call(self, e, baseleft, basetop, 0);
	            clearInterval(inertialMoveStatus.moveInterval);
	            return;
	        }
	
	        var delta = (nowV + inertialMoveStatus.v) / 2 * inertialMovetimeSpan;
	        var direction = delta < 0 ? -1 : 1;
	        delta = Math.abs(Math.floor(delta));
	        var minValue = (rowHeight / 3) * 2;
	        var maxValue = (rowHeight / 3) * 4;
	
	        if (delta > minValue && delta < maxValue) {
	            delta = minValue * direction;
	            inertialMoveStatus.v = delta / inertialMovetimeSpan;
	        } else {
	            delta = delta * direction;
	            inertialMoveStatus.v = nowV;
	        }
	
	        if (leftTop < 0) {
	            inertialMoveStatus.topleftDelta += delta;
	            baseleft = isHorizontal ? 0 : self.scrollOffset.left;
	            basetop = isHorizontal ? self.scrollOffset.top : 0;
	            scrollGrid.call(self, e, baseleft, basetop, inertialMoveStatus.topleftDelta);
	        } else if (rightBottom > contentlength && scrollable) {
	            inertialMoveStatus.rightbottomDelta += delta;
	            baseleft = isHorizontal ? contentlength - viewPortInfo.width : self.scrollOffset.left;
	            basetop = isHorizontal ? self.scrollOffset.top : contentlength - viewPortInfo.height;
	            scrollGrid.call(self, e, baseleft, basetop, inertialMoveStatus.rightbottomDelta);
	        } else {
	            scrollGrid.call(self, e, self.scrollOffset.left, self.scrollOffset.top, delta);
	        }
	    }
	
	    function raiseSwipeEvent_(e) {
	        var self = this;
	        var isHorizontal = touchStatus.moveDirection === 'horizontal';
	        var isSwipeEnd = touchStatus.touchAction === 'swipeend';
	        var nowLocation = isHorizontal ? (isSwipeEnd ? e.changedTouches[0].pageX : e.targetTouches[0].pageX) : (isSwipeEnd ? e.changedTouches[0].pageY : e.targetTouches[0].pageY);
	        e.swipeStatus = touchStatus.touchAction;
	        e.moveDistance = isHorizontal ? (touchStatus.touchEventInfo[0].x - nowLocation) : (touchStatus.touchEventInfo[0].y - nowLocation);
	        e.velocity = getInertialStartVelocity(nowLocation);
	        trigger_(self.onSwipe_, self, e);
	    }
	
	    function canScroll() {
	        var hitInfo = touchStatus.touchStartHitInfo;
	        var inPinnedViewPort = hitInfo && hitInfo.area && hitInfo.area.indexOf('pinned') > -1;
	        if (inPinnedViewPort && touchStatus.moveDirection === 'horizontal') {
	            return false;
	        }
	
	        return true;
	    }
	
	    function canSwipe() {
	        var hitInfo = touchStatus.touchStartHitInfo;
	        var inPinnedViewPort = hitInfo && hitInfo.area && hitInfo.area.indexOf('pinned') > -1;
	        if (inPinnedViewPort) {
	            return false;
	        }
	
	        if (hitInfo && hitInfo.area === 'viewport' && hitInfo.row === -1 && hitInfo.column === -1) {
	            if (hitInfo.groupInfo && (hitInfo.groupInfo.area === 'groupHeader' || hitInfo.groupInfo.area === 'groupFooter')) {
	                return false;
	            }
	        }
	
	        return true;
	    }
	
	    function shouldProcessMove_() {
	        var previousEventInfo = touchStatus.touchEventInfo[touchStatus.touchEventInfo.length - 1];
	        var processMove = ((new Date().getTime()) - previousEventInfo.timeStap) > 1000 / 80 || touchStatus.touchEventInfo.length === 1;
	
	        return processMove;
	    }
	
	    function raiseInertiaMove() {
	        if (!touchStatus.stopInertiaMove) {
	            var evt = new CustomEvent('inertiamove', {bubbles: true, cancelable: true});
	            inertialMoveStatus.element.dispatchEvent(evt);
	        }
	    }
	
	    function resetStatus() {
	        var self = this;
	        touchStatus = {};
	        touchStatus.stopInertiaMove = true;
	        touchStatus.startOffset = self.scrollOffset;
	        touchStatus.stopFeedBack = true;
	
	        if (inertialMoveStatus) {
	            clearInterval(inertialMoveStatus.moveInterval);
	        }
	        self.tapPoint_ = null;
	    }
	
	    function detectTouchAction(e, touchEnd) {
	        var touchStartEvent = touchStatus.touchEventInfo;
	        var self = this;
	        if (touchStartEvent) {
	            if (touchEnd) {
	                if (touchStartEvent[0].x === e.changedTouches[0].pageX && touchStartEvent[0].y === e.changedTouches[0].pageY) {
	                    touchStatus.touchAction = 'tap';
	                } else if (touchStatus.touchAction === 'swipemoving') {
	                    touchStatus.touchAction = 'swipeend';
	                }
	            } else {
	                if (e.touches.length > 1) {
	                    touchStatus.touchAction = 'pinch';
	                } else if (touchStatus.touchAction === 'swipestart' || touchStatus.touchAction === 'swipemoving') {
	                    touchStatus.touchAction = 'swipemoving';
	                } else if (touchStatus.touchAction === 'scroll') {
	                    touchStatus.touchAction = 'scroll';
	                } else {
	                    if (!updateMoveDirection(e)) {
	                        return;
	                    }
	
	                    var deltaX = touchStatus.touchEventInfo[0].x - e.targetTouches[0].pageX;
	                    var deltaY = touchStatus.touchEventInfo[0].y - e.targetTouches[0].pageY;
	
	                    if (self.options.allowSwipe && self.layoutEngine.canDoSwipe_(touchStatus.moveDirection)) {
	                        if (self.layoutEngine.canStartSwipe_(deltaX, deltaY)) {
	                            touchStatus.touchAction = 'swipestart';
	                        }
	                    } else {
	                        touchStatus.touchAction = 'scroll';
	                    }
	                }
	            }
	        }
	    }
	
	    function filterMessage(e) {
	        var touchStartEvent = touchStatus.touchEventInfo;
	        if (touchStartEvent) {
	            if (touchStartEvent[0].x === e.targetTouches[0].pageX && touchStartEvent[0].y === e.targetTouches[0].pageY) {
	                return true;
	            }
	        }
	    }
	
	    function getInertialStartVelocity(nowLocation) {
	        var index = touchStatus.touchEventInfo.length - 1;
	        var lastEvent = touchStatus.touchEventInfo[index];
	        var location = touchStatus.moveDirection === 'horizontal' ? lastEvent.x : lastEvent.y;
	        var nowTime = (new Date()).getTime();
	
	        while (location === nowLocation) {
	            index--;
	            if (index >= 0) {
	                lastEvent = touchStatus.touchEventInfo[index];
	                location = touchStatus.moveDirection === 'horizontal' ? lastEvent.x : lastEvent.y;
	            } else {
	                break;
	            }
	        }
	        return (location - nowLocation) / (nowTime - lastEvent.timeStap);
	    }
	
	    function updateMoveDirection(e) {
	        if (!touchStatus.moveDirection) {
	            var x = e.targetTouches[0].pageX;
	            var y = e.targetTouches[0].pageY;
	            var index = touchStatus.touchEventInfo.length - 1;
	
	            var lastEventInfo = touchStatus.touchEventInfo[index];
	            var moveX = x - lastEventInfo.x;
	            var moveY = y - lastEventInfo.y;
	
	            if (moveX === moveY) {
	                return false;
	            }
	
	            touchStatus.moveDirection = Math.abs(moveY) > Math.abs(moveX) ? 'vertical' : 'horizontal';
	            return true;
	        }
	
	        return true;
	    }
	
	    function scrollGrid(e, left, top, delta) {
	        if (touchStatus.moveDirection === 'horizontal') {
	            scrollGridHorizontal.call(this, e, left, top, delta);
	        } else {
	            scrollGridVertical.call(this, e, left, top, delta);
	        }
	    }
	
	    function scrollGridHorizontal(e, left, top, delta) {
	        var self = this;
	        var layoutInfo = self.layoutEngine.getLayoutInfo();
	        var viewPortInfo = layoutInfo.viewport;
	        if (!viewPortInfo) {
	            return;
	        }
	
	        var length = viewPortInfo.width;
	        var contentLength = viewPortInfo.contentWidth;
	        var scrollable = contentLength > length;
	        left += delta;
	
	        if (left < 0) {
	            left = GetBoundaryValeu(left);
	        } else if (left + length > contentLength && scrollable) {
	            left = contentLength - length + GetBoundaryValeu(left + length - contentLength);
	        }
	
	        self.scrollOffset = {
	            top: top,
	            left: left
	        };
	        if (delta) {
	            self.scollDirection = delta > 0 ? 'left' : 'right';
	        }
	        e.scrollDirection = self.scollDirection;
	        self.layoutEngine.handleScroll(e);
	    }
	
	    function scrollGridVertical(e, left, top, delta) {
	        var self = this;
	        var layoutInfo = self.layoutEngine.getLayoutInfo();
	        var viewPortInfo = layoutInfo.viewport;
	        if (!viewPortInfo) {
	            return;
	        }
	        var length = viewPortInfo.height;
	        var contentHeight = viewPortInfo.contentHeight;
	        var scrollable = contentHeight > length;
	        top += delta;
	
	        if (top < 0) {
	            top = GetBoundaryValeu(top);
	        } else if (top + length > contentHeight && scrollable) {
	            top = contentHeight - length + GetBoundaryValeu(top + length - contentHeight);
	        }
	
	        self.scrollOffset = {
	            top: top,
	            left: left
	        };
	        if (delta) {
	            self.scollDirection = delta > 0 ? 'up' : 'down';
	        }
	        e.scrollDirection = self.scollDirection;
	        self.layoutEngine.handleScroll(e);
	    }
	
	    function GetBoundaryValeu(value) {
	        var _translateOffsetY = value;
	        return GetBoundaryFactor(Math.abs(_translateOffsetY), MAXSCROLLABLEVERTICALOFFSET) * (_translateOffsetY > 0 ? 1 : -1);
	    }
	
	    function GetBoundaryFactor(input, boundary) {
	        return -boundary / (input / boundary + 1.0) + boundary;
	    }
	
	    function handleClick(e) {
	        var grid = this;
	        var tapPoint = grid.tapPoint_;
	        if (tapPoint) {
	            if (tapPoint.pageX === e.pageX && tapPoint.pageY === e.pageY && tapPoint.target === e.target) {
	                trigger_(this.onTap_, grid, {pageX: tapPoint.pageX, pageY: tapPoint.pageY});
	            } else {
	                trigger_(this.onMouseClick, this, e);
	            }
	            grid.tapPoint_ = null;
	        } else {
	            trigger_(this.onMouseClick, this, e);
	        }
	    }
	
	    function handleDoubleClick(e) {
	        trigger_(this.onMouseDbClick, this, e);
	    }
	
	    function handleMouseUp(e) {
	        var self = this;
	        self.scrolling_ = false;
	        trigger_(self.onMouseUp, self, e);
	    }
	
	    function handleMouseDown(e) {
	        trigger_(this.onMouseDown, this, e);
	    }
	
	    function handleMouseWheel(e) {
	        changeScrollPanelZindex.call(this);
	        trigger_(this.onMouseWheel, this, e);
	    }
	
	    function handleMouseMove(e) {
	        var self = this;
	        if (!self.scrolling_) {
	            trigger_(self.onMouseMove, self, e);
	        }
	    }
	
	    function handleKeyDown(e) {
	        trigger_(this.onKeyDown, this, e);
	    }
	
	    function handleWindowResize_() {
	        this.invalidate();
	    }
	
	    function handleScroll_(e) {
	        var self = this;
	        var target = e.target;
	        var scrollDirection;
	        if (!self.layoutEngine.isResizingCol_) {
	            self.scrolling_ = true;
	            e.preventDefault();
	            if (!gcUtils.isUndefined(self.asynRenderTimer_)) {
	                clearTimeout(self.asynRenderTimer_);
	            }
	            if (window && window.requestAnimationFrame) {
	                window.requestAnimationFrame(function() {
	                    scrollDirection = self.scrollOffset.top > target.scrollTop ? 'down' : 'up';
	                    e.scrollDirection = scrollDirection;
	
	                    var className = target.className;
	                    if (className.indexOf('scroll-top') >= 0) {
	                        self.scrollOffset.top = target.scrollTop;
	                    }
	                    if (className.indexOf('scroll-left') >= 0) {
	                        self.scrollOffset.left = target.scrollLeft;
	                    }
	
	                    self.layoutEngine.handleScroll(e);
	                });
	            }
	        }
	    }
	
	    function handleCollectionChanged_() {
	        this.invalidate();
	    }
	
	    function handleScollOver_(sender, args) {
	        startAsyncRender_.call(this, args.scrollDirection);
	    }
	
	    //finds the minimum step to update originalCollection to targetCollection
	    function findMinimumOperations_(originalCollection, targetCollection) {
	        var n1 = originalCollection.length;
	        var n2 = targetCollection.length;
	        var operation = [];
	        var i;
	        var j;
	        var mindis = [];
	
	        if (n1 === 0) {
	            for (i = 0; i < n2; i++) {
	                operation.push({
	                    operation: 'insert',
	                    index: i,
	                    item: targetCollection[i]
	                });
	            }
	            return operation;
	        }
	        if (n2 === 0) {
	            for (i = 0; i < n1; i++) {
	                operation.push({
	                    operation: 'delete',
	                    index: n1 - i - 1
	                });
	            }
	
	            return operation;
	        }
	
	        for (i = 0; i <= n1; i++) {
	            mindis[i] = [];
	        }
	
	        for (i = 0; i <= n1; i++) {
	            mindis[i][0] = i;
	        }
	
	        for (i = 0; i <= n2; i++) {
	            mindis[0][i] = i;
	        }
	
	        for (i = 1; i <= n1; i++) {
	            for (j = 1; j <= n2; j++) {
	                if (originalCollection[i - 1] === targetCollection[j - 1]) {
	                    mindis[i][j] = mindis[i - 1][j - 1];
	                } else {
	                    mindis[i][j] = Math.min(mindis[i - 1][j] + 1, mindis[i][j - 1] + 1, mindis[i - 1][j - 1] + 1);
	                }
	            }
	        }
	
	        i = n1;
	        j = n2;
	        while (i >= 1 || j >= 1) {
	            if (i >= 1 && j >= 1 && (originalCollection[i - 1] === targetCollection[j - 1])) {
	                i = i - 1;
	                j = j - 1;
	                operation.push({
	                    operation: 'update',
	                    index: i
	                });
	            } else if (i >= 1 && (mindis[i][j] === mindis[i - 1][j] + 1)) {
	                operation.push({
	                    operation: 'delete',
	                    index: i - 1
	                });
	                i = i - 1;
	            } else if (j >= 1 && (mindis[i][j] === mindis[i][j - 1] + 1)) {
	                operation.push({
	                    operation: 'insert',
	                    index: i,
	                    item: targetCollection[j - 1]
	                });
	                j = j - 1;
	            } else if (i >= 1 && j >= 1) {
	                operation.push({
	                    operation: 'replace',
	                    index: [i - 1, j - 1]
	                });
	                i = i - 1;
	                j = j - 1;
	            }
	        }
	        return operation;
	    }
	
	    function findScrollMinimumOperations(originalCollection, targetCollection) {
	        //var s1 = _.difference(originalCollection, targetCollection);
	        //var s2 = _.difference(targetCollection, originalCollection);
	        //var i;
	        //var len = Math.min(s1.length, s2.length);
	        //var operation = [];
	        //for (i = 0; i < len; i++) {
	        //    operation.push({
	        //        operation: 'replace',
	        //        index: [s1[i], s2[i]]
	        //    });
	        //}
	        //
	        //for (; i < s1.length; i++) {
	        //    operation.push({
	        //        operation: 'delete',
	        //        index: s1[i]
	        //    });
	        //}
	        //
	        //i = len;
	        //
	        //for (; i < s2.length; i++) {
	        //    operation.push({
	        //        operation: 'insert',
	        //        index: s2[i]
	        //    });
	        //}
	        //return operation;
	        var s1 = originalCollection;
	        var s2 = targetCollection;
	        var n1 = s1.length;
	        var n2 = s2.length;
	        var i = 0;
	        var j = 0;
	        var operation = [];
	        var position = s2.indexOf(s1[0]);
	        if (position === -1) {
	            position = s1.indexOf(s2[0]);
	            for (; i < position; i++) {
	                operation.push({
	                    operation: 'delete',
	                    index: s1[i]
	                });
	            }
	        } else {
	            for (; j < position; j++) {
	                operation.push({
	                    operation: 'insert',
	                    index: s2[j]
	                });
	            }
	        }
	
	        while (i < n1 && j < n2) {
	            if (s1[i] !== s2[j]) {
	                break;
	            }
	            i++;
	            j++;
	        }
	
	        for (; i < n1; i++) {
	            operation.push({
	                operation: 'delete',
	                index: s1[i]
	            });
	        }
	
	        for (; j < n2; j++) {
	            operation.push({
	                operation: 'insert',
	                index: s2[j]
	            });
	        }
	
	        return operation;
	    }
	
	    function createGroupStrategy_(self) {
	        var grid = self.grid;
	        var groupStrategyObj = self.options.groupStrategy;
	        if (grid.data.groups && groupStrategyObj) {
	            var strategy = groupStrategyObj.name;
	            var groupInfos = grid.data.groupDescriptors;
	            if (strategy.toLowerCase() === 'calendarstrategy' &&
	                (groupInfos.length !== 1 || grid.getColById_(groupInfos[0].field).dataType !== 'date')) {
	                /*jshint ignore:start */
	                console && console.error && console.error('calendar strategy can only be used in the case that there is only one level group and the data type of the grouping column is [object Date]');
	                /*jshint ignore:end */
	            } else {
	                self.groupStrategy_ = groupStrategyObj;
	            }
	        }
	        if (self.groupStrategy_) {
	            self.groupStrategy_.init(grid);
	        } else {
	            self.registeEvents_();
	        }
	    }
	
	    function updateGroupStrategy_() {
	        var self = this;
	        var layoutEngine = self.layoutEngine;
	        var groupStrategyObj = self.options.groupStrategy;
	        if (layoutEngine.groupStrategy_) {
	            //remove
	            if (gcUtils.isUndefinedOrNull(groupStrategyObj)) {
	                layoutEngine.groupStrategy_.destroy();
	                delete layoutEngine.groupStrategy_;
	                layoutEngine.registeEvents_();
	            } else {
	                //the same name
	                if (layoutEngine.groupStrategy_.name.toLowerCase() === groupStrategyObj.name.toLowerCase()) {
	                    var newOptons = groupStrategyObj.options;
	                    var oldOptions = layoutEngine.groupStrategy_.options;
	                    if (JSON.stringify(gcUtils.serializeObject(newOptons)) !== JSON.stringify(gcUtils.serializeObject(oldOptions))) {
	                        layoutEngine.groupStrategy_.options = newOptons;
	                        layoutEngine.groupStrategy_.clearRenderCache_();
	                    }
	                } else { //the other new group stratey
	                    layoutEngine.groupStrategy_.destroy();
	                    delete layoutEngine.groupStrategy_;
	                    createGroupStrategy_(layoutEngine);
	                }
	            }
	        } else if (!gcUtils.isUndefinedOrNull(self.options.groupStrategy)) {
	            layoutEngine.unRegisteEvents_();
	            createGroupStrategy_(layoutEngine);
	        } else {
	            layoutEngine.unRegisteEvents_();
	            layoutEngine.registeEvents_();
	        }
	    }
	
	    /**
	     * Gets the control that is hosted in a given DOM element
	     * @param {Element} node The DOM element that is hosting the control.
	     * @returns Control
	     */
	    GcGrid.getControlByElement = function(node) {
	        if (node) {
	            var gridNode = node.querySelector('[role="grid"]');
	            if (gridNode) {
	                var id = gridNode.id;
	                if (id.slice(0, 3) === 'gc-' && id.length > 3 && !isNaN(id.slice(3))) {
	                    return instancesByReactRootID[+(id.slice(3))];
	                }
	
	            }
	        }
	        return null;
	    };
	
	    //<editor-fold desc="Calc Engine">
	    function initCE_() {
	        var self = this;
	        _.forEach(self.columns, function(colObj) {
	            var dataField = colObj.dataField;
	            if (_.startsWith(_.trim(dataField), '=')) {
	                colObj.isCalcColumn_ = true;
	                //calcSource.addCalcColumn(colObj.id, dataField);
	            }
	        });
	
	    }
	
	    //</editor-fold>
	
	    function initBuildInActions_() {
	        var self = this;
	        self.buildInActions_ = {
	            'edit': {
	                name: 'edit',
	                handler: function(e) {
	                    e.closeActionColumnPanel();
	                    self.startEditing();
	                }
	            },
	            'cancel': {
	                name: 'cancel',
	                handler: function(e) {
	                    e.closeActionColumnPanel();
	                    self.cancelEditing();
	                }
	            }
	        };
	    }
	
	    module.exports = {
	        GcGrid: GcGrid,
	        Calc: Calc
	    };
	}());


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var __extends = function(d, b) {
	        for (var p in b) {
	            if (b.hasOwnProperty(p)) {
	                d[p] = b[p];
	            }
	        }
	        function __() {
	            this.constructor = d;
	        }
	
	        __.prototype = b.prototype;
	        d.prototype = new __();
	    };
	
	    /*
	     * Represents an event handler (private class)
	     */
	    var EventHandler = (function() {
	        function EventHandler(handler, self) {
	            this.handler = handler;
	            this.self = self;
	        }
	
	        return EventHandler;
	    })();
	
	    /**
	     * Represents an event.
	     *
	     * Wijmo events are similar to .NET events. Any class may define events by
	     * declaring them as fields. Any class may subscribe to events using the
	     * event's @see:addHandler method, or unsubscribe using the @see:removeHandler
	     * method.
	     *
	     * Wijmo event handlers take two parameters: <i>sender</i> and <i>args</i>.
	     * The first is the object that raised the event, and the second is an object
	     * that contains the the event parameters.
	     *
	     * Classes that define events follow the .NET pattern where for every event
	     * there is an <i>on[EVENTNAME]</i> method that raises the event. This pattern
	     * allows derived classes to override the <i>on[EVENTNAME]</i> method and
	     * handle the event before and/or after the base class raises the event.
	     * Derived classes may even suppress the event by not calling the base class
	     * implementation.
	     *
	     * For example, the TypeScript code below overrides the <b>onValueChanged</b>
	     * event for a control to perform some processing before and after the
	     * <b>valueChanged</b> event fires:
	     * <pre>
	     *   // override base class
	     *   onValueChanged(e: EventArgs) {
	    *   // execute some code before the event fires
	    *   console.log('about to fire valueChanged');
	    *   // optionally, call base class to fire the event
	    *   super.onValueChanged(e);
	    *   // execute some code after the event fired
	    *   console.log('valueChanged event just fired');
	    * }
	     * </pre>
	     */
	    var Event = (function() {
	        function Event() {
	            this._handlers = [];
	        }
	
	        /**
	         * Adds a handler to this event.
	         *
	         * @param handler Function invoked when the event is raised.
	         * @param self Object that defines the event handler
	         * (accessible as 'this' from the handler code).
	         */
	        Event.prototype.addHandler = function(handler, self) {
	            this._handlers.push(new EventHandler(handler, self));
	        };
	
	        /**
	         * Removes a handler from this event.
	         *
	         * @param handler Function invoked when the event is raised.
	         * @param self Object that defines the event handler (accessible as 'this' from the handler code).
	         */
	        Event.prototype.removeHandler = function(handler, self) {
	            for (var i = 0; i < this._handlers.length; i++) {
	                var l = this._handlers[i];
	                if (l.handler === handler && l.self === self) {
	                    this._handlers.splice(i, 1);
	                    break;
	                }
	            }
	        };
	
	        /**
	         * Removes all handlers associated with this event.
	         */
	        Event.prototype.removeAllHandlers = function() {
	            this._handlers.length = 0;
	        };
	
	        /**
	         * Raises this event, causing all associated handlers to be invoked.
	         *
	         * @param sender Source object.
	         * @param args Event parameters.
	         */
	        Event.prototype.raise = function(sender, args) {
	            if (typeof args === 'undefined') {
	                args = null;
	            }
	            for (var i = 0; i < this._handlers.length; i++) {
	                var l = this._handlers[i];
	                l.handler.call(l.self, sender, args);
	            }
	        };
	
	        Object.defineProperty(Event.prototype, 'hasHandlers', {
	            /**
	             * Gets a value that indicates whether this event has any handlers.
	             */
	            get: function() {
	                return this._handlers.length > 0;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        return Event;
	    })();
	    /**
	     * Base class for event arguments.
	     */
	    var EventArgs = (function() {
	        function EventArgs() {
	        }
	
	        EventArgs.empty = new EventArgs();
	        return EventArgs;
	    })();
	
	    /**
	     * Provides arguments for cancellable events.
	     */
	    var CancelEventArgs = (function(_super) {
	        /*jshint -W004 */
	        __extends(CancelEventArgs, _super);
	        function CancelEventArgs() {
	            _super.apply(this, arguments);
	            /**
	             * Gets or sets a value that indicates whether the event should be canceled.
	             */
	            this.cancel = false;
	        }
	
	        return CancelEventArgs;
	    })(EventArgs);
	
	    /**
	     * Provides arguments for property change events.
	     */
	    var PropertyChangedEventArgs = (function(_super) {
	        /*jshint -W004 */
	        __extends(PropertyChangedEventArgs, _super);
	        /**
	         * Initializes a new instance of a @see:PropertyChangedEventArgs.
	         *
	         * @param propertyName The name of the property whose value changed.
	         * @param oldValue The old value of the property.
	         * @param newValue The new value of the property.
	         */
	        function PropertyChangedEventArgs(propertyName, oldValue, newValue) {
	            _super.call(this);
	            this._name = propertyName;
	            this._oldVal = oldValue;
	            this._newVal = newValue;
	        }
	
	        Object.defineProperty(PropertyChangedEventArgs.prototype, 'propertyName', {
	            /**
	             * Gets the name of the property whose value changed.
	             */
	            get: function() {
	                return this._name;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        Object.defineProperty(PropertyChangedEventArgs.prototype, 'oldValue', {
	            /**
	             * Gets the old value of the property.
	             */
	            get: function() {
	                return this._oldVal;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        Object.defineProperty(PropertyChangedEventArgs.prototype, 'newValue', {
	            /**
	             * Gets the new value of the property.
	             */
	            get: function() {
	                return this._newVal;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        return PropertyChangedEventArgs;
	    })(EventArgs);
	
	    module.exports = {
	        Event: Event,
	        EventHandler: EventHandler,
	        EventArgs: EventArgs,
	        CancelEventArgs: CancelEventArgs,
	        PropertyChangedEventArgs: PropertyChangedEventArgs
	    };
	}());


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var gcUtils = __webpack_require__(3);
	
	    var domUtil = {};
	
	    /**
	     * Creates an element from an HTML string.
	     *
	     * @param html HTML fragment to convert into an HTMLElement.
	     * @return The new element.
	     */
	
	    //remove all comments and whitespace only text nodes
	    function clean(node) {
	        if (node && node.childNodes) {
	            for (var n = 0; n < node.childNodes.length; n++) { //do rewrite it to for(var n=0,len=XXX;i<len;)
	                var child = node.childNodes[n];
	                if (child.nodeType === 8 || (child.nodeType === 3 && !/\S/.test(child.nodeValue))) {
	                    node.removeChild(child);
	                    n--;
	                } else if (child.nodeType === 1) {
	                    clean(child);
	                }
	            }
	        }
	    }
	
	    domUtil.createElement = function(html) {
	        var div = document.createElement('div');
	        div.innerHTML = html;
	        var r = div.children[0];
	        div = null;
	        return r;
	    };
	
	    domUtil.createTemplateElement = function(html) {
	        var div = document.createElement('div');
	        div.innerHTML = html;
	        var r = div.children[0];
	        clean(r);
	        return div;
	    };
	
	    domUtil.getElementInnerText = function(element) {
	        return element.innerHTML.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>');
	    };
	
	    domUtil.getElementOuterText = function(element) {
	        return element.outerHTML.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>');
	    };
	
	    /**
	     * Checks whether an element has a class.
	     *
	     * @param {Element} e Element to check.
	     * @param {string} className Class to check for.
	     */
	    domUtil.hasClass = function(e, className) {
	        // note: using e.getAttribute('class') instead of e.classNames
	        // so this works with SVG as well as regular HTML elements.
	        if (e && e.getAttribute) {
	            var rx = new RegExp('\\b' + className + '\\b');
	            return e && rx.test(e.getAttribute('class'));
	        }
	        return false;
	    };
	
	    /**
	     * Removes a class from an element.
	     *
	     * @param {Element} e Element that will have the class removed.
	     * @param {string} className Class to remove form the element.
	     */
	    domUtil.removeClass = function(e, className) {
	        // note: using e.getAttribute('class') instead of e.classNames
	        // so this works with SVG as well as regular HTML elements.
	        if (e && e.setAttribute && domUtil.hasClass(e, className)) {
	            var rx = new RegExp('\\s?\\b' + className + '\\b', 'g');
	            var cn = e.getAttribute('class');
	            e.setAttribute('class', cn.replace(rx, ''));
	        }
	    };
	
	    /**
	     * Adds a class to an element.
	     *
	     * @param {Element} e Element that will have the class added.
	     * @param {string} className Class to add to the element.
	     */
	    domUtil.addClass = function(e, className) {
	        // note: using e.getAttribute('class') instead of e.classNames
	        // so this works with SVG as well as regular HTML elements.
	        if (e && e.setAttribute && !domUtil.hasClass(e, className)) {
	            var cn = e.getAttribute('class');
	            e.setAttribute('class', cn ? cn + ' ' + className : className);
	        }
	    };
	
	    /**
	     * Adds or removes a class to or from an element.
	     *
	     * @param {Element} e Element that will have the class added.
	     * @param {string} className Class to add or remove.
	     * @param {boolean} addOrRemove Whether to add or remove the class.
	     */
	    domUtil.toggleClass = function(e, className, addOrRemove) {
	        if (addOrRemove === true) {
	            domUtil.addClass(e, className);
	        } else {
	            domUtil.removeClass(e, className);
	        }
	    };
	
	    // ** jQuery replacement methods
	    /**
	     * Gets an element from a jQuery-style selector.
	     *
	     * @param {Element|string} selector An element, a selector string, or a jQuery object.
	     */
	    domUtil.getElement = function(selector) {
	        if (selector instanceof HTMLElement) {
	            return selector;
	        }
	        if (gcUtils.isString(selector)) {
	            return document.querySelector(selector);
	        }
	        return null;
	    };
	
	    /**
	     * Checks whether an HTML element contains another.
	     *
	     * @param {Element} parent Parent element.
	     * @param {Element} child Child element.
	     * @return {boolean} True if the parent element contains the child element.
	     */
	    domUtil.contains = function(parent, child) {
	        for (var e = child; e; e = e.parentElement) {
	            if (e === parent) {
	                return true;
	            }
	        }
	        return false;
	    };
	
	    /**
	     * Gets the current coordinates of element.
	     * @param {Element} element
	     */
	    domUtil.offset = function(element) {
	        var rect = element.getBoundingClientRect();
	        return {
	            top: rect.top + element.scrollTop + window.pageYOffset,
	            left: rect.left + element.scrollLeft + window.pageXOffset
	        };
	    };
	
	    /**
	     * Gets the bounding rectangle of an element in page coordinates.
	     *
	     * This is similar to the <b>getBoundingClientRect</b> function,
	     * except that uses window coordinates, which change when the
	     * document scrolls.
	     */
	    domUtil.getElementRect = function(e) {
	        var rc = e.getBoundingClientRect();
	        return {
	            left: rc.left + window.pageXOffset,
	            top: rc.top + window.pageYOffset,
	            width: rc.width,
	            height: rc.height
	        };
	    };
	
	    /**
	     * Get the inner content rectangle of input element.
	     * Padding and box-sizing is considered.
	     * The result is the actual rectangle to place child element.
	     * @param e represent the element
	     */
	    domUtil.getContentRect = function(e) {
	        var rc = e.getBoundingClientRect();
	        var style = this.getStyle(e);
	        var measurements = [
	            'paddingLeft',
	            'paddingRight',
	            'paddingTop',
	            'paddingBottom',
	            'borderLeftWidth',
	            'borderRightWidth',
	            'borderTopWidth',
	            'borderBottomWidth'
	        ];
	        var size = {};
	        measurements.forEach(function(prop) {
	            var num = parseFloat(style[prop]);
	            size[prop] = !isNaN(num) ? num : 0;
	        });
	        var paddingWidth = size.paddingLeft + size.paddingRight;
	        var paddingHeight = size.paddingTop + size.paddingBottom;
	        var borderWidth = size.borderLeftWidth + size.borderRightWidth;
	        var borderHeight = size.borderTopWidth + size.borderBottomWidth;
	        return {
	            left: rc.left + window.pageXOffset + size.borderLeftWidth + size.paddingLeft,
	            top: rc.top + window.pageYOffset + size.borderTopWidth + size.paddingTop,
	            width: rc.width - paddingWidth - borderWidth,
	            height: rc.height - paddingHeight - borderHeight
	        };
	    };
	
	    /**
	     * Modifies the style of an element by applying the properties specified in an object.
	     *
	     * @param {Element} e Element whose style will be modified.
	     * @param {Object} css Object containing the style properties to apply to the element.
	     */
	    domUtil.setCss = function(e, css) {
	        var s = e.style;
	        for (var p in css) {
	            var val = css[p];
	            if (gcUtils.isNumber(val)) {
	                if (p.match(/width|height|left|top|right|bottom|size|padding|margin'/i)) {
	                    val += 'px'; // default unit for geometry properties
	                }
	            }
	            s[p] = val.toString();
	        }
	    };
	
	    domUtil.getScrollbarSize = function() {
	        if (domUtil.scrollbarSize) {
	            return domUtil.scrollbarSize;
	        }
	
	        var div = domUtil.createElement('<div style="position:absolute; top:-10000px; left:-10000px; width:100px; height:100px; overflow:scroll;"></div>');
	        document.body.appendChild(div);
	        domUtil.scrollbarSize = {
	            width: div.offsetWidth - div.clientWidth,
	            height: div.offsetHeight - div.clientHeight
	        };
	        div.parentNode.removeChild(div);
	
	        return domUtil.scrollbarSize;
	    };
	
	    domUtil.getStyle = function(element) {
	        var fn = getComputedStyle || window.getComputedStyle;
	        if (element && fn) {
	            return fn(element, null);
	        }
	        return null;
	    };
	
	    domUtil.getStyleValue = function(element, styleProperty) {
	        var style = domUtil.getStyle(element);
	        return style ? style.getPropertyValue(styleProperty) : null;
	    };
	
	    domUtil.GetMaxSupportedCSSHeight = function() {
	        if (domUtil.maxSupportedCSSHeight) {
	            return domUtil.maxSupportedCSSHeight;
	        }
	
	        var h = 1000000;
	        var testUpTo = 6000000 * 1000;
	        var div = domUtil.createElement('<div style="display:none"/>');
	        var test;
	        document.body.appendChild(div);
	        while (true) {
	            test = h + 500000; //* 2;
	            div.style.height = test + 'px';
	            if (test > testUpTo || div.offsetHeight !== test) {
	                break;
	            }
	            h = test;
	        }
	        div.parentNode.removeChild(div);
	        domUtil.maxSupportedCSSHeight = h;
	        return domUtil.maxSupportedCSSHeight;
	    };
	
	    module.exports = domUtil;
	}());


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	    var UNDEFINED = 'undefined';
	    var gcUtils = {};
	
	    function checkType(val, type) {
	        return typeof(val) === type;
	    }
	
	    /**
	     * Casts a value to a type if possible.
	     *
	     * @param value Value to cast.
	     * @param type Type or interface name to cast to.
	     * @return The value passed in if the cast was successful, null otherwise.
	     */
	    function tryCast(value, type) {
	        // null doesn't implement anything
	        if (isUndefinedOrNull(value)) {
	            return null;
	        }
	
	        // test for interface implementation (IQueryInterface)
	        if (isString(type)) {
	            return isFunction(value.implementsInterface) && value.implementsInterface(type) ? value : null;
	        }
	
	        // regular type test
	        return value instanceof type ? value : null;
	    }
	
	    gcUtils.tryCast = tryCast;
	
	    /**
	     * Determines whether an object is a primitive type (string, number, boolean, or date).
	     *
	     * @param value Value to test.
	     */
	    function isPrimitive(value) {
	        return isString(value) || isNumber(value) || isBoolean(value) || isDate(value);
	    }
	
	    gcUtils.isPrimitive = isPrimitive;
	
	    /**
	     * Determines whether an object is a string.
	     *
	     * @param value Value to test.
	     */
	    function isString(value) {
	        return checkType(value, 'string');
	    }
	
	    gcUtils.isString = isString;
	
	    /**
	     * Determines whether a string is null, empty, or whitespace only.
	     *
	     * @param value Value to test.
	     */
	    function isUndefinedOrNullOrWhiteSpace(value) {
	        return isUndefinedOrNull(value) ? true : value.replace(/\s/g, '').length < 1;
	    }
	
	    gcUtils.isUndefinedOrNullOrWhiteSpace = isUndefinedOrNullOrWhiteSpace;
	
	    /**
	     * Determines whether an object is a number.
	     *
	     * @param value Value to test.
	     */
	    function isNumber(value) {
	        return checkType(value, 'number');
	    }
	
	    gcUtils.isNumber = isNumber;
	
	    /**
	     * Determines whether an object is an integer.
	     *
	     * @param value Value to test.
	     */
	    function isInt(value) {
	        return isNumber(value) && value === Math.round(value);
	    }
	
	    gcUtils.isInt = isInt;
	
	    /**
	     * Determines whether an object is a Boolean.
	     *
	     * @param value Value to test.
	     */
	    function isBoolean(value) {
	        return checkType(value, 'boolean');
	    }
	
	    gcUtils.isBoolean = isBoolean;
	
	    /**
	     * Determines whether an object is a function.
	     *
	     * @param value Value to test.
	     */
	    function isFunction(value) {
	        return checkType(value, 'function');
	    }
	
	    gcUtils.isFunction = isFunction;
	
	    /**
	     * Determines whether an object is undefined.
	     *
	     * @param value Value to test.
	     */
	    function isUndefined(value) {
	        return checkType(value, UNDEFINED);
	    }
	
	    gcUtils.isUndefined = isUndefined;
	
	    /**
	     * Determines whether an object is a Date.
	     *
	     * @param value Value to test.
	     */
	    function isDate(value) {
	        return value instanceof Date && !isNaN(value.getTime());
	    }
	
	    gcUtils.isDate = isDate;
	
	    /**
	     * Determines whether an object is an Array.
	     *
	     * @param value Value to test.
	     */
	    function isArray(value) {
	        return value instanceof Array;
	    }
	
	    gcUtils.isArray = isArray;
	
	    /**
	     * Determines whether an object is an object (as opposed to a value type or a date).
	     *
	     * @param value Value to test.
	     */
	    function isObject(value) {
	        return !isUndefinedOrNull(value) && typeof value === 'object' && !isDate(value);
	    }
	
	    gcUtils.isObject = isObject;
	
	    /**
	     * Gets the type of a value.
	     *
	     * @param value Value to test.
	     * @return A @see:DataType value representing the type of the value passed in.
	     */
	    function getType(value) {
	        if (isNumber(value)) {
	            return 'number';
	        }
	
	        if (isBoolean(value)) {
	            return 'boolean';
	        }
	        if (isDate(value)) {
	            return 'date';
	        }
	        if (isString(value)) {
	            return 'string';
	        }
	        if (isArray(value)) {
	            return 'array';
	        }
	        if (isObject(value)) {
	            return 'object';
	        }
	        return '';
	    }
	
	    gcUtils.getType = getType;
	
	    function isNull(value) {
	        return value === null;
	    }
	
	    function isUndefinedOrNull(value) {
	        return isUndefined(value) || isNull(value);
	    }
	
	    gcUtils.isNull = isNull;
	    gcUtils.isUndefinedOrNull = isUndefinedOrNull;
	
	    //TODO: review this method after formmtter implementation done.
	    /**
	     * Changes the type of a value.
	     *
	     * If the conversion fails, the original value is returned. To check if a
	     * conversion succeeded, you should check the type of the returned value.
	     *
	     * @param value Value to convert.
	     * @param type @see:DataType to convert the value to.
	     * @return The converted value, or the original value if a conversion was not possible.
	     */
	    function changeType(value, type) {
	        if (!isUndefinedOrNull(value)) {
	            type = type.toLowerCase();
	            // convert strings to numbers, dates, or booleans
	            if (isString(value)) {
	                switch (type) {
	                    case 'number':
	                        var num = parseFloat(value);
	                        return isNaN(num) ? value : num;
	                    case 'date':
	                        return new Date(value);
	                    case 'boolean':
	                        return value.toLowerCase() === 'true';
	                }
	            }
	
	            // convert anything to string
	            if (type === 'string') {
	                return value.toString();
	            }
	        }
	
	        return value;
	    }
	
	    gcUtils.changeType = changeType;
	    //
	    ///**
	    // * Replaces each format item in a specified string with the text equivalent of an
	    // * object's value.
	    // *
	    // * The function works by replacing parts of the <b>formatString</b> with the pattern
	    // * '{name:format}' with properties of the <b>data</b> parameter. For example:
	    // *
	    // * <pre>
	    // * var data = { name: 'Joe', amount: 123456 };
	    // * var msg = wijmo.format('Hello {name}, you won {amount:n2}!', data);
	    // * </pre>
	    // *
	    // * The optional <b>formatFunction</b> allows you to customize the content by providing
	    // * context-sensitive formatting. If provided, the format function gets called for each
	    // * format element and gets passed the data object, the parameter name, the format,
	    // * and the value; it should return an output string. For example:
	    // *
	    // * <pre>
	    // * var data = { name: 'Joe', amount: 123456 };
	    // * var msg = wijmo.format('Hello {name}, you won {amount:n2}!', data,
	    // *             function (data, name, fmt, val) {
	    //*               if (wijmo.isString(data[name])) {
	    //*                   val = wijmo.escapeHtml(data[name]);
	    //*               }
	    //*               return val;
	    //*             });
	    // * </pre>
	    // *
	    // * @param format A composite format string.
	    // * @param data The data object used to build the string.
	    // * @param formatFunction An optional function used to format items in context.
	    // * @return The formatted string.
	    // */
	    //function format(format, data, formatFunction) {
	    //    format = asString(format);
	    //    return format.replace(/\{(.*?)(:(.*?))?\}/g, function (match, name, x, fmt) {
	    //        var val = match;
	    //        if (name && name[0] != '{' && data) {
	    //            // get the value
	    //            val = data[name];
	    //
	    //            // apply static format
	    //            if (fmt) {
	    //                val = wijmo.Globalize.format(val, fmt);
	    //            }
	    //
	    //            // apply format function
	    //            if (formatFunction) {
	    //                val = formatFunction(data, name, fmt, val);
	    //            }
	    //        }
	    //        return val == null ? '' : val;
	    //    });
	    //}
	    //gcUtils.format = format;
	
	    /**
	     * Clamps a value between a minimum and a maximum.
	     *
	     * @param value Original value.
	     * @param min Minimum allowed value.
	     * @param max Maximum allowed value.
	     */
	    function clamp(value, min, max) {
	        if (!isUndefinedOrNull(value)) {
	            if (!isUndefinedOrNull(max) && value > max) {
	                value = max;
	            }
	            if (!isUndefinedOrNull(min) && value < min) {
	                value = min;
	            }
	        }
	        return value;
	    }
	
	    gcUtils.clamp = clamp;
	
	    /**
	     * Copies the properties from an object to another.
	     *
	     * The destination object must define all the properties defined in the source,
	     * or an error will be thrown.
	     *
	     * @param dst The destination object.
	     * @param src The source object.
	     */
	    function copy(dst, src) {
	        for (var key in src) {
	            assert(key in dst, 'Unknown key "' + key + '".');
	            var value = src[key];
	            if (!dst._copy || !dst._copy(key, value)) {
	                if (isObject(value) && dst[key]) {
	                    copy(dst[key], value); // copy sub-objects
	                } else {
	                    dst[key] = value; // assign values
	                }
	            }
	        }
	    }
	
	    gcUtils.copy = copy;
	
	    /**
	     * Throws an exception if a condition is false.
	     *
	     * @param condition Condition expected to be true.
	     * @param msg Message of the exception if the condition is not true.
	     */
	    function assert(condition, msg) {
	        if (!condition) {
	            throw '** Assertion failed in Wijmo: ' + msg;
	        }
	    }
	
	    gcUtils.assert = assert;
	
	    /**
	     * Asserts that a value is a string.
	     *
	     * @param value Value supposed to be a string.
	     * @param nullOK Whether null values are acceptable.
	     * @return The string passed in.
	     */
	    function asString(value, nullOK) {
	        if (checkType(nullOK, UNDEFINED)) {
	            nullOK = true;
	        }
	        assert((nullOK && isUndefinedOrNull(value)) || isString(value), 'String expected.');
	        return value;
	    }
	
	    gcUtils.asString = asString;
	
	    /**
	     * Asserts that a value is a number.
	     *
	     * @param value Value supposed to be numeric.
	     * @param nullOK Whether null values are acceptable.
	     * @param positive Whether to accept only positive numeric values.
	     * @return The number passed in.
	     */
	    function asNumber(value, nullOK, positive) {
	        if (checkType(nullOK, UNDEFINED)) {
	            nullOK = false;
	        }
	        if (checkType(positive, UNDEFINED)) {
	            positive = false;
	        }
	        assert((nullOK && isUndefinedOrNull(value)) || isNumber(value), 'Number expected.');
	        if (positive && value && value < 0) {
	            throw 'Positive number expected.';
	        }
	        return value;
	    }
	
	    gcUtils.asNumber = asNumber;
	
	    /**
	     * Asserts that a value is an integer.
	     *
	     * @param value Value supposed to be an integer.
	     * @param nullOK Whether null values are acceptable.
	     * @param positive Whether to accept only positive integers.
	     * @return The number passed in.
	     */
	    function asInt(value, nullOK, positive) {
	        if (checkType(nullOK, UNDEFINED)) {
	            nullOK = false;
	        }
	        if (checkType(positive, UNDEFINED)) {
	            positive = false;
	        }
	        assert((nullOK && isUndefinedOrNull(value)) || isInt(value), 'Integer expected.');
	        if (positive && value && value < 0) {
	            throw 'Positive integer expected.';
	        }
	        return value;
	    }
	
	    gcUtils.asInt = asInt;
	
	    /**
	     * Asserts that a value is a Boolean.
	     *
	     * @param value Value supposed to be Boolean.
	     * @param nullOK Whether null values are acceptable.
	     * @return The Boolean passed in.
	     */
	    function asBoolean(value, nullOK) {
	        if (checkType(nullOK, UNDEFINED)) {
	            nullOK = false;
	        }
	        assert((nullOK && isUndefinedOrNull(value)) || isBoolean(value), 'Boolean expected.');
	        return value;
	    }
	
	    gcUtils.asBoolean = asBoolean;
	
	    /**
	     * Asserts that a value is a Date.
	     *
	     * @param value Value supposed to be a Date.
	     * @param nullOK Whether null values are acceptable.
	     * @return The Date passed in.
	     */
	    function asDate(value, nullOK) {
	        if (checkType(nullOK, UNDEFINED)) {
	            nullOK = false;
	        }
	        assert((nullOK && isUndefinedOrNull(value)) || isDate(value), 'Date expected.');
	        return value;
	    }
	
	    gcUtils.asDate = asDate;
	
	    /**
	     * Asserts that a value is a function.
	     *
	     * @param value Value supposed to be a function.
	     * @param nullOK Whether null values are acceptable.
	     * @return The function passed in.
	     */
	    function asFunction(value, nullOK) {
	        if (checkType(nullOK, UNDEFINED)) {
	            nullOK = false;
	        }
	        assert((nullOK && isUndefinedOrNull(value)) || isFunction(value), 'Function expected.');
	        return value;
	    }
	
	    gcUtils.asFunction = asFunction;
	
	    /**
	     * Asserts that a value is an array.
	     *
	     * @param value Value supposed to be an array.
	     * @param nullOK Whether null values are acceptable.
	     * @return The array passed in.
	     */
	    function asArray(value, nullOK) {
	        if (checkType(nullOK, UNDEFINED)) {
	            nullOK = false;
	        }
	        assert((nullOK && isUndefinedOrNull(value)) || isArray(value), 'Array expected.');
	        return value;
	    }
	
	    gcUtils.asArray = asArray;
	
	    /**
	     * Asserts that a value is an instance of a given type.
	     *
	     * @param value Value to be checked.
	     * @param type Type of value expected.
	     * @param nullOK Whether null values are acceptable.
	     * @return The value passed in.
	     */
	    function asType(value, type, nullOK) {
	        if (checkType(nullOK, UNDEFINED)) {
	            nullOK = false;
	        }
	        assert((nullOK && isUndefinedOrNull(value)) || value instanceof type, type + ' expected.');
	        return value;
	    }
	
	    gcUtils.asType = asType;
	
	    /**
	     * Asserts that a value is a valid setting for an enumeration.
	     *
	     * @param value Value supposed to be a member of the enumeration.
	     * @param enumType Enumeration to test for.
	     * @param nullOK Whether null values are acceptable.
	     * @return The value passed in.
	     */
	    function asEnum(value, enumType, nullOK) {
	        if (checkType(nullOK, UNDEFINED)) {
	            nullOK = false;
	        }
	        if (isUndefinedOrNull(value) && nullOK) {
	            return null;
	        }
	        var e = enumType[value];
	        assert(!isUndefinedOrNull(e), 'Invalid enum value.');
	        return isNumber(e) ? e : value;
	    }
	
	    gcUtils.asEnum = asEnum;
	
	    /**
	     * Enumeration with key values.
	     *
	     * This enumeration is useful when handling <b>keyDown</b> events.
	     */
	    var Key = {
	        /** The backspace key. */
	        Back: 8,
	        /** The tab key. */
	        Tab: 9,
	        /** The enter key. */
	        Enter: 13,
	        /** The escape key. */
	        Escape: 27,
	        /** The space key. */
	        Space: 32,
	        /** The page up key. */
	        PageUp: 33,
	        /** The page down key. */
	        PageDown: 34,
	        /** The end key. */
	        End: 35,
	        /** The home key. */
	        Home: 36,
	        /** The left arrow key. */
	        Left: 37,
	        /** The up arrow key. */
	        Up: 38,
	        /** The right arrow key. */
	        Right: 39,
	        /** The down arrow key. */
	        Down: 40,
	        /** The delete key. */
	        Delete: 46,
	        /** The F1 key. */
	        F1: 112,
	        /** The F2 key. */
	        F2: 113,
	        /** The F3 key. */
	        F3: 114,
	        /** The F4 key. */
	        F4: 115,
	        /** The F5 key. */
	        F5: 116,
	        /** The F6 key. */
	        F6: 117,
	        /** The F7 key. */
	        F7: 118,
	        /** The F8 key. */
	        F8: 119,
	        /** The F9 key. */
	        F9: 120,
	        /** The F10 key. */
	        F10: 121,
	        /** The F11 key. */
	        F11: 122,
	        /** The F12 key. */
	        F12: 123
	    };
	    gcUtils.Key = Key;
	
	    var EditorType = {
	        'Text': 'text',
	        'CheckBox': 'checkbox',
	        'Date': 'date',
	        'Color': 'color',
	        'Number': 'number'
	    };
	    gcUtils.EditorType = EditorType;
	
	    var DataType = {
	        'Object': 'Object',
	        'String': 'String',
	        'Number': 'Number',
	        'Boolean': 'Boolean',
	        'Date': 'Date',
	        'Array': 'Array'
	    };
	    gcUtils.DataType = DataType;
	
	    var isUnitlessNumber = {
	        columnCount: true,
	        flex: true,
	        flexGrow: true,
	        flexShrink: true,
	        fontWeight: true,
	        lineClamp: true,
	        lineHeight: true,
	        opacity: true,
	        order: true,
	        orphans: true,
	        widows: true,
	        zIndex: true,
	        zoom: true,
	
	        // SVG-related properties
	        fillOpacity: true,
	        strokeOpacity: true
	    };
	    var _uppercasePattern = /([A-Z])/g;
	    var msPattern = /^-ms-/;
	
	    function dangerousStyleValue(name, value) {
	        var isEmpty = isUndefinedOrNull(value) || typeof value === 'boolean' || value === '';
	        if (isEmpty) {
	            return '';
	        }
	
	        var isNonNumeric = isNaN(value);
	        if (isNonNumeric || value === 0 ||
	            isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	            return '' + value; // cast to string
	        }
	
	        if (typeof value === 'string') {
	            value = value.trim();
	        }
	        return value + 'px';
	    }
	
	    function memoizeStringOnly(callback) {
	        var cache = {};
	        return function(string) {
	            if (cache.hasOwnProperty(string)) {
	                return cache[string];
	            } else {
	                cache[string] = callback.call(this, string);
	                return cache[string];
	            }
	        };
	    }
	
	    var processStyleName = memoizeStringOnly(function(styleName) {
	        return hyphenateStyleName(styleName);
	    });
	
	    function hyphenate(string) {
	        return string.replace(_uppercasePattern, '-$1').toLowerCase();
	    }
	
	    function hyphenateStyleName(string) {
	        return hyphenate(string).replace(msPattern, '-ms-');
	    }
	
	    function createMarkupForStyles(styles) {
	        var serialized = '';
	        for (var styleName in styles) {
	            if (!styles.hasOwnProperty(styleName)) {
	                continue;
	            }
	            var styleValue = styles[styleName];
	            if (!isUndefinedOrNull(styleValue)) {
	                serialized += processStyleName(styleName) + ':';
	                serialized += dangerousStyleValue(styleName, styleValue) + ';';
	            }
	        }
	        return serialized || null;
	    }
	
	    gcUtils.createMarkupForStyles = createMarkupForStyles;
	
	    /**
	     * Cancels the route for DOM event.
	     */
	    function cancelDefault(e) {
	        if (e.preventDefault) {
	            e.preventDefault();
	            e.stopPropagation();
	        } else {
	            //IE 8
	            e.cancelBubble = false;
	            e.returnValue = false;
	        }
	        return false;
	    }
	
	    gcUtils.cancelDefault = cancelDefault;
	
	    function serializeObject(obj) {
	        var cloneObj = _.clone(obj);
	        var cache_ = [];
	        if (cloneObj) {
	            cache_.push(cloneObj);
	        }
	        var dest;
	        while (cache_.length > 0) {
	            dest = cache_.pop();
	            if (!isObject(dest)) {
	                continue;
	            }
	            for (var item in dest) {
	                cache_.push(dest[item]);
	                if (isFunction(dest[item])) {
	                    dest[item] = serializeFunction(dest[item]);
	                }
	            }
	        }
	        return cloneObj;
	    }
	
	    gcUtils.serializeObject = serializeObject;
	
	    function deserializeObject(obj) {
	        var cloneObj = _.clone(obj);
	        var cache_ = [];
	        if (cloneObj) {
	            cache_.push(cloneObj);
	        }
	        var dest;
	        var func;
	        while (cache_.length > 0) {
	            dest = cache_.pop();
	            if (!isObject(dest)) {
	                continue;
	            }
	            for (var item in dest) {
	                cache_.push(dest[item]);
	                if (isString(dest[item])) {
	                    func = deserializeFunction(dest[item]);
	                    if (func) {
	                        dest[item] = func;
	                    }
	                }
	            }
	        }
	        return cloneObj;
	    }
	
	    gcUtils.deserializeObject = deserializeObject;
	
	    function serializeFunction(value) {
	        return value.toString();
	    }
	
	    gcUtils.serializeFunction = serializeFunction;
	
	    function deserializeFunction(value) {
	        if (isString(value)) {
	            var tempStr = value.substr(8, value.indexOf('(') - 8); //8 is 'function' length
	            if (value.substr(0, 8) === 'function' && tempStr.replace(/\s+/, '') === '') {
	                var argStart = value.indexOf('(') + 1;
	                var argEnd = value.indexOf(')');
	                var args = value.substr(argStart, argEnd - argStart).split(',').map(function(arg) {
	                    return arg.replace(/\s+/, '');
	                });
	                var bodyStart = value.indexOf('{') + 1;
	                var bodyEnd = value.lastIndexOf('}');
	                /*jslint evil: true */
	                return new Function(args, value.substr(bodyStart, bodyEnd - bodyStart));
	            }
	        }
	        return null;
	    }
	
	    gcUtils.deserializeFunction = deserializeFunction;
	    /**
	     * Asserts that a value is an @see:ICollectionView or an Array.
	     *
	     * @param value Array or @see:ICollectionView.
	     * @param nullOK Whether null values are acceptable.
	     * @return The @see:ICollectionView that was passed in or a @see:CollectionView
	     * created from the array that was passed in.
	     */
	    /*
	     function asCollectionView(value, nullOK) {
	     if (typeof nullOK === "undefined") { nullOK = true; }
	     if (value == null && nullOK) {
	     return null;
	     }
	     var cv = tryCast(value, 'ICollectionView');
	     if (cv != null) {
	     return cv;
	     }
	     if (!isArray(value)) {
	     assert(false, 'Array or ICollectionView expected.');
	     }
	     return new wijmo.collections.CollectionView(value);
	     }
	     gcUtils.asCollectionView = asCollectionView;*/
	
	    /**
	     * Find the plugin module.
	     * @param name of module
	     * @returns plugin module object
	     */
	    function findPlugin(name) {
	        var plugin;
	        // find from global
	        try {
	            plugin = GcSpread.Views.GcGrid.Plugins[name];// jshint ignore:line
	        } catch (e) {
	        }
	
	        //if (!plugin && typeof define === 'function' && define.amd) {// jshint ignore:line
	        //    plugin = requirejs && requirejs(name) // jshint ignore:line
	        //}
	        //
	        //// commonjs not supported now
	        //if (!plugin && typeof exports === 'object' && typeof module === 'object') {// jshint ignore:line
	        //}
	        return plugin;
	    }
	
	    gcUtils.findPlugin = findPlugin;
	
	    module.exports = gcUtils;
	}());


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	(function(window) {
	        'use strict';
	
	        var supportEvents = ['touchstart', 'touchmove', 'touchend'];
	
	        var lastHwTimestamp = 0;
	
	        var eventMappings = {
	            touchstart: ['pointerdown', 'MSPointerDown', 'touchstart'],
	            touchmove: ['pointermove', 'MSPointerMove', 'touchmove'],
	            touchend: ['pointerup', 'MSPointerUp', 'touchend']
	        };
	
	        var mappingIndex = window.PointerEvent ? 0 : (window.MSPointerEvent ? 1 : 2);
	
	        var touchesWrapper;
	        var changedTouchesWrapper;
	        var targetTouchesWrapper;
	
	        function TouchWrapper(element) {
	            return new Manager(element);
	        }
	
	        function Manager(element) {
	            this.element = element;
	        }
	
	        Manager.prototype = {
	            on: function(targetEvent, handler) {
	                var element = this.element;
	
	                if (supportEvents.indexOf(targetEvent) === -1) {
	                    element.addEventListener(targetEvent, handler);
	                    return;
	                }
	
	                if (supportTargetEvent(element, targetEvent)) {
	                    element.addEventListener(targetEvent, handler);
	                    return;
	                } else {
	                    var nativeEvent = eventNameGenerate(targetEvent);
	                    if (supportTargetEvent(element, nativeEvent)) {
	                        var nativeHandler = function(evt) {
	                            generateTouchClonedEvent(evt, handler, targetEvent);
	                        };
	
	                        var uid = guid();
	                        handler.uid = uid;
	                        addorRemoveWrapEventListener(element, nativeEvent, nativeHandler, uid, true);
	
	                        disableIEScroll(element);
	                    }
	                }
	            },
	
	            off: function(targetEvent, handler) {
	                var element = this.element;
	
	                if (supportEvents.indexOf(targetEvent) === -1) {
	                    element.removeEventListener(targetEvent, handler);
	                    return;
	                }
	
	                if (supportTargetEvent(element, targetEvent)) {
	                    element.removeEventListener(element, targetEvent);
	                    return;
	                } else {
	                    addorRemoveWrapEventListener(element, targetEvent, handler, false);
	                    enableIEScroll(element);
	                }
	            },
	
	            shouldRaiseTapEvent:function() {
	                return !(window.PointerEvent || window.MSPointerEvent);
	            }
	        };
	
	        function TouchListWrapper() {
	            var touchList = [];
	            var scope = this;
	
	            //refer: http://www.w3.org/TR/touch-events/
	            function Touch(identifier, target, screenX, screenY, clientX, clientY, pageX, pageY) {
	                var self = this;
	                self.identifier = identifier;
	                self.target = target;
	                self.screenX = screenX;
	                self.screenY = screenY;
	                self.clientX = clientX;
	                self.clientY = clientY;
	                self.pageX = pageX;
	                self.pageY = pageY;
	            }
	
	            function getTouch(identifier) {
	                var i;
	                var l;
	                for (i = 0, l = touchList.length; i < l; i += 1) {
	                    if (touchList[i].identifier === identifier) {
	                        return touchList[i];
	                    }
	                }
	            }
	
	            function addUpdateTouch(touch) {
	                var i;
	                var l;
	                for (i = 0, l = touchList.length; i < l; i += 1) {
	                    if (touchList[i].identifier === touch.identifier) {
	                        touchList[i] = touch;
	                        return;
	                    }
	                }
	
	                touchList.push(touch);
	            }
	
	            function removeTouch(identifier) {
	                var i;
	                var l;
	                for (i = 0, l = touchList.length; i < touchList.length; i += 1) {
	                    if (touchList[i].identifier === identifier) {
	                        touchList.splice(i, 1);
	                    }
	                }
	            }
	
	            function clearTouches() {
	                while (touchList.length > 0) {
	                    touchList.pop();
	                }
	            }
	
	            function containsTouchAt(screenX, screenY) {
	                var i;
	
	                for (i = 0; i < touchList.length; i += 1) {
	                    if (touchList[i].screenX === screenX && touchList[i].screenY === screenY) {
	                        return true;
	                    }
	                }
	
	                return false;
	            }
	
	            scope.touchList = touchList;
	
	            scope.Touch = Touch;
	            scope.getTouch = getTouch;
	            scope.addUpdateTouch = addUpdateTouch;
	            scope.removeTouch = removeTouch;
	            scope.clearTouches = clearTouches;
	            scope.containsTouchAt = containsTouchAt;
	        }
	
	        function addorRemoveWrapEventListener(element, event, handler, uid, enable) {
	            if (enable) {
	                element.addEventListener(event, handler, false);
	                if (!window.cachedEvents) {
	                    window.cachedEvents = [];
	                }
	
	                window.cachedEvents.push(
	                    {
	                        element: element,
	                        event: event,
	                        handler: handler,
	                        uid: uid
	                    }
	                );
	            } else {
	                if (!window.cachedEvents) {
	                    return;
	                }
	
	                for (var i = 0, l = window.cachedEvents.length; i < l; i++) {
	                    var cachedEvent = window.cachedEvents[i];
	                    if (cachedEvent.uid === handler.uid) {
	                        cachedEvent.element.removeEventListener(cachedEvent.event, cachedEvent.handler);
	                        break;
	                    }
	                }
	
	                window.cachedEvents.splice(i, 1);
	                if (window.cachedEvents.length === 0) {
	                    delete window.cachedEvents;
	                }
	            }
	        }
	
	        function generateTouchClonedEvent(eventArgs, handler) {
	            var evObj;
	            var oldTouch;
	            var oldTarget;
	
	            function updateTargetTouches(thisTouchTarget, touchesTouchList) {
	                var i;
	                var touch;
	
	                targetTouchesWrapper.clearTouches();
	
	                //targetTouches:a list of Touches for every point of contact that is touching the surface and started on the element that is the target of the current event.
	                for (i = 0; i < touchesTouchList.length; i++) {
	                    touch = touchesTouchList[i];
	                    if (touch.target.isSameNode(thisTouchTarget)) {
	                        targetTouchesWrapper.addUpdateTouch(touch);
	                    }
	                }
	            }
	
	            function touchHandler(event) {
	                var eventType;
	                var touch;
	                var touchEvent;
	
	                if (isPointerDownEvent(event)) {
	                    eventType = 'touchstart';
	                } else {
	                    eventType = 'touchmove';
	                }
	
	                touch = new touchesWrapper.Touch(event.pointerId, (isPointerDownEvent(event) ? event.target : oldTarget),
	                    event.screenX, event.screenY, event.clientX, event.clientY, event.pageX, event.pageY);
	
	                // Remove, from changedTouches, any Touch that is no longer being touched, or is being touched
	                // in exactly the same place.
	                // In order to make sure that simultaneous touches don't kick each other off of the changedTouches array
	                // (because they are processed as different pointer events), skip this if the lastHwTimestamp hasn't increased.
	                if (event.hwTimestamp > lastHwTimestamp) {
	                    (function() {
	                        var i;
	                        var changedTouchList;
	                        var changedTouch;
	                        var matchingTouch;
	                        var identifier;
	                        changedTouchList = changedTouchesWrapper.touchList;
	                        for (i = 0; i < changedTouchList.length; i += 1) {
	                            changedTouch = changedTouchList[i];
	                            identifier = changedTouch.identifier;
	                            matchingTouch = touchesWrapper.getTouch(identifier);
	
	                            if (!matchingTouch || touchesAreAtSameSpot(matchingTouch, changedTouch)) {
	                                changedTouchesWrapper.removeTouch(identifier);
	                            }
	                        }
	                    }());
	                }
	
	                var pointerId = event.pointerId;
	                if (isPointerDownEvent(event)) {
	                    if (event.type === 'MSPointerDown') {
	                        touch.target.msSetPointerCapture(pointerId);
	                    } else {
	                        touch.target.setPointerCapture(pointerId);
	                    }
	
	                    //问题：有些时候，当手指离开当前页面时，element 无法收到pointer up/cancle 事件，
	                    //就没有时机去remove 离开的touch pointer
	                    //方案：目前只有在pointerdown时清空缓存的pointer 信息。
	                    //影响：按照以前设计可以支持多个手指，现在只能支持单个手指，因为IE下的zoom行为已经被浏览器实现，所以
	                    //改动不会导致缺失。后面有时间的话这个点需要再考虑考虑 -Tim 4/28/2015.
	                    touchesWrapper.clearTouches();
	                    log('pointerDown ' + 'timstap:' + event.hwTimestamp + ' pointerId: ' + event.pointerId);
	                } else {
	                    log('pointerMove' + ' timstap:' + event.hwTimestamp + ' pointerId: ' + event.pointerId);
	                }
	                event.stopPropagation();
	                touchesWrapper.addUpdateTouch(touch);
	                changedTouchesWrapper.addUpdateTouch(touch);
	                updateTargetTouches(touch.target, touchesWrapper.touchList);
	
	                touchEvent = new CustomEvent(eventType, {bubbles: true, cancelable: true});
	                touchEvent.touches = touchesWrapper.touchList;
	                touchEvent.changedTouches = changedTouchesWrapper.touchList;
	                touchEvent.targetTouches = targetTouchesWrapper.touchList;
	
	                return touchEvent;
	            }
	
	            function touchChangedHandler(event) {
	                var eventType;
	                var touch;
	                var touchEvent;
	
	                event.changedTouches = [];
	                event.changedTouches.length = 1;
	                event.changedTouches[0] = event;
	                event.changedTouches[0].identifier = event.pointerId;
	
	                touch = new touchesWrapper.Touch(event.pointerId, oldTarget, event.screenX, event.screenY, event.clientX, event.clientY, event.pageX, event.pageY);
	
	                if (isPointerUpEvent(event)) {
	                    eventType = 'touchend';
	                    if (event.type === 'MSPointerUp') {
	                        touch.target.msReleasePointerCapture(event.pointerId);
	                    } else {
	                        touch.target.releasePointerCapture(event.pointerId);
	                    }
	                }
	
	                // This is a new touch event if it happened at a greater time than the last touch event.
	                // If it is a new touch event, clear out the changedTouches TouchList.
	                if (event.hwTimestamp > lastHwTimestamp) {
	                    changedTouchesWrapper.clearTouches();
	                }
	                event.stopPropagation();
	                touchesWrapper.removeTouch(touch.identifier);
	                changedTouchesWrapper.addUpdateTouch(touch);
	                updateTargetTouches(touch.target, touchesWrapper.touchList);
	
	                touchEvent = new CustomEvent(eventType, {bubbles: true, cancelable: true});
	                touchEvent.touches = touchesWrapper.touchList;
	                touchEvent.changedTouches = changedTouchesWrapper.touchList;
	                touchEvent.targetTouches = targetTouchesWrapper.touchList;
	
	                return touchEvent;
	            }
	
	            var output = false;
	
	            function log(value) {
	                if (output) {
	                    console.log(value);
	                }
	            }
	
	            function isPointerDownEvent(event) {
	                return event.type === 'MSPointerDown' || event.type === 'pointerdown';
	            }
	
	            function isPointerMoveEvent(event) {
	                return event.type === 'MSPointerMove' || event.type === 'pointermove';
	            }
	
	            function isPointerUpEvent(event) {
	                return event.type === 'MSPointerUp' || event.type === 'pointerup';
	            }
	
	            if (ignorePointerEvent(eventArgs)) {
	                return;
	            }
	
	            // An important difference between the MS pointer events and the W3C touch events
	            // is that for pointer events except for pointerdown, all target the element that the touch
	            // is over when the event is fired.
	            // The W3C touch events target the element where the touch originally started.
	            // Therefore, when these events are fired, we must make this change manually.
	            if (!isPointerDownEvent(eventArgs)) {
	                oldTouch = touchesWrapper.getTouch(eventArgs.pointerId);
	                oldTarget = oldTouch ? oldTouch.target : eventArgs.target;
	            }
	
	            if (isPointerDownEvent(eventArgs) || isPointerMoveEvent(eventArgs)) {
	                evObj = touchHandler(eventArgs);
	            } else {
	                evObj = touchChangedHandler(eventArgs);
	            }
	
	            evObj.preventDefault = function() {
	                if (eventArgs.preventDefault) {
	                    eventArgs.preventDefault();
	                }
	            };
	
	            handler.call(eventArgs.target, evObj);
	
	            lastHwTimestamp = eventArgs.hwTimestamp;
	        }
	
	        function eventNameGenerate(event) {
	            return eventMappings[event][mappingIndex];
	        }
	
	        function supportTargetEvent(element, event) {
	            var eventPro = 'on' + event.toLowerCase();
	            return (eventPro in element) || (element.hasOwnProperty(eventPro));
	        }
	
	        function ignorePointerEvent(event) {
	
	            if (event.pointerType === 'mouse' || event.pointerType === 4) {
	                return true;
	            }
	
	            if (event.type === 'pointerdown' && event.x === 0 && event.y === 0) {
	                return true;
	            }
	
	            if (event.pointerType === 'pen' && event.pressure === 0 && event.type === 'pointermove') {
	                return true;
	            }
	            return false;
	        }
	
	        function touchesAreAtSameSpot(touch0, touch1) {
	            return touch0.screenX === touch1.screenX && touch0.screenY === touch1.screenY;
	        }
	
	        function disableIEScroll(element) {
	            if (element && element.style) {
	                if (window.MSPointerEvent) {
	                    element.style.setAttribute('-ms-touch-action', 'none;');
	                } else {
	                    element.style.touchAction = 'none';
	                }
	            }
	        }
	
	        function enableIEScroll(element) {
	            if (element && element.style) {
	                if (window.MSPointerEvent) {
	                    element.style.removeAttribute('-ms-touch-action');
	                } else {
	                    element.style.touchAction = null;
	                }
	            }
	        }
	
	        function guid() {
	            function s4() {
	                return Math.floor((1 + Math.random()) * 0x10000)
	                    .toString(16)
	                    .substring(1);
	            }
	
	            return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
	                s4() + '-' + s4() + s4() + s4();
	        }
	
	        touchesWrapper = new TouchListWrapper();
	        changedTouchesWrapper = new TouchListWrapper();
	        targetTouchesWrapper = new TouchListWrapper();
	
	        module.exports = TouchWrapper;
	    }(window));


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var domUtil = __webpack_require__(2);
	    var gcUtils = __webpack_require__(3);
	    var doT = __webpack_require__(8);
	    var EditorType = gcUtils.EditorType;
	    var Editor = {};
	    var EditMode = {
	        Inline: 'inline',
	        PopUp: 'popup',
	        EditForm: 'editForm'
	    };
	
	    //<editor-fold desc="Helper">
	    function setContainerZIndex_(GeneralEditor) {
	        var elements = document.querySelectorAll('#' + GeneralEditor.options.gridModel.uid + '-editing-area .top');
	        var length = elements.length;
	        for (var i = 0; i < length; i++) {
	            domUtil.removeClass(elements[i], 'top');
	        }
	        domUtil.addClass(this, 'top');
	    }
	
	    function adjustStyle_(GeneralEditor) {
	        var self = GeneralEditor;
	        var inputHeight = self.options.position.height;
	        if (self.type_ === EditorType.Date) {
	            var datePickerHeight = 10;
	            var style = domUtil.getStyle(self.$input);
	            var borderTopWidth = parseFloat(style.getPropertyValue('border-top-width'));
	            var borderBottomWidth = parseFloat(style.getPropertyValue('border-bottom-width'));
	            if (!isNaN(borderTopWidth) && !isNaN(borderBottomWidth)) {
	                var padding = (inputHeight - borderTopWidth - borderBottomWidth) / 2 - datePickerHeight;
	                self.$input.style.padding = padding + 'px 0px';
	            }
	        }
	    }
	
	    function fixDate_(value) {
	        var date = new Date(value);
	        var year = date.getFullYear().toString();
	        var month = (date.getMonth() + 1).toString();
	        var day = (date.getDate()).toString();
	        if (month.length === 1) {
	            month = '0' + month;
	        }
	        if (day.length === 1) {
	            day = '0' + day;
	        }
	        return year + '-' + month + '-' + day;
	    }
	
	    function setViewportTransform_(remove) {
	        //Fix bug. transform will make 'z-index' take no effect.
	        var grid = this.gridModel;
	        var proName = (navigator.userAgent.indexOf('MSIE') !== -1 || navigator.appVersion.indexOf('Trident/') > 0 || navigator.userAgent.match(/Firefox/i)) ? 'transform' : '-webkit-transform';
	        var viewportInner = document.getElementById(grid.uid + '-viewport-inner');
	        var scrollOffset = grid.scrollOffset;
	        if (remove) {
	            viewportInner.style.removeProperty(proName);
	            viewportInner.style.left = -scrollOffset.left + 'px';
	            viewportInner.style.top = -scrollOffset.top + 'px';
	        } else {
	            var translate3d = 'translate3d(' + (-scrollOffset.left) + 'px,' + (-scrollOffset.top) + 'px, 0px)';
	            viewportInner.style.removeProperty('left');
	            viewportInner.style.removeProperty('top');
	            viewportInner.style.setProperty(proName, translate3d);
	        }
	    }
	
	    function isValueChanged_(newValue, oldValue) {
	        return JSON.stringify(newValue) !== JSON.stringify(oldValue);
	    }
	
	    function serializeValue_(index) {
	        var self = this;
	        var editMode = self.gridModel.options.editMode;
	        var editor = self.editors_[index];
	        var columnDef = self.gridModel.columns[index];
	        var value;
	        if (editMode === EditMode.Inline) {
	            value = editor.serializeValue();
	        } else {
	            var tagName = editor.tagName.toLowerCase();
	            if (tagName === 'input' && editor.type === EditorType.CheckBox) {
	                value = editor.checked;
	            } else {
	                value = editor.value;
	            }
	        }
	        var dataType = columnDef.dataType;
	        if (!dataType) {
	            dataType = gcUtils.getType(self.formattedItem[columnDef.dataField]);
	        }
	        return dataType ? gcUtils.changeType(value, dataType) : value;
	    }
	
	    function commitChanges_(newItem) {
	        var self = this;
	        var grid = self.gridModel;
	        var editors = self.editors_;
	        var length = grid.columns.length;
	        var row = self.editingInfo_.rowIndex;
	        var groupInfo = self.editingInfo_.groupInfo;
	        var item = groupInfo ? groupInfo.data.getItem(row) : grid.getDataItem(row);
	        var editor;
	        var columnDef;
	        var val;
	        var colDataField;
	        var colID;
	        var calcSource = grid.data.calcSource;
	        for (var col = 0; col < length; col++) {
	            editor = editors[col];
	            if (editor) {
	                columnDef = grid.columns[col];
	                colDataField = columnDef.dataField;
	                colID = columnDef.id;
	                if (columnDef.isCalcColumn_) {
	                    val = newItem[colID];
	                    if (colDataField !== val) {
	                        columnDef.dataField = val;
	                        if (calcSource) {
	                            calcSource.dirtyColumn(colID, -1, val);
	                            self.wholeColumnChanged_ = true;
	                        }
	                    }
	                } else {
	                    val = newItem[colDataField];
	                    if (item[colDataField] !== val) {
	                        item[colDataField] = val;
	                        if (calcSource) {
	                            self.wholeColumnChanged_ = calcSource.dirtyColumn(colID, row);
	                        }
	                    }
	                }
	                editor = null;
	            }
	        }
	        if (grid.data.groups) {
	            grid.data.refresh();
	        }
	    }
	
	    function cacheTemplateEditors_(element) {
	        var self = this;
	        var tempEditors = element.querySelectorAll('[data-column]');
	        var gridModel = self.gridModel;
	        var columns = gridModel.columns;
	        self.editors_ = [];
	        var i;
	        var index;
	        var length;
	        var col;
	        for (i = 0, length = tempEditors.length; i < length; i++) {
	            col = gridModel.getColById_(tempEditors[i].getAttribute('data-column'));
	            index = columns.indexOf(col);
	            if (index >= 0) {
	                self.editors_[index] = tempEditors[i];
	            }
	        }
	    }
	
	    function allowEditing_() {
	        var self = this;
	        var gridModel = self.gridModel;
	        var columns = gridModel.columns;
	        var i;
	        var length;
	        if (!gridModel.options.allowEditing) {
	            return false;
	        }
	        for (i = 0, length = columns.length; i < length; i++) {
	            if (columns[i].allowEditing) {
	                return true;
	            }
	        }
	        return false;
	    }
	
	    //</editor-fold>
	
	    //<editor-fold desc="GeneralEditor">
	    var GeneralEditor = (function() {
	        function GeneralEditor(options) {
	            var self = this;
	            self.options = options;
	        }
	
	        GeneralEditor.prototype = {
	            install: function() {
	                var self = this;
	                var options = self.options;
	                self.type_ = Editor.getEditorType(options.col.dataType);
	                var type = self.type_;
	
	                self.container = options.container;
	
	                var inputElement;
	                if (type === EditorType.CheckBox) {
	                    inputElement = '<input type="checkbox" class="gc-inline-editor checkbox"' +
	                        ' style="margin:0 auto;vertical-align:middle" />';
	                    self.container.style.textAlign = 'center';
	                } else {
	                    inputElement = '<input type="' + type + '" class="gc-inline-editor ' + (type === EditorType.Date ? 'date' : '') + '" />';
	                }
	                self.$input = domUtil.createElement(inputElement);
	
	                var rawValue = options.value;
	                if (type === EditorType.CheckBox) {
	                    self.defaultValue = !!rawValue;
	                    self.$input.checked = self.defaultValue;
	                } else if (type === EditorType.Date) {
	                    self.defaultValue = fixDate_(rawValue);
	                    self.$input.value = self.defaultValue;
	                    self.$input.select();
	                } else {
	                    self.defaultValue = rawValue;
	                    self.$input.value = self.defaultValue;
	                    self.$input.select();
	                }
	
	                self.container.appendChild(self.$input);
	                adjustStyle_(self);
	                self.$input.focus();
	                self.setZIndex_ = setContainerZIndex_.bind(self.container, self);
	                self.container.addEventListener('click', self.setZIndex_);
	            },
	
	            destroy: function() {
	                var container = this.container;
	                container.removeEventListener('click', this.setZIndex_);
	            },
	
	            focus: function() {
	                this.$input.focus();
	            },
	
	            serializeValue: function() {
	                var self = this;
	                if (self.type_ === EditorType.CheckBox) {
	                    return self.$input.checked;
	                } else {
	                    return self.$input.value;
	                }
	            }
	        };
	        return GeneralEditor;
	    })();
	    //</editor-fold>
	
	    //<editor-fold desc="Editor Template">
	    function getEditorTemplate_() {
	        var self = this;
	        var layoutEngine = self.gridModel.layoutEngine;
	        var template = getUserDefinedEditorTemplate_.call(self) || layoutEngine.getDefaultEditorTemplate_();
	        var element = domUtil.createTemplateElement(template);
	        var templateStr = domUtil.getElementInnerText(element);
	        var controls = element.querySelectorAll('[data-column]');
	        var id;
	        var con;
	        var tagName;
	        var oldTmp;
	        var newTmp;
	        var selOpt;
	        var i;
	        var j;
	        var len;
	        var length;
	        var oldOptStr;
	        var newOptStr;
	        for (i = 0, length = controls.length; i < length; i++) {
	            con = controls[i];
	            oldTmp = domUtil.getElementOuterText(con);
	            tagName = con.tagName.toLowerCase();
	            id = con.getAttribute('data-column');
	            if (tagName === 'textarea') {
	                con.innerHTML = '{{=it.' + id + '}}';
	                newTmp = domUtil.getElementOuterText(con);
	            } else if (tagName === 'input' && con.type === 'checkbox') {
	                newTmp = '<input ' + '{{? it.' + id + '}}checked{{?}}' + oldTmp.substr(oldTmp.indexOf('<input') + 6); // 6 is '<input' length
	            } else if (tagName === 'select') {
	                selOpt = con.options;
	                newTmp = oldTmp;
	                for (j = 0, len = selOpt.length; j < len; j++) {
	                    oldOptStr = domUtil.getElementOuterText(selOpt[j]);
	                    newOptStr = '<option ' + '{{? it.' + id + ' === "' + selOpt[j].text + '"}}selected{{?}}' + oldOptStr.substr(oldOptStr.indexOf('<option') + 7); //7 is '<option' length
	                    newTmp = newTmp.replace(oldOptStr, newOptStr);
	                }
	            } else {
	                con.setAttribute('value', '{{=it.' + id + '}}');
	                newTmp = domUtil.getElementOuterText(con);
	            }
	            if (newTmp) {
	                // jscs:disable validateQuoteMarks
	                /*jshint quotmark: double */
	                newTmp = newTmp.replace(/"/g, "'");
	                // jscs:enable validateQuoteMarks
	                templateStr = templateStr.replace(oldTmp, newTmp);
	            }
	        }
	        return doT.template(templateStr, null, null, true);
	    }
	
	    function getUserDefinedEditorTemplate_() {
	        var gridModel = this.gridModel;
	        var options = gridModel.options;
	        if (options && options.editRowTemplate) {
	            var editTmp = gridModel.options.editRowTemplate;
	            if (gcUtils.isString(editTmp) && editTmp.length > 1 && editTmp[0] === '#') {
	                var tmplElement = document.getElementById(editTmp.slice(1));
	                return tmplElement.innerHTML;
	            } else {
	                return editTmp;
	            }
	        }
	        return null;
	    }
	
	    function getFormattedItem_(item) {
	        var self = this;
	        var columns = self.gridModel.columns;
	        var col;
	        var dataField;
	        for (var i = 0, length = columns.length; i < length; i++) {
	            col = columns[i];
	            dataField = col.dataField;
	            if (col.isCalcColumn_) {
	                item[col.id] = dataField;
	            } else {
	                if (col.dataType && col.dataType.toLowerCase() === 'date') {
	                    item[dataField] = fixDate_(item[dataField]);
	                }
	            }
	        }
	        return item;
	    }
	
	    //</editor-fold>
	
	    //<editor-fold desc="Start Editing">
	    function startTemplateEditing_(groupInfo, uiRowIndex) {
	        var self = this;
	        var gridModel = self.gridModel;
	        var editorTemplate_ = getEditorTemplate_.call(this);
	        var rowIndex = self.editingInfo_.rowIndex;
	        var dataItem = groupInfo ? groupInfo.data.getItem(rowIndex) : gridModel.getDataItem(rowIndex);
	        self.formattedItem = getFormattedItem_.call(self, _.clone(dataItem));
	        self.oldItem = _.clone(self.formattedItem);
	        var args = {
	            status: 'beforeStartEditing',
	            gridModel: gridModel,
	            groupInfo: groupInfo,
	            row: rowIndex,
	            item: self.formattedItem,
	            cancel: false
	        };
	        gridModel.editing.raise(gridModel, args);
	        if (args && args.cancel) {
	            return false;
	        }
	        var editorHTML = editorTemplate_(self.formattedItem);
	        gridModel.layoutEngine.startEditing_(groupInfo, uiRowIndex, editorHTML);
	        var element;
	        var uid = gridModel.uid;
	        var editMode = gridModel.options.editMode;
	        if (editMode === EditMode.PopUp) {
	            element = document.getElementById(uid + '-popup-editing-area');
	        } else if (editMode === EditMode.EditForm) {
	            element = document.getElementById(uid + '-form-editing-area');
	        }
	        cacheTemplateEditors_.call(self, element);
	    }
	
	    function startInlineEditing_(groupInfo, uiRowIndex) {
	        var self = this;
	        var grid = self.gridModel;
	        var columns = grid.columns;
	        var editors = self.editors_ = [];
	        //TODO: re-consider this, maybe we don't need remove select effects
	        //var oldElement = domUtil.getElement('.gc-selected');
	        //if (oldElement) {
	        //    domUtil.removeClass(oldElement, 'gc-selected');
	        //}
	        var selector = grid.uid + (groupInfo ? ('-gr' + groupInfo.path.join('_')) : '') + '-r' + uiRowIndex;
	        var pinnedSelector = grid.uid + (groupInfo ? ('-pgr' + groupInfo.path.join('_')) : '') + '-pr' + uiRowIndex;
	        var pinnedRightSelector = grid.uid + (groupInfo ? ('-prgr' + groupInfo.path.join('_')) : '') + '-prr' + uiRowIndex;
	
	        var row = document.getElementById(selector);
	        var rowRect = domUtil.getElementRect(row);
	        var pinnedRow = document.getElementById(pinnedSelector);
	        var pinnedRowRect;
	        if (pinnedRow) {
	            pinnedRowRect = domUtil.getElementRect(pinnedRow);
	        }
	
	        //var pinnedRightRow = document.getElementById(pinnedRightSelector);
	        //var pinnedRightRowRect;
	        //if (pinnedRightRow) {
	        //    pinnedRightRowRect = domUtil.getElementRect(pinnedRightRow);
	        //}
	        self.inlineContainer = document.createDocumentFragment();
	        var container = domUtil.createElement('<div class="gc-inline-editor-container" ></div>');
	        var rowIndex = self.editingInfo_.rowIndex;
	        var dataItem = groupInfo ? groupInfo.data.getItem(rowIndex) : grid.getDataItem(rowIndex);
	        self.formattedItem = getFormattedItem_.call(self, _.clone(dataItem));
	        self.oldItem = _.clone(self.formattedItem);
	        var args = {
	            status: 'beforeStartEditing',
	            gridModel: grid,
	            groupInfo: groupInfo,
	            row: rowIndex,
	            item: self.formattedItem,
	            cancel: false
	        };
	        grid.editing.raise(grid, args);
	        if (args && args.cancel) {
	            return false;
	        }
	        var cloneContainer;
	        var editor;
	        var columnDef;
	        var editingValue;
	        var editNode;
	        var actionNode;
	        var cellPosition;
	        var op;
	        var i;
	        var len;
	        var s;
	        var needSetViewportTransform = false;
	        for (i = 0, len = columns.length; i < len; i++) {
	            columnDef = columns[i];
	            if (columnDef.pinned === 'left') {
	                s = pinnedSelector;
	            } else if (columnDef.pinned === 'right') {
	                s = pinnedRightSelector;
	            } else {
	                s = selector;
	            }
	            if (self.isColumnEditable(grid, columnDef)) {
	                editingValue = columnDef.isCalcColumn_ ? self.formattedItem[columnDef.id] : self.formattedItem[columnDef.dataField];
	                editNode = domUtil.getElement('#' + s + ' [data-column="' + columnDef.id + '"]');
	                if (editNode) {
	                    cellPosition = domUtil.getElementRect(editNode);
	                    cloneContainer = container.cloneNode();
	
	                    domUtil.setCss(cloneContainer, {
	                        'top': cellPosition.top - rowRect.top,
	                        'left': cellPosition.left - (pinnedRowRect ? pinnedRowRect.left : rowRect.left),
	                        'width': cellPosition.width - 1,  //TODO: -1 is not a good way
	                        'zIndex': columnDef.pinned === 'none' ? 1 : 2
	                    });
	                    self.inlineContainer.appendChild(cloneContainer);
	                    op = {
	                        container: cloneContainer,
	                        gridModel: grid,
	                        col: columnDef,
	                        position: cellPosition,
	                        value: editingValue
	                    };
	                    if (columnDef.editor) {
	                        editor = new columnDef.editor(op);
	                    } else {
	                        editor = new GeneralEditor(op);
	                        //fix bug. set height as the default row height for the default editors.
	                        cloneContainer.style.height = cellPosition.height + 'px';
	                    }
	
	                    editor.install();
	                    editors[i] = editor;
	                    editor = null;
	                }
	            } else {
	                if (columnDef.action) {
	                    actionNode = domUtil.getElement('#' + s + ' .c' + i + ' .gc-action-area');
	                    if (actionNode) {
	                        actionNode.className += ' top';
	                    }
	                    needSetViewportTransform = true;
	                }
	            }
	        }
	        if (needSetViewportTransform) {
	            setViewportTransform_.call(self, true);
	        }
	        grid.layoutEngine.startEditing_(groupInfo, uiRowIndex);
	        for (i = 0, len = editors.length; i < len; i++) {
	            if (editors[i] && editors[i].focus) {
	                editors[i].focus();
	                break;
	            }
	        }
	    }
	
	    //</editor-fold>
	
	    //<editor-fold desc="Event">
	    function registEvents_() {
	        var self = this;
	        var grid = self.gridModel;
	        self.doubleClickHandler_ = doubleClickHandler_.bind(self);
	        self.mouseClickHandler_ = mouseClickHandler_.bind(self);
	        self.tapHandler_ = tapHandler_.bind(self);
	        grid.onMouseDbClick.addHandler(self.doubleClickHandler_);
	        grid.onMouseClick.addHandler(self.mouseClickHandler_);
	        grid.onTap_.addHandler(self.tapHandler_);
	    }
	
	    function unRegistEvents_() {
	        var self = this;
	        var grid = self.gridModel;
	        grid.onMouseDbClick.removeHandler(self.doubleClickHandler_);
	        grid.onMouseClick.removeHandler(self.mouseClickHandler_);
	        grid.onTap_.removeHandler(self.tapHandler_);
	        self.doubleClickHandler_ = null;
	        self.mouseClickHandler_ = null;
	        self.tapHandler_ = null;
	    }
	
	    function tapHandler_(sender, e) {
	        mouseClickHandler_.call(this, sender, e);
	    }
	
	    function doubleClickHandler_(sender, e) {
	        var self = this;
	        var gridModel = sender;
	        var layoutEngine = gridModel.layoutEngine;
	        var hitInfo = layoutEngine && layoutEngine.hitTest(e);
	
	        if (!hitInfo || (self.isEditing_ && isEditingSameRow_(hitInfo, self.editingInfo_))) {
	            return;
	        }
	        if ((hitInfo.area === 'viewport' || hitInfo.area === 'pinnedViewport') && !gridModel.hasEditAction_) {
	            var uiRowIndex;
	            var groupInfo = null;
	            var hitGroupInfo = hitInfo.groupInfo;
	            if (hitGroupInfo) {
	                uiRowIndex = hitGroupInfo.row;
	                groupInfo = gridModel.getGroupInfo_(hitGroupInfo.path);
	            } else {
	                uiRowIndex = hitInfo.row;
	            }
	            self.startEditing(gridModel, groupInfo, uiRowIndex);
	        }
	    }
	
	    function isEditingSameRow_(hitInfo, editingInfo) {
	        return hitInfo.groupInfo ?
	            (hitInfo.groupInfo.group === editingInfo.groupInfo.path && hitInfo.groupInfo.row === editingInfo.rowIndex) :
	        hitInfo.row === editingInfo.rowIndex;
	    }
	
	    function mouseClickHandler_(sender, e) {
	        var self = this;
	        var gridModel = sender;
	        var layoutEngine = gridModel.layoutEngine;
	        var hitInfo = layoutEngine.hitTest(e);
	        if (!hitInfo) {
	            return;
	        }
	
	        if (self.isEditing_ && !isEditingSameRow_(hitInfo, self.editingInfo_) && !gridModel.hasEditAction_) {
	            self.stopEditing(gridModel);
	        }
	    }
	
	    function documentMouseMoveHandler_(e) {
	        var self = this;
	        var info = self.startMoveInfo_;
	        var gridModel = self.gridModel;
	        if (info) {
	            var container = document.getElementById(gridModel.uid + '-popup-editing-area');
	            var mouseOffset = info.mouseOffset;
	            var containerOffset = info.containerOffset;
	            domUtil.setCss(container, {
	                'left': containerOffset.left + (e.pageX - mouseOffset.left),
	                'top': containerOffset.top + (e.pageY - mouseOffset.top)
	            });
	        }
	    }
	
	    function documentMouseUpHandler_() {
	        var self = this;
	        self.startMoveInfo_ = null;
	        document.removeEventListener('mousemove', self.documentMouseMoveHandler_);
	        document.removeEventListener('mouseup', self.documentMouseUpHandler_);
	        self.documentMouseMoveHandler_ = null;
	        self.documentMouseUpHandler_ = null;
	    }
	
	    //</editor-fold>
	
	    //<editor-fold desc="Public Method">
	    function init(gridModel) {
	        var self = this;
	        self.gridModel = gridModel;
	        registEvents_.call(self);
	    }
	
	    Editor.init = init;
	
	    function startEditing(gridModel, groupInfo, rowIndex) {
	        var self = this;
	        if (!allowEditing_.call(self)) {
	            return false;
	        }
	        if (self.isEditing_) {
	            if (self.gridModel && self.gridModel.uid !== gridModel.uid) {
	                return false;
	            } else {
	                self.unMountEditors(gridModel);
	            }
	        }
	        self.gridModel = gridModel;
	        var options = gridModel.options;
	        //var dataRowIndex = groupInfo ? groupInfo.data.toGlobalIndex(rowIndex) : rowIndex;
	        self.editingInfo_ = {
	            //group: groupInfo ? groupInfo.path : null,
	            groupInfo: groupInfo,
	            rowIndex: rowIndex
	        };
	        var editMode = options.editMode || EditMode.Inline;
	        if (editMode === EditMode.PopUp || editMode === EditMode.EditForm) {
	            startTemplateEditing_.call(self, groupInfo, rowIndex);
	        } else { //Inline mode
	            startInlineEditing_.call(self, groupInfo, rowIndex);
	        }
	        var args = {
	            status: 'startEditing',
	            gridModel: gridModel,
	            groupInfo: groupInfo,
	            row: rowIndex,
	            item: self.formattedItem
	        };
	        gridModel.editing.raise(gridModel, args);
	        self.isEditing_ = true;
	        return true;
	    }
	
	    Editor.startEditing = startEditing;
	
	    function stopEditing(gridModel) {
	        var self = this;
	        if (!self.isEditing_) {
	            return false;
	        }
	        if (!self.gridModel || self.gridModel.uid !== gridModel.uid) {
	            return false;
	        }
	        var row = self.editingInfo_.rowIndex;
	        var newItem = _.clone(self.formattedItem);
	        var columns = gridModel.columns;
	        var editors = self.editors_;
	        var i;
	        var length;
	        var columnDef;
	        var newValue;
	        for (i = 0, length = columns.length; i < length; i++) {
	            columnDef = columns[i];
	            if (editors[i]) {
	                newValue = serializeValue_.call(self, i);
	                if (columnDef.isCalcColumn_) {
	                    newItem[columnDef.id] = newValue;
	                    //self.calcColumnChanged_ = self.calcColumnChanged_ || columnDef.dataField !== newValue;//calc column changed will invalidate after commit change
	                } else {
	                    newItem[columnDef.dataField] = newValue;
	                }
	            }
	        }
	        var args = {
	            status: 'beforeEndEditing',
	            gridModel: gridModel,
	            groupInfo: self.editingInfo_.groupInfo,
	            row: row,
	            oldItem: self.oldItem,
	            newItem: newItem,
	            cancel: false
	        };
	        gridModel.editing.raise(gridModel, args);
	        if (args && args.cancel) {
	            return false;
	        }
	        var valueChanged = false;
	        if (isValueChanged_(newItem, self.oldItem)) {
	            commitChanges_.call(self, newItem);
	            valueChanged = true;
	        }
	        self.unMountEditors(gridModel, valueChanged);
	        gridModel.editing.raise(gridModel, {
	            status: 'endEditing',
	            gridModel: gridModel,
	            row: row,
	            item: newItem
	        });
	        return true;
	    }
	
	    Editor.stopEditing = stopEditing;
	
	    function unMountEditors(gridModel, valueChanged) {
	        var self = this;
	        if (!self.gridModel || self.gridModel.uid !== gridModel.uid) {
	            return false;
	        }
	        var layoutEngine = gridModel.layoutEngine;
	        layoutEngine.stopEditing_(valueChanged);
	        var editMode = layoutEngine.options.editMode;
	        if (editMode === EditMode.Inline) {
	            var uid = gridModel.uid;
	            var actionColumns = document.querySelectorAll('#' + uid + ' .gc-action-area.top');
	            if (actionColumns && actionColumns.length) {
	                for (var i = 0, length = actionColumns.length; i < length; i++) {
	                    domUtil.removeClass(actionColumns[i], 'top');
	                }
	                setViewportTransform_.call(self);
	            }
	        }
	        self.isEditing_ = false;
	        //self.calcColumnChanged_ = false;
	        self.wholeColumnChanged_ = false;
	        self.editingInfo_ = null;
	        self.formattedItem = null;
	        self.oldItem = null;
	        self.editors_.length = 0;
	        self.inlineContainer = null;
	    }
	
	    Editor.unMountEditors = unMountEditors;
	
	    function isColumnEditable(gridModel, col) {
	        var self = this;
	        if (self.gridModel && self.gridModel.uid !== gridModel.uid) {
	            return;
	        }
	        self.gridModel = gridModel;
	        var options = this.gridModel.options;
	        if (col.visible === false) {
	            return false;
	        }
	        if (col.action) { //action column can't enter editing status
	            return false;
	        }
	        var dataField = col.dataField; //multi-field can't enter editing status
	        if (!_.startsWith(_.trim(dataField), '=') && dataField && dataField.split(',').length !== 1) {
	            return false;
	        }
	        if (options.allowEditing && col.hasOwnProperty('allowEditing')) {
	            return col.allowEditing;
	        }
	        return true;
	    }
	
	    Editor.isColumnEditable = isColumnEditable;
	
	    function destroy(gridModel) {
	        var self = this;
	        if (!self.gridModel || self.gridModel.uid !== gridModel.uid) {
	            return;
	        }
	        unRegistEvents_.call(self);
	        if (self.isEditing_) {
	            self.unMountEditors(gridModel);
	        }
	        self.gridModel = null;
	    }
	
	    Editor.destroy = destroy;
	
	    function getEditorType(dataType) {
	        var editorType = gcUtils.EditorType;
	        if (!dataType) {
	            return editorType.Text;
	        } else {
	            dataType = dataType.toLowerCase();
	            switch (dataType) {
	                case 'boolean':
	                    return editorType.CheckBox;
	                case 'date':
	                    return editorType.Date;
	                case 'number':
	                    return editorType.Number;
	                default:
	                    return editorType.Text;
	            }
	        }
	    }
	
	    Editor.getEditorType = getEditorType;
	
	    function containerMouseDownHandler(e) {
	        var self = this;
	        var gridModel = self.gridModel;
	        var curTarget = e.target;
	        var className = curTarget.className;
	        var tagName = curTarget.tagName.toLowerCase();
	        var arr = className ? className.split(' ') : [];
	        while (tagName !== 'body') {
	            if (arr.indexOf('gc-editing-close') !== -1) {
	                gridModel.cancelEditing();
	                break;
	            } else if (arr.indexOf('gc-editing-update') !== -1) {
	                gridModel.stopEditing();
	                break;
	            } else if (arr.indexOf('gc-editing-cancel') !== -1) {
	                gridModel.cancelEditing();
	                break;
	            } else if (arr.indexOf('gc-editing-header') !== -1) {
	                var container = document.getElementById(gridModel.uid + '-popup-editing-area');
	                if (container) {
	                    self.documentMouseMoveHandler_ = documentMouseMoveHandler_.bind(self);
	                    self.documentMouseUpHandler_ = documentMouseUpHandler_.bind(self);
	                    document.addEventListener('mousemove', self.documentMouseMoveHandler_);
	                    document.addEventListener('mouseup', self.documentMouseUpHandler_);
	                    var containerOffset = domUtil.offset(container);
	                    var containerStyle = domUtil.getStyle(container);
	                    var containerMarginTop = parseFloat(containerStyle.getPropertyValue('margin-top'));
	                    var containerMarginLeft = parseFloat(containerStyle.getPropertyValue('margin-left'));
	                    self.startMoveInfo_ = {
	                        mouseOffset: {
	                            left: e.pageX,
	                            top: e.pageY
	                        },
	                        containerOffset: {
	                            left: containerOffset.left - containerMarginLeft,
	                            top: containerOffset.top - containerMarginTop
	                        }
	                    };
	                }
	                break;
	            }
	            curTarget = curTarget.parentNode;
	            tagName = curTarget.tagName.toLowerCase();
	            className = curTarget.className;
	            arr = className ? className.split(' ') : [];
	        }
	    }
	
	    Editor.containerMouseDownHandler = containerMouseDownHandler;
	
	    function containerKeyDownHandler(e) {
	        var self = this;
	        var gridModel = self.gridModel;
	        var Key = gcUtils.Key;
	        switch (e.keyCode) {
	            case Key.Enter:
	                if (!gridModel.hasEditAction_) {
	                    gridModel.stopEditing();
	                }
	                break;
	            case Key.Escape:
	                if (!gridModel.hasCancelAction_) {
	                    gridModel.cancelEditing();
	                }
	                break;
	            default:
	                break;
	        }
	    }
	
	    Editor.containerKeyDownHandler = containerKeyDownHandler;
	
	    function getInlineFragment() {
	        return this.inlineContainer;
	    }
	
	    Editor.getInlineFragment = getInlineFragment;
	
	    //</editor-fold>
	
	    module.exports = Editor;
	})();


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	        'use strict';
	        var gcUtils = __webpack_require__(3);
	        var doT = __webpack_require__(8);
	        var domUtil = __webpack_require__(2);
	        var POS_ABS = 'absolute';
	        var POS_REL = 'relative';
	        var OVERFLOW_HIDDEN = 'hidden';
	        var OVERFLOW_AUTO = 'auto';
	        var VIEWPORT = 'viewport';
	        var TOOLPANEL = 'toolPanel';
	        var PINNED_VIEWPORT = 'pinnedLeftViewport';
	        var PINNED_COLUMN_HEADER = 'pinnedLeftColumnHeader';
	        var PINNED_RIGHT_VIEWPORT = 'pinnedRightViewport';
	        var PINNED_RIGHT_COLUMN_HEADER = 'pinnedRightColumnHeader';
	        var COLUMN_HEADER = 'columnHeader';
	        var ROW_HEADER = 'rowHeader';
	        var CORNER_HEADER = 'cornerHeader';
	        var GROUP_DRAG_PANEL = 'groupingPanel';
	        var GROUP_DRAG_TEXT = 'Drag a column header here and drop it to group by that column';
	        var RESIZE_GAP_SIZE = 4;
	        var PADDING_LEFT = 'padding-left';
	        var PADDING_RIGHT = 'padding-right';
	
	        var GROUP_HEADER = 'groupHeader';
	        var GROUP_FOOTER = 'groupFooter';
	        var GROUP_CONTENT = 'groupContent';
	        var MIN_COL_WIDTH = 6;
	        var SelectMode = {
	            NONE: 'none',
	            SINGLE: 'single',
	            MULTIPLE: 'multiple'
	        };
	        var swipeStatus = {};
	        var FLICK_THRESHOLD_V = 0.8;
	
	        var GridLayoutEngine = function(options) {
	            var optionDefaults = {
	                rowHeaderWidth: 40,
	                colHeaderHeight: 24,
	                rowHeight: 24,
	                colWidth: '*',
	                showRowHeader: true,
	                showColHeader: true,
	                showGroupHeader: true,
	                showGroupFooter: true,
	                allowEditing: false,
	                allowGrouping: false,  //if set to true, it will show a group drag panel to help user grouping the data at runtime
	                allowSorting: false,
	                selectionMode: SelectMode.SINGLE,
	                allowHeaderSelect: false,
	                allowColumnReorder: true,
	                allowColumnResize: true,
	                editMode: 'inline',
	                showToolPanel: false
	            };
	
	            var self = this;
	            self.layoutInfo_ = null;
	            self.name = 'GridLayoutEngine'; //name must end with LayoutEngine
	            self.options = _.defaults(options || {}, optionDefaults);
	        };
	
	        GridLayoutEngine.prototype = {
	            getColumnDefaults_: function() {
	                var self = this;
	                var options = self.options;
	                return {
	                    width: options.colWidth,
	                    visible: true,
	                    allowSorting: options.allowSorting,
	                    pinned: 'none',
	                    allowEditing: options.allowEditing
	                };
	            },
	
	            updateStartSize_: function() {
	                var scope = this;
	                var grid = scope.grid;
	                var columns = grid.columns;
	                var options = scope.options;
	                var containerRect = grid.getContainerInfo_().contentRect;
	                var szAvailable = containerRect.width - options.rowHeaderWidth - getToolPanelWidth_.call(scope);
	                if ((grid.data.itemCount * options.rowHeight) > (containerRect.height - options.colHeaderHeight)) {
	                    szAvailable -= domUtil.getScrollbarSize().width;
	                }
	
	                var startCount = 0;
	                var lastStartCol;
	                var lastWidth;
	                var szCols = [];
	                var hasStar = false;
	
	                _.each(columns, function(col, index) {
	                    if (grid.isColVisible_(col, col.pinned)) {
	                        var sz = parseStartSize_(col.width);
	                        szCols[index] = sz;
	                        if (sz) {
	                            hasStar = true;
	                            startCount += sz;
	                            lastStartCol = index;
	                        } else {
	                            szAvailable -= col.visibleWidth;
	                        }
	                    }
	                });
	
	                if (hasStar) {
	                    lastWidth = szAvailable;
	                    _.each(columns, function(col, index) {
	                        if (col.visible) {
	                            if (szCols[index]) {
	                                if (index === lastStartCol) {
	                                    col.visibleWidth = lastWidth;
	                                } else {
	                                    col.visibleWidth = Math.max(0, Math.round(szCols[index] / startCount * szAvailable));
	                                    lastWidth -= col.visibleWidth;
	                                }
	                            }
	                        }
	                    });
	                }
	            },
	
	            init: function(grid) {
	                var self = this;
	                self.grid = grid;
	                grid.columns = _.map(grid.columns, function(col) {
	                    return _.defaults(col, _.defaults(self.getColumnDefaults_(), {
	                        id: col.dataField,
	                        caption: col.dataField
	                    }));
	                });
	                _.each(grid.columns, function(col) {
	                    col.visibleWidth = col.width;
	                });
	
	                updatePinnedColumns_.call(self);
	
	                if (_.some(grid.columns, 'pinned', 'left')) {
	                    self.hasLeftPinnedColumn_ = true;
	                }
	
	                if (_.some(grid.columns, 'pinned', 'right')) {
	                    self.hasRightPinnedColumn_ = true;
	                }
	
	                self.updateStartSize_();
	
	                //If there is row template, use the actual column width in row template.
	                consolidateColumnWidth_.call(self, 'none');
	                if (self.hasLeftPinnedColumn_) {
	                    consolidateColumnWidth_.call(self, 'left');
	                }
	                if (self.hasRightPinnedColumn_) {
	                    consolidateColumnWidth_.call(self, 'right');
	                }
	                var showToolPanel_ = self.options.showToolPanel;
	                Object.defineProperty(self.options, 'showToolPanel', {
	                    get: function() {
	                        return showToolPanel_;
	                    },
	                    set: function(newValue) {
	                        if (showToolPanel_ !== newValue) {
	                            //it's usually change the template during layout/group strategy changed
	                            //as the result, the size of the template maybe different and column size may changed
	                            showToolPanel_ = newValue;
	                            self.grid.invalidate();
	                        }
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	            },
	
	            getLayoutInfo: function() {
	                var self = this;
	                var options = self.options;
	                if (self.groupStrategy_) {
	                    return self.groupStrategy_.getLayoutInfo();
	                }
	                if (self.layoutInfo_) {
	                    return self.layoutInfo_;
	                }
	                var layoutInfo = self.layoutInfo_ = {};
	                if (options.showToolPanel) {
	                    layoutInfo[TOOLPANEL] = getToolPanelLayoutInfo_.call(self);
	                }
	                var allColumnHiddlen = _.all(self.grid.columns, function(col) {
	                    return !col.visible;
	                });
	                if (!allColumnHiddlen) {
	                    if (self.hasLeftPinnedColumn_) {
	                        layoutInfo[PINNED_VIEWPORT] = getPinnedViewportLayoutInfo_.call(self, 'left');
	                    }
	                    if (self.hasRightPinnedColumn_) {
	                        layoutInfo[PINNED_RIGHT_VIEWPORT] = getPinnedViewportLayoutInfo_.call(self, 'right');
	                    }
	                    layoutInfo[VIEWPORT] = getViewportLayoutInfo_.call(self);
	
	                    if (options.showColHeader && options.showRowHeader) {
	                        layoutInfo[CORNER_HEADER] = getCornerHeaderLayoutInfo_.call(self);
	                    }
	                    if (options.showRowHeader) {
	                        layoutInfo[ROW_HEADER] = getRowHeaderLayoutInfo_.call(self);
	                    }
	                    if (options.showColHeader) {
	                        layoutInfo[COLUMN_HEADER] = getColumnHeaderLayoutInfo_.call(self);
	                        if (self.hasLeftPinnedColumn_) {
	                            layoutInfo[PINNED_COLUMN_HEADER] = getPinnedColumnHeaderViewportLayoutInfo_.call(self, 'left');
	                        }
	                        if (self.hasRightPinnedColumn_) {
	                            layoutInfo[PINNED_RIGHT_COLUMN_HEADER] = getPinnedColumnHeaderViewportLayoutInfo_.call(self, 'right');
	                        }
	                    }
	                    if (self.options.allowGrouping) {
	                        layoutInfo[GROUP_DRAG_PANEL] = getGroupDragPanelLayoutInfo_.call(self);
	                    }
	                }
	                return layoutInfo;
	            },
	
	            getRenderRowInfo_: function(row, area) {
	                var scope = this;
	                if (scope.groupStrategy_) {
	                    return scope.groupStrategy_.getRenderRowInfo_(row, area);
	                }
	
	                var uid = scope.grid.uid;
	                var hasGroup = hasGroup_(scope.grid);
	
	                if (area === VIEWPORT || area === PINNED_VIEWPORT || area === PINNED_RIGHT_VIEWPORT) {
	                    if (hasGroup) {
	                        var part = row.area;
	                        var currInfo = row.info;
	                        var groupInfo = scope.grid.getGroupInfo_(currInfo.path);
	                        if (part === GROUP_HEADER) {
	                            return getGroupHeaderRow_.call(scope, row.key, currInfo, groupInfo, row.width, row.top, area);
	                        } else if (part === GROUP_CONTENT) {
	                            return getGroupContentRow_.call(scope, row.key, currInfo.itemIndex, groupInfo, row.height, row.top, area);
	                        } else {
	                            return getGroupFooterRow_.call(scope, row.key, currInfo, groupInfo, row.top, area);
	                        }
	                    } else {
	                        return createRowRenderInfo.call(scope, row.index, row.height, area, uid);
	                    }
	                } else if (area === ROW_HEADER) {
	                    var key = row.key;
	                    var top = hasGroup ? row.top : row.index * row.height;
	                    var isRowRole = hasGroup ? false : true;
	                    var height = row.height;
	
	                    return buildHeaderCell.call(scope, key, row.info, isRowRole, top, height, row.index);
	                } else if (area === COLUMN_HEADER || area === PINNED_COLUMN_HEADER || area === PINNED_RIGHT_COLUMN_HEADER) {
	                    return getRenderedColumnHeaderInfo_.call(scope, area);
	                }
	            },
	
	            getRenderRange_: function(options) {
	                var scope = this;
	                if (scope.groupStrategy_) {
	                    return scope.groupStrategy_.getRenderRange_(options);
	                }
	
	                var area = (options && options.area) || '';
	                if (!area || area === CORNER_HEADER || area === TOOLPANEL || area === GROUP_DRAG_PANEL) {
	                    return null;
	                }
	
	                return getRowsRenderInfo.call(scope, area, options);
	            },
	
	            getRenderInfo: function(options) {
	                var scope = this;
	                if (scope.groupStrategy_) {
	                    return scope.groupStrategy_.getRenderInfo(options);
	                }
	                var includeRows = options.includeRows || true;
	                var area = (options && options.area) || '';
	                if (!area) {
	                    return null;
	                }
	
	                var uid = scope.grid.uid;
	                var layoutInfo = this.getLayoutInfo();
	                var currLayoutInfo = layoutInfo[area];
	                var width = currLayoutInfo.width;
	                var height = currLayoutInfo.height;
	                var r;
	                var i;
	                var rowHeight = scope.options.rowHeight;
	                var start;
	                var end;
	                var offsetTop;
	                var grid = scope.grid;
	
	                var renderRange = getRenderRange.call(scope, area, currLayoutInfo, options);
	                start = renderRange.start;
	                end = renderRange.end;
	                offsetTop = renderRange.offsetTop;
	                var cssClass = 'gc-viewport';
	                if (area === PINNED_VIEWPORT) {
	                    cssClass = 'gc-pinned-left';
	                } else if (area === PINNED_RIGHT_VIEWPORT) {
	                    cssClass = 'gc-pinned-right';
	                }
	                if (area === VIEWPORT || area === PINNED_VIEWPORT || area === PINNED_RIGHT_VIEWPORT) {
	                    r = {
	                        outerDivCssClass: cssClass,
	                        outerDivStyle: {
	                            position: POS_ABS,
	                            top: currLayoutInfo.top,
	                            left: currLayoutInfo.left,
	                            height: height,
	                            width: width,
	                            overflow: OVERFLOW_HIDDEN
	                        },
	                        innerDivStyle: {
	                            position: POS_REL,
	                            width: currLayoutInfo.contentWidth,
	                            height: height - (offsetTop < 0 ? offsetTop : 0)
	                        },
	                        innerDivTranslate: {
	                            left: area === VIEWPORT ? (-options.offsetLeft || 0) : 0,
	                            top: -options.offsetTop
	                        },
	                        renderedRows: []
	                    };
	                    if (includeRows) {
	                        if (hasGroup_(grid)) {
	                            r.renderedRows = r.renderedRows.concat(getGroupRenderInfo_.call(scope, start, end, offsetTop, false, false, area));
	                        } else {
	                            for (i = start; i < end; i++) {
	                                r.renderedRows.push(createRowRenderInfo.call(scope, i, rowHeight, area, uid));
	                            }
	                        }
	                    }
	
	                } else if (area === CORNER_HEADER) {
	                    r = {
	                        outerDivCssClass: 'gc-cornerHeader',
	                        outerDivStyle: {
	                            position: POS_ABS,
	                            top: currLayoutInfo.top,
	                            height: height,
	                            width: width,
	                            overflow: OVERFLOW_HIDDEN,
	                            zIndex: 10
	                        },
	                        innerDivStyle: {
	                            position: POS_REL,
	                            height: height,
	                            width: width
	                        },
	                        renderedRows: [{
	                            key: uid + '-corner',
	                            isRowRole: false,
	                            renderInfo: {
	                                cssClass: 'gc-corner-header-cell ch',
	                                style: {
	                                    height: '100%'
	                                },
	                                renderedHTML: scope.options.allowHeaderSelect ? '<div id="' + uid + '-corner-select" class="gc-icon gc-header-select-icon' + ((grid.data.itemCount === (scope.selectedRows_ && scope.selectedRows_.length)) ? ' selected' : '') + '"></div>' : ''
	                            }
	                        }]
	                    };
	                } else if (area === COLUMN_HEADER || area === PINNED_COLUMN_HEADER || area === PINNED_RIGHT_COLUMN_HEADER) {
	                    cssClass = 'gc-columnHeader';
	                    if (area === PINNED_COLUMN_HEADER) {
	                        cssClass += ' gc-pinned-left';
	                    } else if (area === PINNED_RIGHT_COLUMN_HEADER) {
	                        cssClass += ' gc-pinned-right';
	                    }
	                    r = {
	                        outerDivCssClass: cssClass,
	                        outerDivStyle: {
	                            position: POS_ABS,
	                            top: currLayoutInfo.top,
	                            left: currLayoutInfo.left,
	                            height: height,
	                            width: width,
	                            overflow: OVERFLOW_HIDDEN
	                        },
	                        innerDivStyle: {
	                            position: POS_REL,
	                            height: height,
	                            width: currLayoutInfo.contentWidth
	                        },
	                        innerDivTranslate: {
	                            left: area === COLUMN_HEADER ? (-options.offsetLeft || 0) : 0,
	                            top: 0
	                        },
	                        renderedRows: [getRenderedColumnHeaderInfo_.call(scope, area)]
	                    };
	                } else if (area === ROW_HEADER) {
	                    r = {
	                        outerDivCssClass: 'gc-rowHeader',
	                        outerDivStyle: {
	                            position: POS_ABS,
	                            top: currLayoutInfo.top,
	                            left: currLayoutInfo.left,
	                            height: height,
	                            width: width,
	                            overflow: OVERFLOW_HIDDEN
	                        },
	                        innerDivStyle: {
	                            position: POS_REL,
	                            height: height - (offsetTop < 0 ? offsetTop : 0),
	                            width: currLayoutInfo.contentWidth
	                        },
	                        innerDivTranslate: {
	                            left: 0,
	                            top: -options.offsetTop
	                        },
	                        renderedRows: []
	                    };
	                    if (includeRows) {
	                        if (hasGroup_(grid)) {
	                            r.renderedRows = r.renderedRows.concat(getGroupRenderInfo_.call(scope, start, end, offsetTop, true, false, area));
	                        } else {
	                            for (i = start; i < end; i++) {
	                                r.renderedRows.push(getRowHeaderCellRenderInfo_.call(scope, null, i, rowHeight, offsetTop));
	                                offsetTop += rowHeight;
	                            }
	                        }
	                    }
	
	                } else if (area === GROUP_DRAG_PANEL) {
	                    r = {
	                        outerDivCssClass: 'gc-grouping-container no-select',
	                        outerDivStyle: {
	                            position: POS_ABS,
	                            top: currLayoutInfo.top,
	                            left: currLayoutInfo.left,
	                            height: height,
	                            width: width,
	                            overflow: OVERFLOW_HIDDEN
	                        },
	                        innerDivStyle: {
	                            position: POS_REL,
	                            top: currLayoutInfo.top,
	                            left: currLayoutInfo.left,
	                            height: height,
	                            width: width
	                        },
	                        renderedRows: [{
	                            isRowRole: false,
	                            renderInfo: {
	                                renderedHTML: getRenderedGroupDragPanelInfo_.call(scope, true)
	                            }
	                        }]
	                    };
	                } else if (area === TOOLPANEL) {
	                    r = {
	                        outerDivCssClass: 'gc-tool-panel-container',
	                        outerDivStyle: {
	                            position: POS_ABS,
	                            top: currLayoutInfo.top,
	                            left: currLayoutInfo.left,
	                            height: height,
	                            width: width,
	                            overflow: OVERFLOW_HIDDEN,
	                            zIndex: 999
	                        },
	                        innerDivStyle: {
	                            position: POS_REL,
	                            height: '100%',
	                            //width: width
	                        },
	                        renderedRows: [getToolPanelRenderInfo_.call(scope)]
	                    };
	                }
	                return r;
	            },
	
	            getInitialScrollOffset: function() {
	                return {
	                    top: 0,
	                    left: 0
	                };
	            },
	
	            getRowTemplate: function(area) {
	                var self = this;
	                ////TODO: re-consider whether we should use group strategy row template here
	                //if (self.groupStrategy_) {
	                //    return self.groupStrategy_.getRowTemplate();
	                //}
	                return getTemplate_.call(self, false, area);
	            },
	
	            showScrollPanel: function(area) {
	                var self = this;
	                if (self.groupStrategy_) {
	                    return self.groupStrategy_.showScrollPanel(area);
	                }
	                var layoutInfo;
	                if (area === VIEWPORT) {
	                    layoutInfo = self.getLayoutInfo()[VIEWPORT];
	                    if (!self.hasRightPinnedColumn_ && (layoutInfo.height < layoutInfo.contentHeight ||
	                        layoutInfo.width < layoutInfo.contentWidth)) {
	                        return true;
	                    } else if (self.hasRightPinnedColumn_ && layoutInfo.width < layoutInfo.contentWidth) {
	                        return true;
	                    }
	                }
	                if (area === PINNED_RIGHT_VIEWPORT) {
	                    layoutInfo = self.getLayoutInfo()[VIEWPORT];
	                    if (layoutInfo.height < layoutInfo.contentHeight) {
	                        return true;
	                    }
	                }
	                return false;
	            },
	
	            isScrollableArea_: function(area) {
	                var self = this;
	                if (self.groupStrategy_ && self.groupStrategy_.isScrollableArea_) {
	                    return self.groupStrategy_.isScrollableArea_(area);
	                }
	
	                return area === VIEWPORT;
	            },
	
	            getScrollPanelRenderInfo: function(area) {
	                var self = this;
	                if (self.groupStrategy_) {
	                    return self.groupStrategy_.getScrollPanelRenderInfo(area);
	                }
	                if (area === VIEWPORT || area === PINNED_RIGHT_VIEWPORT) {
	                    var layout = self.getLayoutInfo();
	                    var emptyLayout = {width: 0, height: 0, contentWidth: 0, contentHeight: 0};
	                    var columnHeaderLayoutInfo = layout[COLUMN_HEADER] || emptyLayout;
	                    var rowHeaderLayoutInfo = layout[ROW_HEADER] || emptyLayout;
	                    var viewportLayout = layout[VIEWPORT];
	                    var pinnedViewportlayout = layout[PINNED_VIEWPORT];
	                    var showHScrollbar = area === VIEWPORT ? (viewportLayout.contentWidth > viewportLayout.width) : false;
	                    var showVScrollbar = area === VIEWPORT ? (!self.hasRightPinnedColumn_ && viewportLayout.contentHeight > viewportLayout.height) : viewportLayout.contentHeight > viewportLayout.height;
	                    var outerWidth;
	                    var innerWidth;
	                    var outerHeight;
	                    var innerHeight;
	                    var left = 0;
	                    var cssClass = 'gc-grid-' + VIEWPORT + '-scroll-panel';
	                    if (area === VIEWPORT) {
	                        cssClass += ' scroll-left';
	                        if (!self.hasRightPinnedColumn_) {
	                            cssClass += ' scroll-top';
	                        }
	                        outerWidth = viewportLayout.width + (self.hasLeftPinnedColumn_ ? 0 : rowHeaderLayoutInfo.width) + (showVScrollbar ? domUtil.getScrollbarSize().width : 0);
	                        innerWidth = viewportLayout.contentWidth + (self.hasLeftPinnedColumn_ ? 0 : rowHeaderLayoutInfo.width);
	                        outerHeight = viewportLayout.height + columnHeaderLayoutInfo.height + (showHScrollbar ? domUtil.getScrollbarSize().height : 0);
	                        innerHeight = (self.hasRightPinnedColumn_ ? viewportLayout.height : viewportLayout.contentHeight) + columnHeaderLayoutInfo.height;
	                        left = self.hasLeftPinnedColumn_ ? (rowHeaderLayoutInfo.width + pinnedViewportlayout.width) : 0;
	                    } else {
	                        cssClass += ' scroll-top';
	                        var pinnedRightLayout = layout[area];
	                        outerWidth = pinnedRightLayout.width + (showVScrollbar ? domUtil.getScrollbarSize().width : 0);
	                        innerWidth = pinnedRightLayout.width;
	                        outerHeight = pinnedRightLayout.height + columnHeaderLayoutInfo.height;
	                        innerHeight = viewportLayout.contentHeight + columnHeaderLayoutInfo.height;
	                        left = rowHeaderLayoutInfo.width + (self.hasLeftPinnedColumn_ ? pinnedViewportlayout.width : 0) + viewportLayout.width;
	                    }
	
	                    return {
	                        outerDivCssClass: cssClass,
	                        outerDivStyle: {
	                            position: POS_ABS,
	                            top: this.options.allowGrouping ? layout[GROUP_DRAG_PANEL].height : 0,
	                            left: left,
	                            height: outerHeight,
	                            width: outerWidth,
	                            overflow: OVERFLOW_AUTO
	                        },
	                        innerDivStyle: {
	                            position: POS_REL,
	                            height: innerHeight,
	                            width: innerWidth
	                        }
	                    };
	                }
	            },
	
	            clearRenderCache_: function() {
	                var self = this;
	                if (self.groupStrategy_) {
	                    self.groupStrategy_.clearRenderCache_();
	                }
	
	                clearTemplateCache_.call(self);
	                self.toolPanelInfo_ = null;
	                self.grouDragPanelLayoutInfo_ = null;
	                self.cachedViewportLayoutInfo_ = null;
	                self.layoutInfo_ = null;
	
	                if (self.hasLeftPinnedColumn_) {
	                    self.pvInfo_ = null;
	                }
	                if (self.hasRightPinnedColumn_) {
	                    self.prvInfo_ = null;
	                }
	            },
	
	            handleTemplateChange_: function() {
	                var self = this;
	                if (!self.suspendTmplUpdate_) {
	                    self.updateStartSize_();
	                    consolidateColumnWidth_.call(self, 'none');
	                    self.colsResizeInfo_ = null;
	                    self.colLayouts_ = null;
	                    if (self.hasLeftPinnedColumn_) {
	                        consolidateColumnWidth_.call(self, 'left');
	                    }
	                    if (self.hasRightPinnedColumn_) {
	                        consolidateColumnWidth_.call(self, 'right');
	                    }
	                }
	            },
	
	            getGroupInfoDefaults_: function() {
	                if (this.groupStrategy_) {
	                    return this.groupStrategy_.getGroupInfoDefaults_();
	                }
	                return {
	                    footer: {
	                        visible: true,
	                        collapseWithGroup: true
	                    },
	                    header: {
	                        visible: true
	                    }
	                };
	            },
	
	            initGroupInfosHeight_: function() {
	                var self = this;
	                if (self.groupStrategy_ && self.groupStrategy_.initGroupInfosHeight_) {
	                    return self.groupStrategy_.initGroupInfosHeight_();
	                }
	                var groupInfos = self.grid.groupInfos_;
	                var i;
	                var len;
	
	                for (i = 0, len = groupInfos.length; i < len; i++) {
	                    groupInfos[i].height = self.getGroupHeight_(groupInfos[i]);
	                }
	
	            },
	
	            getGroupHeight_: function(groupInfo) {
	                var self = this;
	                if (!groupInfo) {
	                    return 0;
	                }
	                if (!gcUtils.isUndefined(groupInfo.height)) {
	                    return groupInfo.height;
	                }
	
	                var group = groupInfo.data;
	                var height = 0;
	                var header = group.groupDescriptor.header;
	                if (header && header.visible) {
	                    height += self.getGroupHeaderHeight_(group);
	                }
	                var i;
	                var len;
	                var footer;
	                var childGroup;
	                if (!group.collapsed) {
	                    len = group.isBottomLevel ? group.itemCount : groupInfo.children.length;
	                    for (i = 0; i < len; i++) {
	                        if (group.isBottomLevel) {
	                            height += self.getRowHeight_(group.getItem(i));
	                        } else {
	                            childGroup = groupInfo.children[i];
	                            childGroup.height = self.getGroupHeight_(childGroup);
	                            height += childGroup.height;
	                        }
	                    }
	                    height += self.getGroupFooterHeight_(group);
	                } else {
	                    footer = group.groupDescriptor.footer;
	                    if (footer && footer.visible && !footer.collapseWithGroup) {
	                        height += self.getGroupFooterHeight_(group);
	                    }
	                }
	                return height;
	            },
	
	            handleScroll: function(e) {
	                var self = this;
	                if (self.groupStrategy_) {
	                    self.groupStrategy_.handleScroll();
	                } else {
	                    var grid = self.grid;
	                    if (!self.isResizingCol_) {
	                        grid.stopEditing();
	                        grid.scrollRenderPart_(VIEWPORT);
	                        grid.scrollRenderPart_(COLUMN_HEADER);
	                        if (self.hasLeftPinnedColumn_) {
	                            grid.scrollRenderPart_(PINNED_VIEWPORT);
	                            grid.scrollRenderPart_(PINNED_COLUMN_HEADER);
	                        }
	                        if (self.hasRightPinnedColumn_) {
	                            grid.scrollRenderPart_(PINNED_RIGHT_VIEWPORT);
	                            grid.scrollRenderPart_(PINNED_RIGHT_COLUMN_HEADER);
	                        }
	                        grid.scrollRenderPart_(ROW_HEADER);
	                    }
	                }
	                self.grid.onScrollOver_.raise(self.grid, {
	                    scrollDirection: e.scrollDirection
	                });
	            },
	
	            hitTest: function(eventArgs) {
	                var self = this;
	                if (self.groupStrategy_) {
	                    return self.groupStrategy_.hitTest(eventArgs);
	                }
	                var options = self.options;
	                var left = eventArgs.pageX;
	                var top = eventArgs.pageY;
	                var grid = self.grid;
	                var layoutInfo = self.getLayoutInfo();
	                var emptyLayout = {width: 0, height: 0, contentWidth: 0, contentHeight: 0};
	                var viewportLayout = layoutInfo[VIEWPORT] || emptyLayout;
	                var columnHeaderLayout = layoutInfo[COLUMN_HEADER] || emptyLayout;
	                var rowHeaderLayout = layoutInfo[ROW_HEADER] || emptyLayout;
	                var cornerHeaderLayout = layoutInfo[CORNER_HEADER] || emptyLayout;
	                var pinnedViewportLayout = layoutInfo[PINNED_VIEWPORT] || emptyLayout;
	                var pinnedColumnHeaderLayout = layoutInfo[PINNED_COLUMN_HEADER] || emptyLayout;
	                var pinnedRightViewportLayout = layoutInfo[PINNED_RIGHT_VIEWPORT] || emptyLayout;
	                var pinnedRightColumnHeaderLayout = layoutInfo[PINNED_RIGHT_COLUMN_HEADER] || emptyLayout;
	                var toolPanelLayout = layoutInfo[TOOLPANEL] || emptyLayout;
	                var groupDragPanelLayout = options.allowGrouping ? layoutInfo[GROUP_DRAG_PANEL] : null;
	
	                var containerInfo = grid.getContainerInfo_().contentRect;
	                var offsetLeft = left - containerInfo.left;
	                var offsetTop = top - containerInfo.top;
	
	                var panelOffset;
	                var cellElement;
	                var cellOffset;
	                var cellLeft;
	                var cellTop;
	                var cols = grid.columns;
	                var colLen = cols.length;
	                var column = -1;
	                var i;
	                var len;
	                var actIndex;
	                var actLen;
	                var action;
	                var hitTestInfo = null;
	                var point = {
	                    left: offsetLeft,
	                    top: offsetTop
	                };
	                var startRowPosition;
	                var offsetTopLeft;
	                var groupInfo;
	                var rowInfo;
	                var relativeElement;
	                var element;
	                var inViewport = contains_(viewportLayout, point);
	                var inPinnedViewport = false;
	                var inPinnedColumnHeaderArea = false;
	                var inRightPinnedViewport = false;
	                var inRightPinnedColumnHeaderArea = false;
	                var inToolPanel = contains_(toolPanelLayout, point);
	                var inTreeNode = false;
	
	                var inColumnHeaderArea = contains_(columnHeaderLayout, point);
	                if (self.hasLeftPinnedColumn_) {
	                    inPinnedViewport = contains_(pinnedViewportLayout, point);
	                    inPinnedColumnHeaderArea = contains_(pinnedColumnHeaderLayout, point);
	                }
	                if (self.hasRightPinnedColumn_) {
	                    inRightPinnedViewport = contains_(pinnedRightViewportLayout, point);
	                    inRightPinnedColumnHeaderArea = contains_(pinnedRightColumnHeaderLayout, point);
	                }
	                if (options.showToolPanel && inToolPanel) {
	                    hitTestInfo = {
	                        area: TOOLPANEL,
	                        row: -1,
	                        column: -1
	                    };
	                    offsetLeft -= toolPanelLayout.left;
	                    offsetTop -= toolPanelLayout.top;
	
	                    var listItems;
	                    var listItem;
	                    var checkIcon;
	                    var removeIcon;
	                    var toolPanel = document.querySelector('#' + grid.uid + '-' + TOOLPANEL);
	                    var columnList = toolPanel.querySelector('.column-list');
	                    var groupList = toolPanel.querySelector('.group-list');
	                    if (pointIn_.call(self, offsetLeft, offsetTop, columnList, toolPanel)) {
	                        hitTestInfo.columnListInfo = {};
	                        listItems = toolPanel.querySelectorAll('.column-list-item');
	                        for (i = 0, len = listItems.length; i < len; i++) {
	                            listItem = listItems[i];
	                            if (pointIn_(offsetLeft, offsetTop, listItem, toolPanel)) {
	
	                                hitTestInfo.columnListInfo.column = listItem.getAttribute('data-col-id');
	                                checkIcon = listItem.querySelector('.check');
	                                if (pointIn_.call(self, offsetLeft, offsetTop, checkIcon, toolPanel, true)) {
	                                    hitTestInfo.columnListInfo.action = 'visible';
	                                }
	                                break;
	                            }
	                        }
	                    } else if (pointIn_.call(self, offsetLeft, offsetTop, groupList, toolPanel)) {
	                        hitTestInfo.groupListInfo = {};
	                        listItems = toolPanel.querySelectorAll('.group-list-item');
	                        for (i = 0, len = listItems.length; i < len; i++) {
	                            listItem = listItems[i];
	                            if (pointIn_.call(self, offsetLeft, offsetTop, listItem, toolPanel)) {
	                                hitTestInfo.groupListInfo.group = listItem.getAttribute('data-group-id');
	                                removeIcon = listItem.querySelector('.remove');
	                                if (pointIn_.call(self, offsetLeft, offsetTop, removeIcon, toolPanel, true)) {
	                                    hitTestInfo.groupListInfo.action = 'removeGroup';
	                                }
	                                break;
	                            }
	                        }
	                    } else {
	                        var insertColumnIcon = toolPanel.querySelector('.insert-column-icon');
	                        if (insertColumnIcon && pointIn_.call(self, offsetLeft, offsetTop, insertColumnIcon, toolPanel, true)) {
	                            hitTestInfo.columnListInfo = {};
	                            hitTestInfo.columnListInfo.action = 'showAddColumnWindow';
	                        }
	                    }
	                } else if (inViewport || inPinnedViewport || inRightPinnedViewport) {
	                    offsetLeft -= rowHeaderLayout.width;
	                    offsetTop -= (columnHeaderLayout.height);
	                    if (options.allowGrouping) {
	                        offsetTop -= groupDragPanelLayout.height;
	                    }
	                    if (inViewport) {
	                        if (self.hasLeftPinnedColumn_) {
	                            offsetLeft -= pinnedViewportLayout.width;
	                        }
	                        offsetLeft += grid.scrollOffset.left;
	                    }
	                    if (inRightPinnedViewport) {
	                        if (self.hasLeftPinnedColumn_) {
	                            offsetLeft -= pinnedViewportLayout.width;
	                        }
	                        offsetLeft -= viewportLayout.width;
	                    }
	                    offsetTop += grid.scrollOffset.top;
	
	                    if (hasGroup_(grid)) {
	                        startRowPosition = 0;
	                        offsetTopLeft = offsetTop;
	                        for (i = 0, len = grid.data.groups.length; i < len; i++) {
	                            groupInfo = grid.groupInfos_[i];
	                            hitTestInfo = hitTestGroup_.call(self, groupInfo, offsetTopLeft, startRowPosition, offsetLeft, offsetTop, VIEWPORT);
	                            if (hitTestInfo) {
	                                hitTestInfo.area = (inViewport ? VIEWPORT : (inPinnedViewport ? PINNED_VIEWPORT : PINNED_RIGHT_VIEWPORT));
	                                break;
	                            }
	                            offsetTopLeft -= groupInfo.height;
	                            startRowPosition += groupInfo.height;
	                        }
	                    } else {
	                        rowInfo = getRowInfoAt.call(this, {top: offsetTop});
	                        if (rowInfo) {
	                            var row = rowInfo.index;
	                            startRowPosition = rowInfo.startPosition;
	                            var offsetTopFromCurrentRow = offsetTop - startRowPosition;
	                            var rowSelector = grid.uid + (inViewport ? '-r' : (inPinnedViewport ? '-pr' : '-prr')) + row;
	                            var rowElement = document.getElementById(rowSelector);
	                            var actionElements;
	                            offsetLeft -= (rowElement.style.left ? parseFloat(rowElement.style.left) : 0);
	                            for (i = 0; i < colLen; i++) {
	                                cellElement = rowElement.querySelector('.c' + i);
	                                if (cellElement && pointIn_(offsetLeft, offsetTopFromCurrentRow, cellElement, rowElement)) {
	                                    column = i;
	                                    var nodeElement = cellElement.querySelector('.gc-tree-node');
	                                    if (nodeElement && pointIn_.call(self, offsetLeft, offsetTopFromCurrentRow, nodeElement, rowElement, true)) {
	                                        inTreeNode = true;
	                                        break;
	                                    } else if (cols[i].action) {
	                                        actionElements = cellElement.querySelectorAll('[data-action]');
	                                        for (actIndex = 0, actLen = actionElements.length; actIndex < actLen; actIndex++) {
	                                            if (pointIn_(offsetLeft, offsetTopFromCurrentRow, actionElements[actIndex], rowElement)) {
	                                                action = grid.getActionHandler_(cols[i].id, actionElements[actIndex].getAttribute('data-action'));
	                                            }
	                                        }
	                                    }
	                                    break;
	                                }
	                            }
	
	                            if (column === -1) {
	                                action = hitTestTouchPanel_(grid, cols, offsetLeft, offsetTopFromCurrentRow, rowElement);
	                            }
	
	                            hitTestInfo = {
	                                area: (inViewport ? VIEWPORT : (inPinnedViewport ? PINNED_VIEWPORT : PINNED_RIGHT_VIEWPORT)),
	                                row: row,
	                                column: column
	                            };
	
	                            if (inTreeNode) {
	                                hitTestInfo.inTreeNode = true;
	                            }
	
	                            if (action) {
	                                hitTestInfo.action = action;
	                            }
	                        } else {
	                            hitTestInfo = {
	                                area: 'none'
	                            };
	                        }
	                    }
	                } else if (inColumnHeaderArea || inPinnedColumnHeaderArea || inRightPinnedColumnHeaderArea) {
	                    offsetLeft -= rowHeaderLayout.width;
	                    if (inColumnHeaderArea) {
	                        if (self.hasLeftPinnedColumn_) {
	                            offsetLeft -= pinnedColumnHeaderLayout.width;
	                        }
	                    }
	                    if (inRightPinnedColumnHeaderArea) {
	                        if (self.hasLeftPinnedColumn_) {
	                            offsetLeft -= pinnedColumnHeaderLayout.width;
	                        }
	                        offsetLeft -= viewportLayout.width;
	                    }
	                    offsetTop -= (options.allowGrouping ? groupDragPanelLayout.height : 0);
	
	                    var inColumnHeader = false;
	                    var selectPart = inColumnHeaderArea ? COLUMN_HEADER : (inPinnedColumnHeaderArea ? PINNED_COLUMN_HEADER : PINNED_RIGHT_COLUMN_HEADER);
	                    var columnHeaderPanel = document.getElementById(grid.uid + '-' + selectPart);
	                    var pinned = 'none';
	                    if (inPinnedColumnHeaderArea) {
	                        pinned = 'left';
	                    } else if (inRightPinnedColumnHeaderArea) {
	                        pinned = 'right';
	                    }
	                    panelOffset = domUtil.offset(columnHeaderPanel);
	                    for (i = 0; i < colLen; i++) {
	                        if (grid.isColVisible_(cols[i], pinned)) {
	                            cellElement = document.querySelector('#' + grid.uid + '-' + selectPart + ' .gc-column-header-cell.c' + i);
	                            if (cellElement) {
	                                cellOffset = domUtil.offset(cellElement);
	                                cellLeft = cellOffset.left - panelOffset.left;
	                                cellTop = cellOffset.top - panelOffset.top;
	                                var cellElementStyle = domUtil.getStyle(cellElement);
	                                var paddingLeft = parseStylePropertyValue_(cellElementStyle, PADDING_LEFT);
	                                var paddingRight = parseStylePropertyValue_(cellElementStyle, PADDING_RIGHT);
	                                if (pointIn_(offsetLeft, offsetTop, cellElement, columnHeaderPanel)) {
	                                    inColumnHeader = true;
	                                    hitTestInfo = {
	                                        area: selectPart,
	                                        row: -1,
	                                        column: i,
	                                        headerInfo: {
	                                            inResizeMode: (cellLeft + cellElement.offsetWidth - offsetLeft) <= RESIZE_GAP_SIZE,
	                                            resizeFromZero: false
	                                        }
	                                    };
	                                    break;
	                                } else if ((cellElement.clientWidth - paddingLeft - paddingRight) === 0 &&
	                                    cellLeft < offsetLeft && cellTop >= offsetTop && offsetTop <= (cellTop + cellElement.clientHeight) &&
	                                    (cellLeft + RESIZE_GAP_SIZE) > offsetLeft) {
	                                    inColumnHeader = true;
	                                    hitTestInfo = {
	                                        area: selectPart,
	                                        row: -1,
	                                        column: i,
	                                        headerInfo: {
	                                            inResizeMode: true,
	                                            resizeFromZero: true
	                                        }
	                                    };
	                                    break;
	                                }
	                            }
	                        }
	                    }
	                    var groupColumnHeaders = document.querySelectorAll('#' + grid.uid + '-' + selectPart + ' [data-column-group-header]');
	                    for (i = 0; i < groupColumnHeaders.length; i++) {
	                        var columnHeader = groupColumnHeaders[i];
	                        var columnCaption = columnHeader.getAttribute('data-column-group-header');
	                        if (columnCaption && pointIn_(offsetLeft, offsetTop, columnHeader, columnHeaderPanel)) {
	                            cellOffset = domUtil.offset(columnHeader);
	                            inColumnHeader = true;
	                            hitTestInfo = {
	                                area: selectPart,
	                                row: -1,
	                                column: -1,
	                                columnGroupInfo: {
	                                    caption: columnCaption
	                                },
	                                headerInfo: {
	                                    inResizeMode: (cellOffset.left - panelOffset.left + columnHeader.offsetWidth - offsetLeft) <= RESIZE_GAP_SIZE,
	                                    resizeFromZero: false
	                                }
	                            };
	
	                            var iconElement = columnHeader.querySelector('.gc-header-toggle');
	                            if (iconElement && pointIn_.call(self, offsetLeft, offsetTop, iconElement, columnHeaderPanel, true)) {
	                                hitTestInfo.columnGroupInfo.onExpandToggle = true;
	                            }
	                            break;
	                        }
	                    }
	
	                    if (!inColumnHeader) {
	                        hitTestInfo = {
	                            area: 'none'
	                        };
	                    }
	
	                } else if (contains_(rowHeaderLayout, point)) {
	                    offsetTop -= (columnHeaderLayout.height + (options.allowGrouping ? groupDragPanelLayout.height : 0));
	                    offsetTop += grid.scrollOffset.top;
	                    if (hasGroup_(grid)) {
	                        startRowPosition = 0;
	                        offsetTopLeft = offsetTop;
	                        for (i = 0, len = grid.data.groups.length; i < len; i++) {
	                            groupInfo = grid.groupInfos_[i];
	
	                            hitTestInfo = hitTestGroup_.call(this, groupInfo, offsetTopLeft, startRowPosition, offsetLeft, offsetTop, ROW_HEADER);
	                            if (hitTestInfo) {
	                                break;
	                            }
	                            offsetTopLeft -= groupInfo.height;
	                            startRowPosition += groupInfo.height;
	                        }
	                    } else {
	                        rowInfo = getRowInfoAt.call(this, {top: offsetTop});
	                        if (rowInfo) {
	                            hitTestInfo = {
	                                area: ROW_HEADER,
	                                row: rowInfo.index,
	                                column: -1
	                            };
	                            if (options.allowHeaderSelect) {
	                                relativeElement = document.getElementById(grid.uid + '-rh' + rowInfo.index);
	                                element = relativeElement.querySelector('.gc-header-select-icon');
	                                if (element && pointIn_.call(self, offsetLeft, offsetTop - rowInfo.startPosition, element, relativeElement, true)) {
	                                    hitTestInfo.checked = true;
	                                }
	                            }
	                        } else {
	                            hitTestInfo = {
	                                area: 'none'
	                            };
	                        }
	                    }
	                } else if (contains_(cornerHeaderLayout, point)) {
	                    hitTestInfo = {
	                        area: CORNER_HEADER,
	                        row: -1,
	                        column: -1
	                    };
	                    if (options.allowHeaderSelect) {
	                        relativeElement = document.getElementById(grid.uid + '-corner');
	                        element = relativeElement.querySelector('.gc-header-select-icon');
	                        offsetTop = offsetTop - (options.allowGrouping ? groupDragPanelLayout.height : 0);
	                        if (element && pointIn_.call(self, offsetLeft, offsetTop, element, relativeElement, true)) {
	                            hitTestInfo.checked = true;
	                        }
	                    }
	                } else if (options.allowGrouping && contains_(groupDragPanelLayout, point)) {
	                    hitTestInfo = {
	                        area: GROUP_DRAG_PANEL,
	                        row: -1,
	                        column: -1
	                    };
	                    var groupDescriptors = grid.data.groupDescriptors;
	                    var panelElement = document.getElementById(grid.uid + '-' + GROUP_DRAG_PANEL);
	                    for (i = 0, len = groupDescriptors.length; i < len; i++) {
	                        cellElement = document.getElementById(grid.uid + '-grouping-indicator-' + groupDescriptors[i].field);
	                        if (cellElement && pointIn_(offsetLeft, offsetTop, cellElement, panelElement)) {
	                            hitTestInfo.groupingPanelInfo = {
	                                field: groupDescriptors[i].field
	                            };
	                            if (pointIn_(offsetLeft, offsetTop, cellElement.querySelector('.gc-grouping-title'), panelElement)) {
	                                hitTestInfo.groupingPanelInfo.action = 'reorder';
	                            }
	                            if (pointIn_(offsetLeft, offsetTop, cellElement.querySelector('.gc-icon-grouping-delete'), panelElement)) {
	                                hitTestInfo.groupingPanelInfo.action = 'delete';
	                            }
	                            break;
	                        }
	                    }
	
	                }
	                return hitTestInfo;
	            },
	
	            destroy: function() {
	                var self = this;
	                if (self.groupStrategy_) {
	                    self.groupStrategy_.destroy();
	                    delete self.groupStrategy_;
	                } else {
	                    self.unRegisteEvents_();
	                }
	            },
	
	            toJSON: function() {
	                var self = this;
	                var options = self.options;
	                var jsonObj = {};
	                jsonObj.name = self.name;
	                var gridOptions = {};
	                if (options.rowHeaderWidth !== 40) {
	                    gridOptions.rowHeaderWidth = options.rowHeaderWidth;
	                }
	                if (options.colHeaderHeight !== 24) {
	                    gridOptions.colHeaderHeight = options.colHeaderHeight;
	                }
	                if (options.rowHeight !== 24) {
	                    gridOptions.rowHeight = options.rowHeight;
	                }
	                if (options.colWidth !== '*') {
	                    gridOptions.colWidth = options.colWidth;
	                }
	                if (options.showRowHeader !== true) {
	                    gridOptions.showRowHeader = options.showRowHeader;
	                }
	                if (options.showColHeader !== true) {
	                    gridOptions.showColHeader = options.showColHeader;
	                }
	                if (options.showGroupHeader !== true) {
	                    gridOptions.showGroupHeader = options.showGroupHeader;
	                }
	                if (options.showGroupFooter !== true) {
	                    gridOptions.showGroupFooter = options.showGroupFooter;
	                }
	                if (options.allowEditing !== false) {
	                    gridOptions.allowEditing = options.allowEditing;
	                }
	                if (options.allowGrouping !== false) {
	                    gridOptions.allowGrouping = options.allowGrouping;
	                }
	                if (options.rowTemplate) {
	                    gridOptions.rowTemplate = getRawRowTemplate_.call(self, false, VIEWPORT);
	                }
	                if (options.groupStrategy) {
	                    gridOptions.groupStrategy = options.groupStrategy.toJSON();
	                }
	                if (options.editMode !== 'inline') {
	                    gridOptions.editMode = options.editMode;
	                }
	                if (!_.isEmpty(gridOptions)) {
	                    jsonObj.options = gridOptions;
	                }
	                return jsonObj;
	            },
	
	            getSelections: function() {
	                var self = this;
	                var sels = [];
	                var selectedRows = self.selectedRows_;
	                if (!selectedRows || !selectedRows.length) {
	                    return sels;
	                }
	                var collection = self.grid.data.sourceCollection;
	                for (var i = 0, length = selectedRows.length; i < length; i++) {
	                    sels.push(collection[selectedRows[i]]);
	                }
	                return sels;
	            },
	
	            getInnerGroupHeight: function(groupInfo, containerSize) {
	                if (!groupInfo.isBottomLevel) {
	                    return 0;
	                }
	                return this.getRowHeight_() * groupInfo.data.itemCount;
	            },
	
	            getInnerGroupRenderInfo: function(groupInfo, containerSize, layoutCallback) {
	                if (!groupInfo.isBottomLevel) {
	                    return;
	                }
	                var self = this;
	                var group = groupInfo.data;
	                var offsetTop = 0;
	                var i;
	                var len;
	                var rowHeight = self.getRowHeight_();
	                var rows = [];
	                var layout;
	                var additionalStyle;
	                var additionalCSSClass;
	                for (i = 0, len = group.itemCount; i < len; i++) {
	                    if (layoutCallback) {
	                        layout = layoutCallback(groupInfo, i);
	                        additionalCSSClass = layout.cssClass;
	                        additionalStyle = layout.style || {};
	                        additionalStyle.width = containerSize.width;
	                        rowHeight = layout.rowHeight || rowHeight;
	                        if (layout.location) {
	                            rows.push(getRenderedGroupContentItemInfo_.call(self, i, groupInfo, rowHeight, layout.location.top, false, additionalCSSClass, additionalStyle, VIEWPORT));
	                        } else {
	                            rows.push(getRenderedGroupContentItemInfo_.call(self, i, groupInfo, rowHeight, offsetTop, false, additionalCSSClass, additionalStyle, VIEWPORT));
	                            offsetTop += rowHeight;
	                        }
	                    } else {
	                        additionalStyle = {width: containerSize.width};
	                        rows.push(getRenderedGroupContentItemInfo_.call(self, i, groupInfo, rowHeight, offsetTop, false, null, additionalStyle, VIEWPORT));
	                        offsetTop += rowHeight;
	                    }
	                }
	                return rows;
	            },
	
	            getMaxVisibleItemCount: function(containerSize) {
	                var self = this;
	                return Math.floor(containerSize.height / self.getRowHeight_());
	            },
	
	            hitTestGroupContent_: function(groupInfo, area, offsetLeft, offsetTop, containerSize) {
	                if (!groupInfo.isBottomLevel || offsetLeft < 0 || offsetTop < 0) {
	                    return null;
	                }
	                var self = this;
	                var uid = self.grid.uid;
	                var group = groupInfo.data;
	                var i;
	                var len;
	                var rowHeight = getGroupItemRowHeight_.call(self);
	                var hitGroupInfo;
	                var relativeElement;
	                var element;
	                var groupPath = groupInfo.path;
	                for (i = 0, len = group.itemCount; i < len; i++) {
	                    if (offsetTop <= rowHeight) {
	                        if (area === ROW_HEADER) {
	                            hitGroupInfo = {
	                                area: ROW_HEADER,
	                                row: -1,
	                                column: -1,
	                                groupInfo: {
	                                    area: GROUP_CONTENT,
	                                    path: groupPath,
	                                    row: i,
	                                    column: -1
	                                }
	                            };
	                            if (self.options.allowHeaderSelect) {
	                                relativeElement = document.getElementById(self.grid.uid + '-grh' + groupPath.join('-') + '-r' + i);
	                                element = relativeElement.querySelector('.gc-header-select-icon');
	                                if (element && pointIn_.call(self, offsetLeft, offsetTop, element, relativeElement, true)) {
	                                    hitGroupInfo.groupInfo.checked = true;
	                                }
	                            }
	                            return hitGroupInfo;
	                        } else {
	                            relativeElement = document.getElementById(uid + '-gr' + groupPath.join('_') + '-r' + i);
	                            if (!relativeElement) {
	                                return {
	                                    area: VIEWPORT,
	                                    row: -1,
	                                    column: -1,
	                                    groupInfo: {
	                                        area: GROUP_CONTENT,
	                                        path: groupPath,
	                                        row: i,
	                                        column: -1
	                                    }
	                                };
	                            }
	                            hitGroupInfo = hitTestGroupRowColumns_.call(self, groupPath, i, relativeElement, offsetLeft, offsetTop);
	                            return hitGroupInfo;
	                        }
	                    }
	                    offsetTop -= rowHeight;
	                    //accHeight += height;
	                }
	                return null;
	            },
	
	            //TODO: add row index and return different values based on row index
	            getRowHeight_: function() {
	                return this.options.rowHeight;
	            },
	
	            getGroupHeaderHeight_: function(group) {
	                var header = group.groupDescriptor.header;
	                return (header && header.visible) ? (header.height || this.options.rowHeight) : 0;
	            },
	
	            getGroupFooterHeight_: function(group) {
	                var footer = group.groupDescriptor.footer;
	                return (footer && footer.visible) ? (footer.height || this.options.rowHeight) : 0;
	            },
	
	            registeEvents_: function() {
	                var self = this;
	                var grid = self.grid;
	                self.handleMouseMoveFn_ = handleMouseMove_.bind(grid);
	                self.handleTouchMoveFn_ = handleTouchMove_.bind(grid);
	                self.handleTouchEndFn_ = handleTouchEnd_.bind(grid);
	                self.handleSwipeFn_ = handleSwipe_.bind(grid);
	                self.handleScrollTouchFn_ = handleTouchScroll.bind(grid);
	                grid.onMouseClick.addHandler(handleMouseClick_);
	                //grid.onMouseDbClick.addHandler(handleMouseDoubleClick);
	                grid.onMouseMove.addHandler(self.handleMouseMoveFn_);
	                grid.onMouseWheel.addHandler(handleMouseWheel);
	                grid.onMouseDown.addHandler(handleMouseDown);
	                grid.onTouchStart_.addHandler(handleTouchStart);
	                grid.onTouchMove_.addHandler(self.handleTouchMoveFn_);
	                grid.onTouchEnd_.addHandler(self.handleTouchEndFn_);
	                grid.onTap_.addHandler(handleTouchTap);
	                grid.onSwipe_.addHandler(self.handleSwipeFn_);
	                grid.onTouchScroll_.addHandler(self.handleScrollTouchFn_);
	            },
	
	            unRegisteEvents_: function() {
	                var self = this;
	                var grid = self.grid;
	                //grid.onMouseDbClick.removeHandler(handleMouseDoubleClick);
	                grid.onMouseClick.removeHandler(handleMouseClick_);
	                grid.onMouseMove.removeHandler(self.handleMouseMoveFn_);
	                grid.onMouseWheel.removeHandler(handleMouseWheel);
	                grid.onMouseDown.removeHandler(handleMouseDown);
	                grid.onTouchStart_.removeHandler(handleTouchStart);
	                grid.onTouchMove_.removeHandler(self.handleTouchMoveFn_);
	                grid.onTouchEnd_.removeHandler(self.handleTouchEndFn_);
	                grid.onTap_.removeHandler(handleTouchTap);
	                grid.onSwipe_.removeHandler(self.handleSwipeFn_);
	                grid.onTouchScroll_.removeHandler(self.handleScrollTouchFn_);
	            },
	
	            startEditing_: function(groupInfo, uiRowIndex, template) {
	                var self = this;
	                var editMode = self.options.editMode;
	                var grid = self.grid;
	                var editContainer;
	                var selector = grid.uid + (groupInfo ? ('-gr' + groupInfo.path.join('_')) : '') + '-r' + uiRowIndex;
	                var row = document.getElementById(selector);
	                var rowRect = domUtil.getElementRect(row);
	                var viewportRect = domUtil.getElementRect(document.getElementById(grid.uid + '-viewport'));
	                var pinnedViewportRect;
	                var pinnedRowRect;
	                if (self.hasLeftPinnedColumn_) {
	                    pinnedRowRect = domUtil.getElementRect(document.getElementById(grid.uid + (groupInfo ? ('-pgr' + groupInfo.path.join('_')) : '') + '-pr' + uiRowIndex));
	                    pinnedViewportRect = domUtil.getElementRect(document.getElementById(grid.uid + '-pinnedLeftViewport'));
	                }
	
	                var pinnedRightViewportRect;
	                var pinnedRightRowRect;
	                if (self.hasRightPinnedColumn_) {
	                    pinnedRightRowRect = domUtil.getElementRect(document.getElementById(grid.uid + (groupInfo ? ('-prgr' + groupInfo.path.join('_')) : '') + '-prr' + uiRowIndex));
	                    pinnedRightViewportRect = domUtil.getElementRect(document.getElementById(grid.uid + '-pinnedRightViewport'));
	                }
	                var editingHandler = grid.editingHandler;
	                var i;
	                var length;
	
	                self.containerKeyDownHandler_ = editingHandler.containerKeyDownHandler.bind(editingHandler);
	                self.containerMouseDownHandler_ = editingHandler.containerMouseDownHandler.bind(editingHandler);
	                if (editMode === 'inline') {
	                    var inlineFragment = editingHandler.getInlineFragment();
	                    editContainer = domUtil.createElement('<div id="' + grid.uid + '-inline-editing-area" class="gc-inline-editing-area gc-editing-area" style="top:' + rowRect.top + 'px;left:' + (pinnedViewportRect ? pinnedViewportRect.left : viewportRect.left) +
	                        'px; width:' + ((pinnedViewportRect ? pinnedViewportRect.width : 0) + viewportRect.width + (pinnedRightViewportRect ? pinnedRightViewportRect.width : 0)) + 'px;"></div>');
	                    var innerContainer = domUtil.createElement('<div id="' + grid.uid + '-inline-editing-area-inner" style="position:absolute;left:' + ((pinnedRowRect ? pinnedRowRect.left : rowRect.left) - (pinnedViewportRect ? pinnedViewportRect.left : viewportRect.left)) + 'px;"></div>');
	                    innerContainer.appendChild(inlineFragment);
	                    editContainer.appendChild(innerContainer);
	                    editContainer.addEventListener('keydown', self.containerKeyDownHandler_);
	                    document.body.appendChild(editContainer);
	                    var inlineEditors = editContainer.querySelectorAll('.gc-inline-editor-container');
	                    var height = 0;
	                    var rect;
	                    for (i = 0, length = inlineEditors.length; i < length; i++) {
	                        rect = domUtil.getElementRect(inlineEditors[i]);
	                        height = Math.max(height, rect.top - rowRect.top + rect.height);
	                    }
	                    editContainer.style.height = height + 'px';
	                } else if (editMode === 'popup') {
	                    var editPopupOverlay = domUtil.createElement('<div class="gc-editing-overlay"></div>');
	                    editContainer = domUtil.createElement('<div id="' + grid.uid + '-popup-editing-area" class="gc-popup-editing-area gc-editing-area">' +
	                        '<div class="gc-editing-header"><span class="header-text">Edit Form</span><div class="gc-editing-close"><span class="gc-icon close-icon"></span></div></div>' +
	                        '<div class="gc-editing-content">' + template + '</div>' +
	                        '<div class="gc-editing-footer"><div class="gc-editing-cancel gc-editing-button"><span class="cancel-text">Cancel</span></div><div class="gc-editing-update gc-editing-button"><span class="update-text">Update</span></div></div></div>');
	
	                    editContainer.addEventListener('keydown', self.containerKeyDownHandler_);
	                    editContainer.addEventListener('mousedown', self.containerMouseDownHandler_);
	                    document.body.appendChild(editContainer);
	                    document.body.appendChild(editPopupOverlay);
	                    var containerRect = domUtil.getElementRect(editContainer);
	                    var left = parseInt((window.innerWidth - containerRect.width) / 2 + window.pageXOffset);
	                    var top = parseInt((window.innerHeight - containerRect.height) / 2 + window.pageYOffset);
	                    domUtil.setCss(editContainer, {
	                        left: left,
	                        top: top
	                    });
	                } else if (editMode === 'editForm') {
	                    var rowHeaderWidth = grid.options.rowHeaderWidth;
	                    var viewportInnerRect = domUtil.getElementRect(document.getElementById(grid.uid + '-' + VIEWPORT + '-inner'));
	                    var pinnedViewportInnerRect = null;
	                    if (self.hasLeftPinnedColumn_) {
	                        pinnedViewportInnerRect = domUtil.getElementRect(document.getElementById(grid.uid + '-' + PINNED_VIEWPORT + '-inner'));
	                    }
	                    var containerWidth = grid.getContainerInfo_().contentRect.width;
	                    editContainer = domUtil.createElement('<div style="overflow:hidden;position:absolute;left:' + ((pinnedViewportInnerRect ? pinnedViewportInnerRect.left : viewportInnerRect.left) - rowHeaderWidth) + 'px;' +
	                        'width:' + containerWidth +
	                        'px;max-width:' + containerWidth + 'px;" id="' + grid.uid + '-form-editing-area" class="gc-form-editing-area gc-editing-area">' +
	                        '<div class="gc-editing-content">' + template + '</div>' +
	                        '<div class="gc-editing-footer"><div class="gc-editing-cancel gc-editing-button"><span class="cancel-text">Cancel</span></div><div class="gc-editing-update gc-editing-button"><span class="update-text">Update</span></div></div></div>');
	
	                    editContainer.addEventListener('keydown', self.containerKeyDownHandler_);
	                    editContainer.addEventListener('mousedown', self.containerMouseDownHandler_);
	                    document.body.appendChild(editContainer);
	
	                    var renderedRows = grid.lastRenderedRows_.viewport;
	                    var renderedHeaders = grid.lastRenderedRows_.rowHeader;
	                    var pinnedRenderedRows = grid.lastRenderedRows_.pinnedViewport;
	                    var startIndex = renderedRows.indexOf(selector);
	                    var formHeight = domUtil.getElementRect(editContainer).height;
	                    var tempRow;
	                    var tempHeader;
	                    var tempPinnedRow;
	                    if (startIndex >= 0) {
	                        var availableHeight_ = viewportRect.height - rowRect.height - (rowRect.top - viewportRect.top);
	                        var distance;
	                        var topDist;
	                        if (availableHeight_ < formHeight) {
	                            //If there is no enough space to display, some rows move upward.
	                            distance = formHeight - availableHeight_;
	                            for (i = 0; i <= startIndex; i++) {
	                                tempRow = document.getElementById(renderedRows[i]);
	                                tempHeader = document.getElementById(renderedHeaders[i]);
	                                topDist = Math.ceil(parseInt(tempRow.style.top) - distance);
	                                tempRow.style.top = topDist + 'px';
	                                tempHeader.style.top = topDist + 'px';
	                                if (pinnedRenderedRows) {
	                                    tempPinnedRow = document.getElementById(pinnedRenderedRows[i]);
	                                    tempPinnedRow.style.top = topDist + 'px';
	                                }
	                            }
	                            editContainer.style.top = Math.ceil(rowRect.top + rowRect.height - distance) + 'px';
	                        } else {
	                            //If there is enough space, some rows move down
	                            for (i = startIndex + 1, length = renderedRows.length; i < length; i++) {
	                                tempRow = document.getElementById(renderedRows[i]);
	                                tempHeader = document.getElementById(renderedHeaders[i]);
	                                tempRow.style.top = (parseInt(tempRow.style.top) + formHeight) + 'px';
	                                tempHeader.style.top = (parseInt(tempHeader.style.top) + formHeight) + 'px';
	                                if (pinnedRenderedRows) {
	                                    tempPinnedRow = document.getElementById(pinnedRenderedRows[i]);
	                                    tempPinnedRow.style.top = (parseInt(tempPinnedRow.style.top) + formHeight) + 'px';
	                                }
	                            }
	                            editContainer.style.top = Math.ceil(rowRect.top + rowRect.height) + 'px';
	                        }
	                    }
	                }
	                if (!editContainer.tabIndex || editContainer.tabIndex < 0) { //Only focusable element can be bound keydown event.
	                    editContainer.tabIndex = 1;
	                }
	            },
	
	            stopEditing_: function(valueChanged) {
	                var self = this;
	                var grid = self.grid;
	                var editMode = self.options.editMode;
	                var uid = grid.uid;
	                var editingHandler = grid.editingHandler;
	                var editContainer;
	                if (editMode === 'inline') {
	                    editContainer = document.getElementById(uid + '-inline-editing-area');
	                } else if (editMode === 'popup') {
	                    var overlay = document.querySelector('.gc-editing-overlay');
	                    if (overlay) {
	                        document.body.removeChild(overlay);
	                    }
	                    editContainer = document.getElementById(uid + '-popup-editing-area');
	                } else if (editMode === 'editForm') {
	                    editContainer = document.getElementById(uid + '-form-editing-area');
	                }
	                if (editContainer) {
	                    editContainer.removeEventListener('mousedown', self.containerMouseDownHandler_);
	                    editContainer.removeEventListener('keydown', self.containerKeyDownHandler_);
	                    document.body.removeChild(editContainer);
	                }
	                self.containerKeyDownHandler_ = null;
	                self.containerMouseDownHandler_ = null;
	
	                if (editMode === 'editForm') {
	                    grid.invalidate();
	                } else {
	                    if (valueChanged) {
	                        if (grid.data.groups) {
	                            grid.updateGroupInfos_();
	                            grid.invalidate();
	                        } else {
	                            if (editingHandler.wholeColumnChanged_) {
	                                grid.invalidate();
	                            } else {
	                                var groupInfo = editingHandler.editingInfo_.groupInfo;
	                                grid.refreshRow_('viewport', groupInfo ? groupInfo.path : null, editingHandler.editingInfo_.rowIndex);
	                            }
	                        }
	                    }
	                }
	            },
	
	            getDefaultEditorTemplate_: function() {
	                var grid = this.grid;
	                var editingHandler = grid.editingHandler;
	                var cols = grid.columns;
	                var r = '<div>';
	                _.each(cols, function(col) {
	                    if (editingHandler.isColumnEditable(grid, col)) {
	                        r += '<div><div class="gc-editing-template-label"><label class="content-text">' + (col.caption || col.id) + '</label></div><div class="gc-editing-template-field"><input type="' + editingHandler.getEditorType(col.dataType) + '" data-column="' + col.id + '"></div></div>';
	                    }
	                });
	                r += '</div>';
	                return r;
	            },
	            canDoSwipe_: function(moveDirection) {
	                var grid = this.grid;
	                if (moveDirection === 'vertical') {
	                    return false;
	                }
	                var existTouchActionColumn;
	                for (var i = 0, len = grid.columns.length; i < len; i++) {
	                    var col = grid.columns[i];
	                    if (isTouchActionColumn_(col)) {
	                        existTouchActionColumn = true;
	                        break;
	                    }
	                }
	                return existTouchActionColumn;
	            },
	            canStartSwipe_: function(deltaX, deltaY) {
	                return Math.abs(deltaX) >= 10 && Math.abs(deltaY) <= 5;
	            }
	        };
	
	        function clearTemplateCache_() {
	            var self = this;
	            self.cachedTmplFn_ = null;
	            self.cachedGroupFooterFn_ = null;
	            self.cachedGroupHeaderFn_ = null;
	            self.ch_ = null;
	
	            if (self.hasLeftPinnedColumn_) {
	                self.cachedPinedTmplFn_ = null;
	                self.pch_ = null;
	            }
	            if (self.hasRightPinnedColumn_) {
	                self.cachedRightPinedTmplFn_ = null;
	                self.prch_ = null;
	            }
	        }
	
	        function hitTestGroupRowColumns_(groupPath, row, rowElement, offsetLeft, offsetTop) {
	            var self = this;
	            var c;
	            var cols = self.grid.columns;
	            var colLen = cols.length;
	            var colElement;
	            var actionElements;
	            var actIndex;
	            var actLen;
	            var action;
	            var hitGroupInfo;
	            var inTreeNode = false;
	            offsetLeft -= (rowElement.style.left ? parseFloat(rowElement.style.left) : 0);
	            for (c = 0; c < colLen; c++) {
	                colElement = rowElement.querySelector('.c' + c);
	                if (colElement && pointIn_(offsetLeft, offsetTop, colElement, rowElement)) {
	                    var nodeElement = colElement.querySelector('.gc-tree-node');
	                    if (nodeElement && pointIn_.call(self, offsetLeft, offsetTop, nodeElement, rowElement, true)) {
	                        inTreeNode = true;
	                        break;
	                    } else if (cols[c].action) {
	                        actionElements = colElement.querySelectorAll('[data-action]');
	                        for (actIndex = 0, actLen = actionElements.length; actIndex < actLen; actIndex++) {
	                            if (pointIn_(offsetLeft, offsetTop, actionElements[actIndex], rowElement)) {
	                                action = self.grid.getActionHandler_(cols[c].id, actionElements[actIndex].getAttribute('data-action'));
	                            }
	                        }
	                    }
	                    break;
	                }
	            }
	            if (!action) {
	                action = hitTestTouchPanel_(self.grid, cols, offsetLeft, offsetTop, rowElement);
	            }
	            hitGroupInfo = {
	                area: VIEWPORT,
	                row: -1,
	                column: -1,
	                groupInfo: {
	                    area: GROUP_CONTENT,
	                    path: groupPath,
	                    row: row,
	                    column: c === colLen ? -1 : c
	                }
	            };
	            if (inTreeNode) {
	                hitGroupInfo.groupInfo.inTreeNode = true;
	            }
	            if (action) {
	                hitGroupInfo.groupInfo.action = action;
	            }
	            return hitGroupInfo;
	        }
	
	        function getRowsRenderInfo(area, options) {
	            var scope = this;
	            var grid = scope.grid;
	            var uid = grid.uid;
	            var currLayoutInfo = scope.getLayoutInfo()[area];
	            var r = {};
	            var i;
	            var rowHeight = scope.options.rowHeight;
	
	            var renderRange = getRenderRange.call(scope, area, currLayoutInfo, options);
	            if (area === VIEWPORT || area === PINNED_VIEWPORT || area === PINNED_RIGHT_VIEWPORT) {
	
	                r.left = area === VIEWPORT ? (-options.offsetLeft || 0) : 0;
	                r.top = -options.offsetTop;
	                r.renderedRows = [];
	
	                if (hasGroup_(grid)) {
	                    r.renderedRows = r.renderedRows.concat(getGroupRenderInfo_.call(scope, renderRange.start, renderRange.end, renderRange.offsetTop, false, true, area));
	                } else {
	                    for (i = renderRange.start; i < renderRange.end; i++) {
	                        r.renderedRows.push(
	                            {
	                                key: uid + (area === PINNED_VIEWPORT ? '-pr' : (area === PINNED_RIGHT_VIEWPORT ? '-prr' : '-r')) + i,
	                                index: i,
	                                height: rowHeight
	                            });
	                    }
	                }
	            } else if (area === ROW_HEADER) {
	                r.left = 0;
	                r.top = -options.offsetTop;
	                r.renderedRows = [];
	
	                if (hasGroup_(grid)) {
	                    r.renderedRows = r.renderedRows.concat(getGroupRenderInfo_.call(scope, renderRange.start, renderRange.end, renderRange.offsetTop, true, true, area));
	                } else {
	                    for (i = renderRange.start; i < renderRange.end; i++) {
	                        r.renderedRows.push(
	                            {
	                                key: uid + '-rh' + i,
	                                index: i,
	                                height: rowHeight
	                            });
	                    }
	                }
	            } else if (area === COLUMN_HEADER || area === PINNED_COLUMN_HEADER || area === PINNED_RIGHT_COLUMN_HEADER) {
	                r.left = area === COLUMN_HEADER ? (-options.offsetLeft || 0) : 0;
	                r.top = 0;
	                r.renderedRows = [];
	
	                r.renderedRows.push({key: uid + (area === PINNED_COLUMN_HEADER ? '-pch' : (area === PINNED_RIGHT_COLUMN_HEADER ? '-prch' : '-ch'))});
	            }
	
	            return r;
	        }
	
	        function getRenderRange(area, currLayoutInfo, options) {
	            var scope = this;
	            var grid = scope.grid;
	            var renderRange = {};
	            var offsetTop = options.offsetTop;
	            var offsetLeft = options.offsetLeft;
	            var isRowArea = (area === VIEWPORT || area === PINNED_VIEWPORT || area === PINNED_RIGHT_VIEWPORT || area === ROW_HEADER);
	
	            if (isRowArea) {
	                if (hasGroup_(scope.grid)) {
	                    renderRange.start = getGroupInfoAt_.call(scope, offsetTop);
	                    renderRange.end = getGroupInfoAt_.call(scope, offsetTop + currLayoutInfo.height);
	                    renderRange.offsetTop = renderRange.start.startPosition;
	                } else {
	                    var startInfo = getRowInfoAt.call(scope, {top: offsetTop, left: offsetLeft});
	                    var endInfo = getRowInfoAt.call(scope, {
	                        top: offsetTop + currLayoutInfo.height,
	                        left: offsetLeft + currLayoutInfo.width
	                    });
	
	                    if (startInfo) {
	                        renderRange.start = startInfo.index;
	                        renderRange.end = endInfo ? (endInfo.index + 1) : grid.data.itemCount;
	                        renderRange.offsetTop = startInfo.startPosition - offsetTop;
	                    } else {
	                        renderRange.start = renderRange.end = renderRange.offsetTop = 0;
	                    }
	                }
	            }
	
	            return renderRange;
	        }
	
	        function createRowRenderInfo(i, rowHeight, area, uid) {
	            var scope = this;
	            var formattedRowItem = scope.grid.getFormattedDataItem(i);
	            var sourceItemIndex = scope.grid.data.toSourceRow(i);
	            //var sourceItemIndex = i;
	            var keyPrefix = (area === VIEWPORT) ? '-r' : (area === PINNED_VIEWPORT ? '-pr' : '-prr');
	            var fn = area === PINNED_VIEWPORT ? scope.cachedPinedTmplFn_ : (area === PINNED_RIGHT_VIEWPORT ? scope.cachedRightPinedTmplFn_ : scope.cachedTmplFn_);
	            return {
	                key: uid + keyPrefix + i,
	                isRowRole: true,
	                selected: scope.selectedRows_ && scope.selectedRows_.indexOf(sourceItemIndex) !== -1,
	                renderInfo: {
	                    //TODO: remove index,evaluate the cssClasss, why always even?
	                    index: 0,
	                    cssClass: 'gc-row r' + i + ' even',
	                    style: {
	                        top: i * rowHeight,
	                        height: rowHeight
	                    },
	                    renderedHTML: (fn || scope.getRowTemplate(area))(formattedRowItem)
	                }
	            };
	        }
	
	        function getToolPanelWidth_() {
	            var self = this;
	            if (!self.options.showToolPanel) {
	                return 0;
	            }
	            self.toolPanelInfo_ = self.toolPanelInfo_ || getToolPanelInfo_();
	            return self.toolPanelInfo_.width;
	        }
	
	        function getToolPanelPadding_() {
	            var self = this;
	            if (!self.options.showToolPanel) {
	                return 0;
	            }
	            self.toolPanelInfo_ = self.toolPanelInfo_ || getToolPanelInfo_();
	            return self.toolPanelInfo_.padding;
	        }
	
	        function getToolPanelInfo_() {
	            var result = {};
	            var div = '<div style="position:absolute;top:-10000px;left:-10000px;width:5000px;height:5000px;">';
	            div += '<div class="gc-tool-panel-container"></div></div>';
	            var element = domUtil.createElement(div);
	            document.body.appendChild(element);
	            var container = element.firstChild;
	            result.width = parseInt(domUtil.getStyleValue(container, 'width')) || 200;
	            result.padding = (parseInt(domUtil.getStyleValue(container, 'padding-top')) || 0) + (parseInt(domUtil.getStyleValue(container, 'padding-bottom')) || 0);
	            document.body.removeChild(element);
	            return result;
	        }
	
	        function consolidateColumnWidth_(pinned) {
	            var self = this;
	            var tmpl = getUserDefinedTemplate_.call(self, pinned);
	            if (tmpl) {
	                var div = '<div style="position:absolute;top:-10000px;left:-10000px;width:5000px;height:5000px;">';
	                div += tmpl + '</div>';
	                var element = domUtil.createElement(div);
	                document.body.appendChild(element);
	
	                var colElem;
	                _.each(self.grid.columns, function(col) {
	                    colElem = element.querySelector('[data-column="' + col.id + '"]');
	                    if (colElem) {
	                        col.visibleWidth = domUtil.getElementRect(colElem).width;
	                    }
	                });
	
	                document.body.removeChild(element);
	            }
	        }
	
	        function getUserDefinedTemplate_(pinned) {
	            var options = this.options;
	            if (options) {
	                var rowTmpl;
	                if (pinned === 'left') {
	                    rowTmpl = options.pinnedLeftRowTemplate;
	                } else if (pinned === 'right') {
	                    rowTmpl = options.pinnedRightRowTemplate;
	                } else {
	                    rowTmpl = options.rowTemplate;
	                }
	                if (rowTmpl) {
	                    if (gcUtils.isString(rowTmpl) && rowTmpl.length > 1 && rowTmpl[0] === '#') {
	                        var tmplElement = document.getElementById(rowTmpl.slice(1));
	                        return tmplElement.innerHTML;
	                    } else {
	                        return rowTmpl;
	                    }
	                }
	            }
	            return null;
	        }
	
	        function getRawRowTemplate_(isColumnHeader, area) {
	            var self = this;
	            var pinned = 'none';
	            if (area === PINNED_VIEWPORT || area === PINNED_COLUMN_HEADER) {
	                pinned = 'left';
	            } else if (area === PINNED_RIGHT_VIEWPORT || area === PINNED_RIGHT_COLUMN_HEADER) {
	                pinned = 'right';
	            }
	            return getUserDefinedTemplate_.call(self, pinned) || (isColumnHeader ? getDefaultRawColumnHeaderTemplate_.call(self, pinned) : getDefaultRawRowTemplate_.call(self, pinned));
	        }
	
	        function filterActionColumn(templateStr, area) {
	            var self = this;
	            var grid = self.grid;
	            var div = document.createElement('div');
	            div.innerHTML = templateStr;
	            var element = div.children[0];
	            var annotationCols = element.querySelectorAll('[data-column]');
	            var colId;
	            var col;
	            var pinned = 'none';
	            if (area === PINNED_VIEWPORT || area === PINNED_COLUMN_HEADER) {
	                pinned = 'left';
	            } else if (area === PINNED_RIGHT_VIEWPORT || area === PINNED_RIGHT_COLUMN_HEADER) {
	                pinned = 'right';
	            }
	            _.each(annotationCols, function(annotationCol) {
	                colId = annotationCol.getAttribute('data-column');
	                col = grid.getColById_(colId);
	                //filter touch action column
	                if (isTouchActionColumn_(col)) {
	                    annotationCol.style.setProperty('display', 'none');
	                }
	                //filter group columns
	                if (!grid.isColVisible_(col, pinned)) {
	                    annotationCol.style.setProperty('display', 'none');
	                }
	
	            });
	
	            return domUtil.getElementInnerText(div);
	        }
	
	        function getDefaultRawRowTemplate_(pinned) {
	            var self = this;
	            var grid = self.grid;
	            var cols = grid.columns;
	            var left = 0;
	            var height = self.options.rowHeight;
	            var r = '<div style="height:' + height + 'px;">';
	            _.each(cols, function(col) {
	                if (grid.isColVisible_(col, pinned) && ((pinned === 'none' && col.pinned === 'none') || ((pinned === 'left' || pinned === 'right') && col.pinned === pinned))) {
	                    r += '<div class="gc-column" style="height:' + height + 'px;width:' + col.visibleWidth + 'px;left:' + left + 'px;' + (col.visible ? '' : 'display:none') + '" data-column="' + col.id + '"></div>';
	                    left += col.visibleWidth;
	                }
	            });
	            r += '</div>';
	            return r;
	        }
	
	        function getDefaultRawColumnHeaderTemplate_(pinned) {
	            var self = this;
	            var cols = self.grid.columnsConfig_;
	            var left = 0;
	            var baseHeight = self.options.colHeaderHeight;
	            var maxLevel = getColumnHeaderLevel_(cols);
	            var r = '<div style="height:' + baseHeight * maxLevel + 'px;">';
	            var info;
	
	            _.each(cols, function(col) {
	                info = getGroupColumnHeaderRenderInfo_.call(self, col, maxLevel, baseHeight, left, pinned);
	                if (info) {
	                    r += info.html;
	                    left += info.width;
	                }
	            });
	            r += '</div>';
	            return r;
	        }
	
	        function getGroupColumnHeaderRenderInfo_(col, parentGroupLevel, baseHeight, left, pinned) {
	            var self = this;
	            var grid = self.grid;
	            var level = getColumnHeaderLevel_([col]);
	            var colTree = grid.colTree_;
	            var width;
	            var r;
	            var i;
	            var len;
	            var info;
	            var columns;
	            var innerLeft;
	            var colDef;
	            if (level === 1) {
	                if (grid.isColVisible_(col, pinned) && ((pinned === 'none' && col.pinned === 'none') || ((pinned === 'left' || pinned === 'right') && col.pinned === pinned))) {
	                    return {
	                        html: '<div class="gc-column" style="height:' + (parentGroupLevel - level + 1) * baseHeight + 'px;width:' + col.visibleWidth + 'px;max-width:' + col.visibleWidth + 'px;left:' + left + 'px;' + (col.visible ? '' : 'display:none') + '" data-column="' + col.id + '"></div>',
	                        width: col.visibleWidth
	                    };
	                }
	            } else {
	                columns = col.columns;
	                if ((pinned !== 'none' && hasPinnedColumn_(columns)) || pinned === 'none') {
	                    width = getGroupColumnHeaderWidth_.call(self, columns, pinned);
	                    if (width > 0) {
	                        colDef = colTree[col.caption];
	                        r = '<div style="position:absolute; height:' + level * baseHeight + 'px;width:' + width + 'px;left:' + left + 'px;" data-column-group><div class="gc-column-header-cell" style="height:' +
	                            (parentGroupLevel - level + 1) * baseHeight + 'px;width:' + width + 'px;max-width:' + width + 'px;" data-column-group-header="' + col.caption + '"><span>' + col.caption + '</span>' +
	                            ((pinned !== 'none' ? (pinned === 'left' ? colDef.pinnedStatus.showIcon : colDef.pinnedRightStatus.showIcon) : colDef.status.showIcon) ? ' <span class="gc-icon gc-header-toggle ' +
	                            (((pinned !== 'none' ? (pinned === 'left' ? colDef.pinnedStatus.isCollapsed : colDef.pinnedRightStatus.isCollapsed) : colDef.status.isCollapsed)) ? 'collapsed' : 'expand') + '"></span>' : '') + '</div>';
	                        innerLeft = 0;
	                        for (i = 0, len = col.columns.length; i < len; i++) {
	                            info = getGroupColumnHeaderRenderInfo_.call(self, columns[i], level - 1, baseHeight, innerLeft, pinned);
	                            if (info) {
	                                r += info.html;
	                                innerLeft += info.width;
	                            }
	                        }
	                        r += '</div>';
	                        return {
	                            html: r,
	                            width: width
	                        };
	                    }
	                }
	                return null;
	            }
	        }
	
	        function hasPinnedColumn_(cols) {
	            var i;
	            var len;
	            var col;
	            var result = false;
	            for (i = 0, len = cols.length; i < len; i++) {
	                col = cols[i];
	                if (col.columns) {
	                    result = hasPinnedColumn_(col.columns);
	                } else {
	                    result = (col.pinned === 'left' || col.pinned === 'right');
	                }
	                if (result) {
	                    break;
	                }
	            }
	            return result;
	        }
	
	        function getGroupColumnHeaderWidth_(cols, pinned) {
	            var self = this;
	            var i;
	            var len;
	            var width = 0;
	            var col;
	            for (i = 0, len = cols.length; i < len; i++) {
	                col = cols[i];
	                if (col.columns) {
	                    width += getGroupColumnHeaderWidth_.call(self, col.columns, pinned);
	                } else if (self.grid.isColVisible_(col, pinned) && col.pinned === pinned) {
	                    width += col.visibleWidth;
	                }
	            }
	            return width;
	        }
	
	        function getColumnHeaderLevel_(cols) {
	            var i;
	            var len;
	            var max = 0;
	            var col;
	            for (i = 0, len = cols.length; i < len; i++) {
	                col = cols[i];
	                if (!col.hasOwnProperty('columns')) {
	                    max = Math.max(max, 1);
	                } else {
	                    max = Math.max(max, 1 + getColumnHeaderLevel_(col.columns));
	                }
	            }
	            return max;
	        }
	
	        function isTouchActionColumn_(col) {
	            return col.action && col.swipeDirection;
	        }
	
	        function getToolPanelRenderInfo_() {
	            var self = this;
	            var grid = self.grid;
	            var columns = grid.columns;
	            var padding = getToolPanelPadding_.call(self);
	
	            var totalHeight = self.getLayoutInfo()[TOOLPANEL].height - padding;
	
	            var colStr = '<div class="column-list" style="height:' + (totalHeight * 0.6 - 20) + 'px;"><div>'; //20 title height
	            _.each(columns, function(col) {
	                //colStr += '<div class="column-list-item"><input type="checkbox" value="' + col.id + '"' + (col.visible ? ' checked' : '') + '/><label>' + ' ' + col.caption + '</div>';
	                colStr += '<div data-col-id="' + col.id + '" class="column-list-item' + (col.visible ? '' : ' not-visible') + '"><div class="check"><span class="gc-icon select-icon' + (col.visible ? '' : ' not-visible') + '"></span></div><span class="content">' +
	                    col.caption + '</span></div>';
	
	            });
	            colStr += '</div></div>';
	            var html = '<div style="text-align:center; height:20px;">Columns';
	            if (!self.options.rowTemplate) {
	                html += '<span class="gc-icon insert-column-icon"><span>';
	            }
	            html += '</div>' + colStr;
	
	            html += '<div style="text-align:center; height:20px;">Group Columns';
	            colStr = '<div class="group-list" style="height:' + (totalHeight * 0.4 - 20) + 'px;"><div>'; //20 title height
	            var groupDescriptors = grid.data.groupDescriptors;
	            var len = groupDescriptors.length;
	            var col;
	            if (len > 0) {
	                _.each(groupDescriptors, function(desp) {
	                    col = grid.getColById_(desp.field);
	                    colStr += '<div data-group-id="' + col.id + '" class="group-list-item"><span class="content">' + col.caption + '</span><div class="remove"><span class="gc-icon remove-icon"></span></div></div>';
	
	                });
	            } else {
	                colStr += '<div><span class="group-clue">Drag columns from above to create groups</span></div>';
	            }
	            colStr += '</div></div>';
	            html += '</div>' + colStr;
	
	            return {
	                //key: self.grid.uid + '-tool-panel',
	                isRowRole: false,
	                renderInfo: {
	                    cssClass: '',
	                    style: {
	                        height: '100%'
	                    },
	                    renderedHTML: html
	                }
	            };
	        }
	
	        function getRenderedColumnHeaderInfo_(area) {
	            var self = this;
	            var result;
	            if (area === COLUMN_HEADER) {
	                result = self.ch_;
	            } else if (area === PINNED_COLUMN_HEADER) {
	                result = self.pch_;
	            } else {
	                result = self.prch_;
	            }
	            if (!result) {
	                result = getTemplate_.call(this, true, area);
	                if (area === PINNED_COLUMN_HEADER) {
	                    self.pch_ = result;
	                } else if (area === PINNED_RIGHT_COLUMN_HEADER) {
	                    self.prch_ = result;
	                } else {
	                    self.ch_ = result;
	                }
	            }
	            return {
	                key: self.grid.uid + (area === PINNED_COLUMN_HEADER ? '-pch' : (area === PINNED_RIGHT_COLUMN_HEADER ? '-prch' : '-ch')),
	                isRowRole: false,
	                renderInfo: {
	                    cssClass: 'gc-column-header ch',
	                    renderedHTML: result
	                }
	            };
	        }
	
	        function getRenderedGroupDragPanelInfo_(generateId) {
	            var self = this;
	            var grid = self.grid;
	            var groupDescriptors = grid.data.groupDescriptors;
	            var idPrefix = self.grid.uid + '-grouping-indicator-';
	            var i;
	            var colId;
	            var col;
	            var len = groupDescriptors.length;
	            var str = '';
	            if (len === 0) {
	                str += '<div class="gc-grouping-help-content">' + GROUP_DRAG_TEXT + '</div>';
	            } else {
	                for (i = 0; i < len; i++) {
	                    colId = groupDescriptors[i].field;
	                    col = grid.getColById_(colId);
	                    str += ('<div' + (generateId ? (' id="' + idPrefix + colId + '"') : '') + ' class="gc-grouping-indicator"><span class="gc-grouping-title">' + (col ? col.caption : '') + '</span><span class="gc-icon gc-icon-grouping-delete"></span></div>');
	                }
	            }
	            return str;
	        }
	
	        function getGroupDragPanelHeight_() {
	            var scope = this;
	
	            //TODO: appendChild/removeChild twice is too expensive, improve it later.
	            var maxWidth = scope.grid.getContainerInfo_().contentRect.width;
	            var groupDragPanelElement = domUtil.createElement('<div class="gc-grouping-container"><div>');
	            document.body.appendChild(groupDragPanelElement);
	            var groupDragPanelElementStyle = domUtil.getStyle(groupDragPanelElement);
	            var paddingLeft = parseStylePropertyValue_(groupDragPanelElementStyle, PADDING_LEFT);
	            var paddingRight = parseStylePropertyValue_(groupDragPanelElementStyle, PADDING_RIGHT);
	            document.body.removeChild(groupDragPanelElement);
	
	            maxWidth = maxWidth - paddingLeft - paddingRight;
	
	            var div = '<div class="gc-grouping-container"><div style="width:' + maxWidth + 'px;">' + getRenderedGroupDragPanelInfo_.call(scope, false) + '</div></div>';
	
	            var element = domUtil.createElement(div);
	            document.body.appendChild(element);
	            var height = element.offsetHeight;
	            document.body.removeChild(element);
	            return height;
	        }
	
	        function getGroupDragPanelLayoutInfo_() {
	            var scope = this;
	            if (scope.grouDragPanelLayoutInfo_) {
	                return scope.grouDragPanelLayoutInfo_;
	            }
	            var grid = scope.grid;
	            var width = grid.getContainerInfo_().contentRect.width;
	            var options = scope.options;
	            if (options.allowGrouping) {
	                var height = getGroupDragPanelHeight_.call(scope);
	                scope.grouDragPanelLayoutInfo_ = {
	                    top: 0,
	                    left: 0,
	                    width: width,
	                    height: height,
	                    contentWidth: width,
	                    contentHeight: height
	                };
	            } else {
	                scope.grouDragPanelLayoutInfo_ = {
	                    top: 0,
	                    left: 0,
	                    width: 0,
	                    height: 0,
	                    contentWidth: 0,
	                    contentHeight: 0
	                };
	            }
	
	            return scope.grouDragPanelLayoutInfo_;
	        }
	
	        function getPinnedColumnHeaderViewportLayoutInfo_(pinned) {
	            var scope = this;
	            var options = scope.options;
	            var groupDragPanelLayoutInfo = getGroupDragPanelLayoutInfo_.call(scope);
	            var viewportLayoutInfo = getPinnedViewportLayoutInfo_.call(scope, pinned);
	            var colHeaderHeight = (options.showColHeader ? options.colHeaderHeight * getColumnHeaderLevel_(scope.grid.columnsConfig_) : 0);
	
	            return {
	                top: groupDragPanelLayoutInfo.height,
	                left: viewportLayoutInfo.left,
	                width: viewportLayoutInfo.width,
	                height: colHeaderHeight,
	                contentWidth: viewportLayoutInfo.contentWidth,
	                contentHeight: colHeaderHeight
	            };
	        }
	
	        function getToolPanelLayoutInfo_() {
	            var self = this;
	            var containerRect = self.grid.getContainerInfo_().contentRect;
	            var groupDragPanelLayoutInfo = getGroupDragPanelLayoutInfo_.call(self);
	            var width = getToolPanelWidth_.call(self);
	            return {
	                top: groupDragPanelLayoutInfo.height,
	                left: Math.max(0, containerRect.width - width),
	                width: width,
	                height: containerRect.height - groupDragPanelLayoutInfo.height,
	                contentWidth: width,
	                contentHeight: containerRect.height - groupDragPanelLayoutInfo.height
	            };
	        }
	
	        function getPinnedViewportLayoutInfo_(pinned) {
	            var scope = this;
	            if (pinned === 'left' && scope.pvInfo_) {
	                return scope.pvInfo_;
	            } else if (pinned === 'right' && scope.prvInfo_) {
	                return scope.prvInfo_;
	            }
	            var grid = scope.grid;
	            var options = scope.options;
	            var groupDragPanelLayoutInfo = getGroupDragPanelLayoutInfo_.call(scope);
	            var rowHeaderWidth = (options.showRowHeader ? options.rowHeaderWidth : 0);
	            var containerRect = grid.getContainerInfo_().contentRect;
	            var colHeaderHeight = (options.showColHeader ? options.colHeaderHeight * getColumnHeaderLevel_(grid.columnsConfig_) : 0);
	            var height = containerRect.height - colHeaderHeight - groupDragPanelLayoutInfo.height;
	            var width;
	            var template = getUserDefinedTemplate_.call(scope, pinned);
	            if (template) {
	                var divStr = '<div style="position:absolute;top:-10000px;-10000px;width:5000px;height:5000px;">';
	                var element = domUtil.createTemplateElement(template);
	                element.children[0].style.display = 'inline-block';
	                divStr += element.innerHTML + '</div>';
	                var div = domUtil.createElement(divStr);
	                document.body.appendChild(div);
	                width = div.children[0].clientWidth;
	                document.body.removeChild(div);
	                div = null;
	            } else {
	                width = _.reduce(grid.columns, function(sum, col) {
	                    return sum + ((isTouchActionColumn_(col) || col.pinned !== pinned || !grid.isColVisible_(col, pinned)) ? 0 : col.visibleWidth);
	                }, 0);
	            }
	
	            if (pinned === 'left') {
	                scope.pvInfo_ = {
	                    top: colHeaderHeight + groupDragPanelLayoutInfo.height,
	                    left: rowHeaderWidth,
	                    width: width,
	                    height: height,
	                    contentWidth: width,
	                    contentHeight: height
	                };
	                return scope.pvInfo_;
	            } else {
	                var contentHeight = getContentHeight_(grid);
	                var leftPinnedLayout = getPinnedViewportLayoutInfo_.call(scope, 'left');
	                scope.prvInfo_ = {
	                    top: colHeaderHeight + groupDragPanelLayoutInfo.height,
	                    left: Math.max(leftPinnedLayout.left + leftPinnedLayout.width, containerRect.width - getToolPanelWidth_.call(scope) - width - (height < contentHeight ? domUtil.getScrollbarSize().width : 0)),
	                    width: width,
	                    height: height,
	                    contentWidth: width,
	                    contentHeight: height
	                };
	                return scope.prvInfo_;
	            }
	
	        }
	
	        function getViewportLayoutInfo_() {
	            var scope = this;
	            if (scope.cachedViewportLayoutInfo_) {
	                return scope.cachedViewportLayoutInfo_;
	            }
	            var grid = scope.grid;
	            var containerRect = grid.getContainerInfo_().contentRect;
	            var option = scope.options;
	            var groupDragPanelLayoutInfo = getGroupDragPanelLayoutInfo_.call(scope);
	
	            var rowHeaderWidth = (option.showRowHeader ? option.rowHeaderWidth : 0);
	            var colHeaderHeight = (option.showColHeader ? option.colHeaderHeight * getColumnHeaderLevel_(grid.columnsConfig_) : 0);
	
	            var width = containerRect.width - getToolPanelWidth_.call(scope) - rowHeaderWidth;
	            var height = containerRect.height - colHeaderHeight - groupDragPanelLayoutInfo.height;
	            var contentHeight = getContentHeight_(grid);
	            width = (height >= contentHeight) ? width : (width - domUtil.getScrollbarSize().width);
	            var contentWidth;
	            //if there is rowTemplate, measure the template width as the content width
	            var template = getUserDefinedTemplate_.call(scope, false);
	            if (template) {
	                var divStr = '<div style="position:absolute;top:-10000px;-10000px;width:5000px;height:5000px;">';
	                var element = domUtil.createTemplateElement(template);
	                if (element.children[0].style.display !== 'table') {
	                    element.children[0].style.display = 'inline-block';
	                }
	                divStr += element.innerHTML + '</div>';
	                var div = domUtil.createElement(divStr);
	                document.body.appendChild(div);
	                contentWidth = div.children[0].clientWidth;
	                document.body.removeChild(div);
	                div = null;
	            } else {
	                contentWidth = _.reduce(grid.columns, function(sum, col) {
	                    return sum + ((isTouchActionColumn_(col) || (col.pinned !== 'none') || !grid.isColVisible_(col, 'none')) ? 0 : col.visibleWidth);
	                }, 0);
	            }
	            var pinnedWidth = 0;
	            var pinnedViewportLayoutInfo;
	            var pinnedRightViewportLayoutInfo;
	            if (scope.hasLeftPinnedColumn_) {
	                pinnedViewportLayoutInfo = getPinnedViewportLayoutInfo_.call(scope, 'left');
	                pinnedWidth = pinnedViewportLayoutInfo.width;
	            }
	            width -= pinnedWidth;
	            if (scope.hasRightPinnedColumn_) {
	                pinnedRightViewportLayoutInfo = getPinnedViewportLayoutInfo_.call(scope, 'right');
	                width -= pinnedRightViewportLayoutInfo.width;
	            }
	            var scrollbarHeight = domUtil.getScrollbarSize().height;
	            height = (width >= contentWidth) ? height : (height - scrollbarHeight);
	            if (width < contentWidth) {
	                if (pinnedRightViewportLayoutInfo) {
	                    pinnedRightViewportLayoutInfo.height -= scrollbarHeight;
	                }
	            }
	            scope.cachedViewportLayoutInfo_ = {
	                top: colHeaderHeight + groupDragPanelLayoutInfo.height,
	                left: (rowHeaderWidth + pinnedWidth),
	                width: Math.max(0, width),
	                height: height,
	                contentWidth: contentWidth,
	                contentHeight: contentHeight
	            };
	            return scope.cachedViewportLayoutInfo_;
	        }
	
	        function getContentHeight_(grid) {
	            var data = grid.data;
	            if (hasGroup_(grid)) {
	                return _.reduce(grid.groupInfos_, function(sum, item) {
	                    return sum + item.height;
	                }, 0);
	            } else {
	                return data.itemCount * grid.options.rowHeight;
	            }
	        }
	
	        function getRowHeaderLayoutInfo_() {
	            var scope = this;
	            var options = scope.options;
	            var viewportLayoutInfo = getViewportLayoutInfo_.call(scope);
	            var rowHeaderWidth = (options.showRowHeader ? options.rowHeaderWidth : 0);
	            var height = viewportLayoutInfo.height;
	            if (scope.hasLeftPinnedColumn_) {
	                height = getPinnedViewportLayoutInfo_.call(scope, 'left').height;
	            }
	            return {
	                top: viewportLayoutInfo.top,
	                left: 0,
	                width: rowHeaderWidth,
	                height: height,
	                contentWidth: rowHeaderWidth,
	                contentHeight: viewportLayoutInfo.contentHeight
	            };
	        }
	
	        function parseStylePropertyValue_(style, property) {
	            return parseFloat(style.getPropertyValue(property));
	        }
	
	        function getColumnHeaderLayoutInfo_() {
	            var scope = this;
	            var grid = scope.grid;
	            var options = scope.options;
	            var groupDragPanelLayoutInfo = getGroupDragPanelLayoutInfo_.call(scope);
	            var viewportLayoutInfo = getViewportLayoutInfo_.call(scope);
	            var colHeaderHeight = (options.showColHeader ? options.colHeaderHeight * getColumnHeaderLevel_(grid.columnsConfig_) : 0);
	
	            return {
	                top: groupDragPanelLayoutInfo.height,
	                left: viewportLayoutInfo.left,
	                width: viewportLayoutInfo.width,
	                height: colHeaderHeight,
	                contentWidth: viewportLayoutInfo.contentWidth,
	                contentHeight: colHeaderHeight
	            };
	        }
	
	        function getCornerHeaderLayoutInfo_() {
	            var scope = this;
	            var options = scope.options;
	
	            var groupDragPanelLayoutInfo = getGroupDragPanelLayoutInfo_.call(scope);
	            var rowHeaderWidth = (options.showRowHeader ? options.rowHeaderWidth : 0);
	            var colHeaderHeight = (options.showColHeader ? options.colHeaderHeight * getColumnHeaderLevel_(scope.grid.columnsConfig_) : 0);
	            return {
	                top: groupDragPanelLayoutInfo.height,
	                left: 0,
	                width: rowHeaderWidth,
	                height: colHeaderHeight,
	                contentWidth: rowHeaderWidth,
	                contentHeight: colHeaderHeight
	            };
	        }
	
	        function parseStartSize_(value) {
	            if (gcUtils.isString(value) && value.length > 0 && value.slice(-1) === '*') {
	                var sz = value.length === 1 ? 1 : value.slice(0, -1) * 1;
	                if (sz > 0 && !isNaN(sz)) {
	                    return sz;
	                }
	            }
	            return null;
	        }
	
	        function updatePinnedColumns_() {
	            var self = this;
	            var grid = self.grid;
	            var options = self.options;
	            var leftTmpl = options.pinnedLeftRowTemplate;
	            var rightTmpl = options.pinnedRightRowTemplate;
	            if (leftTmpl || rightTmpl) {
	                _.each(grid.columns, function(col) {
	                    col.pinned = false;
	                });
	            }
	            updatePinnedColumnsInRowTemplate_(grid, leftTmpl, 'left');
	            updatePinnedColumnsInRowTemplate_(grid, rightTmpl, 'right');
	        }
	
	        function updatePinnedColumnsInRowTemplate_(grid, rowTemplate, pinned) {
	            if (rowTemplate) {
	                var element = domUtil.createTemplateElement(rowTemplate);
	                var annotationCols = element.querySelectorAll('[data-column]');
	                _.each(annotationCols, function(annotationCol) {
	                    grid.getColById_(annotationCol.getAttribute('data-column')).pinned = pinned;
	                });
	                element = null;
	            }
	        }
	
	        function getGroupDescriptorIndex_(groupDes, id) {
	            var i;
	            var len;
	            for (i = 0, len = groupDes.length; i < len; i++) {
	                if (groupDes[i].field === id) {
	                    return i;
	                }
	            }
	            return -1;
	        }
	
	        function getColIndex_(id) {
	            var self = this;
	            var cols = self.grid.columns;
	            var col;
	            for (var i = 0, len = cols.length; i < len; i++) {
	                col = cols[i];
	                if (col.id === id) {
	                    return i;
	                }
	            }
	            return -1;
	        }
	
	        function getTemplate_(isColumnHeader, area) {
	            var self = this;
	            if (!isColumnHeader) {
	                if (area === VIEWPORT && self.cachedTmplFn_) {
	                    return self.cachedTmplFn_;
	                } else if (area === PINNED_VIEWPORT && self.cachedPinedTmplFn_) {
	                    return self.cachedPinedTmplFn_;
	                } else if (area === PINNED_RIGHT_VIEWPORT && self.cachedRightPinedTmplFn_) {
	                    return self.cachedRightPinedTmplFn_;
	                }
	            }
	
	            var templateStr = getRawRowTemplate_.call(this, isColumnHeader, area);
	            var oldColTmpl;
	            var newColTmpl;
	            var cssName;
	            var tagName;
	            var colId;
	            var colTmpl;
	            var height;
	            var grid = self.grid;
	            var colIndex;
	            templateStr = filterActionColumn.call(this, templateStr, area);
	            var element = domUtil.createTemplateElement(templateStr);
	            //Different browsers may return different innerHTMLs compared with the original HTML,
	            //they may reorder the attribute of a tag,escapes tags with inside a noscript tag etc.
	            templateStr = domUtil.getElementInnerText(element);
	
	            var treeColId = getTreeColumn_(grid);
	            var annotationCols = element.querySelectorAll('[data-column]');
	            _.each(annotationCols, function(annotationCol) {
	                height = annotationCol.style.height;
	                //width = annotationCol.style.width;
	                colId = annotationCol.getAttribute('data-column');
	                var col = grid.getColById_(colId);
	                var colAnnotation;
	                if (col.isCalcColumn_) {
	                    colAnnotation = '{{=it.' + col.id + '}}';
	                } else {
	                    var dataFields = col.dataField ? col.dataField.split(',') : [];
	                    if (dataFields.length === 1) {
	                        colAnnotation = '{{=it.' + col.dataField + '}}';
	                    } else {
	                        var temp = [];
	                        _.each(dataFields, function(dataField) {
	                            temp.push(grid.getColById_(dataField).presenter || '{{=it.' + dataField + '}}');
	                        });
	                        colAnnotation = temp.join(' ');
	                    }
	                }
	                colTmpl = annotationCol;
	                tagName = colTmpl.tagName;
	                oldColTmpl = domUtil.getElementOuterText(colTmpl);
	                colIndex = getColIndex_.call(self, colId);
	                cssName = (isColumnHeader ? 'gc-column-header-cell' : 'gc-cell') + ' c' + colIndex + (col.cssClass ? (' ' + col.cssClass) : '');
	
	                var innerPresenter;
	                if (col.action) {
	                    innerPresenter = isColumnHeader ? (col.caption || '') : createActionColumn_.call(self, col);
	                } else {
	                    innerPresenter = isColumnHeader ? col.caption : (col.presenter ? col.presenter : colAnnotation);
	                }
	
	                if (!isColumnHeader && grid.data.isHierarchical && colId === treeColId) {
	                    var treeColPresenter = '<div style="margin-left:{{=it.node.offset}}px;">' +
	                        '<span class="gc-icon gc-tree-node {{? it.node.collapsed}}collapsed{{??}}expanded{{?}}" style="visibility:{{? it.node.children.length !=0}}visible{{??}}hidden{{?}};"></span></div>';
	                    innerPresenter = treeColPresenter + innerPresenter;
	                }
	
	                newColTmpl = oldColTmpl.slice(0, oldColTmpl.length - (tagName.length + 3)) +
	                    '<div class="' + cssName + '"' + (isColumnHeader ? '' : ' role="gridcell"') + '>' + innerPresenter +
	                    (isColumnHeader ? getSortIndicatorHtml_(self, col, colIndex) : '') +
	                    '</div></' + tagName + '>';
	
	                //outerHTML returns double quotes in attribute sometimes
	                if (templateStr.indexOf(oldColTmpl) === -1) {
	                    // jscs:disable validateQuoteMarks
	                    /*jshint quotmark: double */
	                    oldColTmpl = oldColTmpl.replace(/"/g, "'");
	                    // jscs:enable validateQuoteMarks
	                }
	                templateStr = templateStr.replace(oldColTmpl, newColTmpl);
	            });
	            var result;
	            if (!isColumnHeader) {
	                result = doT.template(templateStr, null, null, true);
	                if (area === PINNED_VIEWPORT) {
	                    self.cachedPinedTmplFn_ = result;
	                } else if (area === PINNED_RIGHT_VIEWPORT) {
	                    self.cachedRightPinedTmplFn_ = result;
	                } else {
	                    self.cachedTmplFn_ = result;
	                }
	                return result;
	            }
	
	            element = null;
	            return templateStr;
	        }
	
	        function getTreeColumn_(grid) {
	            var hierarchy = grid.options.hierarchy;
	            var cols = grid.columns;
	            if (hierarchy && hierarchy.column) {
	                var col = _.find(cols, _.matchesProperty('id', hierarchy.column));
	                return col ? col.id : cols[0].id;
	            } else {
	                return cols[0].id;
	            }
	        }
	
	        function createActionColumn_(col) {
	            var self = this;
	            var innerPresenter = '';
	            if (!self.grid.columnActions_) {
	                return innerPresenter;
	            }
	            var actionInfos = self.grid.columnActions_[col.id];
	            var item;
	            for (var i = 0, length = actionInfos.length; i < length; i++) {
	                item = actionInfos[i];
	                innerPresenter += (item.presenter ? item.presenter : ('<button class="gc-action" data-action="' + item.name + '">' + item.name + '</button>'));
	            }
	            if (innerPresenter !== '') {
	                innerPresenter = '<div class="gc-action-area">' + innerPresenter + '</div>';
	            }
	            return innerPresenter;
	        }
	
	        function createActionColumns() {
	            var self = this;
	            var columns = [];
	            var index = 0;
	            var actionType = swipeStatus.actionType;
	            _.each(self.grid.columns, function(col) {
	                if (isTouchActionColumn_(col) && col.swipeDirection === actionType) {
	                    var innerPresenter = createActionColumn_.call(self, col);
	                    columns.push({
	                        persenter: innerPresenter,
	                        perferredSize: col.visibleWidth,
	                        index: index
	                    });
	                }
	                index++;
	            });
	
	            return columns;
	        }
	
	        function createColumnTouchPanel(panelWidth) {
	            var self = this;
	            var row = swipeStatus.row;
	            var actionType = swipeStatus.actionType;
	            var columns = swipeStatus.columns;
	            var id = row.id + '-' + actionType + '-actionPanel';
	            var layoutInfo = self.getLayoutInfo()[VIEWPORT];
	            var className = row.className + ' actionPanel';
	            var width = panelWidth;
	            var left = actionType === 'left' ? (layoutInfo.contentWidth - width) : 0;
	            var style = 'top:' + row.style.top + '; height:' + row.style.height + '; left:' + left + 'px; width:' + width + 'px;position:absolute';
	            var containerHtml = '<div id="' + id + '" style="' + style + '" class="' + className + '">';
	            var colleft = actionType === 'left' ? 0 : width;
	
	            _.each(columns, function(col) {
	                var colWidth = (col.perferredSize / swipeStatus.columnsTotalWidth) * width;
	                var colTml;
	                if (actionType === 'right') {
	                    colleft -= colWidth;
	                }
	
	                colTml = '<div style = "' + 'height:100%;left:' + colleft + 'px;width:' + colWidth + 'px;position:absolute;overflow:hidden;">';
	                colTml += '<div style="height:100%;float:' + actionType + '" class="gc-actioncolumn' + col.index + '">' + col.persenter + '</div>';
	                colTml += '</div>';
	
	                if (actionType === 'left') {
	                    colleft += colWidth;
	                }
	
	                containerHtml += colTml;
	            });
	
	            containerHtml += '</div>';
	            return domUtil.createElement(containerHtml);
	        }
	
	        function groupInfoAreSame_(left, right) {
	            if (left.itemIndex !== right.itemIndex) {
	                return false;
	            }
	            if (left.area !== right.area) {
	                return false;
	            }
	
	            var leftPath = left.path;
	            var rightPath = right.path;
	            if (leftPath.length !== rightPath.length) {
	                return false;
	            }
	
	            for (var i = 0, len = leftPath.length; i < len; i++) {
	                if (leftPath[i] !== rightPath[i]) {
	                    return false;
	                }
	            }
	            return true;
	        }
	
	        function contains_(layoutInfo, point) {
	            return point.left >= layoutInfo.left && point.top >= layoutInfo.top && point.left <= (layoutInfo.left + layoutInfo.width) && point.top <= (layoutInfo.top + layoutInfo.height);
	        }
	
	        function getGroupInfoAt_(offset) {
	            var self = this;
	            var startPosition = 0;
	            var path;
	            var i;
	            var len = self.grid.data.groups.length;
	            for (i = 0; i < len; i++) {
	                path = [i];
	                var groupInfo = self.grid.getGroupInfo_(path);
	                var groupHeight = groupInfo.height;
	                var result = getGroupInfoAtInternal_.call(self, path, offset, startPosition);
	                if (result) {
	                    return result;
	                }
	
	                if (i === (len - 1)) {
	                    var footer = groupInfo.data.groupDescriptor.footer;
	                    if (footer && footer.visible) {
	                        return {
	                            path: [i],
	                            itemIndex: -1,
	                            area: 'groupFooter',
	                            startPosition: startPosition
	                        };
	                    } else {
	                        path = [i];
	                        result = getLastGroupItemPath_.call(this, path);
	                        result.startPosition = startPosition;
	                        return result;
	                    }
	                }
	                offset -= groupHeight;
	                startPosition += groupHeight;
	            }
	
	            return null;
	        }
	
	        function getLastGroupItemPath_(path) {
	            var self = this;
	            var groupInfo = self.grid.getGroupInfo_(path);
	            var group = groupInfo.data;
	            var gd = group.groupDescriptor;
	            var lastIndex = (group.isBottomLevel ? group.itemCount : groupInfo.children.length) - 1;
	            if (!group.isBottomLevel && !group.collapsed) {
	                return getLastGroupItemPath_.call(self, path.slice().concat([lastIndex]));
	            }
	            var footer = gd.footer;
	            if (group.collapsed) {
	                return {
	                    path: path,
	                    itemIndex: -1,
	                    area: (footer && footer.visible && !footer.collapseWithGroup) ? GROUP_FOOTER : GROUP_HEADER
	                };
	            } else {
	                return {
	                    path: path,
	                    itemIndex: (footer && footer.visible) ? -1 : lastIndex,
	                    area: (footer && footer.visible) ? GROUP_FOOTER : GROUP_HEADER
	                };
	            }
	        }
	
	        function getGroupInfoAtInternal_(path, offsetTop, startPosition) {
	            var self = this;
	            var groupInfo = self.grid.getGroupInfo_(path);
	            var group = groupInfo.data;
	            var i;
	            var len;
	            var height;
	            if (offsetTop <= groupInfo.height) {
	                height = self.getGroupHeaderHeight_(group);
	                if (offsetTop <= height) {
	                    return {
	                        path: path,
	                        itemIndex: -1,
	                        startPosition: startPosition,
	                        area: GROUP_HEADER
	                    };
	                } else {
	                    offsetTop -= height;
	                    startPosition += height;
	                    if (group.isBottomLevel) {
	                        for (i = 0, len = group.itemCount; i < len; i++) {
	                            height = self.getRowHeight_(group.getItem(i));
	                            if (offsetTop <= height) {
	                                return {
	                                    path: path,
	                                    itemIndex: i,
	                                    startPosition: startPosition,
	                                    area: GROUP_CONTENT
	                                };
	                            }
	                            offsetTop -= height;
	                            startPosition += height;
	                        }
	                    } else {
	                        for (i = 0, len = groupInfo.children.length; i < len; i++) {
	                            var result = getGroupInfoAtInternal_.call(self, path.slice().concat([i]), offsetTop, startPosition);
	                            if (result) {
	                                return result;
	                            }
	                            height = groupInfo.children[i].height;
	                            offsetTop -= height;
	                            startPosition += height;
	                        }
	                    }
	                    return {
	                        path: path,
	                        itemIndex: -1,
	                        startPosition: startPosition,
	                        area: GROUP_FOOTER
	                    };
	                }
	            } else {
	                return null;
	            }
	        }
	
	        function getGroupHeaderTemplate_(groupInfo, area) {
	            var self = this;
	            var groupPath = groupInfo.path;
	            var group = groupInfo.data;
	            self.cachedGroupHeaderFn_ = self.cachedGroupHeaderFn_ || {};
	            var cacheObj = self.cachedGroupHeaderFn_;
	            cacheObj[area] = cacheObj[area] || [];
	            if (cacheObj[area][groupPath.length - 1]) {
	                return cacheObj[area][groupPath.length - 1];
	            }
	            var height = self.getGroupHeaderHeight_(group);
	            var header = group.groupDescriptor.header;
	            var templateStr;
	            if (!self.hasLeftPinnedColumn_ || area === PINNED_VIEWPORT) {
	                var colGroupHeaders = '';
	                _.forEach(self.grid.columns, function(column) {
	                    if (column.groupHeader) {
	                        colGroupHeaders = colGroupHeaders + (colGroupHeaders ? ', ' : '') + column.groupHeader;
	                    }
	                });
	                var annotation = colGroupHeaders ? '(' + colGroupHeaders + ')' : '({{=it.count}} items)';
	                //TODO: preprocess user given header template, add height
	                templateStr = (header && header.template) ||
	                    '<div class="gc-group-header gc-group-header-cell " style="height:' + height + 'px;line-height:' +
	                    height + 'px;"><span class="gc-icon gc-grouping-toggle {{=it.groupStatus}}" style="margin-left:{{=it.margin}}px;"></span><span level="{{=it.level}}"> {{=it.name}}<span> ' + annotation + '</span></span></div>';
	
	            } else {
	                templateStr = '<div class="gc-group-header gc-group-header-cell " style="height:' + height + 'px;line-height:' + height + 'px;"></div>';
	            }
	
	            cacheObj[area][groupPath.length - 1] = doT.template(templateStr, null, null, true);
	            return cacheObj[area][groupPath.length - 1];
	        }
	
	        function getGroupFooterTemplate_(groupInfo, area) {
	            var self = this;
	            var grid = self.grid;
	            var groupPath = groupInfo.path;
	            self.cachedGroupFooterFn_ = self.cachedGroupFooterFn_ || {};
	            var cachedObj = self.cachedGroupFooterFn_;
	            cachedObj[area] = cachedObj[area] || [];
	            if (cachedObj[area][groupPath.length - 1]) {
	                return cachedObj[area][groupPath.length - 1];
	            }
	            var footer = groupInfo.data.groupDescriptor.footer;
	            var templateStr;
	            if (footer && area === PINNED_VIEWPORT) {
	                templateStr = footer.pinnedLeftTemplate;
	            } else if (footer && area === PINNED_RIGHT_VIEWPORT) {
	                templateStr = footer.pinnedRightTemplate;
	            }
	            templateStr = templateStr || getRawRowTemplate_.call(self, false, area);
	            var oldColTmpl;
	            var newColTmpl;
	            var cssName;
	            var tagName;
	            var colTmpl;
	            templateStr = filterActionColumn.call(this, templateStr, area);
	            var element = domUtil.createTemplateElement(templateStr);
	            //Different browsers may return different innerHTMLs compared with the original HTML,
	            //they may reorder the attribute of a tag,escapes tags with inside a noscript tag etc.
	            templateStr = domUtil.getElementInnerText(element);
	
	            var annotationCols = element.querySelectorAll('[data-column]');
	            _.each(annotationCols, function(annotationCol, index) {
	                var col = grid.getColById_(annotationCol.getAttribute('data-column'));
	                //TODO: handel the case that col aggragation is an array
	                var colAnnotation = col.groupFooter || '';
	                colTmpl = annotationCol;
	                tagName = colTmpl.tagName;
	                oldColTmpl = colTmpl.outerHTML;
	                cssName = 'gc-cell gc-group-footer-cell' + ' c' + index;
	                newColTmpl = oldColTmpl.slice(0, oldColTmpl.length - (tagName.length + 3)) +
	                    '<div style="height:100%;overflow:hidden;"><div style="height:100%;" class="' + cssName + '">' +
	                    colAnnotation +
	                    '</div></div></' + tagName + '>';
	
	                //outerHTML returns double quotes in attribute sometimes
	                if (templateStr.indexOf(oldColTmpl) === -1) {
	                    // jscs:disable validateQuoteMarks
	                    /*jshint quotmark: double */
	                    oldColTmpl = oldColTmpl.replace(/"/g, "'");
	                    // jscs:enable validateQuoteMarks
	                }
	                templateStr = templateStr.replace(oldColTmpl, newColTmpl);
	            });
	            element = null;
	            cachedObj[area][groupPath.length - 1] = doT.template(templateStr, null, null, true);
	            return cachedObj[area][groupPath.length - 1];
	        }
	
	        function getGroupFooterData_(groupInfo) {
	            var self = this;
	            var group = groupInfo.data;
	            var result = {
	                name: group.name,
	                count: group.itemCount,
	                level: group.level,
	                margin: group.level * 18,
	                groupStatus: group.collapsed ? 'collapsed' : 'expand',
	                condition: group.groupDescriptor.field,
	                eval: function(formula, format) {
	                    var calcSource = self.grid.data.calcSource;
	                    var result = calcSource.getEvaluator().evaluateFormula(formula, calcSource.getParserContext(), calcSource.getEvaluatorContext(-1, groupInfo.path));
	                    return formatValue.call(self, result, format, formula);
	                }
	            };
	            return result;
	        }
	
	        function getGroupFooterRenderInfo_(groupInfo, offset, area) {
	            var self = this;
	            var height = self.getGroupFooterHeight_(groupInfo.data);
	
	            return {
	                cssClass: 'gc-row g' + groupInfo.path.join('_'),
	                style: {
	                    top: offset,
	                    height: height
	                },
	                renderedHTML: getGroupFooterTemplate_.call(self, groupInfo, area)(getGroupFooterData_.call(self, groupInfo))
	            };
	        }
	
	        function getGroupHeaderRenderInfo_(groupPath, groupInfo, width, top, area) {
	            var self = this;
	            return {
	                cssClass: 'gc-row g' + groupPath.join('_'),
	                style: {
	                    top: top,
	                    width: width,
	                    height: self.getGroupHeaderHeight_(groupInfo.data),
	                    overflow: 'hidden'
	                },
	                renderedHTML: renderGroupHeader_.call(self, groupInfo, area)
	            };
	        }
	
	        function getGroupRowRenderInfo_(rowIndex, groupInfo, height, offset, additionalCSSClass, additionalStyle, area) {
	            var self = this;
	            var style = {
	                top: offset,
	                height: height
	            };
	            style = additionalStyle ? _.assign(additionalStyle, style) : style;
	            return {
	                cssClass: 'gc-row' + (additionalCSSClass ? (' ' + additionalCSSClass) : ''),
	                style: style,
	                renderedHTML: self.getRowTemplate(area)(self.grid.formatDataItem(groupInfo.data.getItem(rowIndex)))
	            };
	        }
	
	        function getGroupRenderInfo_(startInfo, endInfo, offsetTop, isRowHeader, getUpdateKey, area) {
	            if (!startInfo || !endInfo) {
	                return [];
	            }
	            var rows = [];
	            var scope = this;
	            var grid = scope.grid;
	            var groupInfos = [];
	            var renderItem = false;
	            var allDone = false;
	            var currInfo;
	            var groupInfo;
	            var i;
	            var len;
	            var tpRow;
	
	            var groupRowHeaderContentWidth = scope.getLayoutInfo()[area].contentWidth;
	
	            for (i = startInfo.path[0], len = endInfo.path[0]; i <= len; i++) {
	                groupInfos.push({
	                    path: [i],
	                    itemIndex: -1,
	                    area: GROUP_HEADER
	                });
	            }
	
	            while (groupInfos.length > 0) {
	                if (allDone) {
	                    break;
	                }
	                currInfo = groupInfos.shift();
	                if (!renderItem && groupInfoAreSame_(currInfo, startInfo)) {
	                    renderItem = true;
	                }
	                if (renderItem && groupInfoAreSame_(currInfo, endInfo)) {
	                    allDone = true;
	                }
	                if (renderItem) {
	                    if (currInfo.area === GROUP_HEADER) {
	                        tpRow = getGroupHeader_.call(scope, currInfo, isRowHeader, groupRowHeaderContentWidth, offsetTop, getUpdateKey, area);
	                    } else if (currInfo.area === GROUP_CONTENT) {
	                        tpRow = getGroupContent_.call(scope, currInfo, isRowHeader, offsetTop, getUpdateKey, area);
	                    } else {
	                        tpRow = getGroupFooter_.call(scope, currInfo, isRowHeader, offsetTop, getUpdateKey, area);
	                    }
	
	                    if (tpRow.row) {
	                        rows = rows.concat(tpRow.row);
	                        offsetTop += tpRow.height;
	                    }
	                }
	
	                if (currInfo.area === GROUP_HEADER) {
	                    groupInfo = grid.getGroupInfo_(currInfo.path);
	                    var group = groupInfo.data;
	                    if (group.collapsed) {
	                        if (group && !group.isBottomeLevel && !(group.groupDescriptor.footer && group.groupDescriptor.footer.collapseWithGroup)) {
	                            groupInfos.unshift({
	                                path: currInfo.path,
	                                itemIndex: -1,
	                                area: GROUP_FOOTER
	                            });
	                        }
	                    } else {
	                        groupInfos.unshift({
	                            path: currInfo.path,
	                            itemIndex: -1,
	                            area: GROUP_FOOTER
	                        });
	
	                        len = group.isBottomLevel ? group.itemCount : groupInfo.children.length;
	                        for (i = len - 1; i >= 0; i--) {
	                            if (group.isBottomLevel) {
	                                groupInfos.unshift({
	                                    path: currInfo.path,
	                                    itemIndex: i,
	                                    area: GROUP_CONTENT
	                                });
	                            } else {
	                                groupInfos.unshift({
	                                    path: currInfo.path.slice().concat([i]),
	                                    itemIndex: -1,
	                                    area: GROUP_HEADER
	                                });
	                            }
	                        }
	                    }
	                }
	            }
	
	            return rows;
	        }
	
	        function getGroupHeader_(currInfo, isRowHeader, width, offsetTop, getUpdateKey, area) {
	            var scope = this;
	            var grid = scope.grid;
	            var rows;
	            var height;
	            var groupInfo = grid.getGroupInfo_(currInfo.path);
	            var header = groupInfo.data.groupDescriptor.header;
	            if (header && header.visible) {
	                rows = [];
	                height = scope.getGroupHeaderHeight_(groupInfo.data);
	                if (isRowHeader) {
	                    rows.push(getGroupRowHeaderCell.call(scope, currInfo, offsetTop, height, getUpdateKey));
	                } else {
	                    var key = grid.uid + (area === PINNED_VIEWPORT ? '-pgh' : (area === VIEWPORT ? '-gh' : '-prgh')) + currInfo.path.join('_');
	                    if (getUpdateKey) {
	                        rows.push({
	                            key: key,
	                            info: currInfo,
	                            top: offsetTop,
	                            width: width,
	                            area: GROUP_HEADER
	                        });
	                    } else {
	                        rows.push(getGroupHeaderRow_.call(scope, key, currInfo, groupInfo, width, offsetTop, area));
	                    }
	                }
	            }
	
	            return {row: rows, height: height};
	        }
	
	        function getGroupHeaderRow_(key, currInfo, groupInfo, width, top, area) {
	            var scope = this;
	            return {
	                key: key,
	                isRowRole: false,
	                renderInfo: getGroupHeaderRenderInfo_.call(scope, currInfo.path, groupInfo, width, top, area)
	            };
	        }
	
	        function getRenderedGroupContentItemInfo_(rowIndex, groupInfo, height, offsetTop, getUpdateKey, additionalCSSClass, additionalStyle, area) {
	            var self = this;
	            var key = self.grid.uid + (area === VIEWPORT ? '-gr' : (area === PINNED_VIEWPORT ? '-pgr' : '-prgr')) + groupInfo.path.join('_') + '-r' + rowIndex;
	            if (getUpdateKey) {
	                return {
	                    key: key,
	                    info: {
	                        path: groupInfo.path,
	                        itemIndex: rowIndex,
	                        area: GROUP_CONTENT
	                    },
	                    top: offsetTop,
	                    height: getGroupItemRowHeight_.call(self),
	                    area: GROUP_CONTENT
	                };
	            } else {
	                return getGroupContentRow_.call(self, key, rowIndex, groupInfo, height, offsetTop, additionalCSSClass, additionalStyle, area);
	            }
	        }
	
	        function getGroupContent_(currInfo, isRowHeader, offsetTop, getUpdateKey, area) {
	            var scope = this;
	            var grid = scope.grid;
	            var rows = [];
	            var groupInfo = grid.getGroupInfo_(currInfo.path);
	            var height = getGroupItemRowHeight_.call(this);
	            if (isRowHeader) {
	                rows.push(getGroupRowHeaderCell.call(scope, currInfo, offsetTop, height, getUpdateKey));
	            } else {
	                rows.push(getRenderedGroupContentItemInfo_.call(scope, currInfo.itemIndex, groupInfo, height, offsetTop, getUpdateKey, null, null, area));
	            }
	
	            return {row: rows, height: height};
	        }
	
	        function getGroupContentRow_(key, rowIndex, groupInfo, height, top, additionalCSSClass, additionalStyle, area) {
	            var scope = this;
	            return {
	                key: key,
	                isRowRole: true,
	                selected: scope.selectedRows_ && scope.selectedRows_.indexOf(groupInfo.data.toSourceRow(rowIndex)) !== -1,
	                renderInfo: getGroupRowRenderInfo_.call(scope, rowIndex, groupInfo, height, top, additionalCSSClass, additionalStyle, area)
	            };
	        }
	
	        function getGroupFooter_(currInfo, isRowHeader, offsetTop, getUpdateKey, area) {
	            var scope = this;
	            var grid = scope.grid;
	            var rows;
	            var groupInfo = grid.getGroupInfo_(currInfo.path);
	            var height;
	            var footer = groupInfo.data.groupDescriptor.footer;
	            if (footer && footer.visible) {
	                rows = [];
	                height = scope.getGroupFooterHeight_(groupInfo.data);
	                if (isRowHeader) {
	                    rows.push(getGroupRowHeaderCell.call(scope, currInfo, offsetTop, height, getUpdateKey));
	                } else {
	                    var key = grid.uid + (area === PINNED_VIEWPORT ? '-pgf' : (area === PINNED_RIGHT_VIEWPORT ? '-prgf' : '-gf')) + currInfo.path.join('_');
	                    if (getUpdateKey) {
	                        rows.push({
	                            key: key,
	                            info: currInfo,
	                            top: offsetTop,
	                            area: GROUP_FOOTER
	                        });
	                    } else {
	                        rows.push(getGroupFooterRow_.call(scope, key, currInfo, groupInfo, offsetTop, area));
	                    }
	                }
	            }
	
	            return {row: rows, height: height};
	        }
	
	        function getGroupFooterRow_(key, currInfo, groupInfo, top, area) {
	            var scope = this;
	            return {
	                key: key,
	                isRowRole: false,
	                renderInfo: getGroupFooterRenderInfo_.call(scope, groupInfo, top, area)
	            };
	        }
	
	        function getGroupRowHeaderCell(currInfo, offsetTop, height, getUpdateKey) {
	            var scope = this;
	            if (getUpdateKey) {
	                return {
	                    key: getRowHeaderCellKey.call(this, currInfo),
	                    top: offsetTop,
	                    height: height,
	                    info: currInfo
	                };
	            } else {
	                return getRowHeaderCellRenderInfo_.call(scope, currInfo, null, height, offsetTop);
	            }
	        }
	
	        function renderGroupHeader_(groupInfo, area) {
	            var self = this;
	            return getGroupHeaderTemplate_.call(self, groupInfo, area)(getGroupFooterData_.call(self, groupInfo));
	        }
	
	        function getRowHeaderCellRenderInfo_(currentInfo, itemIndex, height, offsetTop) {
	            var self = this;
	            var key = getRowHeaderCellKey.call(self, currentInfo, itemIndex);
	            return buildHeaderCell.call(self, key, currentInfo, (currentInfo ? false : true), (itemIndex ? (itemIndex * height) : offsetTop), height, itemIndex);
	        }
	
	        function getRowHeaderCellKey(currentInfo, itemIndex) {
	            var self = this;
	            var key = self.grid.uid;
	            if (currentInfo) {
	                if (currentInfo.area === GROUP_HEADER) {
	                    key += ('-ghh' + currentInfo.path.join('-'));
	                } else if (currentInfo.area === GROUP_CONTENT) {
	                    key += ('-grh' + currentInfo.path.join('-') + '-r' + currentInfo.itemIndex);
	                } else {
	                    key += ('-gfh' + currentInfo.path.join('-'));
	                }
	            } else {
	                key += ('-rh' + itemIndex);
	            }
	
	            return key;
	        }
	
	        function buildHeaderCell(key, info, isRowRole, top, height, itemIndex) {
	            var self = this;
	            var grid = self.grid;
	            var showCheckbox = true;
	            var isChecked = false;
	            var selectedRows = self.selectedRows_;
	            var checkboxSelectable = self.options.allowHeaderSelect;
	            if (checkboxSelectable) {
	                if (info) {
	                    if (info.area === GROUP_HEADER) {
	                        var mappings = getGroupMapping_(grid.getGroupInfo_(info.path));
	                        for (var i = 0, length = mappings.length; i < length; i++) {
	                            isChecked = selectedRows && selectedRows.indexOf(mappings[i]) !== -1;
	                            if (!isChecked) {
	                                break;
	                            }
	                        }
	                    } else if (info.area === GROUP_FOOTER) {
	                        showCheckbox = false;
	                    } else {
	                        var row = grid.getGroupInfo_(info.path).data.toSourceRow(info.itemIndex);
	                        isChecked = selectedRows && selectedRows.indexOf(row) !== -1;
	                    }
	                } else {
	                    isChecked = selectedRows && selectedRows.indexOf(itemIndex) !== -1;
	                }
	            }
	
	            return {
	                key: key,
	                isRowRole: isRowRole,
	                renderInfo: {
	                    cssClass: 'gc-row-header',
	                    style: {
	                        top: top,
	                        height: height,
	                        width: self.options.rowHeaderWidth
	                    },
	                    renderedHTML: '<div class="gc-row-header-cell">' + (checkboxSelectable && showCheckbox ? '<div id="' + key + '-select" class="gc-icon gc-header-select-icon' + (isChecked ? ' selected' : '') + '"></div>' : '') + '</div>'
	
	                }
	            };
	        }
	
	        //TODO: implement if we allow different row height
	        function getGroupItemRowHeight_() {
	            return this.options.rowHeight;
	        }
	
	        function getRowInfoAt(offset) {
	            var self = this;
	            var startPosition = 0;
	            var dataLen = self.grid.data.itemCount;
	            var cachedRowOffset = self.cachedRowOffset_;
	            var offsetTop = offset.top;
	            var startIndex = 0;
	            var rowHeight = self.options.rowHeight;
	            var i;
	            var item;
	            if (cachedRowOffset) {
	                for (i = cachedRowOffset.length - 1; i >= 0; i--) {
	                    item = cachedRowOffset[i];
	                    if (item <= offsetTop) {
	                        startIndex = i * 10000;
	                        offsetTop -= item;
	                        startPosition = item;
	                        break;
	                    }
	                }
	            }
	
	            for (i = startIndex; i < dataLen; i++) {
	                if (offsetTop <= rowHeight) {
	                    return {
	                        index: i,
	                        startPosition: startPosition
	                    };
	                }
	                if (i % 10000 === 0) {
	                    self.cachedRowOffset_ = cachedRowOffset || [];
	                    self.cachedRowOffset_[i / 10000] = startPosition;
	                }
	                offsetTop -= rowHeight;
	                startPosition += rowHeight;
	            }
	
	            return null;
	        }
	
	        function startDragDroping_() {
	            var self = this;
	            var grid = self.grid;
	            var selector;
	            var hitTest = self.dragStartInfo_.hitTestInfo;
	            var hitColGroupCaption = hitTest.columnGroupInfo ? hitTest.columnGroupInfo.caption : null;
	            var capiton;
	            var area = hitTest.area;
	            if (area === COLUMN_HEADER || area === PINNED_COLUMN_HEADER || area === PINNED_RIGHT_COLUMN_HEADER) {
	                if (hitTest.column >= 0) {
	                    selector = '#' + self.grid.uid + '-' + area + ' .gc-column-header-cell.c' + hitTest.column;
	                    capiton = grid.columns[hitTest.column].caption;
	                } else if (hitColGroupCaption) {
	                    selector = '#' + self.grid.uid + '-' + area + ' [data-column-group-header="' + hitColGroupCaption + '"]';
	                    capiton = hitColGroupCaption;
	                }
	
	            } else if (area === GROUP_DRAG_PANEL && hitTest.groupingPanelInfo) {
	                selector = '#' + self.grid.uid + '-grouping-indicator-' + hitTest.groupingPanelInfo.field;
	                capiton = grid.getColById_(hitTest.groupingPanelInfo.field).caption;
	            }
	
	            var element = document.querySelector(selector);
	            if (element) {
	                var offset = domUtil.offset(element);
	                var pointOffset = self.dragStartInfo_.pointOffset;
	                self.dragStartInfo_.pointOffset = {
	                    left: offset.left - pointOffset.left,
	                    top: offset.top - pointOffset.top
	                };
	                var width = element.clientWidth;
	                var height = element.clientHeight;
	                element = domUtil.createElement('<div class="gc-drag-clue"  style="z-index:999"><span class="gc-icon gc-icon-grouping-add"></span><div style="display:inline-block;overflow: hidden;white-space:pre;"><span> ' + capiton + '</span></div></div>');
	                element.id = '';
	                element.style.top = offset.top + 'px';
	                element.style.left = offset.left + 'px';
	                element.style.width = width + 'px';
	                element.style.height = height + 'px';
	                //element.style.height = height + 'px';
	                element.style.position = POS_ABS;
	                document.body.appendChild(element);
	                self.dragDropingElement_ = element;
	
	                var clueIndicatorElement = domUtil.createElement('<div class="gc-drag-clue-indicator"><span class="gc-icon top"></span><span class="gc-icon bottom"></span></div>');
	                document.body.appendChild(clueIndicatorElement);
	                var elementStyle = domUtil.getStyle(element);
	                var paddingLeft = parseStylePropertyValue_(elementStyle, PADDING_LEFT);
	                var paddingRight = parseStylePropertyValue_(elementStyle, PADDING_RIGHT);
	
	                width = width - paddingLeft - paddingRight - 16;
	                element = element.querySelector('div');
	                element.style.width = width + 'px';
	                if (width <= 0) {
	                    element.style.display = 'none';
	                }
	                self.dragDropingIndicatorElement_ = clueIndicatorElement;
	
	                return true;
	            }
	
	            return false;
	        }
	
	        function hitTestGroup_(groupInfo, heightLeft, accHeight, offsetLeft, offsetTop, area) {
	            var self = this;
	
	            var uid = self.grid.uid;
	            var group = groupInfo.data;
	            var groupPath = groupInfo.path;
	            var height = groupInfo.height;
	            var i;
	            var len;
	            var element;
	            var relativeElement;
	            var onGroupToggle = false;
	            var hitGroupInfo;
	            var children;
	            if (heightLeft <= height) {
	                height = self.getGroupHeaderHeight_(group);
	                //TODO: how to handle custom header template
	                if (heightLeft <= height) {
	                    if (area === ROW_HEADER) {
	                        hitGroupInfo = {
	                            area: ROW_HEADER,
	                            row: -1,
	                            column: -1,
	                            groupInfo: {
	                                path: groupPath,
	                                area: GROUP_HEADER
	                            }
	                        };
	                        if (self.options.allowHeaderSelect) {
	                            relativeElement = document.getElementById(self.grid.uid + '-ghh' + groupPath.join('-'));
	                            element = relativeElement.querySelector('.gc-header-select-icon');
	                            if (element && pointIn_.call(self, offsetLeft, offsetTop - accHeight, element, relativeElement, true)) {
	                                hitGroupInfo.groupInfo.checked = true;
	                            }
	                        }
	                        return hitGroupInfo;
	                    } else {
	                        relativeElement = document.getElementById(uid + (self.hasLeftPinnedColumn_ ? '-pgh' : '-gh') + groupPath.join('_'));
	                        element = relativeElement.querySelector('.gc-grouping-toggle');
	                        if (element && pointIn_.call(self, offsetLeft, offsetTop - accHeight, element, relativeElement, true)) {
	                            onGroupToggle = true;
	                        }
	                        return {
	                            area: VIEWPORT,
	                            row: -1,
	                            column: -1,
	                            groupInfo: {
	                                path: groupPath,
	                                area: GROUP_HEADER,
	                                onExpandToggle: onGroupToggle
	                            }
	                        };
	                    }
	
	                } else {
	                    heightLeft -= height;
	                    accHeight += height;
	
	                    if (group.collapsed) {
	                        if (group.groupDescriptor.footer && group.groupDescriptor.footer.collapseWithGroup) {
	                            throw 'group hitTest error';
	                        } else {
	                            if (heightLeft <= self.getGroupFooterHeight_(group)) {
	                                return hitTestGroupFooter_.call(self, groupInfo, offsetLeft, offsetTop, area);
	                            } else {
	                                throw 'group hitTest error';
	                            }
	                        }
	
	                    }
	                    if (!groupInfo.isBottomLevel) {
	                        children = groupInfo.children;
	                        for (i = 0, len = children.length; i < len; i++) {
	                            height = self.getGroupHeight_(children[i]);
	                            if (heightLeft <= height) {
	                                return hitTestGroup_.call(self, groupInfo.children[i], heightLeft, accHeight, offsetLeft, offsetTop, area);
	                            }
	                            heightLeft -= height;
	                            accHeight += height;
	                        }
	                    } else {
	                        hitGroupInfo = self.hitTestGroupContent_(groupInfo, area, offsetLeft, offsetTop - accHeight);
	                        if (hitGroupInfo) {
	                            return hitGroupInfo;
	                        }
	                    }
	                    return hitTestGroupFooter_.call(self, groupInfo, offsetLeft, offsetTop, area);
	                }
	            }
	            return null;
	        }
	
	        function hitTestGroupFooter_(groupInfo, offsetLeft, offsetTop, area) {
	            var groupPath = groupInfo.path;
	            if (area === ROW_HEADER) {
	                return {
	                    area: ROW_HEADER,
	                    row: -1,
	                    column: -1,
	                    groupInfo: {
	                        path: groupPath,
	                        area: GROUP_FOOTER,
	                        row: -1,
	                        column: -1
	                    }
	
	                };
	            }
	
	            var self = this;
	            var uid = self.grid.uid;
	            var cellElement;
	            var cellOffset;
	            var i;
	            var len = self.grid.columns.length;
	            var footerElement = document.getElementById(uid + '-gf' + groupPath.join('_'));
	            var footerElementOffset = domUtil.offset(footerElement);
	
	            for (i = 0; i < len; i++) {
	                cellElement = footerElement.querySelector('.c' + i);
	                if (cellElement) {
	                    cellOffset = domUtil.offset(cellElement);
	                    var left = cellOffset.left - footerElementOffset.left;
	                    if (offsetLeft >= left && offsetLeft <= (left + cellElement.clientWidth)) {
	                        break;
	                    }
	                }
	            }
	            return {
	                area: VIEWPORT,
	                row: -1,
	                column: -1,
	                groupInfo: {
	                    path: groupPath,
	                    area: GROUP_FOOTER,
	                    row: -1,
	                    column: i === len ? -1 : i
	                }
	            };
	        }
	
	        function hitTestTouchPanel_(grid, cols, offsetLeft, offsetTopFromCurrentRow, rowElement) {
	            var actionTouchPanel = getTouchPanel();
	            var actionColumn;
	            var i;
	            var actIndex;
	            var actLen;
	            var actionElements;
	            var action;
	            if (actionTouchPanel) {
	                var actionLen = swipeStatus.columns.length;
	                for (i = 0; i < actionLen; i++) {
	                    var columnIndex = swipeStatus.columns[i].index;
	                    actionColumn = actionTouchPanel.querySelector('.gc-actioncolumn' + columnIndex);
	                    if (actionColumn && pointIn_(offsetLeft, offsetTopFromCurrentRow, actionColumn, rowElement)) {
	                        if (cols[columnIndex].action) {
	                            actionElements = actionColumn.querySelectorAll('[data-action]');
	                            for (actIndex = 0, actLen = actionElements.length; actIndex < actLen; actIndex++) {
	                                if (pointIn_(offsetLeft, offsetTopFromCurrentRow, actionElements[actIndex], rowElement)) {
	                                    action = grid.getActionHandler_(cols[columnIndex].id, actionElements[actIndex].getAttribute('data-action'));
	                                }
	                            }
	                        }
	                        break;
	                    }
	                }
	            }
	
	            return action;
	        }
	
	        function getGroupInsertingLocation_(left, top) {
	            var self = this;
	            var grid = self.grid;
	            var groupDes = grid.data.groupDescriptors;
	            var i;
	            var len = groupDes.length;
	            var to = 0;
	            var groupingElement;
	            var offset;
	            var groupingPanelInfo = self.hitTestInfo_.groupingPanelInfo;
	            var field = groupingPanelInfo ? groupingPanelInfo.field : '';
	            var previousLeft = 0;
	            var previousTop = 0;
	            var previousHeight = 0;
	            var clientHeight;
	            if (!field) {
	                to = len;
	                for (i = 0; i < len; i++) {
	                    groupingElement = document.getElementById(grid.uid + '-grouping-indicator-' + groupDes[i].field);
	                    clientHeight = groupingElement.clientHeight;
	                    offset = domUtil.offset(groupingElement);
	                    if (left < offset.left && top >= offset.top && top <= (offset.top + clientHeight)) {
	                        to = i;
	                        break;
	                    }
	                    if (offset.left < previousLeft && top >= previousTop && top <= (previousTop + previousHeight)) { //line break
	                        to = i;
	                        break;
	                    }
	                    previousLeft = offset.left;
	                    previousTop = offset.top;
	                    previousHeight = clientHeight;
	                }
	            } else {
	                groupingElement = document.getElementById(grid.uid + '-grouping-indicator-' + field);
	                offset = domUtil.offset(groupingElement);
	                if (offset.left <= left && left <= (offset.left + groupingElement.clientWidth) && top >= offset.top && top <= (offset.top + groupingElement.clientHeight)) {
	                    for (i = 0; i < len; i++) {
	                        if (groupDes[i].field === field) {
	                            to = i;
	                            break;
	                        }
	                    }
	                }
	            }
	
	            return to;
	        }
	
	        function handleMouseDown(sender, e) {
	            handlePointerDown(sender, e);
	        }
	
	        function handleTouchStart(sender, e) {
	            var agrs = {pageX: e.targetTouches[0].pageX, pageY: e.targetTouches[0].pageY};
	            if (handlePointerDown(sender, agrs, true)) {
	                e.handled = true;
	            }
	        }
	
	        function handlePointerDown(sender, e, touchEvent) {
	            var grid = sender;
	            var editingHandler = grid.editingHandler;
	            var layoutEngine = grid.layoutEngine;
	            layoutEngine.hitTestInfo_ = layoutEngine.hitTest(e);
	            var hitInfo = layoutEngine.hitTestInfo_;
	            if (!hitInfo) {
	                return;
	            }
	            if (editingHandler.isEditing_) {
	                return;
	            }
	            layoutEngine.mouseDownPoint_ = {
	                left: e.pageX,
	                top: e.pageY
	            };
	
	            var area = hitInfo.area;
	            var element;
	            if (area === COLUMN_HEADER || area === PINNED_COLUMN_HEADER || area === PINNED_RIGHT_COLUMN_HEADER || area === GROUP_DRAG_PANEL) {
	                layoutEngine.dragStartInfo_ = null;
	                if (inResizeGraphicArea.call(layoutEngine.grid, e) && touchEvent) {
	                    layoutEngine.mouseDownHitInfo_ = layoutEngine.touchDownHitInfo_;
	                } else if (hitInfo.headerInfo && hitInfo.headerInfo.inResizeMode && !touchEvent) {
	                    layoutEngine.mouseDownHitInfo_ = hitInfo;
	                } else if (canStartDraging_.call(layoutEngine, hitInfo)) {
	                    layoutEngine.dragStartInfo_ = {
	                        hitTestInfo: _.clone(hitInfo, true),
	                        pointOffset: {
	                            left: e.pageX,
	                            top: e.pageY
	                        }
	                    };
	                }
	            } else if (area === TOOLPANEL && layoutEngine.options.allowColumnReorder && hitInfo.columnListInfo && hitInfo.columnListInfo.column) {
	                element = grid.container.querySelector('.gc-tool-panel-container .column-list [data-col-id="' + hitInfo.columnListInfo.column + '"]');
	                element.className = element.className + ' selected';
	                layoutEngine.dragStartColumn_ = hitInfo.columnListInfo.column;
	            } else if (area === TOOLPANEL && hitInfo.groupListInfo && hitInfo.groupListInfo.group) {
	                element = grid.container.querySelector('.gc-tool-panel-container .group-list [data-group-id="' + hitInfo.groupListInfo.group + '"]');
	                element.className = element.className + ' selected';
	                layoutEngine.dragStartGroup_ = hitInfo.groupListInfo.group;
	            }
	        }
	
	        function inResizeGraphicArea(e) {
	            var grid = this;
	            var graphic = getResizeGraphic.call(grid);
	            if (graphic) {
	                var container = document.getElementById(grid.uid);
	                var containerInfo = domUtil.getContentRect(container);
	                var offsetLeft = e.pageX - containerInfo.left;
	                var offsetTop = e.pageY - containerInfo.top;
	
	                return pointIn_(offsetLeft, offsetTop, graphic, container);
	            }
	
	            return false;
	        }
	
	        function handleTouchMove_(sender, e) {
	            var agrs = {pageX: e.targetTouches[0].pageX, pageY: e.targetTouches[0].pageY};
	            if (handlePointerMove_.call(this, sender, agrs, false)) {
	                e.handled = true;
	            }
	        }
	
	        function handleMouseMove_(sender, e) {
	            handlePointerMove_.call(this, sender, e, true);
	        }
	
	        function getResizingChildCount_(grid, caption, pinned, includeMin) {
	            var childrenKeys = [];
	            var colTree = grid.colTree_;
	            _.each(colTree, function(item, key) {
	                if (item.parent === caption) {
	                    childrenKeys.push(key);
	                }
	            });
	
	            var visibleCount = 0;
	            var col;
	            _.each(childrenKeys, function(key) {
	                //group header
	                col = grid.getColById_(key);
	                if (!col) {
	                    visibleCount += getResizingChildCount_(grid, key, pinned, includeMin);
	                } else if (grid.isColVisible_(col, pinned) && ((includeMin && col.visibleWidth >= MIN_COL_WIDTH) || (col.visibleWidth > MIN_COL_WIDTH))) {
	                    visibleCount += 1;
	                }
	            });
	            return visibleCount;
	        }
	
	        function resizingColumnGroup_(grid, caption, offset, pinned) {
	            var childrenKeys = [];
	            var colTree = grid.colTree_;
	            _.each(colTree, function(item, key) {
	                if (item.parent === caption) {
	                    childrenKeys.push(key);
	                }
	            });
	
	            var visibleCount = 0;
	            var resizeCols_ = [];
	            var resizeColGroups_ = [];
	            var col;
	
	            _.each(childrenKeys, function(key) {
	                //group header
	                col = grid.getColById_(key);
	                if (!col && (offset > 0 || getResizingChildCount_(grid, key, pinned, false) > 0)) {
	                    visibleCount += 1;
	                    resizeColGroups_.push(key);
	                } else if (col && grid.isColVisible_(col, pinned) && ((offset < 0 && col.visibleWidth > MIN_COL_WIDTH) || offset > 0)) {
	                    visibleCount += 1;
	                    resizeCols_.push(key);
	                }
	            });
	
	            var childOffset = Math.floor(offset / visibleCount);
	            var lastCol;
	            var lastColGroup;
	            if (resizeCols_.length > 0) {
	                lastCol = resizeCols_[resizeCols_.length - 1];
	                resizeCols_ = resizeCols_.slice(0, resizeCols_.length - 1);
	            } else if (resizeColGroups_.length > 0) {
	                lastColGroup = resizeColGroups_[resizeColGroups_.length - 1];
	                resizeColGroups_ = resizeColGroups_.slice(0, resizeColGroups_.length - 1);
	            }
	            _.each(resizeCols_, function(key) {
	                col = grid.getColById_(key);
	                col.visibleWidth = Math.max(MIN_COL_WIDTH, col.visibleWidth + childOffset);
	            });
	            _.each(resizeColGroups_, function(key) {
	                resizingColumnGroup_(grid, key, childOffset, pinned);
	            });
	
	            var remainingOffset = offset - childOffset * (resizeCols_.length + resizeColGroups_.length);
	            if (lastCol) {
	                col = grid.getColById_(lastCol);
	                col.visibleWidth = Math.max(MIN_COL_WIDTH, col.visibleWidth + remainingOffset);
	            } else if (lastColGroup) {
	                resizingColumnGroup_(grid, lastColGroup, remainingOffset, pinned);
	            }
	        }
	
	        function canReorderColumn_(hitInfo) {
	            var self = this;
	            var grid = self.grid;
	            var cols = grid.columns;
	            if (!self.options.allowColumnReorder) {
	                return false;
	            }
	            var dragStartHitInfo = self.dragStartInfo_.hitTestInfo;
	            var dragColumnId;
	            var dropColumnId;
	            if (hitInfo && (hitInfo.area === COLUMN_HEADER || hitInfo.area === PINNED_COLUMN_HEADER || hitInfo.area === PINNED_RIGHT_COLUMN_HEADER)) {
	                if (hitInfo.column !== -1) {
	                    dropColumnId = cols[hitInfo.column].id;
	                } else if (hitInfo.columnGroupInfo) {
	                    dropColumnId = hitInfo.columnGroupInfo.caption;
	                }
	                if (dragStartHitInfo.column !== -1) {
	                    dragColumnId = cols[dragStartHitInfo.column].id;
	                } else if (dragStartHitInfo.columnGroupInfo) {
	                    dragColumnId = dragStartHitInfo.columnGroupInfo.caption;
	                }
	                var dragArea = dragStartHitInfo.area;
	                var dropArea = hitInfo.area;
	                return canReorderColumnInternal_(grid, dragColumnId, dropColumnId, dragArea, dropArea, dragStartHitInfo.column, hitInfo.column);
	
	            }
	            return false;
	        }
	
	        function canReorderColumnInternal_(grid, dragColumnId, dropColumnId, dragArea, dropArea, dragColumn, dropColumn) {
	            var container = grid.container;
	            if (dragColumnId !== dropColumnId || dragArea !== dropArea) {
	                var selectorPrefix = '#' + grid.uid;
	                var dragElement = container.querySelector(selectorPrefix + '-' + dragArea + ' .gc-column-header [' + (dragColumn !== -1 ? 'data-column' : 'data-column-group-header') +
	                    '="' + dragColumnId + '"]');
	                var dropElement = container.querySelector(selectorPrefix + '-' + dropArea + ' .gc-column-header [' + (dropColumn !== -1 ? 'data-column' : 'data-column-group-header') +
	                    '="' + dropColumnId + '"]');
	                var dragElementParent = dragElement;
	                if (dragElement === null || dropElement === null) {
	                    if (grid.colTree_) {
	                        if (grid.colTree_[dragColumnId].parent === grid.colTree_[dropColumnId].parent) {
	                            return true;
	                        }
	                        return false;
	                    }
	                    return true;
	                }
	                if (dragArea !== dropArea) {
	                    var totalColsCount = container.querySelectorAll(selectorPrefix + '-' + dragArea + ' [data-column]').length;
	                    var moveColsCount = 0;
	                    if (dragColumn >= 0) {
	                        moveColsCount = 1;
	                    } else {
	                        var tempNode = dragElement;
	                        var endNode = container.querySelector(selectorPrefix + '-' + dragArea);
	                        while (tempNode && tempNode !== endNode) {
	                            if (tempNode.hasAttribute('data-column-group')) {
	                                break;
	                            }
	                            tempNode = tempNode.parentNode;
	                        }
	                        moveColsCount = tempNode.querySelectorAll('[data-column]').length;
	                    }
	                    //need at least one column at the area
	                    if (totalColsCount === moveColsCount) {
	                        return false;
	                    }
	
	                }
	
	                //var offset1 = domUtil.getElementRect(dragElement);
	                //var offset2 = domUtil.getElementRect(dropElement);
	                //if (dragArea === dropArea && (offset1.left + offset1.width === offset2.left)) {
	                //    return false;
	                //}
	
	                var inItselfGroup = (dragColumn === -1);
	                while (dragElementParent && dragElementParent !== container) {
	                    if (dragElementParent.hasAttribute('data-column-group')) {
	                        if (inItselfGroup) {
	                            inItselfGroup = false;
	                        } else {
	                            break;
	                        }
	                    }
	                    dragElementParent = dragElementParent.parentNode;
	                }
	                var dropElementParent = dropElement;
	                inItselfGroup = (dropColumn === -1);
	                while (dropElementParent && dropElementParent !== container) {
	                    if (dropElementParent.hasAttribute('data-column-group')) {
	                        if (inItselfGroup) {
	                            inItselfGroup = false;
	                        } else {
	                            break;
	                        }
	                    }
	                    dropElementParent = dropElementParent.parentNode;
	                }
	
	                if (dragElementParent === dropElementParent) {
	                    return true;
	                }
	                if (dragElementParent.hasAttribute('data-column-group') && dropElementParent.hasAttribute('data-column-group')) {
	                    var dragGroupHeader;
	                    dragElementParent = dragElementParent.querySelector('[data-column-group-header]');
	                    if (dragElementParent) {
	                        dragGroupHeader = dragElementParent.getAttribute('data-column-group-header');
	                    }
	                    var dropGroupHeader;
	                    dropElementParent = dropElementParent.querySelector('[data-column-group-header]');
	                    if (dropElementParent) {
	                        dropGroupHeader = dropElementParent.getAttribute('data-column-group-header');
	                    }
	                    if (dragGroupHeader && dragGroupHeader === dropGroupHeader) {
	                        return true;
	                    }
	                }
	
	            }
	            return false;
	        }
	
	        function handlePointerMove_(sender, e, mouseEvent) {
	            var grid = this;
	            var layoutEngine = grid.layoutEngine;
	            var offset;
	            var indicatorElement;
	            //call from document mousemove
	            if (!e && Object.prototype.toString.call(sender) === '[object MouseEvent]') {
	                e = sender;
	            }
	            var downPoint;
	            var mouseDownHitInfo = layoutEngine.mouseDownHitInfo_;
	            var groupDes = grid.data.groupDescriptors;
	            var col;
	            var hitInfo = layoutEngine.hitTestInfo_ = layoutEngine.hitTest(e);
	            var len;
	            var minWidth = 0;
	            var i;
	            console.log('handle pointer move');
	            if (layoutEngine.isResizingCol_) {
	                var selector = getResizeElementSelector.call(grid);
	                var mouseHitArea = mouseDownHitInfo.area;
	                var leftMostOffset;
	                var pageX;
	                var column = mouseDownHitInfo.column;
	                var pinned = 'none';
	                if (mouseHitArea === PINNED_COLUMN_HEADER) {
	                    pinned = 'left';
	                } else if (mouseHitArea === PINNED_COLUMN_HEADER) {
	                    pinned = 'right';
	                }
	                if (!grid.options.rowTemplate) {
	                    if (column >= 0) {
	                        leftMostOffset = Math.ceil(domUtil.offset(document.querySelector(selector)).left + MIN_COL_WIDTH);
	                    } else if (mouseDownHitInfo.columnGroupInfo) {
	                        var count = getResizingChildCount_(grid, mouseDownHitInfo.columnGroupInfo.caption, pinned, true);
	                        leftMostOffset = Math.ceil(domUtil.offset(document.querySelector(selector)).left + (count * MIN_COL_WIDTH));
	                    }
	                } else {
	                    if (!layoutEngine.colsResizeInfo_) {
	                        initColsResizeInfo_.call(layoutEngine);
	                    }
	
	                    var resizeInfo = layoutEngine.colsResizeInfo_[column];
	                    var colLayouts = layoutEngine.colLayouts_;
	                    var colLayout = colLayouts[column];
	                    var affectedCols = resizeInfo.affectedCols;
	                    var c;
	                    for (i = 0, len = affectedCols.length; i < len; i++) {
	                        c = affectedCols[i];
	                        if (c !== column && colLayout.offset.left < colLayouts[c].offset.left) {
	                            minWidth = Math.max(minWidth, colLayouts[c].offset.left - colLayout.offset.left);
	                        }
	                    }
	                    minWidth = Math.max(minWidth, MIN_COL_WIDTH);
	                    leftMostOffset = Math.floor(domUtil.offset(document.querySelector(selector)).left) + minWidth;
	                }
	                pageX = Math.max(e.pageX, leftMostOffset);
	                offset = pageX - layoutEngine.resizingLastPoint_.left;
	
	                if (offset !== 0) {
	                    if (!grid.options.rowTemplate) {
	                        if (mouseDownHitInfo.column >= 0) {
	                            col = grid.columns[mouseDownHitInfo.column];
	                            col.visibleWidth = col.visibleWidth + offset;
	                            col.width = col.visibleWidth;
	                            grid.container.querySelector('.gc-grid').style.cursor = 'col-resize';
	                        } else if (mouseDownHitInfo.columnGroupInfo) {
	                            resizingColumnGroup_(grid, mouseDownHitInfo.columnGroupInfo.caption, offset, pinned);
	                        }
	                    } else {
	                        //TODO: support reisze column group
	                        if (mouseDownHitInfo.column >= 0) {
	                            var colWidth = grid.columns[mouseDownHitInfo.column].visibleWidth + offset;
	                            //fix a wired bug.
	                            //domUtil.offset(document.querySelector(selector)).left may return float value
	                            //grid.columns[mouseDownHitInfo.column].visibleWidth + offset will not equal to the minWidth
	                            if (pageX === leftMostOffset) {
	                                colWidth = minWidth;
	                            }
	                            setTemplateColumnWidth_.call(layoutEngine, column, colWidth);
	                        }
	                    }
	                    //grid.invalidate(false);
	                    clearTemplateCache_.call(layoutEngine);
	                    if (mouseHitArea !== PINNED_RIGHT_COLUMN_HEADER) {
	                        grid.invalidate(false);
	                    } else {
	                        grid.refresh(PINNED_RIGHT_COLUMN_HEADER);
	                        grid.refresh(PINNED_RIGHT_VIEWPORT);
	                    }
	
	                    updateResizeGraphics.call(grid, offset);
	                }
	                layoutEngine.resizingLastPoint_ = {
	                    left: pageX
	                };
	            } else if (layoutEngine.isDragDroping_) {
	                var dragStartInfo = layoutEngine.dragStartInfo_;
	                var pointOffset = dragStartInfo.pointOffset;
	                var element = layoutEngine.dragDropingElement_;
	                element.style.top = e.pageY + pointOffset.top + 'px';
	                element.style.left = e.pageX + pointOffset.left + 'px';
	                if (hitInfo && hitInfo.area === GROUP_DRAG_PANEL) {
	                    var dragColumn = dragStartInfo.hitTestInfo.column;
	                    if (dragStartInfo.hitTestInfo.area === GROUP_DRAG_PANEL || (dragColumn >= 0 && getGroupDescriptorIndex_(groupDes, grid.columns[dragColumn].id))) {
	                        layoutEngine.dragDropingElement_.querySelector('.gc-icon').className = 'gc-icon gc-icon-grouping-add';
	                        var to = getGroupInsertingLocation_.call(layoutEngine, e.pageX, e.pageY);
	                        var field;
	                        len = groupDes.length;
	                        if (len > 0) {
	                            field = (to === len ? groupDes[len - 1].field : groupDes[to].field);
	                            var groupingElement = document.getElementById(grid.uid + '-grouping-indicator-' + field);
	                            indicatorElement = layoutEngine.dragDropingIndicatorElement_;
	                            offset = domUtil.offset(groupingElement);
	                            indicatorElement.style.left = (to < len ? (offset.left - 15) : (offset.left + groupingElement.clientWidth)) + 'px';
	                            indicatorElement.style.top = (offset.top) + 'px';
	                            indicatorElement.style.height = groupingElement.clientHeight + 'px';
	                        } else {
	                            var panelElement = document.getElementById(grid.uid + '-groupingPanel');
	                            indicatorElement = layoutEngine.dragDropingIndicatorElement_;
	                            offset = domUtil.offset(panelElement);
	                            indicatorElement.style.left = offset.left + 'px';
	                            indicatorElement.style.top = (offset.top + 8) + 'px';
	                            indicatorElement.style.height = '20px';
	                        }
	                        layoutEngine.dragDropingIndicatorElement_.style.display = 'block';
	                    }
	                } else if (canReorderColumn_.call(layoutEngine, hitInfo)) {
	                    layoutEngine.dragDropingElement_.querySelector('.gc-icon').className = 'gc-icon gc-icon-grouping-add';
	                    var dropElement = grid.container.querySelector('#' + grid.uid + '-' + hitInfo.area + ' .gc-column-header [' + (hitInfo.column !== -1 ? 'data-column' : 'data-column-group-header') + '="' +
	                        (hitInfo.column !== -1 ? grid.columns[hitInfo.column].id : hitInfo.columnGroupInfo.caption) + '"]');
	                    offset = domUtil.offset(dropElement);
	                    indicatorElement = layoutEngine.dragDropingIndicatorElement_;
	                    indicatorElement.style.left = (offset.left - 8) + 'px';
	                    indicatorElement.style.top = (offset.top) + 'px';
	                    indicatorElement.style.height = dropElement.clientHeight + 'px';
	                    indicatorElement.style.display = 'block';
	                } else {
	                    layoutEngine.dragDropingElement_.querySelector('.gc-icon').className = 'gc-icon gc-icon-grouping-forbidden';
	                    layoutEngine.dragDropingIndicatorElement_.style.display = 'none';
	                }
	            } else if (layoutEngine.dragStartColumn_ || layoutEngine.dragStartGroup_) {
	                if (mouseEvent) {
	                    layoutEngine.handleMouseUpFn_ = handleMouseUp_.bind(grid);
	                    document.addEventListener('mouseup', layoutEngine.handleMouseUpFn_);
	                }
	                var sel = layoutEngine.dragStartColumn_ ? '.column-list-item' : '.group-list-item';
	                var oldDropElement = grid.container.querySelector('.gc-tool-panel-container ' + sel + '.drop-above');
	                if (oldDropElement) {
	                    oldDropElement.className = oldDropElement.className.replace('drop-above', '');
	                }
	                oldDropElement = grid.container.querySelector('.gc-tool-panel-container ' + sel + '.drop-below');
	                if (oldDropElement) {
	                    oldDropElement.className = oldDropElement.className.replace('drop-below', '');
	                }
	                var groupListElement = grid.container.querySelector('.gc-tool-panel-container .group-list');
	                groupListElement.className = groupListElement.className.replace('drag-over', '');
	                if (hitInfo && hitInfo.area === TOOLPANEL) {
	                    if (layoutEngine.dragStartColumn_ && hitInfo.columnListInfo && hitInfo.columnListInfo.column) {
	                        var dragColumnIndex = getColIndex_.call(layoutEngine, layoutEngine.dragStartColumn_);
	                        var dropColumn = hitInfo.columnListInfo.column;
	                        var dropColumnIndex = getColIndex_.call(layoutEngine, dropColumn);
	                        if (canReorderColumnInternal_(grid, layoutEngine.dragStartColumn_, dropColumn, getColumnArea_.call(layoutEngine, layoutEngine.dragStartColumn_), getColumnArea_.call(layoutEngine, dropColumn), dragColumnIndex, dropColumnIndex)) {
	                            var colElement = grid.container.querySelector('.gc-tool-panel-container .column-list [data-col-id="' + dropColumn + '"]');
	                            colElement.className += ((dragColumnIndex < dropColumnIndex) ? ' drop-below' : ' drop-above');
	                        }
	                    } else if (hitInfo.groupListInfo) {
	                        if (layoutEngine.dragStartColumn_) {
	                            groupListElement.className += ' drag-over';
	                        } else if (layoutEngine.dragStartGroup_ && hitInfo.groupListInfo.group) {
	                            var dragGroupIndex = getGroupDescriptorIndex_(grid.data.groupDescriptors, layoutEngine.dragStartGroup_);
	                            var dropGroup = hitInfo.groupListInfo.group;
	                            var dropGroupIndex = getGroupDescriptorIndex_(grid.data.groupDescriptors, dropGroup);
	                            if (dragGroupIndex !== -1 && dragGroupIndex !== dropGroupIndex) {
	                                var groupElement = grid.container.querySelector('.gc-tool-panel-container .group-list [data-group-id="' + dropGroup + '"]');
	                                groupElement.className += ((dragGroupIndex < dropGroupIndex) ? ' drop-below' : ' drop-above');
	                            }
	                        }
	                    }
	                }
	            } else {
	                downPoint = layoutEngine.mouseDownPoint_;
	                mouseDownHitInfo = layoutEngine.mouseDownHitInfo_;
	                var cursor = 'default';
	                if (hitInfo && (hitInfo.area === COLUMN_HEADER || hitInfo.area === PINNED_COLUMN_HEADER || hitInfo.area === PINNED_RIGHT_COLUMN_HEADER) && mouseDownHitInfo) {
	                    if (layoutEngine.options.allowColumnResize) {
	                        layoutEngine.isResizingCol_ = true;
	                        layoutEngine.resizingLastPoint_ = downPoint;
	                        if (mouseEvent) {
	                            layoutEngine.handleMouseUpFn_ = handleMouseUp_.bind(grid);
	                            document.addEventListener('mouseup', layoutEngine.handleMouseUpFn_);
	                            removeResizeGraphics.call(grid);
	                        }
	                    }
	                } else if (layoutEngine.dragStartInfo_ && !layoutEngine.isDragDroping_ &&
	                    ((downPoint && e.pageX !== downPoint.left) ||
	                    (downPoint && e.pageY !== downPoint.top))) {
	                    var sucess = startDragDroping_.call(layoutEngine);
	                    if (sucess) {
	                        layoutEngine.isDragDroping_ = true;
	                        if (mouseEvent) {
	                            layoutEngine.handleMouseUpFn_ = handleMouseUp_.bind(grid);
	                            //fix a wired bug, if we bind mouse move earlier at the register method, it
	                            //will fail to remove the event listerner later.
	                            layoutEngine.handleMouseMoveFn2_ = handleMouseMove_.bind(grid);
	                            document.addEventListener('mousemove', layoutEngine.handleMouseMoveFn2_);
	                            document.addEventListener('mouseup', layoutEngine.handleMouseUpFn_);
	                        }
	
	                        document.body.className = document.body.className + ' no-select';
	                    }
	                } else {
	                    cursor = 'default';
	                    layoutEngine.cursor_ = layoutEngine.cursor_ || 'default';
	                    if (hitInfo && hitInfo.headerInfo && hitInfo.headerInfo.inResizeMode && layoutEngine.options.allowColumnResize) {
	                        cursor = 'col-resize';
	                    }
	                    if (layoutEngine.cursor_ !== cursor) {
	                        layoutEngine.cursor_ = cursor;
	                        grid.container.querySelector('.gc-grid').style.cursor = cursor;
	                    }
	                }
	            }
	            return !!layoutEngine.dragStartInfo_ || layoutEngine.isResizingCol_ || layoutEngine.dragStartColumn_ || layoutEngine.dragStartGroup_;
	        }
	
	        function getColumnArea_(colId) {
	            var self = this;
	            var container = self.grid.container;
	            var headerElements = container.querySelectorAll('.gc-columnHeader');
	            var i;
	            var len;
	            var header;
	            var className;
	            for (i = 0, len = headerElements.length; i < len; i++) {
	                header = headerElements[i];
	                if (header.querySelector('[data-column="' + colId + '"]')) {
	                    className = header.className;
	                    if (className.indexOf('gc-pinned-left') >= 0) {
	                        return PINNED_COLUMN_HEADER;
	                    } else if (className.indexOf('gc-pinned-right') > 0) {
	                        return PINNED_RIGHT_COLUMN_HEADER;
	                    }
	                    return COLUMN_HEADER;
	                }
	            }
	            return null;
	        }
	
	        function getResizeElementSelector(hitInfo) {
	            var grid = this;
	            var mouseDownHitInfo = hitInfo ? hitInfo : grid.layoutEngine.mouseDownHitInfo_;
	            if (!mouseDownHitInfo) {
	                return;
	            }
	
	            var mouseHitArea = mouseDownHitInfo.area;
	            var selector = '#' + grid.uid + '-' + mouseHitArea;
	            if (mouseDownHitInfo.column >= 0) {
	                selector += ' [data-column="' + grid.columns[mouseDownHitInfo.column].id + '"]';
	            } else {
	                selector += ' [data-column-group-header="' + mouseDownHitInfo.columnGroupInfo.caption + '"]';
	            }
	
	            return selector;
	        }
	
	        function getResizeGraphic() {
	            var grid = this;
	            var id = grid.uid + '-resizeGraphic';
	            return document.getElementById(id);
	        }
	
	        function insertResizeGraphic(hitInfo) {
	            var self = this;
	            var selector = getResizeElementSelector.call(self, hitInfo);
	            var container = document.getElementById(self.uid);
	            var height = 24;
	            var width = 24;
	            self.layoutEngine.touchDownHitInfo_ = hitInfo;
	
	            if (selector) {
	                var element = document.querySelector(selector);
	                var eleRect = domUtil.getContentRect(element);
	                var containerRect = domUtil.getContentRect(container);
	                var left = eleRect.left - containerRect.left;
	                var top = eleRect.top - containerRect.top;
	                var id = self.uid + '-resizeGraphic';
	                var className = 'gc-resizeGraphic';
	                left = left + eleRect.width - width / 2;
	                var html = '<div id =' + id + ' class =' + className + ' style="position:absolute;height:' + height + 'px;width:' + width + 'px;left:' + left + 'px;top:' + top + 'px;"></div>';
	                container.appendChild(domUtil.createElement(html));
	            }
	        }
	
	        function updateResizeGraphics(offsetX) {
	            var grid = this;
	            var resizeGraphic = getResizeGraphic.call(grid);
	            if (resizeGraphic) {
	                var left = parseFloat(resizeGraphic.style.left);
	                resizeGraphic.style.left = (left + offsetX) + 'px';
	            }
	        }
	
	        function removeResizeGraphics() {
	            var self = this;
	            var resizeGraphic = getResizeGraphic.call(self);
	            if (resizeGraphic) {
	                var container = document.getElementById(self.uid);
	                container.removeChild(resizeGraphic);
	            }
	            self.touchDownHitInfo_ = null;
	        }
	
	        function setTemplateColumnWidth_(column, width) {
	            var self = this;
	            var cols = self.grid.columns;
	            var col = cols[column];
	            var colsResizeInfo = self.colsResizeInfo_;
	            var resizeInfo = colsResizeInfo[column];
	            var affectedCols = resizeInfo.affectedCols;
	            var shiftCols = resizeInfo.shiftCols;
	            var i;
	            var len;
	            var c;
	            var j;
	            var len2;
	            var widthOffset = width - col.visibleWidth;
	            var div = document.createElement('div');
	            div.innerHTML = getUserDefinedTemplate_.call(self, false);
	            var element = div.children[0];
	            var colElement;
	            var left;
	            for (i = 0, len = affectedCols.length; i < len; i++) {
	                c = affectedCols[i];
	                col = cols[c];
	                colElement = element.querySelector('[data-column="' + col.id + '"]');
	                if (colElement) {
	                    col.visibleWidth += widthOffset;
	                    col.width = col.visibleWidth;
	                    colElement.style.width = col.visibleWidth + 'px';
	                }
	            }
	
	            var parent = colElement.parentElement;
	            while (parent) {
	                if (parent.hasAttribute('data-column-group')) {
	                    width = parent.style.width;
	                    if (width) {
	                        parent.style.width = (parseInt(width) + widthOffset) + 'px';
	                    }
	                }
	                parent = parent.parentElement;
	            }
	
	            var parentShifted = [];
	            var affcols;
	            for (i = 0, len = shiftCols.length; i < len; i++) {
	                c = shiftCols[i];
	                col = cols[c];
	                colElement = element.querySelector('[data-column="' + col.id + '"]');
	                if (colElement) {
	                    left = colElement.style.left;
	                    if (left) {
	                        colElement.style.left = (parseInt(left) + widthOffset) + 'px';
	                    } else if (!parentShifted[c]) {
	                        //it don't have parent
	                        parent = colElement.parentElement;
	                        while (parent) {
	                            if (parent.hasAttribute('data-column-group')) {
	                                left = parent.style.left;
	                                if (left) {
	                                    parent.style.left = (parseInt(left) + widthOffset) + 'px';
	                                }
	                                parentShifted[c] = true;
	                                affcols = colsResizeInfo[c].affectedCols;
	                                for (j = 0, len2 = affcols.length; j < len2; j++) {
	                                    parentShifted[affcols[j]] = true;
	                                }
	                            }
	                            parent = parent.parentElement;
	                        }
	                    }
	                }
	            }
	            self.suspendTmplUpdate_ = true;
	            self.options.rowTemplate = element.outerHTML;
	            self.suspendTmplUpdate_ = false;
	        }
	
	        function initColsResizeInfo_() {
	            var self = this;
	            var cols = self.grid.columns;
	            var i;
	            var j;
	            var len = cols.length;
	            var col;
	
	            var divStr = '<div style="position:absolute;top:-10000px;-10000px;width:5000px;height:5000px;">';
	            var template = getUserDefinedTemplate_.call(self, false);
	            var element = domUtil.createTemplateElement(template);
	            divStr += element.innerHTML + '</div>';
	            var div = domUtil.createElement(divStr);
	            document.body.appendChild(div);
	
	            var colLayouts = [];
	            var colElement;
	            for (i = 0; i < len; i++) {
	                col = cols[i];
	                colElement = div.querySelector('[data-column="' + col.id + '"]');
	                if (colElement) {
	                    colLayouts[i] = {
	                        offset: domUtil.offset(colElement),
	                        rect: domUtil.getElementRect(colElement)
	                    };
	                }
	            }
	
	            self.colLayouts_ = colLayouts;
	            self.colsResizeInfo_ = [];
	
	            var colLayout;
	            var resizeColEndX;
	            var affectedCols;
	            var shiftCols;
	            var anotherColLayout;
	
	            for (i = 0; i < len; i++) {
	                col = cols[i];
	                colLayout = colLayouts[i];
	                if (colLayout) {
	                    resizeColEndX = colLayout.rect.width + colLayout.offset.left;
	                    affectedCols = [i];
	                    shiftCols = [];
	                    for (j = 0; j < len; j++) {
	                        if (j !== i) {
	                            anotherColLayout = colLayouts[j];
	                            if (col.visibleWidth > 0 && anotherColLayout) {
	                                if (resizeColEndX > anotherColLayout.offset.left && resizeColEndX <= (anotherColLayout.offset.left + anotherColLayout.rect.width)) {
	                                    affectedCols.push(j);
	                                } else if (anotherColLayout.offset.left >= resizeColEndX) {
	                                    shiftCols.push(j);
	                                }
	                            }
	                        }
	                    }
	                    self.colsResizeInfo_[i] = {
	                        affectedCols: affectedCols,
	                        shiftCols: shiftCols
	                    };
	                }
	            }
	            document.body.removeChild(div);
	        }
	
	        function handleTouchEnd_(sender, e) {
	            var agrs = {pageX: e.changedTouches[0].pageX, pageY: e.changedTouches[0].pageY};
	            if (handlePointerUp_.call(this, agrs, false)) {
	                e.handled = true;
	            }
	        }
	
	        function handleMouseUp_(e) {
	            handlePointerUp_.call(this, e, true);
	        }
	
	        function handlePointerUp_(e, mouseEvent) {
	            console.log('mouse up');
	            var self = this.layoutEngine;
	            var grid = self.grid;
	            var groupDes = grid.data.groupDescriptors.slice();
	            var needInvalidate = true;
	            var success;
	            var dragHitInfo;
	            var i;
	            var len;
	            var hitTestInfo = self.hitTestInfo_;
	            if (self.isDragDroping_) {
	                dragHitInfo = self.dragStartInfo_.hitTestInfo;
	                var field;
	                if (hitTestInfo && hitTestInfo.area === GROUP_DRAG_PANEL) {
	                    var to = getGroupInsertingLocation_.call(self, e.pageX, e.pageY);
	                    var groupingPanelInfo = self.hitTestInfo_.groupingPanelInfo;
	                    if ((dragHitInfo.area === COLUMN_HEADER || dragHitInfo.area === PINNED_COLUMN_HEADER || dragHitInfo.area === PINNED_RIGHT_COLUMN_HEADER) && dragHitInfo.column >= 0) {
	                        var newGorupColId = grid.columns[dragHitInfo.column].id;
	                        if (getGroupDescriptorIndex_(groupDes, newGorupColId) === -1) {
	                            groupDes.splice(to, 0, _.defaults({field: newGorupColId}, self.getGroupInfoDefaults_()));
	                            grid.data.groupDescriptors = groupDes;
	                        }
	                    } else if (dragHitInfo.area === GROUP_DRAG_PANEL && dragHitInfo.groupingPanelInfo) {
	                        var fromGroupField = dragHitInfo.groupingPanelInfo.field;
	                        field = groupingPanelInfo ? groupingPanelInfo.field : '';
	
	                        if (field === fromGroupField || (!field && groupDes[groupDes.length - 1].field === fromGroupField)) {
	                            needInvalidate = false;
	                        } else {
	
	                            len = groupDes.length;
	                            var from;
	
	                            for (i = 0; i < len; i++) {
	                                if (groupDes[i].field === fromGroupField) {
	                                    from = i;
	                                    break;
	                                }
	                            }
	                            if (from < to) { //fix bug, if reorder from left to right, we should insert before to item
	                                to = to - 1;
	                            }
	                            if (to === from) {
	                                needInvalidate = false;
	                            } else {
	                                groupDes.splice(to, 0, groupDes.splice(from, 1)[0]);
	                                grid.data.groupDescriptors = groupDes;
	                            }
	                        }
	                    }
	                } else if (canReorderColumn_.call(self, hitTestInfo)) {
	                    dragHitInfo = self.dragStartInfo_.hitTestInfo;
	                    var pinned = 'none';
	                    if (hitTestInfo.area === PINNED_COLUMN_HEADER) {
	                        pinned = 'left';
	                    } else if (hitTestInfo.area === PINNED_RIGHT_COLUMN_HEADER) {
	                        pinned = 'right';
	                    }
	                    var template = getUserDefinedTemplate_.call(self, pinned);
	                    if (template) {
	                        reorderColumnsWidthTemplate_.call(self, template, dragHitInfo.columnGroupInfo && dragHitInfo.columnGroupInfo.caption, dragHitInfo.column, hitTestInfo.area, hitTestInfo.columnGroupInfo && hitTestInfo.columnGroupInfo.caption, hitTestInfo.column, true);
	                    } else {
	                        //update
	                        reorderColumns_.call(self, dragHitInfo.area, dragHitInfo.columnGroupInfo && dragHitInfo.columnGroupInfo.caption, dragHitInfo.column, hitTestInfo.area, hitTestInfo.columnGroupInfo && hitTestInfo.columnGroupInfo.caption, hitTestInfo.column, pinned, true);
	                    }
	                } else {  //remove grouping
	                    if (dragHitInfo.area === GROUP_DRAG_PANEL && dragHitInfo.groupingPanelInfo) {
	                        field = dragHitInfo.groupingPanelInfo.field;
	                    }
	                    if (field) {
	                        //self.grid.removeGroup(field);
	                        self.grid.data.groupDescriptors = _.remove(self.grid.data.groupDescriptors, function(info) {
	                            return info.field !== field;
	                        });
	                    }
	                }
	                document.body.removeChild(self.dragDropingElement_);
	                document.body.removeChild(self.dragDropingIndicatorElement_);
	                self.dragDropingElement_ = null;
	                self.dragDropingIndicatorElement_ = null;
	                if (mouseEvent) {
	                    document.removeEventListener('mousemove', self.handleMouseMoveFn2_);
	                    document.removeEventListener('mouseup', self.handleMouseUpFn_);
	                    self.handleMouseMoveFn2_ = null;
	                    self.handleMouseUpFn_ = null;
	                }
	
	                document.body.className = document.body.className.replace('no-select', '');
	                if (needInvalidate) {
	                    grid.invalidate();
	                }
	
	                success = true;
	            } else if (self.isResizingCol_) {
	                self.resizingLastPoint_ = null;
	                grid.invalidate();
	            } else if (self.dragStartColumn_ || self.dragStartGroup_) {
	                if (hitTestInfo.area === TOOLPANEL) {
	                    processDragColumnInToolPanel.call(self, hitTestInfo);
	                    success = true;
	                }
	            }
	            if (mouseEvent) {
	                document.removeEventListener('mouseup', self.handleMouseUpFn_);
	            }
	            self.dragStartColumn_ = null;
	            self.dragStartGroup_ = null;
	            self.colsResizeInfo_ = null;
	            self.colLayouts_ = null;
	            self.isResizingCol_ = false;
	            self.mouseDownHitInfo_ = null;
	            self.mouseDownPoint_ = null;
	            self.isDragDroping_ = false;
	            self.dragStartInfo_ = null;
	            self.hitTestInfo_ = null;
	            return success;
	        }
	
	        function reorderColumnsWidthTemplate_(template, dragGroupCaption, dragColumn, dropArea, dropGroupCaption, dropColumn, insertBefore) {
	            var self = this;
	            var cols = self.grid.columns;
	            var div = document.createElement('div');
	            div.innerHTML = template;
	            var element = div.children[0];
	            var selector;
	            var originalCol;
	            var destCol;
	            if (dragColumn >= 0) {
	                selector = '[data-column="' + cols[dragColumn].id + '"]';
	                originalCol = element.querySelector(selector);
	            } else if (dragGroupCaption) {
	                selector = '[data-column-group-header="' + dragGroupCaption + '"]';
	                originalCol = element.querySelector(selector);
	                while (originalCol) {
	                    if (originalCol.hasAttribute('data-column-group')) {
	                        break;
	                    }
	                    originalCol = originalCol.parentNode;
	                }
	            }
	            if (dropColumn >= 0) {
	                selector = '[data-column="' + cols[dropColumn].id + '"]';
	                destCol = element.querySelector(selector);
	            } else if (dropGroupCaption) {
	                selector = '[data-column-group-header="' + dropGroupCaption + '"]';
	                destCol = element.querySelector(selector);
	                while (destCol) {
	                    if (destCol.hasAttribute('data-column-group')) {
	                        break;
	                    }
	                    destCol = destCol.parentNode;
	                }
	            }
	            //var cloneOriginalCol = originalCol.cloneNode(true);
	            //var cloneDestCol = destCol.cloneNode(true);
	            originalCol.parentNode.removeChild(originalCol);
	            if (insertBefore) {
	                destCol.parentNode.insertBefore(originalCol, destCol);
	            } else {
	                destCol.parentNode.insertBefore(originalCol, destCol.nextSibling);
	            }
	            self.suspendTmplUpdate_ = true;
	            if (dropArea === PINNED_COLUMN_HEADER) {
	                if (self.options.pinnedRowTemplate) {
	                    self.options.pinnedRowTemplate = element.outerHTML;
	                } else {
	                    self.options.rowTemplate = element.outerHTML;
	                }
	            } else {
	                self.options.rowTemplate = element.outerHTML;
	            }
	            self.suspendTmplUpdate_ = false;
	
	            if (dragColumn >= 0 && dropColumn >= 0) {
	                var temp = cols[dragColumn];
	                var dropColumnId = cols[dropColumn].id;
	                cols.splice(dragColumn, 1);
	                dropColumn = _.findIndex(cols, function(item) {
	                    return item.id === dropColumnId;
	                });
	                cols.splice(insertBefore ? dropColumn : dropColumn + 1, 0, temp);
	
	            }
	        }
	
	        function reorderColumns_(drapArea, dragGroupCaption, dragColumn, dropArea, dropGroupCaption, dropColumn, pinned, insertBefore) {
	            var self = this;
	            var grid = self.grid;
	            var cols = grid.columns;
	            var parents = [];
	            var colTree = grid.colTree_;
	            var temp;
	            temp = dragColumn >= 0 ? cols[dragColumn].id : dragGroupCaption;
	            if (grid.colTree_) {
	                var parent = colTree[temp].parent;
	                while (parent) {
	                    parents.push(parent);
	                    parent = colTree[parent].parent;
	                }
	            }
	            var i;
	
	            var root = grid.columnsConfig_;
	            var j;
	            var len2;
	            if (parents.length > 0) {
	                for (i = parents.length - 1; i >= 0; i--) {
	                    root = root.columns || root;
	                    for (j = 0, len2 = root.length; j < len2; j++) {
	                        if (root[j].caption === parents[i]) {
	                            root = root[j];
	                            break;
	                        }
	                    }
	                }
	            }
	
	            root = root.columns || root;
	            var index1 = _.findIndex(root, function(item) {
	                if (dragColumn >= 0) {
	                    return item.id === cols[dragColumn].id;
	                } else {
	                    return item.caption === dragGroupCaption;
	                }
	            });
	            temp = root[index1];
	            root.splice(index1, 1);
	            var index2 = _.findIndex(root, function(item) {
	                if (dropColumn >= 0) {
	                    return item.id === cols[dropColumn].id;
	                } else {
	                    return item.caption === dropGroupCaption;
	                }
	            });
	
	            if (index2 >= 0) {
	                root.splice(insertBefore ? index2 : index2 + 1, 0, temp);
	            } else {
	                root.push(temp);
	            }
	            if (drapArea !== dropArea) {
	                setColumnPinned_(temp, pinned);
	            }
	            grid.columns = grid.flatternColumns_(grid.columnsConfig_);
	        }
	
	        function setColumnPinned_(col, pinned) {
	            if (!col.columns) {
	                col.pinned = pinned;
	                return;
	            }
	            var i;
	            var len;
	            var cols = col.columns;
	            for (i = 0, len = cols.length; i < len; i++) {
	                setColumnPinned_(cols[i], pinned);
	            }
	        }
	
	        function inToolPanel_(e) {
	            var self = this;
	            var left = e.pageX;
	            var top = e.pageY;
	            var layoutInfo = self.getLayoutInfo();
	            var emptyLayout = {width: 0, height: 0, contentWidth: 0, contentHeight: 0};
	            var toolPanelLayout = layoutInfo[TOOLPANEL] || emptyLayout;
	            var containerInfo = self.grid.getContainerInfo_().contentRect;
	            var offsetLeft = left - containerInfo.left;
	            var offsetTop = top - containerInfo.top;
	            var point = {
	                left: offsetLeft,
	                top: offsetTop
	            };
	            return contains_(toolPanelLayout, point);
	        }
	
	        function handleMouseWheel(sender, e) {
	            var grid = sender;
	            var layoutEngine = grid.layoutEngine;
	            if (layoutEngine.options.showToolPanel && inToolPanel_.call(layoutEngine, e)) {
	                return;
	            }
	            if (!layoutEngine.showScrollPanel(VIEWPORT) && !layoutEngine.showScrollPanel(PINNED_RIGHT_VIEWPORT)) {
	                return;
	            }
	            e.preventDefault();
	            //simulate scroll
	            var offsetDeltaY = e.deltaY;
	            var offsetDeltaX = e.deltaX;
	            if (offsetDeltaY !== 0 || offsetDeltaX !== 0) {
	                /*jshint -W069 */
	                var layout = layoutEngine.getLayoutInfo()[VIEWPORT];
	                var maxOffsetTop = Math.max(layout.contentHeight + grid.options.colHeaderHeight - layout.height, 0);
	                var maxOffsetLeft = Math.max(layout.contentWidth - layout.width, 0);
	                var offsetTop = grid.scrollOffset.top;
	                var offsetLeft = grid.scrollOffset.left;
	                var scrollTop;
	                var scrollLeft;
	                if (Math.abs(offsetDeltaX) <= Math.abs(offsetDeltaY) && offsetDeltaY > 0) {
	                    if (offsetTop >= maxOffsetTop) {
	                        return;
	                    } else {
	                        scrollTop = Math.min(offsetTop + offsetDeltaY, maxOffsetTop);
	                    }
	                    domUtil.getElement('#' + grid.uid + ' .gc-grid-viewport-scroll-panel.scroll-top').scrollTop = scrollTop;
	                } else if (Math.abs(offsetDeltaX) <= Math.abs(offsetDeltaY) && offsetDeltaY < 0) {
	                    if (offsetTop === 0) {
	                        return;
	                    } else {
	                        scrollTop = Math.max(offsetTop + offsetDeltaY, 0);
	                    }
	                    domUtil.getElement('#' + grid.uid + ' .gc-grid-viewport-scroll-panel.scroll-top').scrollTop = scrollTop;
	                } else if (Math.abs(offsetDeltaX) > Math.abs(offsetDeltaY) && offsetDeltaX > 0) {
	                    if (offsetLeft >= maxOffsetLeft) {
	                        return;
	                    } else {
	                        scrollLeft = Math.min(offsetLeft + offsetDeltaX, maxOffsetLeft);
	                    }
	                    domUtil.getElement('#' + grid.uid + ' .gc-grid-viewport-scroll-panel.scroll-left').scrollLeft = scrollLeft;
	                } else if (Math.abs(offsetDeltaX) > Math.abs(offsetDeltaY) && offsetDeltaX < 0) {
	                    if (offsetLeft === 0) {
	                        return;
	                    } else {
	                        scrollLeft = Math.max(offsetLeft + offsetDeltaX, 0);
	                    }
	                    domUtil.getElement('#' + grid.uid + ' .gc-grid-viewport-scroll-panel.scroll-left').scrollLeft = scrollLeft;
	                }
	
	            }
	            console.log('mouse wheel');
	        }
	
	        function handleMouseClick_(sender, e, touchEvent) {
	            console.log('mouse click');
	            var self = sender.layoutEngine;
	            self.mouseDownPoint_ = null;
	            self.mouseDownHitInfo_ = null;
	            self.isDragDroping_ = false;
	            self.dragStartInfo_ = null;
	            self.hitTestInfo_ = self.hitTest(e);
	            var hitInfo = self.hitTestInfo_;
	            if (!hitInfo) {
	                return;
	            }
	            var hitArea = hitInfo.area;
	            var groupInfo;
	            var group;
	            var grid = self.grid;
	            var editingHandler = grid.editingHandler;
	
	            removeResizeGraphics.call(grid);
	            if (editingHandler.isEditing_ && !isEditingSameRow_(hitInfo, editingHandler.editingInfo_) && grid.hasEditAction_) {
	                return;
	            }
	            var actionHandler;
	            if (hitArea === VIEWPORT || hitArea === PINNED_VIEWPORT || hitArea === PINNED_RIGHT_VIEWPORT) {
	                actionHandler = hitInfo.action || null;
	            }
	            if (hitArea === GROUP_DRAG_PANEL) {
	                var groupingInfo = hitInfo.groupingPanelInfo;
	                if (groupingInfo) {
	                    if (groupingInfo.action === 'delete') {
	                        self.grid.data.groupDescriptors = _.remove(self.grid.data.groupDescriptors, function(info) {
	                            return info.field !== groupingInfo.field;
	                        });
	                    }
	                }
	            } else if (hitArea === COLUMN_HEADER || hitArea === PINNED_COLUMN_HEADER || hitArea === PINNED_RIGHT_COLUMN_HEADER) {
	                if (hitInfo.columnGroupInfo && hitInfo.columnGroupInfo.onExpandToggle) {
	                    var info = grid.colTree_[hitInfo.columnGroupInfo.caption];
	                    if (hitArea === COLUMN_HEADER) {
	                        info.status.isCollapsed = !info.status.isCollapsed;
	                    } else if (hitArea === PINNED_COLUMN_HEADER) {
	                        info.pinnedStatus.isCollapsed = !info.pinnedStatus.isCollapsed;
	                    } else {
	                        info.pinnedRightStatus.isCollapsed = !info.pinnedRightStatus.isCollapsed;
	                    }
	                    grid.invalidate();
	                } else {
	                    handleClickColHeader_.call(self, hitInfo);
	                }
	
	                if (((hitInfo.headerInfo && hitInfo.column > -1) || hitInfo.columnGroupInfo) && touchEvent) {
	                    insertResizeGraphic.call(grid, hitInfo);
	                }
	            } else if (hitArea === VIEWPORT || hitArea === PINNED_VIEWPORT || hitArea === PINNED_RIGHT_VIEWPORT) {
	                groupInfo = self.hitTestInfo_.groupInfo;
	                if (hitInfo.groupInfo && hitInfo.groupInfo.area === GROUP_HEADER) {
	                    if (groupInfo && groupInfo.onExpandToggle) {
	                        group = grid.getGroupInfo_(groupInfo.path).data;
	                        group.collapsed = !group.collapsed;
	                        grid.invalidate();
	                    }
	                } else if (hitInfo.groupInfo && hitInfo.groupInfo.area === GROUP_CONTENT) {
	                    actionHandler = hitInfo.groupInfo.action || null;
	                }
	
	                if (hitInfo.inTreeNode || (groupInfo && groupInfo.inTreeNode)) {
	                    updateTreeNode(self);
	                    grid.invalidate();
	                    return;
	                } else if (!editingHandler.isEditing_) {
	                    updateSelection(self);
	                }
	                //var dataItem = grid.getDataItem2_(hitInfo.groupInfo ? grid.getGroupInfo_(hitInfo.groupInfo.path).data : null, hitInfo.groupInfo ? hitInfo.groupInfo.row : hitInfo.row);
	                if (actionHandler) {
	                    actionHandler({
	                        gridModel: grid,
	                        hitInfo: hitInfo,
	                        dataItem: getDataItem.call(self.grid, hitInfo),
	                        closeActionColumnPanel: closeTouchPanel.bind(grid)
	                    });
	                }
	            } else if (hitArea === ROW_HEADER || hitArea === CORNER_HEADER) {
	                if (hitInfo.checked || (hitInfo.groupInfo && hitInfo.groupInfo.checked)) {
	                    updateSelection(self);
	                }
	            } else if (hitArea === TOOLPANEL) {
	                var colId = hitInfo.columnListInfo && hitInfo.columnListInfo.column;
	                var groupId = hitInfo.groupListInfo && hitInfo.groupListInfo.group;
	                if (colId && hitInfo.columnListInfo.action === 'visible') {
	                    var col = grid.getColById_(colId);
	                    col.visible = !col.visible;
	                    grid.invalidate();
	                } else if (hitInfo.columnListInfo && hitInfo.columnListInfo.action === 'showAddColumnWindow') {
	                    var editPopupOverlay = domUtil.createElement('<div class="gc-editing-overlay"></div>');
	                    var editContainer = domUtil.createElement('<div id="' + grid.uid + '-popup-addColumn" class="gc-popup-add-column gc-editing-area">' +
	                        '<div class="gc-popup-header"><span class="header-text">Add column</span><div class="gc-editing-close"><span class="gc-icon close-icon"></span></div></div>' +
	                        '<div class="gc-popup-content">' + '<textarea style="width:100%" rows="3" placeholder="input column or column array JSON object"></textarea><span class="error-text"><span>' + '</div>' +
	                        '<div class="gc-popup-footer"><div class="gc-editing-cancel gc-editing-button"><span class="cancel-text">Cancel</span></div><div class="gc-editing-update gc-editing-button"><span class="update-text">Add</span></div></div></div>');
	                    self.addColumnWindowMouseDownHandler_ = addColumnWindowMouseDownHandler.bind(self);
	                    document.addEventListener('click', self.addColumnWindowMouseDownHandler_);
	                    document.body.appendChild(editContainer);
	                    document.body.appendChild(editPopupOverlay);
	                    var containerRect = domUtil.getElementRect(editContainer);
	                    var left = parseInt((window.innerWidth - containerRect.width) / 2 + window.pageXOffset);
	                    var top = parseInt((window.innerHeight - containerRect.height) / 2 + window.pageYOffset);
	                    domUtil.setCss(editContainer, {
	                        left: left,
	                        top: top
	                    });
	                } else if (groupId && hitInfo.groupListInfo.action === 'removeGroup') {
	                    var tempGroupDes = grid.data.groupDescriptors.slice();
	                    tempGroupDes.splice(getGroupDescriptorIndex_(tempGroupDes, groupId), 1);
	                    grid.data.groupDescriptors = tempGroupDes;
	                }
	
	                var selectedElement = grid.container.querySelector('.gc-tool-panel-container .selected');
	                if (selectedElement) {
	                    selectedElement.className = selectedElement.className.replace('select', '');
	                }
	            }
	            //processDragColumnInToolPanel.call(self, hitInfo);
	        }
	
	        function processDragColumnInToolPanel(hitInfo) {
	            var self = this;
	            var grid = self.grid;
	            var tempGroupDes;
	            var dragColId = self.dragStartColumn_;
	            var dragGroupId = self.dragStartGroup_;
	            self.dragStartColumn_ = null;
	            self.dragStartGroup_ = null;
	            var colId = hitInfo.columnListInfo && hitInfo.columnListInfo.column;
	            var groupId = hitInfo.groupListInfo && hitInfo.groupListInfo.group;
	            if (colId) {
	                if (dragColId && dragColId !== colId) {
	                    var dropElement = grid.container.querySelector('.gc-tool-panel-container .column-list [data-col-id="' + colId + '"]');
	                    var className = dropElement.className;
	                    var dropColumn = grid.getColById_(colId);
	                    var pinned = dropColumn.pinned;
	                    var template = getUserDefinedTemplate_.call(self, pinned);
	                    if (template) {
	                        if (className.indexOf('drop-above') >= 0) {
	                            reorderColumnsWidthTemplate_.call(self, template, null, getColIndex_.call(self, dragColId), getColumnArea_.call(self, colId), null, getColIndex_.call(self, colId), true);
	                        } else if (className.indexOf('drop-below') >= 0) {
	                            reorderColumnsWidthTemplate_.call(self, template, null, getColIndex_.call(self, dragColId), getColumnArea_.call(self, colId), null, getColIndex_.call(self, colId), false);
	                        }
	                    } else {
	                        if (className.indexOf('drop-above') >= 0) {
	                            reorderColumns_.call(self, getColumnArea_.call(self, dragColId), null, getColIndex_.call(self, dragColId), getColumnArea_.call(self, colId), null, getColIndex_.call(self, colId), pinned, true);
	                        } else if (className.indexOf('drop-below') >= 0) {
	                            reorderColumns_.call(self, getColumnArea_.call(self, dragColId), null, getColIndex_.call(self, dragColId), getColumnArea_.call(self, colId), null, getColIndex_.call(self, colId), pinned, false);
	                        }
	                    }
	                    grid.invalidate();
	                }
	            } else if (dragColId && hitInfo.groupListInfo) {
	                if (getGroupDescriptorIndex_(grid.data.groupDescriptors, dragColId) === -1) {
	                    tempGroupDes = grid.data.groupDescriptors.slice();
	                    tempGroupDes.push(_.defaults({field: dragColId}, self.getGroupInfoDefaults_()));
	                    grid.data.groupDescriptors = tempGroupDes;
	                }
	            } else if (dragGroupId && hitInfo.groupListInfo) {
	                if (dragGroupId !== groupId && groupId !== null) {
	                    var dropGroupElement = grid.container.querySelector('.gc-tool-panel-container .group-list [data-group-id="' + groupId + '"]');
	                    var dropGroupElementClassName = dropGroupElement.className;
	                    tempGroupDes = grid.data.groupDescriptors.slice();
	                    var targetItem = tempGroupDes.splice(getGroupDescriptorIndex_(tempGroupDes, dragGroupId), 1)[0];
	                    var insertIndex = getGroupDescriptorIndex_(tempGroupDes, groupId);
	                    if (dropGroupElementClassName.indexOf('drop-above') >= 0) {
	                        tempGroupDes.splice(insertIndex, 0, targetItem);
	                    } else if (dropGroupElementClassName.indexOf('drop-below') >= 0) {
	                        tempGroupDes.splice(insertIndex + 1, 0, targetItem);
	                    }
	                    grid.data.groupDescriptors = tempGroupDes;
	                    grid.invalidate();
	                }
	            }
	            var selectedElement = grid.container.querySelector('.gc-tool-panel-container .selected');
	            if (selectedElement) {
	                selectedElement.className = selectedElement.className.replace('select', '');
	            }
	            var groupListElement = grid.container.querySelector('.gc-tool-panel-container .group-list');
	            groupListElement.className = groupListElement.className.replace('drag-over', '');
	        }
	
	        function removeAddColumnWindow_() {
	            var self = this;
	            var overlay = document.querySelector('.gc-editing-overlay');
	            document.body.removeChild(overlay);
	            var editorForm = document.getElementById(self.grid.uid + '-popup-addColumn');
	            document.body.removeChild(editorForm);
	            document.removeEventListener('click', self.addColumnWindowMouseDownHandler_);
	            self.addColumnWindowMouseDownHandler_ = null;
	        }
	
	        function addColumnWindowMouseDownHandler(e) {
	            var self = this;
	            var grid = self.grid;
	            var curTarget = e.target;
	            var className = curTarget.className;
	            var tagName = curTarget.tagName.toLowerCase();
	            var arr = className ? className.split(' ') : [];
	            while (tagName !== 'body') {
	                if (arr.indexOf('gc-editing-close') !== -1) {
	                    removeAddColumnWindow_.call(self);
	                    break;
	                } else if (arr.indexOf('gc-editing-update') !== -1) {
	                    try {
	                        var editTextarea = document.querySelector('#' + self.grid.uid + '-popup-addColumn textarea');
	                        var columns = JSON.parse(editTextarea.value);
	                        removeAddColumnWindow_.call(self);
	                        grid.insertColumns_(columns);
	                    } catch (err) {
	                        var errorSpan = document.querySelector('#' + self.grid.uid + '-popup-addColumn .error-text');
	                        errorSpan.textContent = 'input is not a valid JSON object';
	                    }
	                    break;
	                } else if (arr.indexOf('gc-editing-cancel') !== -1) {
	                    removeAddColumnWindow_.call(self);
	                    break;
	                } else if (arr.indexOf('gc-popup-header') !== -1) {
	                    var container = document.getElementById(grid.uid + '-popup-addColumn');
	                    if (container) {
	                        self.addColumnWindowMouseMoveHandler_ = addColumnWindowMouseMoveHandler_.bind(self);
	                        self.addColumnWindowMouseUpHandler_ = addColumnWindowMouseUpHandler_.bind(self);
	                        document.addEventListener('mousemove', self.addColumnWindowMouseMoveHandler_);
	                        document.addEventListener('mouseup', self.addColumnWindowMouseUpHandler_);
	                        var containerOffset = domUtil.offset(container);
	                        var containerStyle = domUtil.getStyle(container);
	                        var containerMarginTop = parseFloat(containerStyle.getPropertyValue('margin-top'));
	                        var containerMarginLeft = parseFloat(containerStyle.getPropertyValue('margin-left'));
	                        self.startMoveInfo_ = {
	                            mouseOffset: {
	                                left: e.pageX,
	                                top: e.pageY
	                            },
	                            containerOffset: {
	                                left: containerOffset.left - containerMarginLeft,
	                                top: containerOffset.top - containerMarginTop
	                            }
	                        };
	                    }
	                    break;
	                }
	                curTarget = curTarget.parentNode;
	                tagName = curTarget.tagName.toLowerCase();
	                className = curTarget.className;
	                arr = className ? className.split(' ') : [];
	            }
	        }
	
	        function addColumnWindowMouseUpHandler_() {
	            var self = this;
	            self.startMoveInfo_ = null;
	            document.removeEventListener('mousemove', self.addColumnWindowMouseMoveHandler_);
	            document.removeEventListener('mouseup', self.addColumnWindowMouseUpHandler_);
	            self.documentMouseMoveHandler_ = null;
	            self.documentMouseUpHandler_ = null;
	        }
	
	        function addColumnWindowMouseMoveHandler_(e) {
	            var self = this;
	            var info = self.startMoveInfo_;
	            if (info) {
	                var container = document.getElementById(self.grid.uid + '-popup-addColumn');
	                var mouseOffset = info.mouseOffset;
	                var containerOffset = info.containerOffset;
	                domUtil.setCss(container, {
	                    'left': containerOffset.left + (e.pageX - mouseOffset.left),
	                    'top': containerOffset.top + (e.pageY - mouseOffset.top)
	                });
	            }
	        }
	
	        function handleClickColHeader_(hitInfo) {
	            var self = this;
	            var grid = self.grid;
	            var columns = grid.columns;
	            var col = hitInfo.column;
	            if (col >= 0) {
	                var colObj = columns[col];
	                var canSort = colObj.hasOwnProperty('allowSorting') ? colObj.allowSorting : self.options.allowSorting;
	                if (canSort) {
	                    var currentSortInfo = null;
	                    if (grid.data.sortDescriptors) {
	                        currentSortInfo = _.find(grid.data.sortDescriptors, _.matchesProperty('field', colObj.id));
	                    }
	                    var opSortInfo;
	                    if (grid.options.sorting) {
	                        opSortInfo = _.find(grid.options.sorting, _.matchesProperty('field', colObj.id));
	                        if (opSortInfo && !opSortInfo.hasOwnProperty('ascending')) {
	                            opSortInfo.ascending = true;
	                        }
	                    }
	                    if (!opSortInfo) {
	                        opSortInfo = {field: colObj.id, ascending: true};
	                    }
	                    if (currentSortInfo) {
	                        if (currentSortInfo.ascending !== opSortInfo.ascending) {
	                            currentSortInfo = null;
	                        } else {
	                            currentSortInfo.ascending = !currentSortInfo.ascending;
	                        }
	                    } else {
	                        currentSortInfo = _.clone(opSortInfo);
	                    }
	                    grid.data.sortDescriptors = currentSortInfo;
	                }
	            }
	        }
	
	        function getDataItem(hitInfo) {
	            var dataItem;
	            var groupInfo;
	            var group;
	            var self = this;
	            if (hitInfo.groupInfo && hitInfo.groupInfo.area === GROUP_CONTENT) {
	                groupInfo = hitInfo.groupInfo;
	                group = self.getGroupInfo_(groupInfo.path).data;
	                dataItem = group.getItem(groupInfo.row);
	            } else {
	                dataItem = self.getDataItem(hitInfo.row);
	            }
	
	            return dataItem;
	        }
	
	        function handleTouchTap(sender, e) {
	            handleMouseClick_(sender, e, true);
	        }
	
	        function handleTouchScroll() {
	            var self = this;
	            self.stopEditing();
	            closeTouchPanel.call(self);
	            removeResizeGraphics.call(self);
	        }
	
	        function handleSwipe_(sender, e) {
	            var self = this;
	            var layoutEngine = sender.layoutEngine;
	            var relatedRow;
	
	            if (e.swipeStatus === 'swipestart') {
	                var hitTestInfo_ = layoutEngine.hitTest({
	                    pageX: e.targetTouches[0].pageX,
	                    pageY: e.targetTouches[0].pageY
	                });
	                if (hitTestInfo_ && hitTestInfo_.area === VIEWPORT) {
	                    relatedRow = getRelatedMoveRow.call(layoutEngine, hitTestInfo_);
	                    self.stopEditing();
	                    if (swipeStatus.row && relatedRow !== swipeStatus.row) {
	                        closeTouchPanel.call(self);
	                    }
	
	                    swipeStatus = {};
	                    swipeStatus.row = relatedRow;
	                    if (swipeStatus.row) {
	                        swipeStatus.actionType = getActionType(e.moveDistance);
	                        swipeStatus.columns = createActionColumns.call(layoutEngine);
	                        swipeStatus.columnsTotalWidth = 0;
	                        _.each(swipeStatus.columns, function(col) {
	                            swipeStatus.columnsTotalWidth += col.perferredSize;
	                        });
	                    }
	
	                    if (getTouchPanel()) {
	                        swipeStatus.beginWithTouchPanel = true;
	                    }
	                }
	            } else if (e.swipeStatus === 'swipemoving') {
	                if (swipeStatus.row) {
	                    swipeStatus.moveDistance = e.moveDistance + (swipeStatus.beginWithTouchPanel ? (swipeStatus.actionType === 'left' ? 1 : -1) * swipeStatus.columnsTotalWidth : 0);
	                    if (isReverseMove()) {
	                        refreshActionRow.call(self, -swipeStatus.moveDistance, 0);
	                    } else if (Math.abs(swipeStatus.moveDistance) > swipeStatus.columnsTotalWidth) {
	                        refreshActionRow.call(self, -swipeStatus.moveDistance);
	                    } else {
	                        refreshActionRow.call(self, -swipeStatus.moveDistance, Math.abs(swipeStatus.moveDistance));
	                    }
	                }
	            } else {
	                if (swipeStatus.row) {
	                    swipeStatus.moveDistance = e.moveDistance + (swipeStatus.beginWithTouchPanel ? (swipeStatus.actionType === 'left' ? 1 : -1) * swipeStatus.columnsTotalWidth : 0);
	                    var v = Math.abs(e.velocity);
	                    if (isReverseMove()) {
	                        refreshActionRow.call(self, 0, 0, true, v);
	                    } else if (v > FLICK_THRESHOLD_V) {
	                        if (swipeStatus.beginWithTouchPanel) {
	                            refreshActionRow.call(self, 0, 0, true, v);
	                        } else {
	                            handleFlickGesture.call(self, e);
	                        }
	                    } else {
	                        if (Math.abs(swipeStatus.moveDistance) < swipeStatus.columnsTotalWidth / 2) {
	                            refreshActionRow.call(self, 0, 0, true, v);
	                        } else {
	                            refreshActionRow.call(self, (swipeStatus.moveDistance > 0 ? -1 : 1) * swipeStatus.columnsTotalWidth, swipeStatus.columnsTotalWidth, true, v);
	                        }
	                    }
	                }
	            }
	        }
	
	        function handleFlickGesture(e) {
	            var grid = this;
	            var layoutEngine = grid.layoutEngine;
	            var agrs;
	            var hitInfo;
	            var fn;
	
	            var action = findExecuteFlickAction.call(grid);
	            if (action && action.actionHandler) {
	                refreshActionRow.call(grid, (swipeStatus.moveDistance > 0 ? -1 : 1) * swipeStatus.columnsTotalWidth, swipeStatus.columnsTotalWidth, false, e.velocity);
	                agrs = {pageX: e.changedTouches[0].pageX, pageY: e.changedTouches[0].pageY};
	                layoutEngine.hitTestInfo_ = layoutEngine.hitTest(agrs);
	                hitInfo = layoutEngine.hitTestInfo_;
	                fn = function() {
	                    action.actionHandler({
	                        gridModel: grid,
	                        hitInfo: hitInfo,
	                        dataItem: getDataItem.call(grid, hitInfo),
	                        closeActionColumnPanel: closeTouchPanel.bind(grid)
	                    });
	                };
	                setTimeout(fn, 100);
	            } else {
	                refreshActionRow.call(grid, (swipeStatus.moveDistance > 0 ? -1 : 1) * swipeStatus.columnsTotalWidth, swipeStatus.columnsTotalWidth, true, e.velocity);
	            }
	        }
	
	        function findExecuteFlickAction() {
	            var self = this;
	            var actionPresenter;
	            var actionHandler;
	            var col;
	            var actionInfos;
	            var item;
	
	            for (var i = 0, collength = self.columns.length; i < collength; i++) {
	                col = self.columns[i];
	                actionInfos = self.columnActions_[col.id];
	                if (!actionInfos) {
	                    continue;
	                }
	
	                for (var j = 0, length = actionInfos.length; j < length; j++) {
	                    item = actionInfos[j];
	                    if (item.flickAction === swipeStatus.actionType) {
	                        actionPresenter = (item.presenter ? item.presenter : ('<button class="gc-action" data-action="' + item.name + '">' + item.name + '</button>'));
	                        actionHandler = self.getActionHandler_(col.id, item.name);
	                        break;
	                    }
	                }
	
	                if (actionPresenter) {
	                    break;
	                }
	            }
	
	            if (actionPresenter !== '') {
	                return {
	                    presenter: '<div class="gc-action-area">' + actionPresenter + '</div>',
	                    actionHandler: actionHandler
	                };
	            } else {
	                return null;
	            }
	        }
	
	        function getActionType(moveDistance) {
	            var actionPanel;
	            var acType;
	            _.each(['left', 'right'], function(actionType) {
	                actionPanel = document.getElementById(swipeStatus.row.id + '-' + actionType + '-actionPanel');
	                if (actionPanel) {
	                    acType = actionType;
	                }
	            });
	
	            if (!acType) {
	                acType = moveDistance > 0 ? 'left' : 'right';
	            }
	
	            return acType;
	        }
	
	        function getTouchPanel() {
	            if (swipeStatus.row) {
	                return document.getElementById(swipeStatus.row.id + '-left-actionPanel') || document.getElementById(swipeStatus.row.id + '-right-actionPanel');
	            }
	        }
	
	        function isReverseMove() {
	            return (swipeStatus.moveDistance > 0 ? 'left' : 'right') !== swipeStatus.actionType;
	        }
	
	        function refreshActionRow(rowleft, panelWidth, useAnimation, velocity) {
	            var self = this;
	
	            if (!swipeStatus.row) {
	                return;
	            }
	
	            if (useAnimation) {
	                var currentRowleft = parseFloat(swipeStatus.row.style.left);
	                var touchPanel = document.getElementById(swipeStatus.row.id + '-' + swipeStatus.actionType + '-actionPanel');
	                var currentPanelWidth = touchPanel ? parseFloat(touchPanel.style.width) : 0;
	
	                var rowOffset = rowleft - currentRowleft;
	                var panelOffset = panelWidth - currentPanelWidth;
	                var duration = 0.25 * (1 / velocity);
	                duration = duration > 0.10 ? 0.10 : duration;
	
	                ani.play(duration, function(p) {
	                    updateRow.call(self, rowOffset * p + currentRowleft);
	                    updateTouchPanel.call(self, panelOffset * p + currentPanelWidth);
	                });
	            } else {
	                updateRow.call(self, rowleft);
	                updateTouchPanel.call(self, panelWidth);
	            }
	        }
	
	        function updateRow(newleft) {
	            var self = this;
	            var layoutInfo = self.getLayoutInfo()[VIEWPORT];
	            swipeStatus.row.style.left = newleft + 'px';
	            if (newleft > 0) {
	                swipeStatus.row.style['border-right'] = '1px solid rgba(0, 0, 0, 0.2)';
	                swipeStatus.row.style.overflow = 'hidden';
	                swipeStatus.row.style.width = (layoutInfo.contentWidth - newleft) + 'px';
	            } else {
	                swipeStatus.row.style.removeProperty('border-right');
	                swipeStatus.row.style.removeProperty('overflow');
	                swipeStatus.row.style.removeProperty('width');
	            }
	        }
	
	        function updateTouchPanel(panelWidth) {
	            var self = this;
	            if (gcUtils.isNumber(panelWidth)) {
	                var viewPort = document.getElementById(self.uid + '-viewport-inner');
	                var actionPanel = document.getElementById(swipeStatus.row.id + '-' + swipeStatus.actionType + '-actionPanel');
	
	                if (actionPanel) {
	                    viewPort.removeChild(actionPanel);
	                }
	
	                if (panelWidth > 0) {
	                    viewPort.appendChild(createColumnTouchPanel.call(self, panelWidth));
	                }
	            }
	        }
	
	        function closeTouchPanel() {
	            var self = this;
	            ani.stop();
	            refreshActionRow.call(self, 0, 0);
	            swipeStatus = {};
	        }
	
	        var ani = (function() {
	            var startTime = 0;
	            var _time = 0;
	            var _callback = null;
	            var playType = 0;//0 = timer, 1 = raf
	            var _lastTime = 0;
	            var _stopAnimation;
	            var raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame;
	
	            function playAnimation(time, cb) {
	                startTime = (new Date()).getTime();
	                _stopAnimation = false;
	                _time = time * 1000;
	                _callback = cb;
	
	                if (playType && raf) {
	                    raf(_ani);
	                } else {
	                    setTimeout(_ani, 16.6);
	                }
	            }
	
	            function _ani() {
	                var now = (new Date()).getTime();
	                var count = now - startTime;
	
	                var cb = function(val) {
	                    _callback(val || easeOut(count, 0, 1, _time));
	
	                };
	
	                if (count >= _time || _stopAnimation) {
	                    cb(1);
	                    return;
	                }
	
	                cb();
	
	                _lastTime = (new Date()).getTime();
	
	                if (playType && raf) {
	                    raf(_ani);
	                } else {
	                    setTimeout(_ani, 16.6);
	                }
	            }
	
	            function easeOut(t, b, c, d) {
	                t /= d / 2;
	                if (t < 1) {
	                    return c / 2 * t * t + b;
	                }
	
	                t--;
	                return -c / 2 * (t * (t - 2) - 1) + b;
	            }
	
	            //function easeInOut(t, b, c, d) {
	            //    if ((t /= d / 2) < 1) {
	            //        return c / 2 * t * t + b;
	            //    }
	            //    return -c / 2 * ((--t) * (t - 2) - 1) + b;
	            //}
	
	            //function linear(t, d) {
	            //    return t / d;
	            //}
	
	            function stopAnimation() {
	                _stopAnimation = true;
	            }
	
	            return {
	                play: playAnimation,
	                stop: stopAnimation
	            };
	        })();
	
	        function getRelatedMoveRow(hitTestInfo) {
	            var self = this;
	            var uid = self.grid.uid;
	            var key;
	            var groupInfo = hitTestInfo.groupInfo;
	            if (groupInfo) {
	                var part = groupInfo.area;
	                if (part === GROUP_HEADER) {
	                    key = uid + '-gh' + groupInfo.path.join('_');
	                } else if (part === GROUP_CONTENT) {
	                    key = uid + '-gr' + groupInfo.path.join('_') + '-r' + groupInfo.row;
	                } else {
	                    key = uid + '-gf' + groupInfo.path.join('_');
	                }
	            } else {
	                key = uid + '-r' + hitTestInfo.row;
	            }
	
	            return document.getElementById(key);
	        }
	
	        function hasGroup_(grid) {
	            return grid.data.groups && grid.data.groups.length > 0;
	        }
	
	        function pointIn_(offsetLeft, offsetTop, element, relativeElement, enlarge) {
	            var self = this;
	            var eleOffset = domUtil.offset(element);
	            var targetEleOffset = domUtil.offset(relativeElement);
	            var left = eleOffset.left - targetEleOffset.left;
	            var top = eleOffset.top - targetEleOffset.top;
	            var elementRect = domUtil.getElementRect(element);
	            var enlargelength = (enlarge && self.grid.isTouchMode) ? 10 : 0;
	            left -= enlargelength;
	            top -= enlargelength;
	            var right = left + elementRect.width + 2 * enlargelength;
	            var bottom = top + elementRect.height + 2 * enlargelength;
	
	            if (offsetLeft >= left && offsetLeft <= right &&
	                offsetTop >= top && offsetTop <= bottom) {
	                return true;
	            }
	            return false;
	        }
	
	        function canStartDraging_(hitTestInfo) {
	            var self = this;
	            var grid = self.grid;
	            var data;
	            var column;
	            var groupDescriptors;
	            var area;
	            if (hitTestInfo) {
	                area = hitTestInfo.area;
	                if (area === GROUP_DRAG_PANEL) {
	                    return true;
	                } else if ((area === COLUMN_HEADER || area === PINNED_COLUMN_HEADER || area === PINNED_RIGHT_COLUMN_HEADER) && (hitTestInfo.column >= 0 || (hitTestInfo.columnGroupInfo && hitTestInfo.columnGroupInfo.caption))) {
	                    if (self.options.allowColumnReorder) {
	                        return true;
	                    }
	                    data = grid.data;
	                    groupDescriptors = data.groupDescriptors;
	                    column = grid.columns[hitTestInfo.column];
	                    var grouped = !!_.find(groupDescriptors, _.matchesProperty('field', column.id));
	                    return grouped ? false : !!(column.hasOwnProperty('allowGrouping') ? column.allowGrouping : this.grid.options.allowGrouping);
	                }
	            }
	            return false;
	        }
	
	        function updateTreeNode(layoutEngine) {
	            var self = layoutEngine;
	            var hitInfo = self.hitTestInfo_;
	            var hitGroupInfo = hitInfo.groupInfo;
	            var node;
	            if (hitGroupInfo) {
	                var group = self.grid.getGroupInfo_(hitGroupInfo.path).data;
	                node = group.rootNode.findNode(hitGroupInfo.row);
	            } else {
	                node = self.grid.data.rootNode.findNode(hitInfo.row);
	            }
	            if (node) {
	                node.collapsed = !node.collapsed;
	            }
	        }
	
	        function updateSelection(layoutEngine) {
	            var self = layoutEngine;
	            if (self.options.allowHeaderSelect) {
	                updateCheckboxSelection_(self);
	            } else {
	                updateGeneralSelection_(self);
	            }
	        }
	
	        function updateCheckboxSelection_(layoutEngine) {
	            var self = layoutEngine;
	            var hitInfo = self.hitTestInfo_;
	            var groupHitInfo = hitInfo.groupInfo;
	            if (!hitInfo.checked && (!groupHitInfo || !groupHitInfo.checked)) {
	                return;
	            }
	
	            var groupInfo = groupHitInfo ? self.grid.getGroupInfo_(groupHitInfo.path) : null;
	            var viewRow = groupHitInfo ? groupHitInfo.row : hitInfo.row;
	            var srcRow = groupInfo ? groupInfo.data.toSourceRow(viewRow) : self.grid.data.toSourceRow(viewRow);
	
	            var selectedRows = self.selectedRows_ = self.selectedRows_ || [];
	            var selModeOpt = self.options.selectionMode;
	            var i;
	            var length;
	            var targetElement;
	            var checked;  //current checked status;
	
	            if (selModeOpt === SelectMode.NONE) {
	                selectedRows.length = 0;
	                setAllStatus_(self, false, VIEWPORT);
	                if (self.hasLeftPinnedColumn_) {
	                    setAllStatus_(self, false, PINNED_VIEWPORT);
	                }
	                if (self.hasRightPinnedColumn_) {
	                    setAllStatus_(self, false, PINNED_RIGHT_VIEWPORT);
	                }
	            } else if (selModeOpt === SelectMode.SINGLE) {
	                targetElement = getCheckElement_(self, hitInfo);
	                if (hitInfo.area === CORNER_HEADER || (groupHitInfo && groupHitInfo.area === GROUP_HEADER)) {
	                    setCheckElementSelect_(targetElement, false);
	                    return;
	                }
	                if (!isNaN(srcRow) && selectedRows.indexOf(srcRow) === -1) {
	                    selectedRows.length = 0;
	                    selectedRows.push(srcRow);
	                    setAllStatus_(self, false, VIEWPORT);
	                    var element = getRowElement_(self, viewRow, groupHitInfo, VIEWPORT);
	                    setRowElementSelect_(element, true);
	                    if (self.hasLeftPinnedColumn_) {
	                        setAllStatus_(self, false, PINNED_VIEWPORT);
	                        element = getRowElement_(self, viewRow, hitInfo.groupInfo, PINNED_VIEWPORT);
	                        setRowElementSelect_(element, true);
	                    }
	                    if (self.hasRightPinnedColumn_) {
	                        setAllStatus_(self, false, PINNED_RIGHT_VIEWPORT);
	                        element = getRowElement_(self, viewRow, hitInfo.groupInfo, PINNED_RIGHT_VIEWPORT);
	                        setRowElementSelect_(element, true);
	                    }
	                }
	                setCheckElementSelect_(targetElement, true);
	            } else {
	                if (hitInfo.area === CORNER_HEADER) {
	                    checked = selectedRows.length === self.grid.data.itemCount;
	                    selectedRows.length = 0;
	                    if (!checked) {
	                        for (i = 0, length = self.grid.data.sourceCollection.length; i < length; i++) {
	                            selectedRows.push(i);
	                        }
	                    }
	                    setAllStatus_(self, !checked, VIEWPORT);
	                    if (self.hasLeftPinnedColumn_) {
	                        setAllStatus_(self, !checked, PINNED_VIEWPORT);
	                    }
	                    if (self.hasRightPinnedColumn_) {
	                        setAllStatus_(self, !checked, PINNED_RIGHT_VIEWPORT);
	                    }
	                } else if (hitInfo.area === ROW_HEADER) {
	                    if (groupHitInfo && groupHitInfo.area === GROUP_HEADER) {
	                        var mappings = getGroupMapping_(self.grid.getGroupInfo_(groupHitInfo.path));
	                        checked = _.difference(mappings, selectedRows).length <= 0;
	                        if (checked) {
	                            var intersection = _.intersection(selectedRows, mappings);
	                            for (i = 0, length = intersection.length; i < length; i++) {
	                                selectedRows.splice(selectedRows.indexOf(intersection[i]), 1);
	                            }
	                        } else {
	                            selectedRows = self.selectedRows_ = _.union(mappings, selectedRows);
	                        }
	                    } else {
	                        var itemIndex = selectedRows.indexOf(srcRow);
	                        checked = itemIndex !== -1;
	                        if (checked) {
	                            selectedRows.splice(itemIndex, 1);
	                        } else {
	                            selectedRows.push(srcRow);
	                        }
	                    }
	                    checked = !checked; // after click, the checked status changed.
	                    setMultiStatus_(self, checked);
	                }
	            }
	        }
	
	        function updateGeneralSelection_(layoutEngine) {
	            var self = layoutEngine;
	            var hitInfo = self.hitTestInfo_;
	            var groupHitInfo = hitInfo.groupInfo;
	            var hitInfoColumn = groupHitInfo ? groupHitInfo.column : hitInfo.column;
	            if (hitInfoColumn < 0) {
	                return;
	            }
	
	            var groupInfo = groupHitInfo ? self.grid.getGroupInfo_(groupHitInfo.path) : null;
	            var viewRow = groupHitInfo ? groupHitInfo.row : hitInfo.row;
	            var srcRow = groupInfo ? groupInfo.data.toSourceRow(viewRow) : self.grid.data.toSourceRow(viewRow);
	
	            if (isNaN(viewRow) || isNaN(srcRow)) {
	                return;
	            }
	
	            var selModeOpt = self.options.selectionMode;
	            var element;
	            var selectedRows = self.selectedRows_ = self.selectedRows_ || [];
	            var row = viewRow;
	            if (selModeOpt === SelectMode.NONE) {
	                selectedRows.length = 0;
	                setAllStatus_(self, false, VIEWPORT);
	                if (self.hasLeftPinnedColumn_) {
	                    setAllStatus_(self, false, PINNED_VIEWPORT);
	                }
	                if (self.hasRightPinnedColumn_) {
	                    setAllStatus_(self, false, PINNED_RIGHT_VIEWPORT);
	                }
	            } else if (selModeOpt === SelectMode.MULTIPLE) {
	                var itemIndex = selectedRows.indexOf(srcRow);
	                element = getRowElement_(self, row, groupHitInfo, VIEWPORT);
	                if (domUtil.hasClass(element, 'gc-selected')) {
	                    selectedRows.splice(itemIndex, 1);
	                    setRowElementSelect_(element, false);
	                } else {
	                    if (itemIndex < 0) {
	                        selectedRows.push(srcRow);
	                        setRowElementSelect_(element, true);
	                    }
	                }
	                if (self.hasLeftPinnedColumn_) {
	                    element = getRowElement_(self, row, groupHitInfo, PINNED_VIEWPORT);
	                    if (domUtil.hasClass(element, 'gc-selected')) {
	                        setRowElementSelect_(element, false);
	                    } else {
	                        if (itemIndex < 0) {
	                            setRowElementSelect_(element, true);
	                        }
	                    }
	                }
	                if (self.hasRightPinnedColumn_) {
	                    element = getRowElement_(self, row, groupHitInfo, PINNED_RIGHT_VIEWPORT);
	                    if (domUtil.hasClass(element, 'gc-selected')) {
	                        setRowElementSelect_(element, false);
	                    } else {
	                        if (itemIndex < 0) {
	                            setRowElementSelect_(element, true);
	                        }
	                    }
	                }
	            } else {
	                selectedRows.length = 0;
	                selectedRows.push(srcRow);
	                setAllStatus_(self, false, VIEWPORT);
	                element = getRowElement_(self, row, groupHitInfo, VIEWPORT);
	                setRowElementSelect_(element, true);
	                if (self.hasLeftPinnedColumn_) {
	                    setAllStatus_(self, false, PINNED_VIEWPORT);
	                    element = getRowElement_(self, row, groupHitInfo, PINNED_VIEWPORT);
	                    setRowElementSelect_(element, true);
	                }
	                if (self.hasRightPinnedColumn_) {
	                    setAllStatus_(self, false, PINNED_RIGHT_VIEWPORT);
	                    element = getRowElement_(self, row, groupHitInfo, PINNED_RIGHT_VIEWPORT);
	                    setRowElementSelect_(element, true);
	                }
	
	            }
	        }
	
	        //TODO: iterate all is not very efficient
	        function setAllStatus_(layoutEngine, status, area) {
	            var self = layoutEngine;
	            var i;
	            var length;
	            if (self.options.allowHeaderSelect) {
	                var rowCheckElements = self.grid.container.querySelectorAll('.gc-header-select-icon');
	                for (i = 0, length = rowCheckElements.length; i < length; i++) {
	                    setCheckElementSelect_(rowCheckElements[i], status);
	                }
	            }
	            var viewport = document.getElementById(self.grid.uid + '-' + area + '-inner');
	            var rows = viewport.children;
	            if (status) {
	                for (i = 0, length = rows.length; i < length; i++) {
	                    domUtil.addClass(rows[i], 'gc-selected');
	                    rows[i].setAttribute('aria-selected', 'true');
	                }
	            } else {
	                for (i = 0, length = rows.length; i < length; i++) {
	                    domUtil.removeClass(rows[i], 'gc-selected');
	                    rows[i].removeAttribute('aria-selected');
	                }
	            }
	        }
	
	        function setMultiStatus_(layoutEngine, checkedStatus) {
	            var self = layoutEngine;
	            var hitInfo = self.hitTestInfo_;
	            var groupHitInfo = hitInfo.groupInfo;
	            var uid = self.grid.uid;
	            var i;
	            var length;
	            var rowElement;
	            var targetElement = getCheckElement_(self, hitInfo);
	            var rootCheckElement = document.getElementById(uid + '-corner-select');
	            setCheckElementSelect_(rootCheckElement, self.selectedRows_.length === self.grid.data.itemCount);
	            //update row header checkbox
	            if (!groupHitInfo) {
	                rowElement = getRowElement_(self, hitInfo.row, null, VIEWPORT);
	                setRowElementSelect_(rowElement, checkedStatus);
	                if (self.hasLeftPinnedColumn_) {
	                    rowElement = getRowElement_(self, hitInfo.row, null, PINNED_VIEWPORT);
	                    setRowElementSelect_(rowElement, checkedStatus);
	                }
	                if (self.hasRightPinnedColumn_) {
	                    rowElement = getRowElement_(self, hitInfo.row, null, PINNED_RIGHT_VIEWPORT);
	                    setRowElementSelect_(rowElement, checkedStatus);
	                }
	                setCheckElementSelect_(targetElement, checkedStatus);
	            } else {
	                //If there are groups, need to sync parent and children status
	                var targetGroupInfo;
	                var children;
	                var mappings;
	                //set parent status.
	                var path = _.clone(groupHitInfo.path);
	                if (groupHitInfo.area === GROUP_HEADER) {
	                    path.pop();
	                    setCheckElementSelect_(targetElement, checkedStatus);
	                } else if (groupHitInfo.area === GROUP_CONTENT) {
	                    rowElement = getRowElement_(self, null, groupHitInfo, VIEWPORT);
	                    setRowElementSelect_(rowElement, checkedStatus);
	                    if (self.hasLeftPinnedColumn_) {
	                        rowElement = getRowElement_(self, hitInfo.row, null, PINNED_VIEWPORT);
	                        setRowElementSelect_(rowElement, checkedStatus);
	                    }
	                    if (self.hasRightPinnedColumn_) {
	                        rowElement = getRowElement_(self, hitInfo.row, null, PINNED_RIGHT_VIEWPORT);
	                        setRowElementSelect_(rowElement, checkedStatus);
	                    }
	                    setCheckElementSelect_(targetElement, checkedStatus);
	                }
	                while (path.length > 0) {
	                    targetElement = document.getElementById(uid + '-ghh' + path.join('-') + '-select');
	                    if (targetElement) {
	                        targetGroupInfo = self.grid.getGroupInfo_(path);
	                        mappings = getGroupMapping_(targetGroupInfo);
	                        setCheckElementSelect_(targetElement, _.difference(mappings, self.selectedRows_).length <= 0);
	                    }
	                    path.pop();
	                }
	                //set children status.
	                if (groupHitInfo.area === GROUP_HEADER) {
	                    var currentGroupInfo = self.grid.getGroupInfo_(groupHitInfo.path);
	                    if (currentGroupInfo.children) {
	                        children = _.clone(currentGroupInfo.children);
	                        while (children.length) {
	                            targetGroupInfo = children.pop();
	                            path = targetGroupInfo.path;
	                            targetElement = document.getElementById(uid + '-ghh' + path.join('-') + '-select');
	                            setCheckElementSelect_(targetElement, checkedStatus);
	                            if (targetGroupInfo.children) {
	                                children.concat(targetGroupInfo.children);
	                            } else {
	                                for (i = 0, length = targetGroupInfo.data.itemCount; i < length; i++) {
	                                    targetElement = document.getElementById(uid + '-grh' + path.join('-') + '-r' + i + '-select');
	                                    setCheckElementSelect_(targetElement, checkedStatus);
	                                    rowElement = document.getElementById(uid + '-gr' + path.join('_') + '-r' + i);
	                                    setRowElementSelect_(rowElement, checkedStatus);
	                                    if (self.hasLeftPinnedColumn_) {
	                                        rowElement = document.getElementById(uid + '-pgr' + path.join('_') + '-r' + i);
	                                        setRowElementSelect_(rowElement, checkedStatus);
	                                    }
	                                    if (self.hasRightPinnedColumn_) {
	                                        rowElement = document.getElementById(uid + '-prgr' + path.join('_') + '-r' + i);
	                                        setRowElementSelect_(rowElement, checkedStatus);
	                                    }
	                                }
	                            }
	                        }
	                    } else {
	                        for (i = 0, length = currentGroupInfo.data.itemCount; i < length; i++) {
	                            targetElement = document.getElementById(uid + '-grh' + currentGroupInfo.path.join('-') + '-r' + i + '-select');
	                            setCheckElementSelect_(targetElement, checkedStatus);
	                            rowElement = document.getElementById(uid + '-gr' + currentGroupInfo.path.join('_') + '-r' + i);
	                            setRowElementSelect_(rowElement, checkedStatus);
	                            if (self.hasLeftPinnedColumn_) {
	                                rowElement = document.getElementById(uid + '-pgr' + currentGroupInfo.path.join('_') + '-r' + i);
	                                setRowElementSelect_(rowElement, checkedStatus);
	                            }
	                            if (self.hasRightPinnedColumn_) {
	                                rowElement = document.getElementById(uid + '-prgr' + currentGroupInfo.path.join('_') + '-r' + i);
	                                setRowElementSelect_(rowElement, checkedStatus);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	
	        function setRowElementSelect_(element, status) {
	            if (element) {
	                if (status) {
	                    domUtil.addClass(element, 'gc-selected');
	                    element.setAttribute('aria-selected', 'true');
	                } else {
	                    domUtil.removeClass(element, 'gc-selected');
	                    element.removeAttribute('aria-selected');
	                }
	            }
	        }
	
	        function setCheckElementSelect_(element, status) {
	            if (element) {
	                if (status) {
	                    domUtil.addClass(element, 'selected');
	                } else {
	                    domUtil.removeClass(element, 'selected');
	                }
	            }
	        }
	
	        function getRowElement_(layoutEngine, row, groupInfo, area) {
	            var self = layoutEngine;
	            var uid = self.grid.uid;
	            var selector;
	            var prefix = area === PINNED_VIEWPORT ? 'p' : (area === PINNED_RIGHT_VIEWPORT ? 'pr' : '');
	            if (!groupInfo) {
	                if (row >= 0) {
	                    selector = uid + '-' + prefix + 'r' + row;
	                }
	            } else {
	                if (groupInfo.area === GROUP_CONTENT && groupInfo.row >= 0) {
	                    selector = uid + '-' + prefix + 'gr' + groupInfo.path.join('_') + '-r' + groupInfo.row;
	                } else if (groupInfo.area === GROUP_FOOTER) {
	                    selector = uid + '-' + prefix + 'gf' + groupInfo.path.join('_');
	                } else if (groupInfo.area === GROUP_HEADER) {
	                    selector = uid + '-' + prefix + 'gh' + groupInfo.path.join('_');
	                }
	            }
	            return selector ? document.getElementById(selector) : null;
	        }
	
	        function getCheckElement_(layoutEngine, hitInfo) {
	            var self = layoutEngine;
	            var uid = self.grid.uid;
	            var selector;
	            var groupInfo = hitInfo.groupInfo;
	            if (hitInfo.area === CORNER_HEADER) {
	                selector = uid + '-corner';
	            } else if (hitInfo.area === ROW_HEADER) {
	                if (!groupInfo) {
	                    var row = hitInfo.row;
	                    if (row >= 0) {
	                        selector = uid + '-rh' + row;
	                    }
	                } else {
	                    if (groupInfo.area === GROUP_CONTENT && groupInfo.row >= 0) {
	                        selector = uid + '-grh' + groupInfo.path.join('-') + '-r' + groupInfo.row;
	                    } else if (groupInfo.area === GROUP_HEADER) {
	                        selector = uid + '-ghh' + groupInfo.path.join('-');
	                    }
	                }
	            }
	            return selector ? document.getElementById(selector + '-select') : null;
	        }
	
	        function getGroupMapping_(groupInfo) {
	            var mappings = [];
	            var group = groupInfo.data;
	            var i = 0;
	            while (i < group.itemCount) {
	                mappings.push(group.toSourceRow(i));
	                i++;
	            }
	            return mappings;
	        }
	
	        function formatValue(value, format, formula) {
	            var self = this;
	            var Sparkline = gcUtils.findPlugin('Sparkline');
	            if (Sparkline && value instanceof Sparkline.BaseSparkline) {
	                var containerHeight = self.options.rowHeight;
	                return '<span data-formula=\'' + formula + '\' class="gc-group-sparkline" style="position:relative;display:inline-block;vertical-align:middle;width:' + containerHeight * 4 + 'px;height:' + containerHeight + 'px;"></span>';
	            }
	            if (gcUtils.isFunction(format)) {
	                return format(value);
	            } else if (!gcUtils.isUndefinedOrNull(window.GcSpread)) {
	                var Formatter = gcUtils.findPlugin('Formatter');
	                var ExcelFormatter = Formatter ? Formatter.ExcelFormatter : null;
	                if (ExcelFormatter) {
	                    var formatObj = new ExcelFormatter(format);
	                    return formatObj.format(value);
	                }
	            }
	            return value;
	        }
	
	        function getSortIndicatorHtml_(layoutEngine, colObj, colIndex) {
	            var grid = layoutEngine.grid;
	            var sortInfo;
	            if (grid.data.sortDescriptors) {
	                sortInfo = _.find(grid.data.sortDescriptors, _.matchesProperty('field', colObj.id));
	            }
	            if (sortInfo) {
	                if (grid.options.sorting) {
	                    var opSortInfo = _.find(grid.options.sorting, _.matchesProperty('field', colObj.id));
	                    if (opSortInfo) {
	                        sortInfo = _.defaults(sortInfo, opSortInfo);
	                    }
	                }
	                var sortCss = getSortCssClass_(sortInfo, colIndex);
	                return '<div class="sortContainer" style="float: right"><div class="' + sortCss + '"></div></div>';
	            }
	            return '';
	        }
	
	        function getSortCssClass_(sortInfo, colIndex) {
	            var ascending;
	            if (!sortInfo) {
	                ascending = true;
	            } else {
	                ascending = gcUtils.isUndefinedOrNull(sortInfo.ascending) ? true : !!sortInfo.ascending;
	            }
	            return ascending ? ('gc-icon gc-sorting ascending c' + colIndex) : ('gc-icon gc-sorting descending c' + colIndex);
	        }
	
	        function isEditingSameRow_(hitInfo, editingInfo) {
	            return hitInfo.groupInfo ?
	                (hitInfo.groupInfo.group === editingInfo.groupInfo.path && hitInfo.groupInfo.row === editingInfo.rowIndex) :
	            hitInfo.row === editingInfo.rowIndex;
	        }
	
	        module.exports = GridLayoutEngine;
	    }
	    ()
	)
	;


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var CalcCommon = __webpack_require__(9); // jshint ignore:line
	    //var CalcFunctions = require('./functions'); // jshint ignore:line
	    var CalcContext = __webpack_require__(10);
	    var CalcParser = __webpack_require__(11);
	    var CalcExpressions = __webpack_require__(12);
	    var CalcEvaluator = __webpack_require__(13);
	    var CalcHelper = __webpack_require__(14); // jshint ignore:line
	    var CalcManager = __webpack_require__(15);
	    var CalcModels = __webpack_require__(16); // jshint ignore:line
	    var CalcSource = __webpack_require__(17);
	    var CalcCollections = __webpack_require__(18);
	    var CalcFunctions = __webpack_require__(19);
	
	    module.exports = {
	        Common: CalcCommon,
	        Helper: CalcHelper,
	        CalcManager: CalcManager,
	        ParserContext: CalcContext.ParserContext,
	        EvaluatorContext: CalcContext.EvaluateContext,
	        Expressions: CalcExpressions,
	        Parser: CalcParser.Parser,
	        Evaluator: CalcEvaluator,
	        CalcSource: CalcSource.CalcSource,
	        Collections: CalcCollections,
	        Functions: CalcFunctions
	    };
	}());


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	// doT.js
	// 2011-2014, Laura Doktorova, https://github.com/olado/doT
	// Licensed under the MIT license.
	
	/* jshint ignore:start */
	
	(function() {
	    "use strict";
	
	    var doT = {
	        version: "1.0.3",
	        templateSettings: {
	            evaluate: /\{\{([\s\S]+?(\}?)+)\}\}/g,
	            interpolate: /\{\{=([\s\S]+?)\}\}/g,
	            encode: /\{\{!([\s\S]+?)\}\}/g,
	            use: /\{\{#([\s\S]+?)\}\}/g,
	            useParams: /(^|[^\w$])def(?:\.|\[[\'\"])([\w$\.]+)(?:[\'\"]\])?\s*\:\s*([\w$\.]+|\"[^\"]+\"|\'[^\']+\'|\{[^\}]+\})/g,
	            define: /\{\{##\s*([\w\.$]+)\s*(\:|=)([\s\S]+?)#\}\}/g,
	            defineParams: /^\s*([\w$]+):([\s\S]+)/,
	            conditional: /\{\{\?(\?)?\s*([\s\S]*?)\s*\}\}/g,
	            iterate: /\{\{~\s*(?:\}\}|([\s\S]+?)\s*\:\s*([\w$]+)\s*(?:\:\s*([\w$]+))?\s*\}\})/g,
	            varname: "it",
	            strip: true,
	            append: true,
	            selfcontained: false,
	            doNotSkipEncoded: false
	        },
	        template: undefined, //fn, compile template
	        compile: undefined  //fn, for express
	    }, _globals;
	
	    doT.encodeHTMLSource = function(doNotSkipEncoded) {
	        var encodeHTMLRules = {"&": "&#38;", "<": "&#60;", ">": "&#62;", '"': "&#34;", "'": "&#39;", "/": "&#47;"},
	            matchHTML = doNotSkipEncoded ? /[&<>"'\/]/g : /&(?!#?\w+;)|<|>|"|'|\//g;
	        return function(code) {
	            return code ? code.toString().replace(matchHTML, function(m) {
	                return encodeHTMLRules[m] || m;
	            }) : "";
	        };
	    };
	
	
	    _globals = (function() {
	        return this || (0, eval)("this");
	    }());
	
	    //Hiber
	    //replate the module definition with simple module.exports since we only run
	    //it in node like environment
	
	    module.exports = doT;
	    //if (typeof module !== "undefined" && module.exports) {
	    //
	    //} else if (typeof define === "function" && define.amd) {
	    //	define(function(){return doT;});
	    //} else {
	    //	_globals.doT = doT;
	    //}
	
	    var startend = {
	        append: {start: "'+(", end: ")+'", startencode: "'+encodeHTML("},
	        split: {start: "';out+=(", end: ");out+='", startencode: "';out+=encodeHTML("}
	    }, skip = /$^/;
	
	    function resolveDefs(c, block, def) {
	        return ((typeof block === "string") ? block : block.toString())
	            .replace(c.define || skip, function(m, code, assign, value) {
	                if (code.indexOf("def.") === 0) {
	                    code = code.substring(4);
	                }
	                if (!(code in def)) {
	                    if (assign === ":") {
	                        if (c.defineParams) value.replace(c.defineParams, function(m, param, v) {
	                            def[code] = {arg: param, text: v};
	                        });
	                        if (!(code in def)) def[code] = value;
	                    } else {
	                        new Function("def", "def['" + code + "']=" + value)(def);
	                    }
	                }
	                return "";
	            })
	            .replace(c.use || skip, function(m, code) {
	                if (c.useParams) code = code.replace(c.useParams, function(m, s, d, param) {
	                    if (def[d] && def[d].arg && param) {
	                        var rw = (d + ":" + param).replace(/'|\\/g, "_");
	                        def.__exp = def.__exp || {};
	                        def.__exp[rw] = def[d].text.replace(new RegExp("(^|[^\\w$])" + def[d].arg + "([^\\w$])", "g"), "$1" + param + "$2");
	                        return s + "def.__exp['" + rw + "']";
	                    }
	                });
	                var v = new Function("def", "return " + code)(def);
	                return v ? resolveDefs(c, v, def) : v;
	            });
	    }
	
	    function unescape(code) {
	        return code.replace(/\\('|\\)/g, "$1").replace(/[\r\t\n]/g, " ");
	    }
	
	    doT.template = function(tmpl, c, def, dontRenderNullOrUndefined) {
	        c = c || doT.templateSettings;
	        var cse = c.append ? startend.append : startend.split, needhtmlencode, sid = 0, indv,
	            str = (c.use || c.define) ? resolveDefs(c, tmpl, def || {}) : tmpl;
	
	        var unescapeCode;
	
	        str = ("var out='" + (c.strip ? str.replace(/(^|\r|\n)\t* +| +\t*(\r|\n|$)/g, " ")
	            .replace(/\r|\n|\t|\/\*[\s\S]*?\*\//g, "") : str)
	            .replace(/'|\\/g, "\\$&")
	            .replace(c.interpolate || skip, function(m, code) {
	                if (!!dontRenderNullOrUndefined) {
	                    unescapeCode = unescape(code);
	                    if (code.indexOf('||') >= 0) {
	                        return cse.start + unescapeCode + cse.end;
	                    } else {
	                        return cse.start + '(typeof ' + code + ' !== "undefined" && ' + code + '!== null)?' + unescapeCode + ': ""' + cse.end;
	                    }
	                } else {
	                    return cse.start + unescape(code) + cse.end;
	                }
	
	                return cse.start + unescape(code) + cse.end;
	            })
	            .replace(c.encode || skip, function(m, code) {
	                needhtmlencode = true;
	                return cse.startencode + unescape(code) + cse.end;
	            })
	            .replace(c.conditional || skip, function(m, elsecase, code) {
	                return elsecase ?
	                    (code ? "';}else if(" + unescape(code) + "){out+='" : "';}else{out+='") :
	                    (code ? "';if(" + unescape(code) + "){out+='" : "';}out+='");
	            })
	            .replace(c.iterate || skip, function(m, iterate, vname, iname) {
	                if (!iterate) return "';} } out+='";
	                sid += 1;
	                indv = iname || "i" + sid;
	                iterate = unescape(iterate);
	                return '\';var arr' + sid + '=' + iterate + ";if(arr" + sid + "){var " + vname + "," + indv + "=-1,l" + sid + "=arr" + sid + ".length-1;while(" + indv + "<l" + sid + "){"
	                    + vname + "=arr" + sid + "[" + indv + "+=1];out+='";
	            })
	            .replace(c.evaluate || skip, function(m, code) {
	                return "';" + unescape(code) + "out+='";
	            })
	        + "';return out;")
	            .replace(/\n/g, "\\n").replace(/\t/g, '\\t').replace(/\r/g, "\\r")
	            .replace(/(\s|;|\}|^|\{)out\+='';/g, '$1').replace(/\+''/g, "");
	        //.replace(/(\s|;|\}|^|\{)out\+=''\+/g,'$1out+=');
	
	        if (needhtmlencode) {
	            if (!c.selfcontained && _globals && !_globals._encodeHTML) _globals._encodeHTML = doT.encodeHTMLSource(c.doNotSkipEncoded);
	            str = "var encodeHTML = typeof _encodeHTML !== 'undefined' ? _encodeHTML : ("
	                + doT.encodeHTMLSource.toString() + "(" + (c.doNotSkipEncoded || '') + "));"
	                + str;
	        }
	        try {
	            return new Function(c.varname, str);
	        } catch (e) {
	            if (typeof console !== "undefined") console.log("Could not create a template function: " + str);
	            throw e;
	        }
	    };
	
	    doT.compile = function(tmpl, def) {
	        return doT.template(tmpl, null, def);
	    };
	
	}());
	
	/* jshint ignore:end */


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 *
	 * SpreadJS Library 1.0.0
	 * http://wijmo.com/
	 *
	 * Copyright(c) GrapeCity, Inc.  All rights reserved.
	 *
	 * Licensed under the Wijmo Commercial License. Also available under the GNU GPL Version 3 license.
	 * licensing@wijmo.com
	 * http://wijmo.com/widgets/license/
	 *
	 *
	 **/
	
	(function() {
	    /* jshint ignore:start */
	    'use strict';
	    var Calc = {}
	    module.exports = Calc;
	
	    var CONST_UNDEFINED = 'undefined';
	    var CONST_NUMBER = 'number';
	    var CONST_STRING = 'string';
	    var CONST_BOOLEAN = 'boolean';
	    var CONST_TRUE = 'TRUE';
	    var CONST_FALSE = 'FALSE';
	    var CONST_ARRAY = 'ARRAY'; // jshint ignore:line
	    var CONST_ARRAYROW = 'ARRAYROW'; // jshint ignore:line
	    var CONST_NULL = '#NULL!';
	    var CONST_DIV0 = '#DIV/0!';
	    var CONST_VALUE = '#VALUE!';
	    var CONST_REF = '#REF!';
	    var CONST_NAME = '#NAME?';
	    var CONST_NA = '#N/A';
	    var CONST_NUM = '#NUM!';
	    var CONST_EXPR = 'expr'; // jshint ignore:line
	    var ERROR_LIST = [CONST_NULL, CONST_DIV0, CONST_VALUE, CONST_REF, CONST_NAME, CONST_NA, CONST_NUM];
	    var ERRORCODE_LIST = [0x00, 0x07, 0x0F, 0x17, 0x1D, 0x2A, 0x24];
	    var LETTER_POWS = [1, 26, 676]; // jshint ignore:line
	    var KEYWORD_NULL = null;
	    var KEYWORD_UNDEFINED = undefined;
	    var MATH_MIN = Math.min; // jshint ignore:line
	    var MATH_MAX = Math.max; // jshint ignore:line
	    var MATH_ABS = Math.abs;
	    var MATH_POW = Math.pow; // jshint ignore:line
	    var SR = __webpack_require__(20);
	    Calc.sr = SR;
	    Calc.parseOption = null;
	
	    var SRHelper = (function() {
	        function SRHelper() {
	
	        }
	
	        SRHelper.throwSR = function(sr) {
	            //throw SRHelper.sr(sr)
	        }
	
	        SRHelper.sr = function(sr) {
	            //return globalize.Cultures.SR[sr];
	        }
	
	        SRHelper.cr = function(name) {
	            //return globalize.Cultures.CR[name];
	        }
	
	        return SRHelper;
	    })();
	    Calc.SRHelper = SRHelper;
	
	    var throwSR = Calc.SRHelper.throwSR;
	    var sr = Calc.SRHelper.sr;
	    var cr = Calc.SRHelper.cr;
	    var invalidCast = 'Exp_InvalidCast';
	
	    /**
	     * Represents the missing argument constant.
	     */
	    Calc.missingArgument = {};
	
	    var __extends = function(d, b) {
	        for (var p in b) {
	            if (b.hasOwnProperty(p)) {
	                d[p] = b[p];
	            }
	        }
	        function __() {
	            this.constructor = d;
	        }
	
	        __.prototype = b.prototype;
	        d.prototype = new __();
	    };
	    Calc.__extends = __extends;
	
	    (function(CalcValueType) {
	        /**
	         *  The any type.
	         */
	        CalcValueType[CalcValueType['anyType'] = 0] = 'anyType';
	
	        /**
	         *  The number type.
	         */
	        CalcValueType[CalcValueType['numberType'] = 1] = 'numberType';
	
	        /**
	         *  The string type.
	         */
	        CalcValueType[CalcValueType['stringType'] = 2] = 'stringType';
	
	        /**
	         *  The boolean type.
	         */
	        CalcValueType[CalcValueType['booleanType'] = 3] = 'booleanType';
	
	        /**
	         *  The date type.
	         */
	        CalcValueType[CalcValueType['dateType'] = 4] = 'dateType';
	    })(Calc.CalcValueType || (Calc.CalcValueType = {}));
	
	    var Convert = (function() {
	        function Convert() {
	        }
	
	        //isNumber use short name to reduce size
	        Convert.num = function(value) {
	            return (typeof value === CONST_NUMBER) || (typeof value === CONST_BOOLEAN) || (!isNaN(value) && !isNaN(parseFloat(value))) || (value instanceof Date);
	        };
	
	        //static isNumber(value: any): boolean {
	        //    return (typeof value === const_number) || (!isNaN(value) && !isNaN(parseFloat(value))) ||
	        //        (value instanceof Date);
	        //}
	        // isError, use short name to reduce size
	        Convert.err = function(value) {
	            return value instanceof CalcError;
	        };
	
	        // isArray, use short name to reduce size
	        Convert.arr = function(value) {
	            return value instanceof Array;
	        };
	
	        //isReference, use short name to reduce size
	        Convert.ref = function(value) {
	            return value instanceof Reference;
	        };
	
	        Convert.toResult = function(value) {
	            if (isNaN(value) || !isFinite(value)) {
	                return Calc.CalcErrorsNumber;
	            }
	            return value;
	        };
	
	        Convert.toArr = function(value, valueType, toOneDimension, breakOnError, breakOnConvertError, ignoreBlank) {
	            return KEYWORD_NULL;
	        };
	
	        Convert.convertValue = function(value, valueType, convert, ignoreBlank) {
	            if (Convert.err(value)) {
	                return value;
	            }
	            var refValue = {value: KEYWORD_NULL};
	            var error = Convert.CalcConvertedError;
	            if (ignoreBlank && valueType !== 0 /* anyType */ && (value === KEYWORD_NULL || value === KEYWORD_UNDEFINED)) {
	                return error;
	            }
	            switch (valueType) {
	                case 1 /* numberType */
	                :
	                    if (!convert) {
	                        if ((typeof value) !== CONST_NUMBER && !(value instanceof Date)) {
	                            value = error;
	                        }
	                    } else {
	                        if (Convert.rD(value, refValue)) {
	                            value = refValue.value;
	                        } else {
	                            value = error;
	                        }
	                    }
	                    break;
	                case 4 /* dateType */
	                :
	                    if (typeof (value) === CONST_STRING) {
	                        var date = Convert._parseLocale(value);
	                        if (typeof date !== CONST_UNDEFINED && date !== KEYWORD_NULL) {
	                            value = Convert._toOADate(date);
	                        } else {
	                            value = error;
	                        }
	                    } else if (!convert) {
	                        if ((typeof value) !== CONST_NUMBER && !(value instanceof Date)) {
	                            value = error;
	                        }
	                    } else {
	                        if (Convert.rD(value, refValue)) {
	                            value = refValue.value;
	                        } else {
	                            value = error;
	                        }
	                    }
	                    break;
	                case 3 /* booleanType */
	                :
	                    if (!convert) {
	                        if ((typeof value) !== CONST_BOOLEAN) {
	                            value = error;
	                        }
	                    } else {
	                        if (Convert.rB(value, refValue)) {
	                            value = refValue.value;
	                        } else {
	                            value = false;
	                        }
	                    }
	                    break;
	                case 2 /* stringType */
	                :
	                    value = value === KEYWORD_NULL || value === KEYWORD_UNDEFINED ? '' : value.toString();
	                    break;
	            }
	            return value;
	        };
	
	        Convert._isNaNOrInfinite = function(value) {
	            return isNaN(value) || !isFinite(value);
	        };
	
	        // toInt, use I for code size.
	        Convert.I = function(value) {
	            var dVal = Convert.D(value);
	            if (MATH_ABS(dVal) < 1E+21) {
	                return parseInt(dVal, 10);
	            }
	
	            throwSR('Exp_InvalidCast');
	        };
	
	        // toDouble, use D for code size.
	        Convert.D = function(value) {
	            var doubleValue = {value: 0};
	            if (Convert.rD(value, doubleValue)) {
	                return doubleValue.value;
	            }
	            throwSR(invalidCast);
	            ;
	        };
	
	        // tryToDouble, use rD for code size.
	        Convert.rD = function(value, doubleValue) {
	            var result = KEYWORD_NULL;
	            if (typeof value === CONST_UNDEFINED || value === KEYWORD_NULL) {
	                doubleValue.value = 0;
	                return true;
	            }
	            var typestr = typeof value;
	            try {
	                if (typestr === CONST_NUMBER) {
	                    result = new Number(value).valueOf();
	                    if (Convert._isNaNOrInfinite(result)) {
	                        return false;
	                    }
	                } else if (typestr === CONST_STRING) {
	                    // Cylj comment this code at 2014/2/11.
	                    // This code will take the performence problem, and SpreadX dose not have
	                    // this code too.
	                    //var date = spread._DateTimeHelper.parseLocale(value);
	                    //if (typeof date !== const_undefined && date !== keyword_null)
	                    //    result = new spread._DateTimeHelper(date).toOADate();
	                    //else {
	                    value = value.trim();
	                    if (value.length === 0) {
	                        doubleValue.value = 0;
	                        return true;
	                    }
	                    var isPercent = false;
	                    if (value.charAt(value.length - 1) === '%') {
	                        isPercent = true;
	                        value = value.substr(0, value.length - 1);
	                    }
	                    result = new Number(value).valueOf();
	                    if (Convert._isNaNOrInfinite(result)) {
	                        return false;
	                    }
	                    if (isPercent) {
	                        result /= 100;
	                    }
	                    //}
	                } else if (typestr === CONST_BOOLEAN) {
	                    result = value ? 1 : 0;
	                } else if (value instanceof Date) {
	                    result = Convert._toOADate(value);
	                } else {
	                    return false;
	                }
	            } catch (ex) {
	                return false;
	            }
	            doubleValue.value = result;
	            return true;
	        };
	
	        // tryToBool, use rB for code size.
	        Convert.rB = function(value, boolValue) {
	            try {
	                if (typeof value === CONST_UNDEFINED || value === KEYWORD_NULL) {
	                    return false;
	                } else if (typeof value === CONST_BOOLEAN) {
	                } else if (value instanceof Date) {
	                    value = Convert._toOADate(value) !== 0;
	                } else if (Convert.num(value)) {
	                    value = value !== 0;
	                } else {
	                    throwSR(invalidCast);
	                }
	            } catch (ex) {
	            }
	            boolValue.value = value;
	            return true;
	        };
	
	        // toBool, use B for code size.
	        Convert.B = function(value) {
	            if (typeof value === CONST_UNDEFINED || value === KEYWORD_NULL) {
	                return false;
	            } else if (typeof value === CONST_BOOLEAN) {
	                return value;
	            } else if (value instanceof Date) {
	                return Convert._toOADate(value) !== 0;
	            } else if (Convert.num(value)) {
	                return value !== 0;
	            } else if (Convert.err(value)) {
	                return false;
	            } else {
	                throwSR(invalidCast);
	                ;
	            }
	        };
	
	        // toString, use S for code size.
	        Convert.S = function(value) {
	            try {
	                if (typeof value === CONST_UNDEFINED || value === KEYWORD_NULL) {
	                    return '';
	                } else if (typeof value === CONST_BOOLEAN) {
	                    return value ? CONST_TRUE : CONST_FALSE;
	                } else if (typeof value === CONST_STRING) {
	                    return value;
	                } else if (value instanceof Date) {
	                    // TODO
	                    //return new _DateTimeHelper(value).localeFormat('M/d/yyyy h:mm:ss');
	                } else if (Convert.arr(value)) {
	                    throwSR(invalidCast);
	                    ;
	                } else {
	                    return value.toString();
	                }
	            } catch (err) {
	                throwSR(invalidCast);
	                ;
	            }
	        };
	
	        // toDateTime, use DT for code size.
	        Convert.DT = function(value) {
	            var dateValue = {value: KEYWORD_NULL};
	            if (Convert.rDT(value, dateValue)) {
	                return dateValue.value;
	            }
	            throwSR(invalidCast);
	            ;
	        };
	
	        // tryToDateTime, use rDT for code size.
	        Convert.rDT = function(value, dateValue) {
	            if (typeof value === CONST_UNDEFINED || value === KEYWORD_NULL) {
	                dateValue.value = Convert._fromOADate(0);
	            } else if (value instanceof Date) {
	                dateValue.value = new Date(value);
	            } else if (typeof value === CONST_STRING) {
	                // TODO
	                var dateTime = Convert._parseLocale(value);
	                if ((typeof dateTime === CONST_UNDEFINED || dateTime === KEYWORD_NULL) && !isNaN(value)) {
	                    dateTime = Convert._fromOADate(parseFloat(value));
	                }
	                if (dateTime === KEYWORD_UNDEFINED || dateTime === KEYWORD_NULL) {
	                    return false;
	                }
	                dateValue.value = dateTime;
	            } else if (typeof value === CONST_NUMBER) {
	                dateValue.value = Convert._fromOADate(value);
	            } else {
	                return false;
	            }
	            return true;
	        };
	
	        // 1440: 60*24  oneDayMinute
	        // 86400000: oneDayMillSeconds
	        // 25569: oaDate of 1970/1/1
	        // Date.getTime() mill seconds from 1970/1/1(UTC)
	        Convert._toOADate = function(date) {
	            if (date === KEYWORD_UNDEFINED || date === KEYWORD_NULL) {
	                return 0;
	            }
	            if (typeof date === 'number') {
	                date = new Date(date);
	            }
	
	            //return (date.getTime() / 86400000) + 25569 - date.getTimezoneOffset() / 1440;
	            // multiply 86400000 and 1440 first then do divide. it will cause some float precision error if the order is not.
	            return (date.getTime() * 1440 + 25569 * 86400000 * 1440 - date.getTimezoneOffset() * 86400000) / (86400000 * 1440);
	        };
	
	        Convert._fromOADate = function(oadate) {
	            var offsetDay = oadate - 25569;
	            var date = new Date(offsetDay * 86400000);
	
	            // multiply 86400000 first then do divide. it will cause some float precision error if the order is not.
	            // 2014/10/17 ben.yin here is a '+1' or '-1', is for javascript divide low precision, it will loss last digit precision.So here add 1, for loss, for result right.
	            // add 1 when after 1987, sub 1 when before 1987
	            var adjustValue = offsetDay >= 0 ? 1 : -1;
	            return new Date((oadate * 86400000 * 1440 + adjustValue - 25569 * 86400000 * 1440 + date.getTimezoneOffset() * 86400000) / 1440);
	        };
	
	        // TODO
	        Convert._parseLocale = function(value) {
	            return new Date(value);
	        };
	        Convert.CalcConvertedError = {};
	        return Convert;
	    })();
	    Calc.Convert = Convert;
	
	    var _Helper = (function() {
	        function _Helper() {
	        }
	
	        _Helper._argumentExists = function(args, index) {
	            return args && index < args.length && (args[index] !== Calc.missingArgument);
	        };
	        _Helper._argumentValid = function(args, index) {
	            if (!args) {
	                return false;
	            }
	            var arg = args[index];
	            return arg !== Calc.missingArgument && arg !== KEYWORD_NULL && arg !== KEYWORD_UNDEFINED && !arg._error;
	        };
	        return _Helper;
	    })();
	    Calc._Helper = _Helper;
	
	    var StringUtil = (function() {
	        function StringUtil() {
	        }
	
	        StringUtil.replace = function(src, substr, replacement) {
	            return src.split(substr).join(replacement);
	        };
	
	        StringUtil.startsWith = function(src, prefix) {
	            return src.indexOf(prefix) === 0;
	        };
	
	        StringUtil.endsWith = function(src, suffix) {
	            var l = src.length - suffix.length;
	            return l >= 0 && src.indexOf(suffix, l) === l;
	        };
	
	        StringUtil.leftBefore = function(src, suffex) {
	            var index = src.indexOf(suffex);
	            if (index < 0 || index >= src.length) {
	                return src;
	            } else {
	                return src.substr(0, index);
	            }
	        };
	
	        StringUtil.contains = function(src, ss) {
	            return src.indexOf(ss) >= 0;
	        };
	
	        StringUtil.count = function(src, ss) {
	            var count = 0;
	            var pos = src.indexOf(ss);
	            while (pos >= 0) {
	                count += 1;
	                pos = src.indexOf(ss, pos + 1);
	            }
	            return count;
	        };
	        return StringUtil;
	    })();
	    Calc.StringUtil = StringUtil;
	
	    var RegUtil = (function() {
	        function RegUtil() {
	        }
	
	        RegUtil.getReg = function(regStr) {
	            var reg = RegUtil.regDict[regStr];
	            if (!reg) {
	                reg = RegUtil.regDict[regStr] = new RegExp(regStr, 'g');
	            }
	            reg.lastIndex = 0;
	            return reg;
	        };
	
	        RegUtil.getRegIgnoreCase = function(regStr) {
	            var reg = RegUtil.regDictIgnoreCase[regStr];
	            if (!reg) {
	                reg = RegUtil.regDictIgnoreCase[regStr] = new RegExp(regStr, 'gi');
	            }
	            reg.lastIndex = 0;
	            return reg;
	        };
	
	        RegUtil.getWildcardCriteria = function(criteria) {
	            if (RegUtil.wildcardParseRecord[criteria]) {
	                return RegUtil.wildcardParseResultBuffer[criteria];
	            }
	            if (RegUtil.getReg('[~?*]+').test(criteria)) {
	                var criteriaTemp = criteria;
	                var asteriskSymbol = RegUtil.getReplaceSymbol('asterisk', criteriaTemp);
	                var questionSymbol = RegUtil.getReplaceSymbol('question', criteriaTemp);
	                var tildeSymbol = RegUtil.getReplaceSymbol('tilde', criteriaTemp);
	
	                criteriaTemp = StringUtil.replace(criteriaTemp, '~~', tildeSymbol);
	                criteriaTemp = StringUtil.replace(criteriaTemp, '~*', asteriskSymbol);
	                criteriaTemp = StringUtil.replace(criteriaTemp, '~?', questionSymbol);
	
	                criteriaTemp = criteriaTemp.replace(RegUtil.getReg('([.+$^\\[\\](){}|\/])'), '\\$1');
	                criteriaTemp = StringUtil.replace(criteriaTemp, '*', '.*');
	                criteriaTemp = StringUtil.replace(criteriaTemp, '?', '.');
	
	                criteriaTemp = StringUtil.replace(criteriaTemp, asteriskSymbol, '\\*');
	                criteriaTemp = StringUtil.replace(criteriaTemp, questionSymbol, '\\?');
	                criteriaTemp = StringUtil.replace(criteriaTemp, tildeSymbol, '~');
	                RegUtil.wildcardParseResultBuffer[criteria] = criteriaTemp;
	                RegUtil.wildcardParseRecord[criteria] = true;
	                return criteriaTemp;
	            }
	
	            return KEYWORD_NULL;
	        };
	
	        RegUtil.getWildcardCriteriaFullMatch = function(criteria) {
	            var criteriaTemp = RegUtil.getWildcardCriteria(criteria);
	            if (criteriaTemp) {
	                criteriaTemp = '^' + criteriaTemp + '$';
	            }
	            return criteriaTemp;
	        };
	
	        RegUtil.getReplaceSymbol = function(expectSymbol, srcStr) {
	            var asteriskSymbol = '#' + expectSymbol + '0#';
	            for (var i = 1; i < 10000; i++) {
	                if (srcStr.indexOf(asteriskSymbol) > 0) {
	                    asteriskSymbol = StringUtil.replace(asteriskSymbol, '#' + expectSymbol + (i - 1) + '#', '#' + expectSymbol + i + '#');
	                    continue;
	                }
	                return asteriskSymbol;
	            }
	        };
	        RegUtil.regDict = {};
	        RegUtil.regDictIgnoreCase = {};
	        RegUtil.wildcardParseRecord = {};
	        RegUtil.wildcardParseResultBuffer = {};
	        return RegUtil;
	    })();
	    Calc.RegUtil = RegUtil;
	
	    var CalcError = (function() {
	        /**
	         * Represents an error in calculation.
	         * @class
	         * @param {string} error The description of the error.
	         * @param {number} errorCode The error code.
	         */
	        function CalcError(error, errorCode) {
	            this._error = error;
	            this._code = errorCode;
	        }
	
	        /**
	         * Returns a string that represents this instance.
	         * @returns {string} The error string.
	         */
	        CalcError.prototype.toString = function() {
	            return this._error;
	        };
	
	        /**
	         * Parses the specified error from the string.
	         * @param {string} value The error string.
	         * @returns {$.wijmo.wijspread.Calc.Error} The calculation error.
	         */
	        CalcError.parse = function(value) {
	            var err = CalcError._parseCore(value);
	            if (err === KEYWORD_UNDEFINED) {
	                throw 'Incorrect error!';
	            }
	            return err;
	        };
	
	        CalcError._parseCore = function(value) {
	            if (typeof value !== CONST_UNDEFINED && value !== KEYWORD_NULL && value !== '') {
	                for (var i = 0; i < ERROR_LIST.length; i++) {
	                    var errItem = ERROR_LIST[i];
	                    if (errItem === value || errItem === value.toUpperCase()) {
	                        return new CalcError(errItem, ERRORCODE_LIST[i]);
	                    }
	                }
	            }
	            return KEYWORD_UNDEFINED;
	        };
	        return CalcError;
	    })();
	    Calc.CalcError = CalcError;
	
	    Calc.CalcErrorsNull = new CalcError(CONST_NULL, 0x00);
	    Calc.CalcErrorsDivideByZero = new CalcError(CONST_DIV0, 0x07);
	    Calc.CalcErrorsValue = new CalcError(CONST_VALUE, 0x0F);
	    Calc.CalcErrorsReference = new CalcError(CONST_REF, 0x17);
	    Calc.CalcErrorsName = new CalcError(CONST_NAME, 0x1D);
	    Calc.CalcErrorsNotAvailable = new CalcError(CONST_NA, 0x2A);
	    Calc.CalcErrorsNumber = new CalcError(CONST_NUM, 0x24);
	
	    /**
	     * Represents an Errors object that lists all the supported errors.
	     * @class $.wijmo.wijspread.Calc.Errors
	     */
	    var Errors = (function() {
	        function Errors() {
	        }
	
	        Errors.Null = Calc.CalcErrorsNull;
	
	        Errors.DivideByZero = Calc.CalcErrorsDivideByZero;
	
	        Errors.Value = Calc.CalcErrorsValue;
	
	        Errors.Reference = Calc.CalcErrorsReference;
	
	        Errors.Name = Calc.CalcErrorsName;
	
	        Errors.NotAvailable = Calc.CalcErrorsNotAvailable;
	
	        Errors.Number = Calc.CalcErrorsNumber;
	        return Errors;
	    })();
	    Calc.Errors = Errors;
	
	    var ParserConstants = (function() {
	        function ParserConstants() {
	        }
	
	        ParserConstants.BAND_INDEX_CONST = -2147483648;
	        ParserConstants.maxRowCount = 1048576;
	        ParserConstants.maxColumnCount = 16384;
	        return ParserConstants;
	    })();
	    Calc.ParserConstants = ParserConstants;
	
	    var CalcColumnReference = (function() {
	        /**
	         * Represents an area referenced in a spread sheet.
	         * @class $.wijmo.wijspread.Calc.Reference
	         */
	        function CalcColumnReference(calcSource, column) {
	            var self = this;
	            self.calcSource = calcSource;
	            self.column = column;
	            self.dataType = calcSource.getDataType(column);
	        }
	
	        CalcColumnReference.prototype.getValue = function(index, groupPath) {
	            var self = this;
	            if (index == -1) {
	                return self.calcSource.getValues(self.column, groupPath);
	            } else {
	                return self.calcSource.getValue(self.column, index, groupPath);
	            }
	        };
	        return CalcColumnReference;
	    })();
	    Calc.CalcColumnReference = CalcColumnReference;
	
	    var CalcTableReference = (function() {
	        /**
	         * Represents an area referenced in a spread sheet.
	         * @class $.wijmo.wijspread.Calc.Reference
	         */
	        function CalcTableReference(calcSource) {
	            var self = this;
	            self.calcSource = calcSource;
	            self.name = calcSource.getName();
	        }
	
	        CalcTableReference.prototype.toArray = function() {
	            return this.calcSource.toArray();
	        }
	
	        return CalcTableReference;
	    })();
	    Calc.CalcTableReference = CalcTableReference;
	
	    var CalcFieldReference = (function() {
	        /**
	         * Represents an area referenced in a spread sheet.
	         * @class $.wijmo.wijspread.Calc.Reference
	         */
	        function CalcFieldReference(calcSource, name) {
	            var self = this;
	            self.calcSource = calcSource;
	            self.name = name;
	        }
	
	        CalcFieldReference.prototype.getValue = function() {
	            var self = this;
	            return self.calcSource.getFieldValue(self.name);
	        };
	        return CalcFieldReference;
	    })();
	    Calc.CalcFieldReference = CalcFieldReference;
	    /* jshint ignore:end */
	})();


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 *
	 * SpreadJS Library 1.0.0
	 * http://wijmo.com/
	 *
	 * Copyright(c) GrapeCity, Inc.  All rights reserved.
	 *
	 * Licensed under the Wijmo Commercial License. Also available under the GNU GPL Version 3 license.
	 * licensing@wijmo.com
	 * http://wijmo.com/widgets/license/
	 *
	 *
	 **/
	
	(function() {
	    'use strict';
	    var KEYWORD_UNDEFINED = undefined; // jshint ignore:line
	
	    var EvaluateContext = (function() {
	        function EvaluateContext(calcSource, currentRow, groupPath) {
	            var self = this;
	            self.calcSource = calcSource;
	            self.currentRow = currentRow;
	            self.groupPath = groupPath;
	            self.expandArrayToMultiCallCount_ = 0;
	            self.aggregatingCount_ = 0;
	            self.filteringCount_ = 0;
	            self.currentRowInternal_ = KEYWORD_UNDEFINED;
	        }
	
	        EvaluateContext.prototype = {
	            getCurrentRow: function() {
	                var self = this;
	                if (self.currentRow !== KEYWORD_UNDEFINED) {
	                    return self.currentRow;
	                }
	                if (self.isAggregating_() || self.isFiltering_()) {
	                    return -1;
	                } else if (self.currentRowInternal_ !== KEYWORD_UNDEFINED) {
	                    return self.currentRowInternal_;
	                } else {
	                    return -1;
	                }
	            },
	
	            isAggregating_: function() {
	                return this.aggregatingCount_ > 0;
	            },
	            beginAggregating_: function() {
	                this.aggregatingCount_++;
	            },
	            endAggregating_: function() {
	                this.aggregatingCount_--;
	            },
	
	            isFiltering_: function() {
	                return this.filteringCount_ > 0;
	            },
	            beginFilter_: function() {
	                this.filteringCount_++;
	            },
	            endFilter_: function() {
	                this.filteringCount_--;
	            }
	        };
	        return EvaluateContext;
	    })();
	    var ParserContext = (function() {
	        function ParserContext(calcSource, option) {
	            var self = this;
	            self.calcSource = calcSource;
	            self.option = option;
	        }
	
	        return ParserContext;
	    })();
	
	    module.exports = {
	        EvaluateContext: EvaluateContext,
	        ParserContext: ParserContext
	    };
	})();


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 *
	 * SpreadJS Library 1.0.0
	 * http://wijmo.com/
	 *
	 * Copyright(c) GrapeCity, Inc.  All rights reserved.
	 *
	 * Licensed under the Wijmo Commercial License. Also available under the GNU GPL Version 3 license.
	 * licensing@wijmo.com
	 * http://wijmo.com/widgets/license/
	 *
	 *
	 **/
	
	(function() {
	    'use strict';
	    var Calc = __webpack_require__(9);
	    var CalcExpressions = __webpack_require__(12);
	    var CalcContext = __webpack_require__(10);
	    var CalcFunctions = __webpack_require__(19);
	
	    var SRHelper = Calc.SRHelper;
	    var throwSR = SRHelper.throwSR;
	    var sr = SRHelper.sr;// jshint ignore:line
	    var cr = SRHelper.cr;// jshint ignore:line
	
	    var notSupport = 'Exp_NotSupport';
	    var invalidArr = 'Exp_InvalidArray';// jshint ignore:line
	    var atIndexOn = 'AtIndexOn';
	    var singleQuote = 'SingleQuote';
	    var fullStop = 'FullStop';
	    var formulaInvalid = 'Exp_FormulaInvalid';
	    var invalidTokenAt = 'Exp_InvalidTokenAt';
	    var invalidPara = 'Exp_InvalidParameters';
	    var noSyntax = 'Exp_NoSyntax';
	    var matchSyntax = 'Exp_MatchSyntax';
	    var singleQuotesFullStop = 'SingleQuotesFullStop';
	    var isValid = 'Exp_IsValid'; // jshint ignore:line
	    var invalidArrayAt = 'Exp_InvalidArrayAt';
	    var singleQuoteAt = 'SingleQuoteAt';// jshint ignore:line
	
	    var CalcParser = {};
	    module.exports = CalcParser;
	
	    var CONST_UNDEFINED = 'undefined';
	    var CONST_NUMBER = 'number';// jshint ignore:line
	    var CONST_STRING = 'string';
	    var CONST_BOOLEAN = 'boolean';
	    var CONST_TRUE = 'TRUE';
	    var CONST_FALSE = 'FALSE';
	    var CONST_ARRAY = 'ARRAY';
	    var CONST_ARRAYROW = 'ARRAYROW';
	    var CONST_NULL = '#NULL!';
	    var CONST_DIV0 = '#DIV/0!';
	    var CONST_VALUE = '#VALUE!';
	    var CONST_REF = '#REF!';
	    var CONST_NAME = '#NAME?';
	    var CONST_NA = '#N/A';
	    var CONST_NUM = '#NUM!';
	    var CONST_EXPR = 'expr';// jshint ignore:line
	    var CONST_ARRAYINFO = 'arrayInfo';// jshint ignore:line
	    var CONST_WORKINGEXPR = 'workingExpr';// jshint ignore:line
	    var ERROR_LIST = [CONST_NULL, CONST_DIV0, CONST_VALUE, CONST_REF, CONST_NAME, CONST_NA, CONST_NUM];
	    var ERRORCODE_LIST = [0x00, 0x07, 0x0F, 0x17, 0x1D, 0x2A, 0x24];// jshint ignore:line
	    var LETTER_POWS = [1, 26, 676];// jshint ignore:line
	    var KEYWORD_NULL = null;
	    var KEYWORD_UNDEFINED = undefined;// jshint ignore:line
	    var SUPPROT_ROW_COLUMN_FORMULA = false;// jshint ignore:line
	    var MATH_MIN = Math.min;// jshint ignore:line
	    var MATH_MAX = Math.max;// jshint ignore:line
	    var MATH_ABS = Math.abs;
	    var MATH_POW = Math.pow;
	
	    //<editor-fold desc='Char Helper'>
	    var NumberState = {
	        None: 0,
	        Sign: 1,
	        Int: 2,
	        Dot: 3,
	        Decimal: 4,
	        Exponent: 5,
	        SignExponent: 6,
	        ScientificNotation: 7,
	        Number: 8
	    };
	
	    var LatinUnicodeCategory = {
	        UppercaseLetter: 0x00,
	        LowercaseLetter: 0x01,
	        DecimalDigitNumber: 0x08,
	        OtherNumber: 0x0a,
	        SpaceSeparator: 0x0b,
	        Control: 0x0e,
	        ConnectorPunctuation: 0x12,
	        DashPunctuation: 0x13,
	        OpenPunctuation: 0x14,
	        ClosePunctuation: 0x15,
	        InitialQuotePunctuation: 0x16,
	        FinalQuotePunctuation: 0x17,
	        OtherPunctuation: 0x18,
	        MathSymbol: 0x19,
	        currencySymbol: 0x1a,
	        ModifierSymbol: 0x1b,
	        OtherSymbol: 0x1c
	    };
	    var categoryForLatin1 = [
	        0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	        0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	        0xb, 0x18, 0x18, 0x18, 0x1a, 0x18, 0x18, 0x18, 0x14, 0x15, 0x18, 0x19, 0x18, 0x13, 0x18, 0x18,
	        0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x18, 0x18, 0x19, 0x19, 0x19, 0x18,
	        0x18, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x14, 0x18, 0x15, 0x1b, 0x12,
	        0x1b, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	        0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x14, 0x19, 0x15, 0x19, 0xe,
	        0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	        0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	        0xb, 0x18, 0x1a, 0x1a, 0x1a, 0x1a, 0x1c, 0x1c, 0x1b, 0x1c, 0x1, 0x16, 0x19, 0x13, 0x1c, 0x1b,
	        0x1c, 0x19, 0xa, 0xa, 0x1b, 0x1, 0x1c, 0x18, 0x1b, 0xa, 0x1, 0x17, 0xa, 0xa, 0xa, 0x18,
	        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x19, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1,
	        0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	        0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x19, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1
	    ];
	
	    var Parser = (function() {
	        function Parser(option) {
	            if ((typeof (option) === CONST_UNDEFINED || option === KEYWORD_NULL)) {
	                return;
	            }
	            Parser.setParserOption(option);
	        }
	
	        Parser.setParserOption = function(option) {
	            Parser.listSeparator = getProperty(option, 'listSeparator', ',');
	            Parser.numberDecimalSeparator = getProperty(option, 'numberDecimalSeparator', '.');
	            Parser.arrayGroupSeparator = getProperty(option, 'arrayGroupSeparator', ';');
	            Parser._arrayArgumentSepatator = (Parser.listSeparator === Parser.arrayGroupSeparator) ? '\\' : Parser.listSeparator;
	            Parser._operatorInfix = '\\+-*/^&=><: ' + Parser.listSeparator;
	        };
	
	        Parser.getParserOption = function() {
	            var option = {
	                'numberDecimalSeparator': Parser.numberDecimalSeparator,
	                'listSeparator': Parser.listSeparator,
	                'arrayGroupSeparator': Parser.arrayGroupSeparator
	            };
	            return option;
	        };
	
	        /**
	         * Parses a string formula to the expression using the specified ParserContext.
	         * @param {string} formula A string formula.
	         * @param {$.wijmo.wijspread.Calc.ParserContext} context The parser context setting.
	         * @returns {$.wijmo.wijspread.CalcExpressions.Expression} The expression for the parsed string formula.
	         */
	        Parser.prototype.parse = function(formula, context) {
	            var self = this;
	            if (!context) {
	                return KEYWORD_NULL;
	            }
	            if (context.option) {
	                Parser.setParserOption(context.option);
	            }
	            var tokens = self._parseToToken(formula);
	            return self._buildExpressionTree(context, tokens);
	        };
	
	        /**
	         * Unparses a CalcExpression to a string using the specified ParserContext.
	         * @param {$.wijmo.wijspread.CalcExpressions.Expression} expr An expression that indicates the expression tree.
	         * @param {$.wijmo.wijspread.Calc.ParserContext} context The parser context setting.
	         * @returns {string} The specified CalcExpression as a string.
	         */
	        Parser.prototype.unparse = function(expr, context) {
	            Parser.unparseWithoutCulture = false;
	            if (!expr) {
	                return '';
	            }
	            if (!context) {
	                context = new CalcContext.ParserContext(KEYWORD_NULL);
	            }
	            if (context.option) {
	                Parser.setParserOption(context.option);
	            }
	            var formula = {content: ''};
	            this._unparseExpression(expr, context, formula);
	            return formula.content;
	        };
	
	        Parser.prototype.unparseWithoutCulture = function(expr, context) {
	            Parser.unparseWithoutCulture = true;
	            if (!expr) {
	                return '';
	            }
	            if (!context) {
	                context = new CalcContext.ParserContext(KEYWORD_NULL);
	            }
	            if (context.option) {
	                Parser.setParserOption(context.option);
	            }
	            var formula = {content: ''};
	            this._unparseExpression(expr, context, formula);
	            Parser.unparseWithoutCulture = false;
	            return formula.content;
	        };
	
	        // unparse
	        Parser.prototype._unparseExpression = function(expr, context, formula) {
	            var self = this;
	            if (expr instanceof Calc.Expressions.ConstantExpression) {
	                self._unparseConstantExpression(expr, context, formula);
	            } else if (expr instanceof Calc.Expressions.OperatorExpression) {
	                self._unParseOperatorExpressions(expr, context, formula);
	            } else if (expr instanceof Calc.Expressions.StructReferenceExpression) {
	                self._unParseStructExpression(expr, context, formula);
	            } else if (expr.t === 8 /* Parentheses */) {
	                formula.content += '(';
	                self._unparseExpression(expr.argument, context, formula);
	                formula.content += ')';
	            } else if (expr.t === 3 /* Function */) {
	                formula.content += expr.getFunctionName();
	                formula.content += '(';
	                for (var i = 0; i < expr.argCount(); i++) {
	                    if (i !== 0) {
	                        if (Parser.unparseWithoutCulture) {
	                            formula.content += ',';
	                        } else {
	                            // TODO global listSpeparator
	                            //formula.content += spread.CR.listSeparator;
	                        }
	                    }
	                    self._unparseExpression(expr.getArg(i), context, formula);
	                }
	                formula.content += ')';
	            } else {
	                throwSR(notSupport);
	            }
	        };
	
	        /* jshint ignore:start */
	        Parser.prototype._unparseSource = function(source, context, formula) {
	            return '';
	        };
	        /* jshint ignore:end */
	
	        Parser.prototype._removeApostrophe = function(formula) {
	            var formulaContent = formula.content;
	            var length = formulaContent.length;
	            if (formulaContent.charAt(length - 1) === '\'') {
	                formula.content = formulaContent.substr(1, length - 2);
	                return true;
	            }
	            return false;
	        };
	
	        Parser.prototype._removeWorkbook = function(formula) {
	            if (formula.content.charAt(0) !== '[') {
	                return {success: false, workBookName: ''};
	            }
	            var index = formula.content.indexOf(']');
	            var workBookName = formula.content.substr(0, index + 1);
	            formula.content = formula.content.substr(index);
	            return {success: true, workBookName: workBookName};
	        };
	
	        /* jshint ignore:start */
	        Parser.prototype._unParseOperatorExpressions = function(expr, context, formula) {
	            var self = this;
	            if (expr.t === 5 /* UnaryOperator */) {
	                var op = expr.operator;
	                if (op === Operators.percent) {
	                    self._unparseExpression(expr.operand, context, formula);
	                    formula.content += op.name;
	                } else {
	                    formula.content += op.name;
	                    self._unparseExpression(expr.operand, context, formula);
	                }
	            } else if (expr.t === 4 /* BinaryOperator */) {
	                var leftPart = {content: ''};
	                var rightPart = {content: ''};
	                self._unparseExpression(expr.right, context, rightPart);
	                var leftIsBin = expr.left.t === 4 /* BinaryOperator */;
	                var rightIsBin = expr.right.t === 4 /* BinaryOperator */;
	                var priority = getOpeatorPriority(expr.operator.name);
	                if (leftIsBin && getOpeatorPriority(expr.left.operator.name) > priority) {
	                    leftPart.content += '(';
	                    self._unparseExpression(expr.left, context, leftPart);
	                    leftPart.content += ')';
	                } else {
	                    self._unparseExpression(expr.left, context, leftPart);
	                }
	                if (rightIsBin && getOpeatorPriority(expr.right.operator.name) > priority) {
	                    rightPart.content += '(';
	                    self._unparseExpression(expr.right, context, rightPart);
	                    rightPart.content += '(';
	                }
	                formula.content += leftPart.content;
	                formula.content += expr.operator.t === 5 /* UnaryOperator */ ? Parser.listSeparator : expr.operator.name;
	                formula.content += rightPart.content;
	            } else {
	                throwSR(notSupport);
	            }
	        };
	
	        Parser.prototype._unparseConstantExpression = function(expr, context, formula) {
	            var self = this;
	            var errMsg = sr(invalidArr);
	            if (expr.t === 1 /* String */) {
	                formula.content += '"';
	                formula.content += expr.value;
	                formula.content += '"';
	            } else if (expr.t === 0 /* Double */) {
	                var value = expr.originalValue;
	                if (!Parser.unparseWithoutCulture) {
	                    // TODO parser globalize
	                    //value = _NumberHelper.replaceNormalToCultureSymble(value.toString())
	                }
	                formula.content += value;
	            } else if (expr.t === 2 /* Boolean */) {
	                formula.content += expr.value ? CONST_TRUE : CONST_FALSE;
	            } else if (expr.t === 9 /* Array */) {
	                formula.content += '{';
	                var array = expr.value;
	                if (array.getRowCount() <= 0) {
	                    throw errMsg;
	                }
	                var bandIndex = Calc.ParserConstants.BAND_INDEX_CONST;
	                var colCount = bandIndex;
	                for (var rowIndex = 0; rowIndex < array.getRowCount(); rowIndex++) {
	                    if (rowIndex >= 1) {
	                        if (Parser.unparseWithoutCulture) {
	                            formula.content += ';';
	                        } else {
	                            formula.content += Parser.arrayGroupSeparator;
	                        }
	                    }
	                    for (var columnIndex = 0; columnIndex < array.getColumnCount(); columnIndex++) {
	                        if (colCount !== bandIndex && (colCount !== array.getColumnCount() || array.getColumnCount() === 0)) {
	                            throw errMsg;
	                        }
	                        if (columnIndex !== 0) {
	                            var arrayArgumentSepatator;
	                            if (Parser.unparseWithoutCulture) {
	                                arrayArgumentSepatator = ',';
	                            } else {
	                                arrayArgumentSepatator = (Parser.listSeparator === Parser.arrayGroupSeparator) ? '\\' : Parser.listSeparator;
	                            }
	                            formula.content += arrayArgumentSepatator;
	                        }
	                        var v = array.getValue(rowIndex, columnIndex);
	                        if (v === KEYWORD_UNDEFINED || v === KEYWORD_NULL) {
	                            throw errMsg;
	                        }
	                        if (v instanceof CalcExpressions.Expression) {
	                            self._unparseExpression(v, context, formula);
	                        } else {
	                            if (typeof v === CONST_STRING) {
	                                formula.content += '"';
	                                formula.content += v;
	                                formula.content += '"';
	                            } else if (typeof v === CONST_BOOLEAN) {
	                                formula.content += v ? CONST_TRUE : CONST_FALSE;
	                            } else if (!Parser.unparseWithoutCulture && typeof v === CONST_NUMBER) {
	                                // TODO parser globalize
	                                //formula.content += _NumberHelper.replaceNormalToCultureSymble(v.toString());
	                            } else {
	                                formula.content += v.toString();
	                            }
	                        }
	                    }
	                }
	                formula.content += '}';
	            } else if (expr.t === 7 /* ExternalError */) {
	                self._unparseSource(expr.source, context, formula);
	                formula.content += '!';
	                formula.content += expr.value.toString();
	            } else if (expr.t === 6 /* Error */) {
	                formula.content += expr.value.toString();
	            } else if (expr.t === 12 /* MissingArgument */) {
	                // do nothing.
	            } else {
	                throwSR(notSupport);
	            }
	        };
	
	        Parser.prototype._unParseStructExpressions = function(expr, context, formula) {
	            var self = this;
	            formula.content += expr.table;
	            if (expr.column) {
	                formula.content += '[';
	                formula.content += expr.column;
	                formula.content += ']';
	            }
	        };
	        /* jshint ignore:end */
	
	        Parser.prototype._parseToToken = function(formula, throwError) {
	            if (typeof throwError === 'undefined') {
	                throwError = true;
	            }
	            var self = this;
	            var len = formula.length;
	            var tokens1 = [];
	            var stack = [];
	            var stackEnd = -1;
	            var value = '';
	            var CONST_AT_INDEX_ON = sr(atIndexOn);
	            var currentToken;
	            var tokenStartIndex = 0;
	            var startIndex = 0;
	            var stackToken;
	            while (startIndex < len && formula.charAt(startIndex) === ' ') {
	                startIndex++;
	            }
	            if (formula.charAt(startIndex) === '=') {
	                startIndex++;
	            }
	            tokenStartIndex = startIndex;
	            for (var index = startIndex; index < len; index++) {
	                var currentChar = formula.charAt(index);
	                var rs;
	                var previous;
	                var endIndex;
	
	                if (currentChar === '"') {
	                    // double-quoted strings
	                    rs = readString(formula, index, '"', '"', throwError);
	                    if (rs) {
	                        tokens1.push(new FormulaToken(rs.result, 0 /* Operand */, index + 1, 3 /* Text */));
	                        index = rs.endIndex;
	                        tokenStartIndex = index + 1;
	                    } else {
	                        value += formula.substring(index, len);
	                        index = len - 1;
	                    }
	                } else if (currentChar === '\'') {
	                    // single-quoted strings (links), in path. such as 'She+ et1'!A1 + 2
	                    rs = readString(formula, index, '\'', '\'', throwError);
	                    if (rs) {
	                        value += '\'';
	                        value += rs.result;
	                        value += '\'';
	                        index = rs.endIndex;
	                    } else {
	                        value += '\'';
	                        index = index + 1;
	                    }
	                } else if (currentChar === '[') {
	                    // bracked strings (R1C1 range index or linked workbook name),
	                    // R[1]C[1]or[workbook1]sheet1!R1C1 or table1[#All]
	                    //rs = readString(formula, index, '[', ']');
	                    rs = readString2(formula, index, '[', ']', '\'', throwError); // table1[[#All], [col'[umn1]]
	                    if (rs) {
	                        //value += '[';
	                        value += rs.result;
	                        value += ']';
	                        index = rs.endIndex;
	                    } else {
	                        if (value === 'R' || value === 'r' || value === 'C' || value === 'c') {
	                            continue;
	                        }
	                        value += formula.substring(index, len);
	                        index = len - 1;
	                    }
	                } else if (currentChar === '\r' || currentChar === '\n') {
	                    continue;
	                } else if (currentChar === '#') {
	                    // error values, end marks a token, determined from absolute list of values
	                    var re = readError(formula, index);
	                    if (re) {
	                        var nextChar = index < len ? formula.charAt(index + 1) : '\0';
	                        if (index > 0 && formula.charAt(index - 1) === '!') {
	                            value += re.result;
	                        } else if (CONST_REF === re.result.toUpperCase() && index < len && (isLetterOrDigit(nextChar) || nextChar === '$')) {
	                            // #REF!A1  #REF!$A$1:$B$2
	                            value += re.result;
	                        } else {
	                            tokens1.push(new FormulaToken(re.result, 0 /* Operand */, index, 6 /* Error */));
	                            tokenStartIndex = index + 1;
	                        }
	                        index = re.endIndex;
	                    } else {
	                        value += currentChar;
	                        //tokens1.push(new FormulaToken(currentChar, ExcelFormulaTokenType.Unknown, index));
	                        //value = '';
	                        //tokenStartIndex = index + 1;
	                    }
	                } else if (currentChar === '+' || currentChar === '-') {
	                    previous = tokens1.length === 0 ? null : tokens1[tokens1.length - 1];
	                    if (value.length !== 0) {
	                        tokens1.push(new FormulaToken(value, 0 /* Operand */, tokenStartIndex));
	                        tokens1.push(new FormulaToken(currentChar, 5 /* OperatorInfix */, index));
	                        value = '';
	                        tokenStartIndex = index + 1;
	                    } else {
	                        if (previous && previous.type === 7 /* Whitespace */) {
	                            tokens1.pop();
	                            previous = tokens1[tokens1.length - 1];
	                        }
	                        if (previous && ((previous.type === 1 /* Function */ && previous.subType === 2 /* Stop */) || (previous.type === 2 /* Subexpression */ && previous.subType === 2 /* Stop */) || (previous.type === 6 /* OperatorPostfix */) || (previous.type === 0 /* Operand */))) {
	                            // binary operator
	                            tokens1.push(new FormulaToken(currentChar, 5 /* OperatorInfix */, index));
	                            tokenStartIndex = index + 1;
	                        } else {
	                            tokens1.push(new FormulaToken(currentChar, 4 /* OperatorPrefix */, index));
	                            tokenStartIndex = index + 1;
	                        }
	                    }
	                } else if (currentChar === Parser.numberDecimalSeparator || isDigit(currentChar)) {
	                    var isNum;
	                    if (value.length > 0) {
	                        value += currentChar;
	                    } else if ((isNum = isNumber2(formula, index, Parser.numberDecimalSeparator)).result) {
	                        endIndex = isNum.endIndex;
	                        var num = formula.slice(index, endIndex + 1);
	                        if (Parser.numberDecimalSeparator !== '.') {
	                            // TODO parser globalize
	                            //num = _NumberHelper.replaceCultureSymbolToNormal(num);
	                        }
	                        while (endIndex <= len - 2 && formula.charAt(endIndex + 1) === ' ') {
	                            endIndex++;
	                        }
	
	                        // in the formula SUM(1 : 2), 1 and 2 is a row reference, not a number.
	                        if (endIndex <= len - 2 && formula.charAt(endIndex + 1) === ':') {
	                            value += num;
	                            value += ':';
	                            endIndex++;
	                            tokenStartIndex = index;
	                        } else {
	                            tokens1.push(new FormulaToken(num, 0 /* Operand */, index, 4 /* Number */));
	                            tokenStartIndex = index + 1;
	                        }
	                        index = endIndex;
	                    } else {
	                        value += currentChar;
	                    }
	                } else if (currentChar === '{') {
	                    if (value.length > 0 && throwError) {
	                        throw sr(formulaInvalid) + sr(singleQuote) + '{' + CONST_AT_INDEX_ON + index + sr(fullStop);
	                    }
	                    currentToken = new FormulaToken(CONST_ARRAY, 1 /* Function */, index, 1 /* Start */);
	                    tokens1.push(currentToken);
	                    stack[++stackEnd] = currentToken;
	                    currentToken = new FormulaToken(CONST_ARRAYROW, 1 /* Function */, index, 1 /* Start */);
	                    tokens1.push(currentToken);
	                    stack[++stackEnd] = currentToken;
	                    tokenStartIndex = index + 1;
	                } else if (currentChar === Parser.arrayGroupSeparator && stackEnd >= 0 && (stack[stackEnd].value === CONST_ARRAY || stack[stackEnd].value === CONST_ARRAYROW)) {
	                    // the array separator
	                    if (value.length > 0) {
	                        tokens1.push(new FormulaToken(value, 0 /* Operand */, tokenStartIndex));
	                        value = '';
	                    }
	                    if (stackEnd < 0 && throwError) {
	                        throw sr(formulaInvalid) + sr(singleQuote) + currentChar + CONST_AT_INDEX_ON + index + sr(fullStop);
	                    }
	                    stackToken = stack[stackEnd--];
	                    stackToken = new FormulaToken(currentChar, stackToken.type, index, 2 /* Stop */);
	                    tokens1.push(stackToken);
	                    tokens1.push(new FormulaToken(Parser.listSeparator, 3 /* Argument */, index));
	                    currentToken = new FormulaToken(CONST_ARRAYROW, 1 /* Function */, index + 1, 1 /* Start */);
	                    tokens1.push(currentToken);
	                    stack[++stackEnd] = currentToken;
	                    tokenStartIndex = index + 1;
	                } else if (currentChar === '}') {
	                    if (value.length > 0) {
	                        tokens1.push(new FormulaToken(value, 0 /* Operand */, tokenStartIndex));
	                        value = '';
	                    }
	                    if (endIndex < 0 && throwError) {
	                        throw sr(formulaInvalid) + sr(singleQuote);
	                        //+currentChar + CONST_AT_INDEX_ON + index + sr(fullStop);
	                    }
	                    stackToken = stack[stackEnd--];
	                    stackToken = new FormulaToken(currentChar, stackToken.type, index, 2 /* Stop */);
	                    tokens1.push(stackToken);
	                    stackToken = stack[stackEnd--];
	                    stackToken = new FormulaToken(currentChar, stackToken.type, index, 2 /* Stop */);
	                    tokens1.push(stackToken);
	                    tokenStartIndex = index + 1;
	                } else if (currentChar === ' ') {
	                    var sIndex = index;
	                    index++;
	                    while ((index < len) && value.charAt(value.length - 1) === ' ') {
	                        index++;
	                    }
	                    if (value.length > 0 && value.charAt(value.length - 1) !== ':' && index < len && formula.charAt(index) !== ':') {
	                        tokens1.push(new FormulaToken(value, 0 /* Operand */, tokenStartIndex));
	                        value = '';
	                        tokens1.push(new FormulaToken('', 7 /* Whitespace */, sIndex));
	                    }
	                    tokenStartIndex = index;
	                    index--;
	                } else if ((index + 2) <= len && currentChar === '<' && formula.charAt(index + 1) === '=' || currentChar === '>' && formula.charAt(index + 1) === '=' || currentChar === '<' && formula.charAt(index + 1) === '>') {
	                    if (value.length > 0) {
	                        tokens1.push(new FormulaToken(value, 0 /* Operand */, tokenStartIndex));
	                        value = '';
	                    }
	                    tokens1.push(new FormulaToken(formula.slice(index, index + 2), 5 /* OperatorInfix */, index, 5 /* Logical */));
	                    index++;
	                    tokenStartIndex = index + 1;
	                } else if (currentChar === '%') {
	                    if (value.length > 0) {
	                        tokens1.push(new FormulaToken(value, 0 /* Operand */, tokenStartIndex));
	                        value = '';
	                    }
	                    tokens1.push(new FormulaToken(formula.charAt(index), 6 /* OperatorPostfix */, index));
	                    tokenStartIndex = index + 1;
	                } else if (currentChar === '+' || currentChar === '-' || currentChar === '*' || currentChar === '/' || currentChar === '=' || currentChar === '>' || currentChar === '<' || currentChar === '&' || currentChar === '^' || currentChar === '|') {
	                    // standard infix operators
	                    if (value.length > 0) {
	                        tokens1.push(new FormulaToken(value, 0 /* Operand */, tokenStartIndex));
	                        value = '';
	                    }
	                    if (currentChar === '&') {
	                        if (formula.charAt(index + 1) === '&') {
	                            tokens1.push(new FormulaToken('&&', 5 /* OperatorInfix */, index));
	                            tokenStartIndex = index + 1;
	                            index += 1;
	                            continue;
	                        }
	                    } else if (currentChar === '|') {
	                        if (formula.charAt(index + 1) === '|') {
	                            tokens1.push(new FormulaToken('||', 5 /* OperatorInfix */, index));
	                            tokenStartIndex = index + 1;
	                            index += 1;
	                        } else {
	                            value += currentChar;
	                        }
	                        continue;
	                    }
	                    tokens1.push(new FormulaToken(currentChar, 5 /* OperatorInfix */, index));
	                    tokenStartIndex = index + 1;
	                } else if (currentChar === '(') {
	                    // start sub expression or function
	                    if (value.length > 0) {
	                        var lastChar = value.charAt(value.length - 1);
	                        if (lastChar === ':' || lastChar === Parser.listSeparator || lastChar === ' ') {
	                            // A1:(A2,A3) | A1,(A2,A3)
	                            value = value.slice(0, value.length - 1);
	                            tokens1.push(new FormulaToken(value, 0 /* Operand */, tokenStartIndex, 7 /* RangeOrName */));
	                            tokens1.push(new FormulaToken(lastChar, 5 /* OperatorInfix */, index - 1, 0 /* Nothing */));
	                            currentToken = new FormulaToken('', 2 /* Subexpression */, index, 1 /* Start */);
	                            tokens1.push(currentToken);
	                            stack[++stackEnd] = currentToken;
	                        } else {
	                            //try A1:INDIRECT('B1')
	                            var refOpIndex = value.indexOf(':');
	                            var refOpToken = ':';
	                            if (refOpIndex === -1) {
	                                refOpIndex = value.indexOf(Parser.listSeparator);
	                                refOpToken = Parser.listSeparator;
	                            }
	                            if (refOpIndex === -1) {
	                                refOpIndex = value.indexOf(' ');
	                                refOpToken = ' ';
	                            }
	                            if (refOpIndex !== -1 && refOpIndex > 0) {
	                                tokens1.push(new FormulaToken(value.substr(0, refOpIndex), 0 /* Operand */, tokenStartIndex, 7 /* RangeOrName */));
	                                tokens1.push(new FormulaToken(refOpToken, 5 /* OperatorInfix */, tokenStartIndex + refOpIndex, 0 /* Nothing */));
	                                value = value.slice(refOpIndex + 1);
	                                currentToken = new FormulaToken(value.toUpperCase(), 1 /* Function */, tokenStartIndex + refOpIndex + 1, 1 /* Start */);
	                                tokens1.push(currentToken);
	                                stack[++stackEnd] = currentToken;
	                            } else {
	                                // function
	                                currentToken = new FormulaToken(value.toUpperCase(), 1 /* Function */, index - value.length, 1 /* Start */);
	                                tokens1.push(currentToken);
	                                stack[++stackEnd] = currentToken;
	                            }
	                        }
	                        value = '';
	                    } else {
	                        currentToken = new FormulaToken('', 2 /* Subexpression */, index, 1 /* Start */);
	                        tokens1.push(currentToken);
	                        stack[++stackEnd] = currentToken;
	                    }
	                    tokenStartIndex = index + 1;
	                } else if (currentChar === Parser.listSeparator || currentChar === Parser._arrayArgumentSepatator || currentChar === Parser.arrayGroupSeparator) {
	                    // function, sub expression, or array parameters, or operand unions
	                    if (value.length > 0) {
	                        tokens1.push(new FormulaToken(value, 0 /* Operand */, tokenStartIndex));
	                        value = '';
	                    }
	                    if (stackEnd < 0 || stack[stackEnd].type !== 1 /* Function */) {
	                        tokens1.push(new FormulaToken(Parser.listSeparator, 5 /* OperatorInfix */, index, 10 /* Union */));
	                    } else {
	                        tokens1.push(new FormulaToken(Parser._arrayArgumentSepatator, 3 /* Argument */, index));
	                    }
	                    tokenStartIndex = index + 1;
	                } else if (currentChar === ')') {
	                    if (value.length > 0) {
	                        tokens1.push(new FormulaToken(value, 0 /* Operand */, tokenStartIndex));
	                        value = '';
	                    }
	                    if (stackEnd < 0 && throwError) {
	                        throw sr(formulaInvalid) + sr(singleQuote);
	                        //+currentChar + CONST_AT_INDEX_ON + index + sr(fullStop);
	                    }
	                    stackToken = stack[stackEnd--];
	                    stackToken = new FormulaToken(currentChar, stackToken.type, index, 2 /* Stop */);
	                    tokens1.push(stackToken);
	                    tokenStartIndex = index + 1;
	                } else if (currentChar === ':') {
	                    // such as (A1 A2):B3
	                    if (value.length === 0 && tokens1[tokens1.length - 1].subType === 2 /* Stop */) {
	                        tokens1.push(new FormulaToken(':', 5 /* OperatorInfix */, index, 11 /* RangeOp */));
	                        tokenStartIndex = index + 1;
	                    } else {
	                        value += ':';
	                    }
	                } else {
	                    value += currentChar;
	                }
	            }
	            if (value.length > 0) {
	                tokens1.push(new FormulaToken(value, 0 /* Operand */, tokenStartIndex));
	            }
	
	            return self._processTokens(tokens1, throwError);
	        };
	
	        Parser.prototype._processTokens = function(tokens1, throwError) {
	            // remove unnecessary white-space tokens;
	            // identifying operand and infix-operator subtypes;
	            // pulling '@' from function names;
	            // process error tokens.
	            // build token tree.
	            var tokens2 = this._removeWhiteSpace(tokens1);
	            var stack = [];
	            var rootToken = new FormulaToken('', 8 /* Unknown */, 0, 1 /* Start */);
	            stack.push(rootToken);
	            var parent;
	            var length = tokens2.length;
	            for (var i = 0; i < length; i++) {
	                var currentToken = tokens2[i];
	                if (!currentToken) {
	                    continue;
	                }
	                var previous = i === 0 ? KEYWORD_NULL : tokens2[i - 1];
	                var next = i === length - 1 ? KEYWORD_NULL : tokens2[i + 1];
	
	                // determine the logical values
	                if (currentToken.type === 0 /* Operand */ && currentToken.subType === 0 /* Nothing */) {
	                    var value = currentToken.value.toUpperCase();
	                    if (value === CONST_TRUE || value === CONST_FALSE) {
	                        currentToken.subType = 5 /* Logical */;
	                        currentToken.value = value;
	                    } else {
	                        currentToken.subType = 7 /* RangeOrName */;
	                    }
	                } else if (currentToken.type === 1 /* Function */) {
	                    // remove the char '@' before the Function
	                    if (currentToken.value.length > 0) {
	                        if (currentToken.value.charAt(0) === '@') {
	                            currentToken.value = currentToken.value.substr(1);
	                        }
	                    }
	                }
	                if (stack.length === 0 && throwError) {
	                    throw sr(invalidTokenAt) + currentToken.index + sr(fullStop);
	                }
	                parent = stack[stack.length - 1];
	
	                // process the possible error tokens
	                if (parent.value === CONST_ARRAYROW) {
	                    if (throwError && (currentToken.type !== 3 /* Argument */ && currentToken.subType !== 6 /* Error */ && currentToken.subType !== 2 /* Stop */ && currentToken.subType !== 5 /* Logical */ && currentToken.subType !== 4 /* Number */ && currentToken.subType !== 3 /* Text */ && currentToken.type !== 4 /* OperatorPrefix */)) {
	                        throw sr(invalidArrayAt) + currentToken.index + sr(fullStop);
	                    }
	                }
	                switch (currentToken.type) {
	                    case 0 /* Operand */
	                    :
	                        if (throwError && (previous && (previous.type === 0 /* Operand */ || previous.type === 6 /* OperatorPostfix */ || previous.type === 1 /* Function */ && previous.subType === 2 /* Stop */ || previous.type === 2 /* Subexpression */ && previous.subType === 2 /* Stop */))) {
	                            throw sr(invalidTokenAt) + currentToken.index + sr(fullStop);
	                        }
	                        break;
	                    case 1 /* Function */
	                    :
	                    case 2 /* Subexpression */
	                    :
	                        if (currentToken.value === CONST_ARRAY && currentToken.type === 1 /* Function */ && currentToken.subType === 1 /* Start */ && !previous) {
	                            break;
	                        } else if (throwError && (currentToken.subType === 2 /* Stop */ && (!previous || previous.type === 4 /* OperatorPrefix */ || previous.type === 5 /* OperatorInfix */) || currentToken.subType === 1 /* Start */ && previous && (!next || previous.type === 6 /* OperatorPostfix */ || previous.subType === 2 /* Stop */))) {
	                            throw sr(invalidTokenAt) + currentToken.index + sr(fullStop);
	                        }
	                        if (throwError && (currentToken.subType === 2 /* Stop */ && currentToken.type === 2 /* Subexpression */ && previous.subType === 1 /* Start */)) {
	                            throw sr(invalidTokenAt) + currentToken.index + sr(fullStop);
	                        }
	                        if (throwError && (currentToken.subType === 2 /* Stop */ && currentToken.type === 1 /* Function */ && previous.type === 2 /* Subexpression */ && previous.subType === 1 /* Start */)) {
	                            throw sr(invalidTokenAt) + currentToken.index + sr(fullStop);
	                        }
	                        if (throwError && currentToken.subType === 1 /* Start */ && previous && (previous.type === 1 /* Function */ && previous.subType === 2 /* Stop */ || previous.type === 0 /* Operand */ || previous.type === 6 /* OperatorPostfix */)) {
	                            throw sr(invalidTokenAt) + currentToken.index + sr(fullStop);
	                        }
	                        break;
	                    case 3 /* Argument */
	                    :
	                        if (throwError && (!next || !previous || previous.type === 5 /* OperatorInfix */ || previous.type === 4 /* OperatorPrefix */)) {
	                            throw sr(invalidTokenAt) + currentToken.index + sr(fullStop);
	                        }
	                        break;
	                    case 4 /* OperatorPrefix */
	                    :
	                        if (throwError && (!next || previous && (previous.type === 6 /* OperatorPostfix */))) {
	                            throw sr(invalidTokenAt) + currentToken.index + sr(fullStop);
	                        }
	                        break;
	                    case 5 /* OperatorInfix */
	                    :
	                        if (throwError && (!next || !previous || previous.type === 5 /* OperatorInfix */ || previous.type === 4 /* OperatorPrefix */ || previous.type === 3 /* Argument */ || previous.type === 1 /* Function */ && previous.subType === 1 /* Start */ || previous.type === 2 /* Subexpression */ && previous.subType === 1 /* Start */)) {
	                            throw sr(invalidTokenAt) + currentToken.index + sr(fullStop);
	                        }
	                        break;
	                    case 6 /* OperatorPostfix */
	                    :
	                        if (throwError && (!previous || previous.type === 4 /* OperatorPrefix */ || previous.type === 5 /* OperatorInfix */ || previous.type === 1 /* Function */ && previous.subType === 1 /* Start */ || previous.type === 2 /* Subexpression */ && previous.subType === 1 /* Start */)) {
	                            throw sr(invalidTokenAt) + currentToken.index + sr(fullStop);
	                        }
	                        break;
	                    default:
	                        if (throwError) {
	                            throw sr(invalidTokenAt) + currentToken.index + sr(fullStop);
	                        }
	                }
	
	                //if throwError is false, it's called by formula textbox, so return token array
	                if (throwError) {
	                    //build token tree.
	                    if (currentToken.subType === 1 /* Start */) {
	                        stack.push(currentToken);
	                        parent.children.push(currentToken);
	                    } else if (currentToken.subType === 2 /* Stop */) {
	                        if (stack.length === 0) {
	                            var currentChar;
	                            if (currentToken.value === CONST_ARRAY || currentToken.value === CONST_ARRAYROW) {
	                                currentChar = '}';
	                            } else {
	                                currentChar = ')';
	                            }
	                            if (throwError) {
	                                throw sr(formulaInvalid) + sr(singleQuote);
	                                //+currentChar + sr(singleQuoteAt) + currentToken.index + sr(fullStop);
	                            }
	                        }
	                        stack.pop();
	                    } else {
	                        parent.children.push(currentToken);
	                    }
	                }
	            }
	            if (throwError) {
	                return rootToken.children;
	            } else {
	                return tokens2;
	            }
	        };
	
	        Parser.prototype._removeWhiteSpace = function(tokens1) {
	            // remove unnecessary white-space tokens and converting necessary ones to binary intersection operator.
	            var tokens2 = [];
	            var length = tokens1.length;
	            for (var i = 0; i < length; i++) {
	                var token = tokens1[i];
	                if (!token) {
	                    continue;
	                }
	                if (token.type !== 7 /* Whitespace */) {
	                    tokens2.push(token);
	                    continue;
	                }
	
	                var previous = i === 0 ? KEYWORD_NULL : tokens1[i - 1];
	                var next = i === length - 1 ? KEYWORD_NULL : tokens1[i + 1];
	                if (!previous || !next) {
	                    continue;
	                }
	                if ((((previous.type === 1 /* Function */) && (previous.subType === 2 /* Stop */)) || ((previous.type === 2 /* Subexpression */) && (previous.subType === 2 /* Stop */)) || (previous.type === 0 /* Operand */)) && (((next.type === 1 /* Function */) && (next.subType === 1 /* Start */)) || ((next.type === 2 /* Subexpression */) && (next.subType === 1 /* Start */)) || (next.type === 0 /* Operand */))) {
	                    tokens2.push(new FormulaToken(' ', 5 /* OperatorInfix */, token.index, 9 /* Intersection */));
	                }
	            }
	            return tokens2;
	        };
	
	        Parser.prototype._buildExpressionNode = function(context, token) {
	            var self = this;
	            var currentExpression;
	            if (token.type === 1 /* Function */) {
	                if (token.value === CONST_ARRAY) {
	                    currentExpression = self._buildArraryExpression(context, token);
	                } else {
	                    currentExpression = self._buildFunctionExpression(context, token);
	                }
	            } else if (token.type === 2 /* Subexpression */) {
	                currentExpression = self._buildSubExpression(context, token);
	            } else if (token.type === 0 /* Operand */) {
	                if (token.subType === 4 /* Number */) {
	                    currentExpression = new CalcExpressions.DoubleExpression(parseFloat(token.value), token.value);
	                } else if (token.subType === 6 /* Error */) {
	                    currentExpression = new CalcExpressions.ErrorExpression(Calc.CalcError.parse(token.value));
	                } else if (token.subType === 5 /* Logical */) {
	                    if (compareStringIgnoreCase(token.value, CONST_TRUE)) {
	                        currentExpression = new CalcExpressions.BooleanExpression(true);
	                    } else if (compareStringIgnoreCase(token.value, CONST_FALSE)) {
	                        currentExpression = new CalcExpressions.BooleanExpression(false);
	                    }
	                } else if (token.subType === 7 /* Struct or Field */) {
	                    currentExpression = self._buildStructOrFieldExpression(context, token.value, token.index);
	                } else {
	                    currentExpression = new CalcExpressions.StringExpression(token.value);
	                }
	            }
	            return currentExpression;
	        };
	
	        Parser.prototype._buildExpressionTree = function(context, tokens) {
	            // parse to expression and binary operator list
	            // the list should be: expression operator expression operator expression
	            var results = this._parseToBinaryOperatorList(context, tokens);
	            var currentExpression;
	            var lastExpression;
	            var nextExpression;
	            var index;
	
	            for (index = 3; index < results.length;) {
	                var nextToken = results[index];
	                var currentToken = results[index - 2];
	                if (nextToken && nextToken.type === 5 /* OperatorInfix */) {
	                    while (index >= 3 && getOpeatorPriority(nextToken.value) >= getOpeatorPriority(currentToken.value)) {
	                        //compose two expressions and the binary operator to one expression
	                        lastExpression = results[index - 3];
	                        nextExpression = results[index - 1];
	                        currentExpression = new CalcExpressions.BinaryOperatorExpression(getBinaryOperator(currentToken), lastExpression, nextExpression);
	                        results.splice(index - 3, 3);
	                        results.splice(index - 3, 0, currentExpression);
	                        index -= 2;
	                        if (index >= 3) {
	                            currentToken = results[index - 2];
	                        }
	                    }
	                    index += 2;
	                } else {
	                    index++;
	                }
	            }
	            if (results.length === 1) {
	                return results[0];
	            } else {
	                for (index = results.length - 2; index > 0; index -= 2) {
	                    lastExpression = results[index - 1];
	                    nextExpression = results[index + 1];
	                    currentExpression = new CalcExpressions.BinaryOperatorExpression(getBinaryOperator(results[index]), lastExpression, nextExpression);
	                    results.splice(index - 1, 3);
	                    results.push(currentExpression);
	                }
	                return currentExpression;
	            }
	        };
	
	        Parser.prototype._parseToBinaryOperatorList = function(context, tokens) {
	            var results = [];
	            var currentExpression;
	            var Operators = CalcParser.Operators;
	            for (var i = 0; i < tokens.length; i++) {
	                var currentToken = tokens[i];
	                if (currentToken.type === 4 /* OperatorPrefix */) {
	                    var opStack = [];
	                    while (currentToken.type === 4 /* OperatorPrefix */) {
	                        opStack.push(currentToken.value === '+' ? Operators.plus : Operators.negate);
	                        i++;
	                        currentToken = tokens[i];
	                    }
	                    var nextToken = tokens[i];
	                    currentExpression = new CalcExpressions.UnaryOperatorExpression(opStack.pop(), this._buildExpressionNode(context, nextToken));
	                    while (opStack.length > 0) {
	                        currentExpression = new CalcExpressions.UnaryOperatorExpression(opStack.pop(), currentExpression);
	                    }
	                    results.push(currentExpression);
	                } else if (currentToken.type === 6 /* OperatorPostfix */) {
	                    var lastExpression = results[results.length - 1];
	                    currentExpression = new CalcExpressions.UnaryOperatorExpression(Operators.percent, lastExpression);
	                    results.pop();
	                    results.push(currentExpression);
	                } else if (currentToken.type === 5 /* OperatorInfix */) {
	                    results.push(currentToken);
	                } else {
	                    currentExpression = this._buildExpressionNode(context, currentToken);
	                    results.push(currentExpression);
	                }
	            }
	            return results;
	        };
	
	        Parser.prototype._buildFunctionExpression = function(context, rootToken) {
	            var args = [];
	            var subTokens = [];
	            for (var i = 0; i < rootToken.children.length; i++) {
	                var token = rootToken.children[i];
	                if (token.type !== 3 /* Argument */) {
	                    subTokens.push(token);
	                } else {
	                    if (subTokens.length === 0) {
	                        args.push(new CalcExpressions.MissingArgumentExpression());
	                    } else {
	                        args.push(this._buildExpressionTree(context, subTokens));
	                        subTokens = [];
	                    }
	                }
	            }
	            if (subTokens.length !== 0) {
	                args.push(this._buildExpressionTree(context, subTokens));
	            } else if (rootToken.children.length !== 0) {
	                args.push(new CalcExpressions.MissingArgumentExpression());
	            }
	            var fn = CalcFunctions.findGlobalFunction(rootToken.value);
	            if (fn) {
	                var argsLength = args.length;
	                if (argsLength < fn.minArgs || argsLength > fn.maxArgs) {
	                    throw sr(invalidPara) + rootToken.index + sr(fullStop);
	                }
	                return new CalcExpressions.FunctionExpression(fn, args);
	            } else {
	                return new CalcExpressions.FunctionExpression(rootToken.value, args);
	            }
	        };
	
	        Parser.prototype._buildSubExpression = function(context, rootToken) {
	            return new CalcExpressions.ParenthesesExpression(this._buildExpressionTree(context, rootToken.children));
	        };
	
	        Parser.prototype._buildStructOrFieldExpression = function(context, value) {
	            if (value === KEYWORD_UNDEFINED || value === KEYWORD_NULL || value === '') {
	                return {endIndex: 0, expression: KEYWORD_NULL};
	            }
	            var length = value.length;
	
	            var reg = /^([^\[\]]*)[\[]{1}([^\[\]]+)[\]]{1}$/g;
	            var results = reg.exec(value);
	            if (results) {
	                if (results.length !== 3) {
	                    return {endIndex: length, expression: KEYWORD_NULL};
	                }
	                var table = results[1];
	                var column = results[2];
	                if (column) {
	                    if (context.calcSource.hasColumn(column)) {
	                        if (!table) {
	                            table = context.calcSource.getName();
	                        }
	                        return new CalcExpressions.StructReferenceExpression(table, column);
	                    } else if (context.calcSource.hasField(column)) {
	                        return new CalcExpressions.FieldReferenceExpression(column);
	                    } else {
	                        return new CalcExpressions.UnknownReferenceExpression(column);
	                    }
	                }
	            } else {
	                return new CalcExpressions.StructReferenceExpression(value);
	            }
	            //return null;
	        };
	
	        Parser.prototype._validateName = function(name) {
	            if (name === KEYWORD_UNDEFINED || name === KEYWORD_NULL || name === '') {
	                return false;
	            }
	            var nameLength = name.length;
	            if (nameLength === 1 && (name === 'R' || name === 'r' || name === 'C' || name === 'c')) {
	                return false;
	            }
	            var currentChar = name.charAt(0);
	            if (!(currentChar === '_' || currentChar === '\\' || isLetter(currentChar) || isSymbol(currentChar))) {
	                return false;
	            }
	            for (var i = 1; i < nameLength; i++) {
	                currentChar = name.charAt(i);
	                if (!(currentChar === '_' || currentChar === '\\' || currentChar === '?' || currentChar === '.' || isLetterOrDigit(currentChar) || isSymbol(currentChar))) {
	                    return false;
	                }
	            }
	            return true;
	        };
	        Parser._isLetter = isLetter;
	        Parser._isLetterOrDigit = isLetterOrDigit;
	
	        Parser.listSeparator = ',';
	        Parser.numberDecimalSeparator = '.';
	        Parser.arrayGroupSeparator = ';';
	        Parser._arrayArgumentSepatator = Parser.listSeparator;
	        Parser._operatorInfix = '\\+-*/^&=><: ' + Parser.listSeparator;
	        Parser.unparseWithoutCulture = false;
	        return Parser;
	    })();
	    CalcParser.Parser = Parser;
	
	    function isLatin1(cc) {
	        return cc <= 0x00ff;
	    }
	
	    function isAscii(cc) {
	        return cc <= 0x007f;
	    }
	
	    function isDigit(c) {
	        var cc = c.charCodeAt(0);
	
	        //if (!isLatin1(cc)) { // not latin character, not supported yet.
	        //    return false;
	        //}
	        // 0-9
	        return cc >= 48 && cc <= 57;
	    }
	
	    function isLetter(c) {
	        var cc = c.charCodeAt(0);
	        if (!isLatin1(cc)) {
	            return true;
	        }
	
	        // fix bug 92964
	        if (!isAscii(cc)) {
	            return categoryForLatin1[cc] === LatinUnicodeCategory.UppercaseLetter || categoryForLatin1[cc] === LatinUnicodeCategory.LowercaseLetter;
	        }
	        // make lowcase
	        cc |= 0x20; // jshint ignore:line
	
	        // // a-z;
	        return (cc >= 96 && cc <= 122);
	    }
	
	    function isLetterOrDigit(c) {
	        var cc = c.charCodeAt(0);
	        if (!isLatin1(cc)) {
	            return true;
	        }
	
	        // fix bug 92964
	        if (!isAscii(cc)) {
	            return categoryForLatin1[cc] === LatinUnicodeCategory.UppercaseLetter || categoryForLatin1[cc] === LatinUnicodeCategory.LowercaseLetter;
	        }
	        if (cc <= 57) {
	            return cc >= 48;
	        }
	        // make lowcase
	        cc |= 0x20; // jshint ignore:line
	
	        // a-z;
	        return (cc >= 96 && cc <= 122);
	    }
	
	    function isSymbol(c) {
	        var cc = c.charCodeAt(0);
	        if (!isLatin1(cc)) {
	            return false;
	        }
	        return categoryForLatin1[cc] === LatinUnicodeCategory.MathSymbol || categoryForLatin1[cc] === LatinUnicodeCategory.currencySymbol || categoryForLatin1[cc] === LatinUnicodeCategory.ModifierSymbol || categoryForLatin1[cc] === LatinUnicodeCategory.OtherSymbol;
	    }
	
	    /* jshint ignore:start */
	    function isNumber(c) {
	        var cc = c.charCodeAt(0);
	
	        //if (!isLatin1(cc)) {
	        //    return false;
	        //}
	        // fix bug 92964
	        if (!isAscii(cc)) {
	            return categoryForLatin1[cc] === LatinUnicodeCategory.DecimalDigitNumber || categoryForLatin1[cc] === LatinUnicodeCategory.OtherNumber;
	        }
	
	        // 0-9
	        return cc >= 48 && cc <= 57;
	    }
	    /* jshint ignore:end */
	
	    function isNumber2(str, startIndex, numberDecimalSeparator) {
	        var len = str.length;
	        var state = NumberState.None;
	        for (var i = startIndex; i < len; i++) {
	            var currentChar = str.charAt(i);
	            if (isDigit(currentChar)) {
	                if (state === NumberState.None) {
	                    state = NumberState.Int;
	                } else if (state === NumberState.Dot) {
	                    state = NumberState.Decimal;
	                } else if (state === NumberState.Sign) {
	                    state = NumberState.Int;
	                } else if (state === NumberState.Exponent || state === NumberState.SignExponent) {
	                    state = NumberState.ScientificNotation;
	                }
	            } else if (currentChar === numberDecimalSeparator) {
	                if (state === NumberState.Int) {
	                    state = NumberState.Decimal;
	                } else if (state === NumberState.None || state === NumberState.Sign) {
	                    state = NumberState.Dot;
	                } else {
	                    return {result: false};
	                }
	            } else if (currentChar === '+' || currentChar === '-') {
	                if (state === NumberState.None) {
	                    state = NumberState.Sign;
	                } else if (state === NumberState.Exponent) {
	                    state = NumberState.SignExponent;
	                } else {
	                    return {result: true, endIndex: i - 1};
	                }
	            } else if (currentChar === 'E' || currentChar === 'e') {
	                if (state === NumberState.Int || state === NumberState.Decimal) {
	                    state = NumberState.Exponent;
	                } else {
	                    return {result: false};
	                }
	            } else if (state === NumberState.Int || state === NumberState.Decimal || state === NumberState.ScientificNotation) {
	                return {result: true, endIndex: i - 1};
	            }
	        }
	        if (state === NumberState.Int || state === NumberState.Decimal || state === NumberState.ScientificNotation) {
	            return {result: true, endIndex: len - 1};
	        }
	        return {result: false};
	    }
	
	    //</editor-fold>
	    //<editor-fold desc='Parser Definition'>
	    var ExcelFormulaTokenType;
	    (function(ExcelFormulaTokenType) {
	        ExcelFormulaTokenType[ExcelFormulaTokenType.Operand = 0] = 'Operand';
	        ExcelFormulaTokenType[ExcelFormulaTokenType.Function = 1] = 'Function';
	        ExcelFormulaTokenType[ExcelFormulaTokenType.Subexpression = 2] = 'Subexpression';
	        ExcelFormulaTokenType[ExcelFormulaTokenType.Argument = 3] = 'Argument';
	        ExcelFormulaTokenType[ExcelFormulaTokenType.OperatorPrefix = 4] = 'OperatorPrefix';
	        ExcelFormulaTokenType[ExcelFormulaTokenType.OperatorInfix = 5] = 'OperatorInfix';
	        ExcelFormulaTokenType[ExcelFormulaTokenType.OperatorPostfix = 6] = 'OperatorPostfix';
	        ExcelFormulaTokenType[ExcelFormulaTokenType.Whitespace = 7] = 'Whitespace';
	        ExcelFormulaTokenType[ExcelFormulaTokenType.Unknown = 8] = 'Unknown';
	    })(ExcelFormulaTokenType || (ExcelFormulaTokenType = {}));
	    var ExcelFormulaTokenSubtype;
	    (function(ExcelFormulaTokenSubtype) {
	        ExcelFormulaTokenSubtype[ExcelFormulaTokenSubtype.Nothing = 0] = 'Nothing';
	        ExcelFormulaTokenSubtype[ExcelFormulaTokenSubtype.Start = 1] = 'Start';
	        ExcelFormulaTokenSubtype[ExcelFormulaTokenSubtype.Stop = 2] = 'Stop';
	        ExcelFormulaTokenSubtype[ExcelFormulaTokenSubtype.Text = 3] = 'Text';
	        ExcelFormulaTokenSubtype[ExcelFormulaTokenSubtype.Number = 4] = 'Number';
	        ExcelFormulaTokenSubtype[ExcelFormulaTokenSubtype.Logical = 5] = 'Logical';
	        ExcelFormulaTokenSubtype[ExcelFormulaTokenSubtype.Error = 6] = 'Error';
	        ExcelFormulaTokenSubtype[ExcelFormulaTokenSubtype.RangeOrName = 7] = 'RangeOrName';
	        ExcelFormulaTokenSubtype[ExcelFormulaTokenSubtype.Concatenation = 8] = 'Concatenation';
	        ExcelFormulaTokenSubtype[ExcelFormulaTokenSubtype.Intersection = 9] = 'Intersection';
	        ExcelFormulaTokenSubtype[ExcelFormulaTokenSubtype.Union = 10] = 'Union';
	        ExcelFormulaTokenSubtype[ExcelFormulaTokenSubtype.RangeOp = 11] = 'RangeOp';
	    })(ExcelFormulaTokenSubtype || (ExcelFormulaTokenSubtype = {}));
	
	    var FormulaToken = (function() {
	        function FormulaToken(value, type, index, subType) {
	            if (subType === KEYWORD_UNDEFINED || subType === KEYWORD_NULL) {
	                subType = 0 /* Nothing */;
	            }
	
	            var self = this;
	            self.value = value;
	            self.type = type;
	            self.index = index;
	            self.subType = subType;
	            self.children = [];
	        }
	
	        return FormulaToken;
	    })();
	
	    function readString(formula, startIndex, startSign, endSign, throwError) {
	        var len = formula.length;
	        var startSignCount = (startSign === endSign) ? 0 : 1;
	        var text = '';
	        for (var index = startIndex + 1; index < len; index++) {
	            var currentChar = formula.charAt(index);
	            if (currentChar === startSign) {
	                startSignCount++;
	            }
	            if (currentChar === endSign) {
	                startSignCount--;
	                if (startSign === endSign && index + 2 < len && formula.charAt(index + 1) === startSign) {
	                    text += startSign;
	                    index++;
	                } else if (startSignCount !== 0) {
	                    text += currentChar;
	                } else {
	                    return {result: text, endIndex: index};
	                }
	            } else {
	                text += currentChar;
	            }
	        }
	        if (throwError) {
	            throw sr(noSyntax) + endSign + sr(matchSyntax) + startSign + sr(singleQuotesFullStop);
	        }
	    }
	
	    function readString2(formula, startIndex, startSign, endSign, escapeSign, throwError) {
	        var len = formula.length;
	        var startSignCount = 0;
	        var text = '';
	        for (var index = startIndex; index < len; index++) {
	            var currentChar = formula.charAt(index);
	            if (currentChar === escapeSign) {
	                text += currentChar;
	                index++;
	                currentChar = formula.charAt(index);
	            }
	            if (currentChar === startSign) {
	                text += currentChar;
	                startSignCount++;
	            } else if (currentChar === endSign) {
	                startSignCount--;
	                if (startSignCount !== 0) {
	                    text += currentChar;
	                } else {
	                    return {result: text, endIndex: index};
	                }
	            } else {
	                text += currentChar;
	            }
	        }
	        if (throwError) {
	            throw sr(noSyntax) + endSign + sr(matchSyntax) + startSign + sr(singleQuotesFullStop);
	        }
	    }
	
	    function readError(formula, startIndex, throwError) {
	        var len = formula.length;
	        var surplusLen = len - startIndex;
	        for (var i = 0; i < ERROR_LIST.length; i++) {
	            var err = ERROR_LIST[i];
	            var errLength = err.length;
	            if (startIndex + errLength > len) {
	                continue;
	            }
	            var errStr = formula.slice(startIndex, startIndex + errLength);
	            if (errLength <= surplusLen && (err === errStr || err === errStr.toUpperCase())) {
	                return {result: err, endIndex: startIndex + errLength - 1};
	            }
	        }
	        if (throwError) {
	            throw sr(singleQuote);
	            //+formula.slice(startIndex) + sr(isValid);
	        }
	    }
	
	    function getOpeatorPriority(op) {
	        if (op === '^' || op === ':') {
	            return 1;
	        } else if (op === '*' || op === '/' || op === ' ') {
	            return 2;
	        } else if (op === '+' || op === '-' || op === ',') {
	            return 3;
	        } else if (op === '&') {
	            return 4;
	        } else if (op === '||' || op === '&&') {
	            return 6;
	        } else {
	            return 5;
	        }
	    }
	
	    function getBinaryOperator(token) {
	        var value = token.value;
	        var Operators = CalcParser.Operators;
	        if (value === '^') {
	            return Operators.exponent;
	        } else if (value === '*') {
	            return Operators.multiply;
	        } else if (value === '/') {
	            return Operators.divide;
	        } else if (value === '+') {
	            return Operators.add;
	        } else if (value === '-') {
	            return Operators.subtract;
	        } else if (value === '&') {
	            return Operators.concatenate;
	        } else if (value === '<') {
	            return Operators.lessThan;
	        } else if (value === '=') {
	            return Operators.equal;
	        } else if (value === '>') {
	            return Operators.greaterThan;
	        } else if (value === '>=') {
	            return Operators.greaterThanOrEqual;
	        } else if (value === '<=') {
	            return Operators.lessThanOrEqual;
	        } else if (value === '<>') {
	            return Operators.notEqual;
	        } else if (value === '&&') {
	            return Operators.and;
	        } else if (value === '||') {
	            return Operators.or;
	        }
	        return Operators.add;
	    }
	
	    function getProperty(obj, name, fallback) {
	        return (obj && obj.hasOwnProperty(name)) ? obj[name] : fallback;
	    }
	
	    function compareStringIgnoreCase(s1, s2) {
	        if ((s1 === KEYWORD_UNDEFINED || s1 === KEYWORD_NULL) && (s2 === KEYWORD_UNDEFINED || s2 === KEYWORD_NULL)) {
	            return true;
	        }
	        if (((s1 === KEYWORD_UNDEFINED || s1 === KEYWORD_NULL) && (s2 !== KEYWORD_UNDEFINED && s2 !== KEYWORD_NULL)) || ((s1 !== KEYWORD_UNDEFINED && s1 !== KEYWORD_NULL) && (s2 === KEYWORD_UNDEFINED || s2 === KEYWORD_NULL))) {
	            return false;
	        }
	        return s1.toLowerCase() === s2.toLowerCase();
	    }
	
	    (function(Operators) {
	        var Operator = (function() {
	            /**
	             * Represents an operator. This is a base class.
	             * @class
	             * @param {string} name The name of the operator.
	             */
	            function Operator(name) {
	                this.name = name;
	            }
	
	            /**
	             * Gets the name of the operator.
	             * @returns {string} The name of the operator.
	             */
	            Operator.prototype.getName = function() {
	                return this.name;
	            };
	
	            /**
	             * Tests whether two operator structures are different.
	             * @returns {boolean} <c>true</c> if the operators are the same; otherwise, <c>false</c>.
	             */
	            Operator.prototype.compareTo = function(other) {
	                return compareStringIgnoreCase(this.name, other.name);
	            };
	
	            Operator.prototype.toString = function() {
	                return this.getName();
	            };
	            return Operator;
	        })();
	        Operators.Operator = Operator;
	
	        //<editor-fold desc='UnaryOperator'>
	        var UnaryOperator = (function(_super) {
	            /**
	             * Returns the result of the operator applied to the operand.
	             * @class
	             * @param {string} name Represents the operator name.
	             */
	            function UnaryOperator_(name) {
	                _super.call(this, name);
	            }
	            Calc.__extends(UnaryOperator_, _super);
	
	            UnaryOperator_.prototype._evaluateSingle = function(operand, context) { // jshint ignore:line
	            };
	            /**
	             * Returns the result of the operator applied to the operand.
	             * @param {object} operand The operand for the operator evaluation.
	             * @param {object} context The context associated with the operator evaluation.
	             * @returns {object} The result of the operator applied to the operand.
	             */
	            UnaryOperator_.prototype.evaluate = function(operand, context) { // jshint ignore:line
	                var self = this;
	                var operandValue = operand;
	                if (operandValue instanceof Calc.CalcColumnReference || operandValue instanceof  Calc.CalcFieldReference) {
	                    operandValue = operandValue.getValue(context.getCurrentRow(), context.groupPath);
	                }
	                if (_.isArray(operandValue)) {
	                    return _.map(operandValue, function(value) {
	                        return self._evaluateSingle(value, context);
	                    });
	                } else {
	                    return self._evaluateSingle(operandValue, context);
	                }
	            };
	            return UnaryOperator_;
	        })(Operator);
	        Operators.UnaryOperator = UnaryOperator;
	
	        Operators.plus = new UnaryOperator('+');
	        Operators.plus._evaluateSingle = function(operand, context) { // jshint ignore:line
	            if (operand === KEYWORD_UNDEFINED || operand === KEYWORD_NULL) {
	                return 0;
	            }
	            var doubleLeft = {value: 0};
	            if (!Calc.Convert.rD(operand, doubleLeft)) {
	                // cylj fix the bug 69442, return the string direct as excel.
	                if (typeof operand === 'string') {
	                    return operand;
	                }
	                return Calc.CalcErrorsValue;
	            }
	            return Calc.Convert.D(doubleLeft.value);
	        };
	
	        Operators.negate = new UnaryOperator('-');
	        Operators.negate._evaluateSingle = function(operand, context) { // jshint ignore:line
	            if (operand === KEYWORD_UNDEFINED || operand === KEYWORD_NULL) {
	                return 0;
	            }
	            var doubleValue = {value: 0};
	            if (!Calc.Convert.rD(operand, doubleValue)) {
	                return Calc.CalcErrorsValue;
	            }
	            return -doubleValue.value;
	        };
	
	        Operators.percent = new UnaryOperator('%');
	        Operators.percent._evaluateSingle = function(operand, context) { // jshint ignore:line
	            if (operand === KEYWORD_UNDEFINED || operand === KEYWORD_NULL) {
	                return 0;
	            }
	            var doubleValue = {value: 0};
	            if (!Calc.Convert.rD(operand, doubleValue)) {
	                return Calc.CalcErrorsValue;
	            }
	            return doubleValue.value / 100;
	        };
	
	        //</editor-fold>
	        //<editor-fold desc='BinaryOperator'>
	        function _approxEqual(x, y) {
	            if (x === y) {
	                return true;
	            }
	            return MATH_ABS(x - y) < MATH_ABS(x) / (16777216.0 * 16777216.0);
	        }
	
	        var BinaryOperator = (function(_super) {
	            /**
	             * Represents a binary operator.
	             * @class
	             * @param {string} name The name of the operator.
	             * @param {boolean} acceptsReference Determines whether the operator accepts reference values for the specified operand.
	             */
	            function BinaryOperator_(name, acceptsReference) {
	                _super.call(this, name);
	                this.acceptsReference = acceptsReference;
	            }
	            Calc.__extends(BinaryOperator_, _super);
	
	            BinaryOperator_.prototype._evaluateSingle = function(left, right, context) { // jshint ignore:line
	            };
	
	            /**
	             * Returns the result of the operator applied to the operands.
	             * @param {object} left The left operand.
	             * @param {object} right The right operand.
	             * @param {object} context The context associated with the operator evaluation.
	             * @returns {object} Result of the operator applied to the operands.
	             */
	            BinaryOperator_.prototype.evaluate = function(left, right, context) {
	                var self = this;
	                var leftValue;
	                if (left instanceof Calc.CalcColumnReference || left instanceof Calc.CalcFieldReference) {
	                    leftValue = left.getValue(context.getCurrentRow(), context.groupPath);
	                } else {
	                    leftValue = left;
	                }
	                var rightValue;
	                if (right instanceof Calc.CalcColumnReference || right instanceof Calc.CalcFieldReference) {
	                    rightValue = right.getValue(context.getCurrentRow(), context.groupPath);
	                } else {
	                    rightValue = right;
	                }
	                var leftArray = _.isArray(leftValue);
	                var rightArray = _.isArray(rightValue);
	                if (leftArray && rightArray && leftValue.length === rightValue.length) {
	                    return _.map(leftValue, function(value, index) {
	                        return self._evaluateSingle(value, rightValue[index], context);
	                    });
	                } else if (!leftArray && !rightArray) {
	                    return self._evaluateSingle(leftValue, rightValue, context);
	                } else if (leftArray) {
	                    return _.map(leftValue, function(value) {
	                        return self._evaluateSingle(value, rightValue, context);
	                    });
	                } else if (rightArray) {
	                    return _.map(rightValue, function(value) {
	                        return self._evaluateSingle(leftValue, value, context);
	                    });
	                }
	            };
	            return BinaryOperator_;
	        })(Operator);
	        Operators.BinaryOperator = BinaryOperator;
	
	        Operators.add = new BinaryOperator('+', false);
	        Operators.add._evaluateSingle = function(left, right, context) { // jshint ignore:line
	            if (Calc.Convert.err(left)) {
	                return left;
	            }
	            if (Calc.Convert.err(right)) {
	                return right;
	            }
	            if (left === KEYWORD_UNDEFINED || left === KEYWORD_NULL) {
	                left = 0;
	            }
	            if (right === KEYWORD_UNDEFINED || right === KEYWORD_NULL) {
	                right = 0;
	            }
	            var doubleLeft = {value: 0};
	            if (!Calc.Convert.rD(left, doubleLeft)) {
	                return Calc.CalcErrorsValue;
	            }
	            var doubleRight = {value: 0};
	            if (!Calc.Convert.rD(right, doubleRight)) {
	                return Calc.CalcErrorsValue;
	            }
	            return doubleLeft.value + doubleRight.value;
	        };
	
	        Operators.subtract = new BinaryOperator('-', false);
	        Operators.subtract._evaluateSingle = function(left, right, context) { // jshint ignore:line
	            if (Calc.Convert.err(left)) {
	                return left;
	            }
	            if (Calc.Convert.err(right)) {
	                return right;
	            }
	            if (left === KEYWORD_UNDEFINED || left === KEYWORD_NULL) {
	                left = 0;
	            }
	            if (right === KEYWORD_UNDEFINED || right === KEYWORD_NULL) {
	                right = 0;
	            }
	            var doubleLeft = {value: 0};
	            if (!Calc.Convert.rD(left, doubleLeft)) {
	                return Calc.CalcErrorsValue;
	            }
	            var doubleRight = {value: 0};
	            if (!Calc.Convert.rD(right, doubleRight)) {
	                return Calc.CalcErrorsValue;
	            }
	            return doubleLeft.value - doubleRight.value;
	        };
	
	        Operators.multiply = new BinaryOperator('*', false);
	        Operators.multiply._evaluateSingle = function(left, right, context) { // jshint ignore:line
	            if (Calc.Convert.err(left)) {
	                return left;
	            }
	            if (Calc.Convert.err(right)) {
	                return right;
	            }
	            if (left === KEYWORD_UNDEFINED || left === KEYWORD_NULL) {
	                left = 0;
	            }
	            if (right === KEYWORD_UNDEFINED || right === KEYWORD_NULL) {
	                right = 0;
	            }
	            var doubleLeft = {value: 0};
	            if (!Calc.Convert.rD(left, doubleLeft)) {
	                return Calc.CalcErrorsValue;
	            }
	            var doubleRight = {value: 0};
	            if (!Calc.Convert.rD(right, doubleRight)) {
	                return Calc.CalcErrorsValue;
	            }
	            return doubleLeft.value * doubleRight.value;
	        };
	
	        Operators.divide = new BinaryOperator('/', false);
	        Operators.divide._evaluateSingle = function(left, right, context) { // jshint ignore:line
	            if (right === KEYWORD_UNDEFINED || right === KEYWORD_NULL || right === '' || right === 0) {
	                return Calc.CalcErrorsDivideByZero;
	            }
	            if (Calc.Convert.err(left)) {
	                return left;
	            }
	            if (Calc.Convert.err(right)) {
	                return right;
	            }
	            if (left === KEYWORD_UNDEFINED || left === KEYWORD_NULL) {
	                left = 0;
	            }
	            var doubleLeft = {value: 0};
	            if (!Calc.Convert.rD(left, doubleLeft)) {
	                return Calc.CalcErrorsValue;
	            }
	            var doubleRight = {value: 0};
	            if (!Calc.Convert.rD(right, doubleRight)) {
	                return Calc.CalcErrorsValue;
	            }
	
	            if (doubleRight.value === 0) {
	                return Calc.CalcErrorsDivideByZero;
	            }
	            return doubleLeft.value / doubleRight.value;
	        };
	
	        Operators.exponent = new BinaryOperator('^', false);
	        Operators.exponent._evaluateSingle = function(left, right, context) { // jshint ignore:line
	            if (Calc.Convert.err(left)) {
	                return left;
	            }
	            if (Calc.Convert.err(right)) {
	                return right;
	            }
	            if (left === KEYWORD_UNDEFINED || left === KEYWORD_NULL) {
	                left = 0;
	            }
	            if (right === KEYWORD_UNDEFINED || right === KEYWORD_NULL) {
	                right = 0;
	            }
	            var doubleLeft = {value: 0};
	            if (!Calc.Convert.rD(left, doubleLeft)) {
	                return Calc.CalcErrorsValue;
	            }
	            left = doubleLeft.value;
	            var doubleRight = {value: 0};
	            if (!Calc.Convert.rD(right, doubleRight)) {
	                return Calc.CalcErrorsValue;
	            }
	            right = doubleRight.value;
	            if (left === 0.0 && right < 0) {
	                return Calc.CalcErrorsDivideByZero;
	            }
	            return MATH_POW(left, right);
	        };
	
	        Operators.concatenate = new BinaryOperator('&', false);
	        Operators.concatenate._evaluateSingle = function(left, right, context) { // jshint ignore:line
	            if (Calc.Convert.err(left)) {
	                return left;
	            }
	            if (Calc.Convert.err(right)) {
	                return right;
	            }
	            if (left === KEYWORD_UNDEFINED || left === KEYWORD_NULL) {
	                left = '';
	            }
	            if (right === KEYWORD_UNDEFINED || right === KEYWORD_NULL) {
	                right = '';
	            }
	            return left.toString() + right.toString();
	        };
	
	        Operators.and = new BinaryOperator('&&', false);
	        Operators.and._evaluateSingle = function(left, right, context) { // jshint ignore:line
	            if (Calc.Convert.err(left)) {
	                return left;
	            }
	            if (Calc.Convert.err(right)) {
	                return right;
	            }
	            return (!!left) && (!!right);
	        };
	
	        Operators.or = new BinaryOperator('||', false);
	        Operators.or._evaluateSingle = function(left, right, context) { // jshint ignore:line
	            if (Calc.Convert.err(left)) {
	                return left;
	            }
	            if (Calc.Convert.err(right)) {
	                return right;
	            }
	            return (!!left) || (!!right);
	        };
	
	        Operators.equal = new BinaryOperator('=', false);
	        Operators.equal._evaluateSingle = function(left, right, context) { // jshint ignore:line
	            if (Calc.Convert.err(left)) {
	                return left;
	            }
	            if (Calc.Convert.err(right)) {
	                return right;
	            }
	            if (left === KEYWORD_UNDEFINED || left === KEYWORD_NULL) {
	                if (typeof right === CONST_STRING) {
	                    left = '';
	                } else {
	                    left = 0;
	                }
	            }
	            if (right === KEYWORD_UNDEFINED || right === KEYWORD_NULL) {
	                if (typeof left === CONST_STRING) {
	                    right = '';
	                } else {
	                    right = 0;
	                }
	            }
	            if (typeof left === CONST_STRING || typeof right === CONST_STRING) {
	                return left.toString().toUpperCase() === right.toString().toUpperCase();
	            } else {
	                var doubleLeft = {value: 0};
	                if (!Calc.Convert.rD(left, doubleLeft)) {
	                    return Calc.CalcErrorsValue;
	                }
	                left = doubleLeft.value;
	                var doubleRight = {value: 0};
	                if (!Calc.Convert.rD(right, doubleRight)) {
	                    return Calc.CalcErrorsValue;
	                }
	                right = doubleRight.value;
	                var x = left;
	                var y = right;
	                return _approxEqual(x, y);
	            }
	        };
	
	        Operators.notEqual = new BinaryOperator('<>', false);
	        Operators.notEqual._evaluateSingle = function(left, right, context) {
	            var value = Operators.equal._evaluateSingle.call(this, left, right, context);
	            if (typeof value === CONST_BOOLEAN) {
	                return !value;
	            }
	            return value;
	        };
	
	        Operators.lessThan = new BinaryOperator('<', false);
	        Operators.lessThan._evaluateSingle = function(left, right, context) { // jshint ignore:line
	            if (Calc.Convert.err(left)) {
	                return left;
	            }
	            if (Calc.Convert.err(right)) {
	                return right;
	            }
	            if (left === KEYWORD_UNDEFINED || left === KEYWORD_NULL) {
	                left = 0;
	            }
	            if (right === KEYWORD_UNDEFINED || right === KEYWORD_NULL) {
	                right = 0;
	            }
	            if (typeof left === CONST_STRING || typeof right === CONST_STRING) {
	                return left.toString().toUpperCase() < right.toString().toUpperCase();
	            } else {
	                var doubleLeft = {value: 0};
	                if (!Calc.Convert.rD(left, doubleLeft)) {
	                    return Calc.CalcErrorsValue;
	                }
	                left = doubleLeft.value;
	                var doubleRight = {value: 0};
	                if (!Calc.Convert.rD(right, doubleRight)) {
	                    return Calc.CalcErrorsValue;
	                }
	                right = doubleRight.value;
	                var x = left;
	                var y = right;
	                return x < y && !_approxEqual(x, y);
	            }
	        };
	
	        Operators.greaterThan = new BinaryOperator('>', false);
	        Operators.greaterThan._evaluateSingle = function(left, right, context) { // jshint ignore:line
	            if (Calc.Convert.err(left)) {
	                return left;
	            }
	            if (Calc.Convert.err(right)) {
	                return right;
	            }
	            if (left === KEYWORD_UNDEFINED || left === KEYWORD_NULL) {
	                left = 0;
	            }
	            if (right === KEYWORD_UNDEFINED || right === KEYWORD_NULL) {
	                right = 0;
	            }
	            if (typeof left === CONST_STRING || typeof right === CONST_STRING) {
	                return left.toString().toUpperCase() > right.toString().toUpperCase();
	            } else {
	                var doubleLeft = {value: 0};
	                if (!Calc.Convert.rD(left, doubleLeft)) {
	                    return Calc.CalcErrorsValue;
	                }
	                left = doubleLeft.value;
	                var doubleRight = {value: 0};
	                if (!Calc.Convert.rD(right, doubleRight)) {
	                    return Calc.CalcErrorsValue;
	                }
	                right = doubleRight.value;
	                var x = left;
	                var y = right;
	                return x > y && !_approxEqual(x, y);
	            }
	        };
	
	        Operators.lessThanOrEqual = new BinaryOperator('<=', false);
	        Operators.lessThanOrEqual._evaluateSingle = function(left, right, context) { // jshint ignore:line
	            if (Calc.Convert.err(left)) {
	                return left;
	            }
	            if (Calc.Convert.err(right)) {
	                return right;
	            }
	            if (left === KEYWORD_UNDEFINED || left === KEYWORD_NULL) {
	                left = 0;
	            }
	            if (right === KEYWORD_UNDEFINED || right === KEYWORD_NULL) {
	                right = 0;
	            }
	            if (typeof left === CONST_STRING || typeof right === CONST_STRING) {
	                return left.toString().toUpperCase() <= right.toString().toUpperCase();
	            } else {
	                var doubleLeft = {value: 0};
	                if (!Calc.Convert.rD(left, doubleLeft)) {
	                    return Calc.CalcErrorsValue;
	                }
	                left = doubleLeft.value;
	                var doubleRight = {value: 0};
	                if (!Calc.Convert.rD(right, doubleRight)) {
	                    return Calc.CalcErrorsValue;
	                }
	                right = doubleRight.value;
	                var x = left;
	                var y = right;
	                return x < y || _approxEqual(x, y);
	            }
	        };
	
	        Operators.greaterThanOrEqual = new BinaryOperator('>=', false);
	        Operators.greaterThanOrEqual._evaluateSingle = function(left, right, context) { // jshint ignore:line
	            if (Calc.Convert.err(left)) {
	                return left;
	            }
	            if (Calc.Convert.err(right)) {
	                return right;
	            }
	            if (left === KEYWORD_UNDEFINED || left === KEYWORD_NULL) {
	                left = 0;
	            }
	            if (right === KEYWORD_UNDEFINED || right === KEYWORD_NULL) {
	                right = 0;
	            }
	            if (typeof left === CONST_STRING || typeof right === CONST_STRING) {
	                return left.toString().toUpperCase() >= right.toString().toUpperCase();
	            } else {
	                var doubleLeft = {value: 0};
	                if (!Calc.Convert.rD(left, doubleLeft)) {
	                    return Calc.CalcErrorsValue;
	                }
	                left = doubleLeft.value;
	                var doubleRight = {value: 0};
	                if (!Calc.Convert.rD(right, doubleRight)) {
	                    return Calc.CalcErrorsValue;
	                }
	                right = doubleRight.value;
	                var x = left;
	                var y = right;
	                return x > y || _approxEqual(x, y);
	            }
	        };
	
	    })(CalcParser.Operators || (CalcParser.Operators = {}));
	
	})();


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 *
	 * SpreadJS Library 1.0.0
	 * http://wijmo.com/
	 *
	 * Copyright(c) GrapeCity, Inc.  All rights reserved.
	 *
	 * Licensed under the Wijmo Commercial License. Also available under the GNU GPL Version 3 license.
	 * licensing@wijmo.com
	 * http://wijmo.com/widgets/license/
	 *
	 *
	 **/
	
	(function() {
	    'use strict';
	    var Calc = __webpack_require__(9);
	
	    var CalcExpressions = {};
	    module.exports = CalcExpressions;
	
	    var CONST_UNDEFINED = 'undefined'; // jshint ignore:line
	    var CONST_NUMBER = 'number'; // jshint ignore:line
	    var CONST_STRING = 'string';
	    var CONST_BOOLEAN = 'boolean'; // jshint ignore:line
	    var CONST_TRUE = 'TRUE'; // jshint ignore:line
	    var CONST_FALSE = 'FALSE'; // jshint ignore:line
	    var CONST_ARRAY = 'ARRAY'; // jshint ignore:line
	    var CONST_ARRAYROW = 'ARRAYROW'; // jshint ignore:line
	    var CONST_NULL = '#NULL!';
	    var CONST_DIV0 = '#DIV/0!';
	    var CONST_VALUE = '#VALUE!';
	    var CONST_REF = '#REF!';
	    var CONST_NAME = '#NAME?';
	    var CONST_NA = '#N/A';
	    var CONST_NUM = '#NUM!';
	    var CONST_EXPR = 'expr'; // jshint ignore:line
	    var CONST_ARRAYINFO = 'arrayInfo'; // jshint ignore:line
	    var CONST_WORKINGEXPR = 'workingExpr'; // jshint ignore:line
	    var ERROR_LIST = [CONST_NULL, CONST_DIV0, CONST_VALUE, CONST_REF, CONST_NAME, CONST_NA, CONST_NUM]; // jshint ignore:line
	    var ERRORCODE_LIST = [0x00, 0x07, 0x0F, 0x17, 0x1D, 0x2A, 0x24]; // jshint ignore:line
	    var LETTER_POWS = [1, 26, 676]; // jshint ignore:line
	    var KEYWORD_NULL = null;
	    var KEYWORD_UNDEFINED = undefined; // jshint ignore:line
	    var SUPPORT_ROW_COLUMN_FORMULA = false; // jshint ignore:line
	    var MATH_MIN = Math.min; // jshint ignore:line
	    var MATH_MAX = Math.max; // jshint ignore:line
	    var MATH_ABS = Math.abs; // jshint ignore:line
	    var MATH_POW = Math.pow; // jshint ignore:line
	
	    (function(ExpressionType) {
	        ExpressionType[ExpressionType.Double = 0] = 'Double';
	        ExpressionType[ExpressionType.String = 1] = 'String';
	        ExpressionType[ExpressionType.Boolean = 2] = 'Boolean';
	        ExpressionType[ExpressionType.Function = 3] = 'Function';
	        ExpressionType[ExpressionType.BinaryOperator = 4] = 'BinaryOperator';
	        ExpressionType[ExpressionType.UnaryOperator = 5] = 'UnaryOperator';
	        ExpressionType[ExpressionType.Error = 6] = 'Error';
	        ExpressionType[ExpressionType.ExternalError = 7] = 'ExternalError';
	        ExpressionType[ExpressionType.Parentheses = 8] = 'Parentheses';
	        ExpressionType[ExpressionType.Array = 9] = 'Array';
	        ExpressionType[ExpressionType.StructReference = 10] = 'StructReference';
	        ExpressionType[ExpressionType.SheetRangeError = 11] = 'SheetRangeError';
	        ExpressionType[ExpressionType.MissingArgument = 12] = 'MissingArgument';
	    })(CalcExpressions.ExpressionType || (CalcExpressions.ExpressionType = {}));
	    var ExpressionType = CalcExpressions.ExpressionType; // jshint ignore:line
	
	    (function(Expressions) {
	        var Expression = (function() {
	            /**
	             * Provides the base class from which the classes that represent expression tree nodes are derived. This is an abstract class.
	             * @class
	             */
	            function Expression() {
	            }
	
	            return Expression;
	        })();
	        Expressions.Expression = Expression;
	
	        var ParenthesesExpression = (function(_super) {
	            /**
	             * Represents an expression type for parentheses surrounding a specified expression.
	             * @extends $.wijmo.wijspread.Calc.Expressions.Expression
	             * @class
	             * @param {object} arg The expression inside the parentheses.
	             */
	            function ParenthesesExpression_(arg) {
	                _super.call(this);
	                this.argument = arg;
	                this.t = 8 /* Parentheses */;
	            }
	
	            Calc.__extends(ParenthesesExpression_, _super);
	            return ParenthesesExpression_;
	        })(Expression);
	        Expressions.ParenthesesExpression = ParenthesesExpression;
	
	        var FunctionExpression = (function(_super) {
	            /**
	             * Represents an expression with a function applied to a list of parameters as the expression.
	             * @extends $.wijmo.wijspread.Calc.Expressions.Expression
	             * @class
	             * @param {object} fn The name of the function.
	             * @param {object[]} args The list of parameters.
	             */
	            function FunctionExpression_(fn, args) {
	                _super.call(this);
	                this.fn = fn;
	                this.args = args;
	                this.t = 3 /* Function */;
	            }
	            Calc.__extends(FunctionExpression_, _super);
	
	            /**
	             * Gets the number of parameters being passed to the function.
	             * @returns {number} The number of parameters.
	             */
	            FunctionExpression_.prototype.argCount = function() {
	                return this.args ? this.args.length : 0;
	            };
	
	            /**
	             * Returns the specified parameter being passed to the function.
	             * @param {number} index The index of the parameter (or argument).
	             * @returns {object} The specified parameter.
	             */
	            FunctionExpression_.prototype.getArg = function(index) {
	                return this.args ? this.args[index] : KEYWORD_NULL;
	            };
	
	            /**
	             * Gets the name of the function.
	             * @returns {string} The name of the function.
	             */
	            FunctionExpression_.prototype.getFunctionName = function() {
	                var self = this;
	                return typeof (self.fn) === CONST_STRING ? self.fn : self.fn.name;
	            };
	
	            return FunctionExpression_;
	        })(Expression);
	        Expressions.FunctionExpression = FunctionExpression;
	
	        var ConstantExpression = (function(_super) {
	            /**
	             * Represents an expression that has a constant value.
	             * @extends $.wijmo.wijspread.Calc.Expressions.Expression
	             * @class
	             * @param {object} value The constant value.
	             */
	            function ConstantExpression_(value) {
	                _super.call(this);
	                this.value = value;
	            }
	            Calc.__extends(ConstantExpression_, _super);
	
	            return ConstantExpression_;
	        })(Expression);
	        Expressions.ConstantExpression = ConstantExpression;
	
	        var BooleanExpression = (function(_super) {
	            /**
	             * Represents a boolean constant value.
	             * @extends $.wijmo.wijspread.Calc.Expressions.ConstantExpression
	             * @class
	             * @param {boolean} boolValue The boolean value.
	             */
	            function BooleanExpression_(value) {
	                _super.call(this, value);
	                this.t = 2 /* Boolean */;
	            }
	            Calc.__extends(BooleanExpression_, _super);
	
	            return BooleanExpression_;
	        })(ConstantExpression);
	        Expressions.BooleanExpression = BooleanExpression;
	
	        var DoubleExpression = (function(_super) {
	            /**
	             * Represents a double constant value.
	             * @extends $.wijmo.wijspread.Calc.Expressions.ConstantExpression
	             * @class
	             * @param {number} value The double value.
	             * @param {string} originalNumAsString The original string of the number.
	             */
	            function DoubleExpression_(value, originalNumAsString) {
	                _super.call(this, value);
	                this.originalValue = originalNumAsString;
	                this.t = 0 /* Double */;
	            }
	            Calc.__extends(DoubleExpression_, _super);
	
	            return DoubleExpression_;
	        })(ConstantExpression);
	        Expressions.DoubleExpression = DoubleExpression;
	
	        var StringExpression = (function(_super) {
	            /**
	             * Represents a string constant value.
	             * @extends $.wijmo.wijspread.Calc.Expressions.ConstantExpression
	             * @class
	             * @param {string} value The string value.
	             */
	            function StringExpression_(value) {
	                _super.call(this, value);
	                this.t = 1 /* String */;
	            }
	            Calc.__extends(StringExpression_, _super);
	
	            return StringExpression_;
	        })(ConstantExpression);
	        Expressions.StringExpression = StringExpression;
	
	        var ErrorExpression = (function(_super) {
	            /**
	             * Represents an error constant value.
	             * @extends $.wijmo.wijspread.Calc.Expressions.ConstantExpression
	             * @class
	             * @param {$.wijmo.wijspread.Calc.Error} value The error value.
	             */
	            function ErrorExpression_(value) {
	                _super.call(this, value);
	                this.t = 6 /* Error */;
	            }
	            Calc.__extends(ErrorExpression_, _super);
	
	            return ErrorExpression_;
	        })(ConstantExpression);
	        Expressions.ErrorExpression = ErrorExpression;
	
	        var ExternalErrorExpression = (function(_super) {
	            /**
	             * Represents an external error value.
	             * @extends $.wijmo.wijspread.Calc.Expressions.ErrorExpression
	             * @class
	             * @param {object} source The owner of the error.
	             * @param {$.wijmo.wijspread.Calc.Error} value The error value.
	             */
	            function ExternalErrorExpression_(source, value) {
	                _super.call(this, value);
	                this.source = source;
	                this.t = 7 /* ExternalError */;
	            }
	            Calc.__extends(ExternalErrorExpression_, _super);
	
	            return ExternalErrorExpression_;
	        })(ErrorExpression);
	        Expressions.ExternalErrorExpression = ExternalErrorExpression;
	
	        var MissingArgumentExpression = (function(_super) {
	            /**
	             * Represents a missing argument constant value.
	             * @extends $.wijmo.wijspread.Calc.Expressions.ConstantExpression
	             * @class
	             */
	            function MissingArgumentExpression_() {
	                _super.call(this, Calc.missingArgument);
	                this.t = 12 /* MissingArgument */;
	            }
	            Calc.__extends(MissingArgumentExpression_, _super);
	
	            return MissingArgumentExpression_;
	        })(ConstantExpression);
	        Expressions.MissingArgumentExpression = MissingArgumentExpression;
	
	        var OperatorExpression = (function(_super) {
	            /**
	             * Represents an operator expression. This is an abstract class.
	             * @extends $.wijmo.wijspread.Calc.Expressions.Expression
	             * @class
	             * @param {object} operator The operator.
	             */
	            function OperatorExpression_(operator) {
	                _super.call(this);
	                this.operator = operator;
	            }
	            Calc.__extends(OperatorExpression_, _super);
	
	            return OperatorExpression_;
	        })(Expression);
	        Expressions.OperatorExpression = OperatorExpression;
	
	        var UnaryOperatorExpression = (function(_super) {
	            /**
	             * Represents an expression that has a unary operator.
	             * @extends $.wijmo.wijspread.Calc.Expressions.OperatorExpression
	             * @class
	             * @param {object} operator The unary operator.
	             * @param {object} operand The operand.
	             */
	            function UnaryOperatorExpression_(operator, operand) {
	                _super.call(this, operator);
	                this.operand = operand;
	                this.t = 5 /* UnaryOperator */;
	            }
	            Calc.__extends(UnaryOperatorExpression_, _super);
	
	            return UnaryOperatorExpression_;
	        })(OperatorExpression);
	        Expressions.UnaryOperatorExpression = UnaryOperatorExpression;
	
	        var BinaryOperatorExpression = (function(_super) {
	            /**
	             * Represents an expression that has a binary operator.
	             * @extends $.wijmo.wijspread.Calc.Expressions.OperatorExpression
	             * @class
	             * @param {object} operator The binary operator.
	             * @param {object} left The left operand.
	             * @param {object} right The right operand.
	             */
	            function BinaryOperatorExpression_(operator, left, right) {
	                _super.call(this, operator);
	                this.left = left;
	                this.right = right;
	                this.t = 4 /* BinaryOperator */;
	            }
	            Calc.__extends(BinaryOperatorExpression_, _super);
	
	            return BinaryOperatorExpression_;
	        })(OperatorExpression);
	        Expressions.BinaryOperatorExpression = BinaryOperatorExpression;
	
	        var StructReferenceExpression = (function(_super) {
	            /**
	             * Represents a struct reference expression.
	             * @extends $.wijmo.wijspread.Calc.Expressions.ReferenceExpression
	             * @class
	             * @param {string} structRef The struct reference string.
	             */
	            function StructReferenceExpression_(table, column) {
	                var self = this;
	                self.table = table;
	                self.column = column;
	            }
	            Calc.__extends(StructReferenceExpression_, _super);
	
	            return StructReferenceExpression_;
	        })(Expression);
	        Expressions.StructReferenceExpression = StructReferenceExpression;
	
	        var FieldReferenceExpression = (function(_super) {
	            /**
	             * Represents a struct reference expression.
	             * @extends $.wijmo.wijspread.Calc.Expressions.ReferenceExpression
	             * @class
	             * @param {string} structRef The struct reference string.
	             */
	            function FieldReferenceExpression_(name) {
	                var self = this;
	                self.name = name;
	            }
	            Calc.__extends(FieldReferenceExpression_, _super);
	
	            return FieldReferenceExpression_;
	        })(Expression);
	        Expressions.FieldReferenceExpression = FieldReferenceExpression;
	
	        var UnknownReferenceExpression = (function(_super) {
	            /**
	             * Represents a struct reference expression.
	             * @extends $.wijmo.wijspread.Calc.Expressions.ReferenceExpression
	             * @class
	             * @param {string} structRef The struct reference string.
	             */
	            function UnknownReferenceExpression_(name) {
	                var self = this;
	                self.name = name;
	            }
	            Calc.__extends(UnknownReferenceExpression_, _super);
	
	            return UnknownReferenceExpression_;
	        })(Expression);
	        Expressions.UnknownReferenceExpression = UnknownReferenceExpression;
	
	    })(CalcExpressions || (CalcExpressions = {}));
	})();


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var CONST_UNDEFINED = 'undefined';// jshint ignore:line
	    var CONST_NUMBER = 'number';// jshint ignore:line
	    var CONST_STRING = 'string';// jshint ignore:line
	    var CONST_BOOLEAN = 'boolean';// jshint ignore:line
	    var CONST_TRUE = 'TRUE';// jshint ignore:line
	    var CONST_FALSE = 'FALSE';// jshint ignore:line
	    var CONST_ARRAY = 'ARRAY';// jshint ignore:line
	    var CONST_ARRAYROW = 'ARRAYROW';// jshint ignore:line
	    var CONST_NULL = '#NULL!';
	    var CONST_DIV0 = '#DIV/0!';
	    var CONST_VALUE = '#VALUE!';
	    var CONST_REF = '#REF!';
	    var CONST_NAME = '#NAME?';
	    var CONST_NA = '#N/A';
	    var CONST_NUM = '#NUM!';
	    var CONST_EXPR = 'expr';// jshint ignore:line
	    var CONST_ARRAYINFO = 'arrayInfo';// jshint ignore:line
	    var CONST_WORKINGEXPR = 'workingExpr';// jshint ignore:line
	    var ERROR_LIST = [CONST_NULL, CONST_DIV0, CONST_VALUE, CONST_REF, CONST_NAME, CONST_NA, CONST_NUM];// jshint ignore:line
	    var ERRORCODE_LIST = [0x00, 0x07, 0x0F, 0x17, 0x1D, 0x2A, 0x24];// jshint ignore:line
	    var LETTER_POWS = [1, 26, 676];// jshint ignore:line
	    var KEYWORD_NULL = null;
	    var KEYWORD_UNDEFINED = undefined;// jshint ignore:line
	    var SUPPROT_ROW_COLUMN_FORMULA = false;// jshint ignore:line
	    var MATH_MIN = Math.min;// jshint ignore:line
	    var MATH_MAX = Math.max;// jshint ignore:line
	    var MATH_ABS = Math.abs;// jshint ignore:line
	    var MATH_POW = Math.pow;// jshint ignore:line
	
	    var Calc = __webpack_require__(9);
	    var CalcExpressions = __webpack_require__(12);
	    var CalcParser = __webpack_require__(11);
	    var CalcHelper = __webpack_require__(14);
	    var CalcFunctions = __webpack_require__(19);
	
	    var throwSR = Calc.SRHelper.throwSR;
	
	    var defaultParser = new CalcParser.Parser();
	
	    var Evaluator = (function() {
	        function Evaluator() {
	        }
	
	        Evaluator.prototype.evaluateFormula = function(formula, parserContext, evaluatorContext) {
	            var expr = defaultParser.parse(formula, parserContext);
	            return this.evaluateExpression(expr, evaluatorContext);
	        };
	
	        /**
	         * Evaluates an expression with the specified context.
	         * @param {$.wijmo.wijspread.CalcExpressions.Expression} expression The expression to be evaluated.
	         * @param {$.wijmo.wijspread.Calc.EvaluateContext} evaluatorContext The context for the evaluator to query data.
	         * @returns {object} The result of the evaluation.
	         */
	        Evaluator.prototype.evaluateExpression = function(expression, evaluatorContext) {
	            var result = this._evaluate(expression, evaluatorContext);
	            return result;
	        };
	        Evaluator.prototype._evaluate = function(expr, context) {
	            if (!expr) {
	                throwSR('Exp_ExprIsNull');
	            }
	            while (expr.t === 8 /* Parentheses */) {
	                expr = expr.argument;
	            }
	            var self = this;
	            var result;
	            if (expr instanceof CalcExpressions.ConstantExpression) {
	                result = self._evaluateConst(expr, context);
	            } else if (expr instanceof CalcExpressions.UnaryOperatorExpression /* UnaryOperator */) {
	                result = self._evaluateUnaryOperation(expr, context);
	            } else if (expr instanceof CalcExpressions.BinaryOperatorExpression /* BinaryOperator */) {
	                result = self._evaluateBinaryOperation(expr, context);
	            } else if (expr instanceof CalcExpressions.FunctionExpression /* Function */) {
	                if (expr.fn.isCalculate()) {
	                    result = self._evaluateCalculateFunction(expr, context);
	                } else if (expr.fn.isSummarize()) {
	                    result = self._evaluateSummarizeFunction(expr, context);
	                } else {
	                    result = self._evaluateFunction(expr, context);
	                }
	            } else if (expr instanceof CalcExpressions.StructReferenceExpression /* StructExpression */) {
	                result = self._evaluateStructExpression(expr, context);
	            } else if (expr instanceof CalcExpressions.FieldReferenceExpression /* FieldExpression */) {
	                result = self._evaluateFieldExpression(expr, context);
	            } else if (expr instanceof CalcExpressions.UnknownReferenceExpression /* FieldExpression */) {
	                result = self._evaluateUnknownExpression(expr, context);
	            }
	            return result;
	        };
	
	        Evaluator.prototype._evaluateConst = function(expr, context) { // jshint ignore:line
	            var value = expr.value;
	            return value;
	        };
	        Evaluator.prototype._evaluateUnaryOperation = function(expr, context) {
	            //var acceptsReferences = false;
	
	            // first evaluate the parameter, then invoke operator.
	            var arg = this._evaluate(expr.operand, context);
	            if (Calc.Convert.err(arg)) {
	                return arg;
	            }
	            if (arg === Calc.missingArgument) {
	                return Calc.CalcErrorsNotAvailable;
	            }
	            return expr.operator.evaluate(arg, context);
	        };
	        Evaluator.prototype._evaluateBinaryOperation = function(expr, context) {
	
	            // first evaluate arguments expressions one by one, if error found, return directly.
	            // Then invoke operator
	            var sub = [expr.left, expr.right];
	            var args = [];
	            for (var i = 0; i < 2; i++) {
	                var arg = this._evaluate(sub[i], context);
	                if (Calc.Convert.err(arg)) {
	                    return arg;
	                }
	                if (arg === Calc.missingArgument) {
	                    return Calc.CalcErrorsNotAvailable;
	                }
	                args[i] = arg;
	            }
	            return expr.operator.evaluate(args[0], args[1], context);
	        };
	
	        Evaluator.prototype._evaluateFunction = function(expr, context) {
	            if (!expr || !expr.fn || typeof expr.fn === 'string') {
	                return Calc.CalcErrorsName;
	            }
	            var self = this;
	            var argCount = expr.argCount();
	            var fn = expr.fn;
	            var argExprs = [];
	            var args = [];
	            var arg;
	            var i;
	            var cachedSource;
	            for (i = 0; i < argCount; i++) {
	                argExprs.push(expr.getArg(i));
	            }
	            var tableArgIndex = fn.tableArgIndex();
	            if (tableArgIndex !== -1) {
	                cachedSource = context.calcSource;
	                var filterArgs = preProcessFilterContext_.call(self, argExprs, tableArgIndex, context);
	                if (filterArgs.filterOmitted) {
	                    ++argCount;
	                }
	                args[tableArgIndex] = filterArgs.tableContextArg;
	            }
	
	            var isAggregator = fn.isAggregator();
	            if (isAggregator) {
	                context.beginAggregating_();
	            }
	            if (argCount !== 0) {
	                for (i = 0; i < argCount; i++) {
	                    if (i === tableArgIndex) {
	                        continue;
	                    }
	
	                    var argExpr = argExprs[i];
	                    arg = self._evaluate(argExpr, context);
	
	                    if ((Calc.Convert.err(arg)) && !fn.acceptsError(i)) {
	                        return arg;
	                    }
	                    if (arg === Calc.missingArgument) {
	                        if (!fn.acceptsMissingArgument(i)) {
	                            arg = KEYWORD_NULL;
	                        }
	                    }
	                    args[i] = arg;
	                }
	
	            }
	            var result = expr.fn.evaluate(args, context);
	            if (tableArgIndex !== -1 && cachedSource) {
	                context.calcSource = cachedSource;
	            }
	            if (isAggregator) {
	                context.endAggregating_();
	            }
	            return result;
	        };
	
	        Evaluator.prototype._evaluateCalculateFunction = function(expr, context) {
	            if (!expr || !expr.fn || typeof expr.fn === 'string') {
	                return Calc.CalcErrorsName;
	            }
	            var self = this;
	            var calcExpr = expr.getArg(0);
	            var argCount = expr.argCount();
	            var argExpr;
	            var i;
	            var result;
	            var filter;
	            var filterExprs = [];
	            var tempContext;
	            var fieldObj;
	            var columnObj;
	            var cachedSource = context.calcSource;
	
	            if (argCount === 1) {
	                result = self._evaluate(calcExpr, context);
	                if (CalcHelper.columnRef(result)) {
	                    result = result.getValue(context.getCurrentRow(), context.groupPath);
	                } else if (CalcHelper.fieldRef(result)) {
	                    result = result.getValue();
	                }
	                return result;
	            }
	            for (i = 1; i < argCount; i++) {
	                argExpr = expr.getArg(i);
	                filterExprs.push(argExpr);
	            }
	            _.forEach(filterExprs, function(filterExpr) {
	                if (CalcHelper.fnExpr(filterExpr) && filterExpr.fn.isTableResult()) {
	                    if (!CalcHelper.err(tempContext = self._evaluate(filterExpr, context))) {
	                        context.calcSource = tempContext.calcSource;
	                    }
	                } else {
	                    filter = CalcFunctions.findGlobalFunction('filter');
	                    filter = new CalcExpressions.FunctionExpression(filter, [filterExpr]);
	                    if (!CalcHelper.err(tempContext = self._evaluate(filter, context))) {
	                        context.calcSource = tempContext.calcSource;
	                    }
	                }
	            });
	            result = self._evaluate(calcExpr, context);
	            if (CalcHelper.columnRef(result)) {
	                columnObj = result.calcSource.findColumn(result.column);
	                if (!columnObj) {
	                    return Calc.CalcErrorsReference;
	                }
	                var row = context.getCurrentRow(false);
	                if (context.calcSource.isFilterOut(row)) {
	                    return;
	                } else {
	                    result = (columnObj.type === CalcHelper.DATA_COLUMN) ?
	                        result.getValue(row, context.groupPath) :
	                        self._evaluate(columnObj.expression, context);
	                }
	            } else if (CalcHelper.fieldRef(result)) {
	                fieldObj = result.calcSource.findCalcField(result.name);
	                argExpr = fieldObj && fieldObj.expression;
	                if (!argExpr) {
	                    return Calc.CalcErrorsReference;
	                }
	                result = self._evaluate(argExpr, context);
	            }
	            context.calcSource = cachedSource;
	            return result;
	        };
	
	        Evaluator.prototype._evaluateSummarizeFunction = function(expr, context) {
	            if (!expr || !expr.fn || typeof expr.fn === 'string') {
	                return Calc.CalcErrorsName;
	            }
	            var self = this;
	            var argCount = expr.argCount();
	            var fn = expr.fn;
	            var argExprs = [];
	            var args = [];
	            var i;
	            var cachedSource = context.calcSource;
	            for (i = 0; i < argCount; i++) {
	                argExprs.push(expr.getArg(i));
	            }
	
	            var tableArgIndex = fn.tableArgIndex();
	            var filterArgs = preProcessFilterContext_.call(self, argExprs, tableArgIndex, context);
	            if (filterArgs.filterOmitted) {
	                ++argCount;
	            }
	            args[tableArgIndex] = filterArgs.tableContextArg;
	
	            var isAggregator = fn.isAggregator();
	            if (isAggregator) {
	                context.beginAggregating_();
	            }
	
	            //get parameters:
	            var columnNames = [];
	            var newColumns = [];
	            var newExprs = [];
	            var len = argExprs.length;
	            i = 1;
	            //todo: adjust the logic to correct the case of nest summarize
	            var tempExpr;
	            while (CalcHelper.structExpr(tempExpr = argExprs[i]) && tempExpr.column && i < len) {
	                columnNames.push(tempExpr.column);
	                ++i;
	            }
	            while (CalcHelper.strExpr(tempExpr = argExprs[i]) && i < len) {
	                if (_.indexOf(columnNames, tempExpr.value) < 0) {
	                    newColumns.push(tempExpr.value);
	                    ++i;
	                } else {
	                    return Calc.CalcErrorsReference;
	                }
	                newExprs.push(argExprs[i++] || Calc.CalcErrorsReference);
	            }
	
	            //set group and calculate
	            var tempCalcSource = context.calcSource;
	            var tempTable = tempCalcSource.getModel(CalcHelper.CALC_TABLE);
	            var groupDesc = _.map(columnNames, function(name) {
	                return {field: name};
	            });
	
	            tempTable.beginUseGroup();
	            var groupTree = tempCalcSource.group(groupDesc);
	            var groupPathBackup = context.groupPath;
	            var groupPathStack = [];
	            for (i = groupTree.groups.length - 1; i >= 0; --i) {
	                groupPathStack.push([i]);
	            }
	            var currGroupPath;
	            var currGroup;
	            var isBottomLevel;
	            var result = [];
	            var tempResult;
	            var itemSample;
	            while (groupPathStack.length > 0) {
	                currGroupPath = groupPathStack.pop();
	                currGroup = getGroupByPath_(groupTree, currGroupPath);
	                context.groupPath = currGroupPath;
	                itemSample = currGroup.getItem(0);
	                isBottomLevel = currGroup.isBottomLevel;
	                if (isBottomLevel === true) {
	                    tempResult = {};
	                    for (i = 0, len = newColumns.length; i < len; ++i) {
	                        tempExpr = newExprs[i];
	                        if (CalcHelper.err(tempExpr)) {
	                            tempResult[newColumns[i]] = tempExpr;
	                        } else {
	                            tempResult[newColumns[i]] = self._evaluate(tempExpr, context);
	                        }
	                    }
	                    for (i = 0, len = columnNames.length; i < len; ++i) {
	                        tempResult[columnNames[i]] = itemSample[columnNames[i]];
	                    }
	                    result.push(tempResult);
	                } else if (currGroup.isBottomLevel === false) {
	                    for (i = currGroup.groups.length - 1; i >= 0; --i) {
	                        groupPathStack.push(currGroupPath.concat([i]));
	                    }
	                }
	            }
	            context.groupPath = groupPathBackup;
	            tempTable.endUseGroup();
	            if (tableArgIndex !== -1 && cachedSource) {
	                context.calcSource = cachedSource;
	            }
	            if (isAggregator) {
	                context.endAggregating_();
	            }
	            return new Calc.CalcTableReference(context.calcSource.create('summarizedTable', result));
	        };
	
	        function preProcessFilterContext_(argExprs, tableArgIndex, context) {
	            var self = this;
	            var tableContextArg;
	            var tableContextExpr = argExprs[tableArgIndex];
	            var calcSource = context.calcSource;
	            var filterOmitted = false;
	            if (CalcHelper.structExpr(tableContextExpr) && !tableContextExpr.column) {
	                if (tableContextExpr.table === calcSource.name) {
	                    tableContextArg = self._evaluate(tableContextExpr, context);
	                } else {
	                    return Calc.CalcErrorsReference;
	                }
	            } else if (CalcHelper.strExpr(tableContextExpr)) {
	                if (tableContextExpr.value === calcSource.name) {
	                    tableContextArg = new Calc.CalcTableReference(calcSource);
	                } else {
	                    return Calc.CalcErrorsReference;
	                }
	            } else if (CalcHelper.fnExpr(tableContextExpr) && tableContextExpr.fn.isTableResult()) {
	                tableContextArg = self._evaluate(tableContextExpr, context);
	            } else {
	                tableContextArg = new Calc.CalcTableReference(calcSource);
	                argExprs.splice(tableArgIndex, 0, null);
	                filterOmitted = true;
	            }
	            if (CalcHelper.err(tableContextArg)) {
	                return Calc.CalcErrorsReference;
	            }
	            if (CalcHelper.tabRef(tableContextArg)) {
	                context.calcSource = tableContextArg.calcSource;
	            }
	            //else if(_.isArray(tableContextArg)){ // like SUMX([price] > 100,[count] * [price]), it has no filter/table, just array of filter results
	            //    var tmpSource = cachedSource.clone();
	            //    tmpSource.setFilterStates(tableContextArg);
	            //    context.calcSource = tmpSource;
	            //}
	            return {
	                filterOmitted: filterOmitted,
	                tableContextArg: tableContextArg
	            };
	        }
	
	        function getGroupByPath_(group, path) {
	            var i;
	            var len;
	            var currentGroup = group.groups[path[0]];
	            for (i = 1, len = path.length; i < len; i++) {
	                currentGroup = currentGroup.groups[path[i]];
	            }
	            return currentGroup;
	        }
	
	        Evaluator.prototype._evaluateStructExpression = function(expr, context) {
	            if (expr.table && expr.column) {
	                return new Calc.CalcColumnReference(context.calcSource, expr.column);
	            } else if (expr.table) {
	                return new Calc.CalcTableReference(context.calcSource, expr.table);
	            }
	        };
	
	        Evaluator.prototype._evaluateFieldExpression = function(expr, context) {
	            return new Calc.CalcFieldReference(context.calcSource, expr.name);
	        };
	
	        Evaluator.prototype._evaluateUnknownExpression = function(expr, context) {
	            if (context.calcSource.findColumn(expr.name)) {
	                return new Calc.CalcColumnReference(context.calcSource, expr.name);
	            } else if (context.calcSource.findCalcField(expr.name)) {
	                return new Calc.CalcFieldReference(context.calcSource, expr.name);
	            }
	            return Calc.CalcErrorsReference;
	        };
	
	        Evaluator.prototype._evaluateWithArgs = function(expr, evaluateDelegate, context, args) {
	            return evaluateDelegate(args, context);
	        };
	        return Evaluator;
	    })();
	
	    module.exports = Evaluator;
	})();


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 *
	 * SpreadJS Library 1.0.0
	 * http://wijmo.com/
	 *
	 * Copyright(c) GrapeCity, Inc.  All rights reserved.
	 *
	 * Licensed under the Wijmo Commercial License. Also available under the GNU GPL Version 3 license.
	 * licensing@wijmo.com
	 * http://wijmo.com/widgets/license/
	 *
	 *
	 **/
	
	(function() {
	    'use strict';
	    var Calc = __webpack_require__(9);
	    var CalcExpressions = __webpack_require__(12);
	    var CalcFunctions = __webpack_require__(19);
	
	    var CalcHelper = (function() {
	        function CalcHelper() {
	
	        }
	
	        CalcHelper.DATA_COLUMN = 'DataCol';
	        CalcHelper.CALC_COLUMN = 'CalcCol';
	        CalcHelper.EXTERNAL_COLUMN = 'ExternalCol';
	        CalcHelper.CALC_FIELD = 'CalcField';
	        CalcHelper.CALC_G_FIELD = 'CalcGField';
	        CalcHelper.CALC_TABLE = 'CalcTable';
	
	        CalcHelper.resolveDepends = function(expression, calcSource) {
	            var depExprList = [];
	            resolveExpressions_(expression, null, depExprList);
	            if (depExprList.length === 0) {
	                return null;
	            }
	            return _.map(depExprList, function(depExpr) {
	                var expr = depExpr.expr;
	                var aggContext = depExpr.aggContext;
	                if (CalcHelper.structExpr(expr)) {
	                    var column = expr.column;
	                    if (column) {
	                        var type = null;
	                        var colObj = calcSource.findColumn(column);
	                        if (colObj) {
	                            type = colObj.type;
	                        } else {
	                            type = CalcHelper.EXTERNAL_COLUMN;
	                        }
	                        //if(calcSource.findDataColumn(column)){
	                        //    type = CalcHelper.DATA_COLUMN;
	                        //}else if(calcSource.findCalcColumn(column)) {
	                        //    type = CalcHelper.CALC_COLUMN;
	                        //}else {
	                        //    type = CalcHelper.EXTERNAL_COLUMN;
	                        //}
	                        return {
	                            type: type,
	                            table: expr.table,
	                            column: column,
	                            aggContext: aggContext
	                        };
	                    } else {
	                        return {
	                            type: 'table',
	                            table: expr.table
	                        };
	                    }
	                } else if (CalcHelper.fieldExpr(expr)) {
	                    var name = expr.name;
	                    if (name) {
	                        return {type: CalcHelper.CALC_FIELD, name: name};
	                    } else {
	                        return null;
	                    }
	                }
	            });
	        };
	
	        CalcHelper.structExpr = function(expr) {
	            return expr instanceof CalcExpressions.StructReferenceExpression;
	        };
	
	        CalcHelper.fnExpr = function(expr) {
	            return expr instanceof CalcExpressions.FunctionExpression;
	        };
	
	        CalcHelper.fieldExpr = function(expr) {
	            return expr instanceof CalcExpressions.FieldReferenceExpression;
	        };
	
	        CalcHelper.binaryExpr = function(expr) {
	            return expr instanceof CalcExpressions.BinaryOperatorExpression;
	        };
	
	        CalcHelper.tableContextFn = function(fn) {
	            return fn.tableArgIndex() !== -1;
	        };
	
	        CalcHelper.filterFn = function(expr) {
	            return expr instanceof CalcExpressions.FunctionExpression && expr.fn instanceof CalcFunctions.Function && expr.fn.isFilter();
	        };
	
	        CalcHelper.aggFn = function(expr) {
	            return expr instanceof CalcExpressions.FunctionExpression && expr.fn instanceof CalcFunctions.Function && expr.fn.isAggregator();
	        };
	
	        CalcHelper.fieldRef = function(ref) {
	            return ref instanceof Calc.CalcFieldReference;
	        };
	
	        CalcHelper.columnRef = function(ref) {
	            return ref instanceof Calc.CalcColumnReference;
	        };
	
	        CalcHelper.tabRef = function(ref) {
	            return ref instanceof Calc.CalcTableReference;
	        };
	
	        CalcHelper.err = function(value) {
	            return value instanceof Calc.CalcError;
	        };
	
	        CalcHelper.strExpr = function(expr) {
	            return expr instanceof CalcExpressions.StringExpression;
	        };
	
	        CalcHelper.unknowExpr = function(expr) {
	            return expr instanceof CalcExpressions.UnknownReferenceExpression;
	        };
	
	        CalcHelper.getCalcObj = function(calcDepNode, calcSource) {
	            var calcObj;
	            var colName = calcDepNode.column;
	            if (calcDepNode.type === CalcHelper.CALC_COLUMN) {
	                calcObj = calcSource.findCalcColumn(colName);
	            } else if (calcDepNode.type === CalcHelper.DATA_COLUMN) {
	                calcObj = calcSource.findDataColumn(colName);
	            } else if (calcDepNode.type === CalcHelper.CALC_FIELD) {
	                calcObj = calcSource.findCalcField(calcDepNode.name);
	            } else if (calcDepNode.type === CalcHelper.CALC_G_FIELD) {
	                calcObj = calcSource.findCalcGroupField(calcDepNode.name);
	            } else {
	                calcObj = null;
	            }
	            return calcObj;
	        };
	
	        function resolveExpressions_(expr, parentExpr, depExprList) {
	            if (CalcHelper.structExpr(expr)) {
	                depExprList.push({expr: expr, aggContext: CalcHelper.aggFn(parentExpr)});
	            } else if (CalcHelper.fieldExpr(expr)) {
	                depExprList.push({expr: expr});
	            } else if (CalcHelper.binaryExpr(expr)) {
	                resolveExpressions_(expr.left, expr, depExprList);
	                resolveExpressions_(expr.right, expr, depExprList);
	            } else if (CalcHelper.fnExpr(expr)) {
	                var args = expr.args;
	                if (args && args.length > 0) {
	                    _.forEach(args, function(argExpr) {
	                        resolveExpressions_(argExpr, expr, depExprList);
	                    });
	                }
	            }
	        }
	
	        return CalcHelper;
	    })();
	
	    module.exports = CalcHelper;
	})();


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 *
	 * SpreadJS Library 1.0.0
	 * http://wijmo.com/
	 *
	 * Copyright(c) GrapeCity, Inc.  All rights reserved.
	 *
	 * Licensed under the Wijmo Commercial License. Also available under the GNU GPL Version 3 license.
	 * licensing@wijmo.com
	 * http://wijmo.com/widgets/license/
	 *
	 *
	 **/
	
	(function() {
	    'use strict';
	    //var Calc = require('./common');
	    var CalcSource = __webpack_require__(17).CalcSource;
	    var CalcContext = __webpack_require__(10);
	    //var CalcModels = require('./calcModels');
	    var CalcHelper = __webpack_require__(14);
	
	    var CalcManager = (function() {
	        function CalcManager(name, dataSource) {
	            var self = this;
	            var calcSource = new CalcSource(name, dataSource);
	            self.calcSource_ = calcSource;
	            self.dataColumns_ = calcSource.getModel(CalcHelper.DATA_COLUMN);
	            self.calcColumns_ = calcSource.getModel(CalcHelper.CALC_COLUMN);
	            self.calcTable_ = calcSource.getModel(CalcHelper.CALC_TABLE);
	            self.calcFields_ = calcSource.getModel(CalcHelper.CALC_FIELD);
	            self.calcGroupFields_ = calcSource.getModel(CalcHelper.CALC_G_FIELD);
	        }
	
	        CalcManager.prototype = {
	            addCalcColumn: function(name, formula) {
	                this.calcColumns_.addColumn(name, formula);
	            },
	
	            removeCalcColumn: function(name) {
	                this.calcColumns_.removeColumn(name);
	            },
	
	            getCalcColumnValues: function(name) {
	                return this.calcSource_.getValues(name);
	            },
	
	            getCalcColumnValue: function(name, index) {
	                return this.calcSource_.getValue(name, index);
	            },
	
	            calculateColumn: function(name, force) {
	                this.calcColumns_.calculateColumn(name, force);
	            },
	
	            getCalcRowItem: function(row) {
	                return this.calcTable_.getCalcRowItem(row);
	            },
	
	            getRowItem: function(row) {
	                this.calcTable_.getRowItem(row);
	            },
	
	            addCalcField: function(name, formula) {
	                var self = this;
	                self.calcFields_.addField(name, formula);
	                var unknownExprColumns = getUnknownExpressionColumns.call(self);
	                if (unknownExprColumns.length > 0) {
	                    _.forEach(unknownExprColumns, function(col) {
	                        self.calcColumns_.updateColumnFormula(col);
	                    });
	                }
	            },
	
	            getCalcFieldValue: function(name) {
	                return this.calcFields_.getValue(name);
	            },
	
	            calculateField: function(name) {
	                return this.calcFields_.calculateField(name);
	            },
	
	            addCalcGroupField: function(name, formula) {
	                this.calcGroupFields_.addField(name, formula);
	            },
	
	            getCalcGroupFieldValue: function(name, groupPath) {
	                return this.calcGroupFields_.getValue(name, groupPath);
	            },
	
	            getParserContext: function() {
	                return new CalcContext.ParserContext(this.calcSource_);
	            },
	
	            getEvaluatorContext: function(row, groupPath) {
	                return new CalcContext.EvaluateContext(this.calcSource_, row, groupPath);
	            },
	
	            getParser: function() {
	                return this.calcSource_.getParser();
	            },
	
	            getEvaluator: function() {
	                return this.calcSource_.getEvaluator();
	            },
	
	            getDimension: function() {
	                return this.calcSource_.getDimension();
	            },
	
	            findDataColumn: function(name) {
	                return this.dataColumns_.findDataColumn(name);
	            },
	
	            findCalcColumn: function(name) {
	                return this.calcColumns_.findCalcColumn(name);
	            },
	
	            findColumn: function(name) {
	                return this.calcSource_.findColumn(name);
	            },
	
	            findCalcField: function(name) {
	                return this.calcFields_.findField(name);
	            },
	
	            findCalcGroupField: function(name) {
	                return this.calcGroupFields_.findField(name);
	            },
	
	            addRowItem: function(index, item) { // jshint ignore:line
	
	            },
	
	            removeRowItem: function(index) { // jshint ignore:line
	
	            },
	
	            group: function(gds) {
	                this.calcSource_.group(gds);
	            },
	
	            getGroups: function() {
	                if (this.dataSource.getGroups) {
	                    return this.dataSource.getGroups();
	                }
	                return null;
	            },
	
	            dirtyColumn: function(column, index, newFormula) {
	                this.calcSource_.dirtyColumn(column, index, newFormula);
	            },
	
	            dirtyField: function(name) {
	                this.calcSource_.dirtyField(name);
	            },
	
	            getCalcSource: function() {
	                return this.calcSource_;
	            }
	        };
	
	        function getUnknownExpressionColumns() {
	            var self = this;
	            var columns = [];
	            var calcColumns = self.calcColumns_.getColumns();
	            if (calcColumns) {
	                _.forEach(calcColumns, function(calcCol) {
	                    var result = containsUnknownExpression.call(self, calcCol.expression);
	                    if (result) {
	                        columns.push(calcCol.name);
	                    }
	                });
	            }
	            return columns;
	        }
	
	        function containsUnknownExpression(expr) {
	            if (!expr) {
	                return false;
	            }
	            if (CalcHelper.unknowExpr(expr)) {
	                return true;
	            } else if (CalcHelper.binaryExpr(expr)) {
	                if (containsUnknownExpression(expr.left) ||
	                        containsUnknownExpression(expr.right)) {
	                    return true;
	                }
	                return false;
	            } else if (CalcHelper.fnExpr(expr)) {
	                var args = expr.args;
	                if (args && args.length > 0) {
	                    for (var i = 0, len = args.length; i < len; i++) {
	                        if (containsUnknownExpression(args[i])) {
	                            return true;
	                        }
	                    }
	                }
	                return false;
	            } else {
	                return false;
	            }
	        }
	
	        return CalcManager;
	    })();
	
	    module.exports = CalcManager;
	})();


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 *
	 * SpreadJS Library 1.0.0
	 * http://wijmo.com/
	 *
	 * Copyright(c) GrapeCity, Inc.  All rights reserved.
	 *
	 * Licensed under the Wijmo Commercial License. Also available under the GNU GPL Version 3 license.
	 * licensing@wijmo.com
	 * http://wijmo.com/widgets/license/
	 *
	 *
	 **/
	
	(function() {
	    'use strict';
	    //var Calc = require('./common');
	    var CalcHelper = __webpack_require__(14);
	    var CalcContext = __webpack_require__(10);
	    //var gcUtils = require('../gcUtils');
	    var CalcModels = {};
	    var objectDefineProperty = Object.defineProperty;
	
	    var CalcGroup_ = (function() {
	        function CalcGroup_(table, name, level, isBottomLevel) {
	            var self = this;
	            self.level = level;
	            self.table_ = table;
	            self.isBottomLevel = isBottomLevel;
	            self.name = name;
	            if (isBottomLevel) {
	                self.items = [];
	            } else {
	                self.groups = [];
	            }
	        }
	
	        CalcGroup_.prototype = {
	            getItem: function(index) {
	                var self = this;
	                var bottomGroupInfo = self.searchChildGroup(index);
	                if (bottomGroupInfo) {
	                    if (self.rootNode_) {
	                        return self.rootNode_.getItem(index);
	                    } else {
	                        return self.table_.getRowItem_(bottomGroupInfo.group.items[bottomGroupInfo.relativeIndex]);
	                    }
	                }
	                return null;
	            },
	
	            getIndexMappingIndexes: function() {
	                var self = this;
	                var indexes = [];
	                var bGroups = self.getBottomGroups();
	                if (bGroups) {
	                    for (var gi = 0, gLen = bGroups.length; gi < gLen; gi++) {
	                        var bGroug = bGroups[gi];
	                        for (var i = 0, len = bGroug.items.length; i < len; i++) {
	                            indexes.push(bGroug.items[i]);
	                        }
	                    }
	                }
	                return indexes;
	            },
	
	            getItems: function() {
	                var self = this;
	                var items = [];
	                var bGroups = self.getBottomGroups();
	                if (bGroups) {
	                    for (var gi = 0, gLen = bGroups.length; gi < gLen; gi++) {
	                        var bGroug = bGroups[gi];
	                        for (var i = 0, len = bGroug.items.length; i < len; i++) {
	                            items.push(self.table_.getRowItem_(bGroug.items[i]));
	                        }
	                    }
	                }
	                return items;
	            },
	
	            toSourceIndex: function(localIndex) {
	                var self = this;
	                var bottomGroupInfo = self.searchChildGroup(localIndex);
	                var indexMappingIndex = bottomGroupInfo && bottomGroupInfo.group.items[bottomGroupInfo.relativeIndex];
	                var indexMappings = self.table_.indexMappings_;
	                if (indexMappings && indexMappingIndex >= 0 && indexMappingIndex < indexMappings.length) {
	                    return indexMappings[indexMappingIndex];
	                }
	                return indexMappingIndex;
	            },
	
	            hierarchy: function(hierarchyInfo) {
	                var self = this;
	                var table = self.table_;
	                self.hierarchyInfo_ = hierarchyInfo;
	                delete self.rootNode_;
	                if (!hierarchyInfo || !hierarchyInfo.hasOwnProperty('parentField') || !hierarchyInfo.hasOwnProperty('keyField')) {
	                    return null;
	                }
	
	                var root = createGroupsForTree_.call(self, {field: hierarchyInfo.parentField});
	                if (root && root.groups && root.groups.length > 0) {
	                    var groups = root.groups;
	                    var keyColObj = self.table_.findColumn(hierarchyInfo.keyField);
	                    var firstGroup = _.find(groups, _.matchesProperty('name', undefined));
	                    if (!firstGroup) {
	                        self.rootNode_ = null;
	                        return null;
	                    }
	                    var rootNode = new CalcNode_(table, -1, null, false);
	                    CalcTableModel.createTree_.call(table, firstGroup, rootNode, groups, keyColObj);
	                    self.rootNode_ = rootNode;
	                    if (self.sortInfos_) {
	                        CalcTableModel.sortNode_.call(table, self.rootNode_, self.sortInfos_);
	                    }
	                    return self.rootNode_;
	                }
	            },
	
	            findNode: function(index) {
	                var self = this;
	                if (self.rootNode_) {
	                    return self.rootNode_.findNode(index);
	                }
	            },
	
	            //toLocalIndex: function(sourceIndex) {
	            //    var self = this;
	            //    var mappingIndexes = self.getIndexMappingIndexes();
	            //    var sourceIndexes = _.map(mappingIndexes, function(mappingIndex) {
	            //        return self.table_.indexMappings[mappingIndex];
	            //    });
	            //    return sourceIndexes.indexOf(sourceIndex);
	            //},
	
	            //toGlobalIndex: function(localIndex) {
	            //    var self = this;
	            //    if (localIndex >= self.itemCount || localIndex < 0) {
	            //        return null;
	            //    }
	            //    if (self.level === -1) {
	            //        return localIndex;
	            //    }
	            //    var globalIndex = localIndex;
	            //    var currGroup = self;
	            //    var groups = [];
	            //    var tempGroup;
	            //    var parent = currGroup.parent;
	            //    while (parent) {
	            //        groups = parent.groups;
	            //        for (var i = 0, len = groups.length; i < len; ++i) {
	            //            tempGroup = groups[i];
	            //            if (tempGroup.name === currGroup.name) {
	            //                break;
	            //            } else {
	            //                globalIndex += tempGroup.itemCount;
	            //            }
	            //        }
	            //        currGroup = parent;
	            //        parent = currGroup.parent;
	            //    }
	            //    return globalIndex;
	            //},
	
	            searchChildGroup: function(index) {
	                var self = this;
	                var i = index;
	                if (i < 0 || i >= this.itemCount || !_.isNumber(i) || _.isNaN(i)) {
	                    return null;
	                }
	                if (this.isBottomLevel) {
	                    return {group: self, relativeIndex: i};
	                } else {
	                    var notBottom = true;
	                    var group = self;
	                    var childGroup;
	                    var groupIndex = 0;
	                    var itemCount;
	                    while (notBottom) {
	                        childGroup = group.groups[groupIndex];
	                        if ((itemCount = childGroup.itemCount) > i) {
	                            group = childGroup;
	                            notBottom = !group.isBottomLevel;
	                            groupIndex = 0;
	                        } else {
	                            i -= itemCount;
	                            ++groupIndex;
	                        }
	                    }
	                    return {group: group, relativeIndex: i};
	                }
	            },
	
	            sortTree: function() {
	                var self = this;
	                var bottomGroups = self.getBottomGroups();
	                if (bottomGroups) {
	                    _.forEach(bottomGroups, function(group) {
	                        if (group.rootNode) {
	                            group.rootNode.sort();
	                        }
	                    });
	                }
	            },
	
	            getBottomGroups: function() {
	                return getBottomGroups_(this);
	            }
	        };
	        var calcGroupProto = CalcGroup_.prototype;
	
	        objectDefineProperty(calcGroupProto, 'itemCount', {
	            get: function() {
	                var self = this;
	                var bottomGroups = getBottomGroups_(self);
	                var itemCount = 0;
	                _.forEach(bottomGroups, function(group) {
	                    // only when group has own property 'rootNode_' means the group is hierarchied
	                    if (group.hasOwnProperty('rootNode_')) {
	                        if (group.rootNode) { // it means that the group is hierarchied successfully, all nodes excepting the root node have its parent.
	                            itemCount += group.rootNode.nodeCount;
	                        } else { // it means that the group is hierarchied failed, the items are not bad.
	                            // 0
	                        }
	                    } else {
	                        itemCount += group.items.length;
	                    }
	                });
	                return itemCount;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        objectDefineProperty(calcGroupProto, 'rootNode', {
	            get: function() {
	                return this.rootNode_;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        function getBottomGroups_(group) {
	            var result = [];
	            if (group.isBottomLevel) {
	                return [group];
	            } else {
	                for (var i = 0, len = group.groups.length; i < len; i++) {
	                    var subGroups = getBottomGroups_(group.groups[i]);
	                    result = result.concat(subGroups);
	                }
	            }
	            return result;
	        }
	
	        function createGroupsForTree_(treeGroupInfo) {
	            var self = this;
	            if (!self.isBottomLevel) {
	                return null;
	            }
	            var root = {};
	            var rowCount = self.items.length; // here must use self.items.length, can not use self.itemCount
	            root.itemCount = rowCount;
	            var groups;
	            var parent;
	            var i;
	            var name;
	            var group;
	            var colObj = self.table_.findColumn(treeGroupInfo.field);
	            for (i = 0; i < rowCount; ++i) {
	                groups = root.groups;
	                parent = root;
	
	                name = getGroupNameFromItemIndex_.call(self, colObj, i);
	                group = getGroup_.call(self, parent, name);
	                ++group.itemCount;
	                // move on to the next group
	                group.parent = parent;
	                parent = group;
	                groups = group.groups;
	
	                group.items.push(self.items[i]);
	            }
	            return root;
	        }
	
	        function getGroupNameFromItemIndex_(colObj, index) {
	            var self = this;
	            if (colObj) {
	                var value = getValue_.call(self, colObj, index);
	                if (value === null || value === undefined || value === '') {
	                    return undefined;
	                }
	                return value;
	            }
	            return undefined;
	        }
	
	        function getGroup_(parent, name) {
	            if (!parent.groups) {
	                parent.groups = [];
	            }
	            var groups = parent.groups;
	            for (var i = 0; i < groups.length; i++) {
	                if (groups[i].name === name) {
	                    return groups[i];
	                }
	            }
	            // not found, create new group
	            var group = {name: name, itemCount: 0, items: []};
	            groups.push(group);
	            return group;
	        }
	
	        function getValue_(colObj, localIndex) {
	            var self = this;
	            var table = self.table_;
	            var indexMappings = table.indexMappings_;
	            var indexMappingIndex = self.items[localIndex];
	            var srcIndex = indexMappingIndex;
	            if (indexMappings && indexMappingIndex >= 0 && indexMappingIndex < indexMappings.length) {
	                srcIndex = indexMappings[indexMappingIndex];
	            }
	            var value;
	            if (colObj.type === CalcHelper.DATA_COLUMN) {
	                //value = self.dataColumns_.sourceCollection[index][colObj.name];
	                value = table.dataColumns_.getValue(srcIndex, colObj);
	            } else { // calc column
	                value = table.calcColumns_.getValue(colObj, srcIndex);
	            }
	            return value;
	        }
	
	        return CalcGroup_;
	    })();
	    CalcModels.CalcGroup_ = CalcGroup_;
	
	    var CalcNode_ = (function() {
	        function CalcNode_(table, itemIndex, parent, collapsed) {
	            var self = this;
	            self.itemIndex = itemIndex;
	            self.children = [];
	            self.parent = parent;
	            self.level = parent && parent.hasOwnProperty('level') ? parent.level + 1 : -1;
	            if (parent) {
	                parent.children.push(self);
	            }
	            //if (parent) {
	            if (collapsed === undefined) {
	                self.collapsed = true;
	            } else {
	                self.collapsed = collapsed;
	            }
	            //} else {
	            //    self.collapsed = false;
	            //}
	            self.table_ = table;
	        }
	
	        CalcNode_.prototype = {
	            getItem: function(relativeIndex) {
	                var self = this;
	                if (relativeIndex !== undefined) {
	                    var node = findNode_.call(self, self, relativeIndex);
	                    if (node) {
	                        return self.table_.getRowItem_(node.itemIndex);
	                    }
	                } else {
	                    return self.table_.getRowItem_(self.itemIndex);
	                }
	            },
	            getItems: function(option) {
	                var self = this;
	                var arg = {};
	                arg.containCollapsed = option ? !!option.collapsed : false;
	                arg.start = option && option.start ? option.start : 0;
	                arg.end = option && option.end ? option.end : Number.MAX_VALUE;
	                var nodes = travelNode_(self, arg);
	                var items = _.map(nodes, function(node) {
	                    return node.getItem();
	                });
	                return items;
	            },
	            expandAll: function() {
	                operateNodes_(this, function(node) {
	                    node.collapsed = false;
	                });
	            },
	            collapseAll: function() {
	                operateNodes_(this, function(node) {
	                    node.collapsed = true;
	                });
	            },
	            findNode: function(index) {
	                return findNode_(this, index);
	            },
	            getIndexMappingIndexes: function() {
	                var result = [];
	                operateNodes_(this, function(node) {
	                    result.push(node.itemIndex);
	                });
	                return result;
	            },
	            toSourceIndex: function(index) {
	                var self = this;
	                var node = self.findNode(index);
	                if (node) {
	                    var indexMappings = self.table_.indexMappings_;
	                    if (indexMappings) {
	                        return indexMappings[node.itemIndex];
	                    }
	                    return node.itemIndex;
	                }
	            },
	            sort: function() {
	                var table = this.table_;
	                CalcTableModel.sortNode_.call(table, this, table.sortInfos_);
	            }
	        };
	
	        objectDefineProperty(CalcNode_.prototype, 'nodeCount', {
	            /*
	             * Gets an array containing the this group's subgroups.
	             */
	            get: function() {
	                var counter = 0;
	                operateNodes_(this, function() {
	                    counter++;
	                });
	                return counter;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        function findNode_(node, searchIndex, currentIndex, all) {
	            if (currentIndex === undefined) {
	                currentIndex = node.level === -1 ? -1 : 0;
	            } else {
	                currentIndex++;
	            }
	            if (currentIndex === searchIndex) {
	                return node;
	            }
	            try {
	                if (all || !node.collapsed) {
	                    for (var i = 0; i < node.children.length; i++) {
	                        var result = findNode_(node.children[i], searchIndex, currentIndex);
	                        if (_.isNumber(result)) {
	                            currentIndex = result;
	                        } else {
	                            return result;
	                        }
	                    }
	                }
	            } catch (e) {
	                console.log(e);
	            }
	            return currentIndex;
	        }
	
	        CalcNode_.findNode_ = findNode_;
	
	        function travelNode_(node, arg, action) {
	            var nodes = [];
	            if (!arg.hasOwnProperty('currentIndex')) {
	                arg.currentIndex = node.level === -1 ? -1 : 0;
	            } else {
	                arg.currentIndex++;
	            }
	            var currentIndex = arg.currentIndex;
	            if (currentIndex > arg.end) {
	                return nodes;
	            }
	            if (currentIndex >= arg.start && node.level !== -1) {
	                nodes.push(node);
	                if (action) {
	                    action(node);
	                }
	            }
	            if (arg.containCollapsed || !node.collapsed) {
	                _.forEach(node.children, function(childNode) {
	                    var childNodes = travelNode_(childNode, arg, action);
	                    if (childNodes.length > 0) {
	                        nodes = nodes.concat(childNodes);
	                    }
	                });
	            }
	            return nodes;
	        }
	
	        function operateNodes_(node, action) {
	            var arg = {};
	            arg.containCollapsed = false;
	            arg.start = 0;
	            arg.end = Number.MAX_VALUE;
	            travelNode_(node, arg, action);
	        }
	
	        CalcNode_.operateNodes_ = operateNodes_;
	
	        return CalcNode_;
	    })();
	    CalcModels.CalcNode_ = CalcNode_;
	
	    var CalcTableModel = (function() {
	        function CalcTableModel(calcSource, dataColumns, calcColumns) {
	            var self = this;
	            if (!dataColumns) {
	                return;
	            }
	            self.calcSource_ = calcSource;
	            self.dataColumns_ = dataColumns;
	            self.calcColumns_ = calcColumns;
	            self.columns_ = _.map(dataColumns.columns, function(col) {
	                return {
	                    name: col.name,
	                    field: col.field,
	                    type: CalcHelper.DATA_COLUMN,
	                    dataType: col.dataType
	                };
	            });
	            clearFilterStates_.call(self);
	            self.indexMappings_ = null;
	            self.sortSensitive_ = false;
	            self.groupSensitive_ = false;
	        }
	
	        CalcTableModel.prototype = {
	            getRowCount: function() {
	                var self = this;
	                if (self.indexMappings_) {
	                    return self.indexMappings_.length;
	                } else {
	                    return self.dataColumns_.getDimension();
	                }
	            },
	
	            filter: function(expression) {
	                var self = this;
	                self.filterExpr_ = expression;
	                var cachedGroupInfos = self.groupInfos_;
	                var cachedSortInfos = self.sortInfos_;
	                var cachedHierachyInfo = self.hierarchyInfo_;
	                clearAllStates_.call(self);
	                if (expression) {
	                    var calcSource = self.calcSource_;
	                    if (expression) {
	                        var parser = calcSource.getParser();
	                        var parserContext = calcSource.getParserContext();
	                        var evaluator = calcSource.getEvaluator();
	                        var evaluatorContext = calcSource.getEvaluatorContext();
	
	                        var expr = parser.parse(expression, parserContext);
	                        self.filterStates_ = evaluator.evaluateExpression(expr, evaluatorContext);
	                    }
	                } else {
	                    clearFilterStates_.call(self);
	                }
	
	                updateStatesOnSetFilterStates_.call(this);
	
	                if (cachedHierachyInfo) {
	                    if (cachedGroupInfos) {
	                        self.hierarchyInfo_ = cachedHierachyInfo;
	                        // hierachy will be accomplished in group
	                        self.group(cachedGroupInfos);
	                    } else {
	                        self.hierarchy(cachedHierachyInfo);
	                    }
	                } else {
	                    if (cachedSortInfos) {
	                        self.sort(cachedSortInfos);
	                    }
	                    if (cachedGroupInfos) {
	                        self.group(cachedGroupInfos);
	                    }
	                }
	            },
	
	            sort: function(sortInfos) {
	                var self = this;
	                self.sortInfos_ = sortInfos;
	                var cachedGds;
	
	                // if no sortInfo, then must reset the indexMappings
	                if (!sortInfos || sortInfos.length === 0) {
	                    self.sortInfos_ = null;
	
	                    updateStatesOnSetFilterStates_.call(this);
	
	                    if (self.hierarchyInfo_) {
	                        // must restore the node collapsed status after re hierarchy
	                        var cachedNodeStatus = {};
	                        if (self.groups_) {
	                            var bottomGroups = self.groups_.getBottomGroups();
	                            if (bottomGroups) {
	                                _.forEach(bottomGroups, function(group) {
	                                    if (group.rootNode) {
	                                        CalcNode_.operateNodes_(group.rootNode, function(node) {
	                                            cachedNodeStatus[node.value] = node.collapsed;
	                                        });
	                                    }
	                                    CalcNode_.operateNodes_(group.rootNode, function(node) {
	                                        if (cachedNodeStatus.hasOwnProperty(node.value)) {
	                                            node.collapsed = cachedNodeStatus[node.value];
	                                        }
	                                    });
	                                });
	                            }
	
	                            cachedGds = self.groupInfos_;
	                            clearGroupStates_.call(self);
	                            self.group(cachedGds);
	
	                            bottomGroups = self.groups_.getBottomGroups();
	                            if (bottomGroups) {
	                                _.forEach(bottomGroups, function(group) {
	                                    if (group.rootNode) {
	                                        CalcNode_.operateNodes_(group.rootNode, function(node) {
	                                            if (cachedNodeStatus.hasOwnProperty(node.value)) {
	                                                node.collapsed = cachedNodeStatus[node.value];
	                                            }
	                                        });
	                                    }
	                                });
	                            }
	                        } else {
	                            if (self.rootNode_) {
	                                CalcNode_.operateNodes_(self.rootNode_, function(node) {
	                                    cachedNodeStatus[node.value] = node.collapsed;
	                                });
	                            }
	                            self.hierarchy(self.hierarchyInfo_);
	                            CalcNode_.operateNodes_(self.rootNode_, function(node) {
	                                if (cachedNodeStatus.hasOwnProperty(node.value)) {
	                                    node.collapsed = cachedNodeStatus[node.value];
	                                }
	                            });
	                        }
	                    }
	                } else {
	                    if (self.hierarchyInfo_) {
	                        if (self.groups_) {
	                            self.groups_.sortTree();
	                        } else {
	                            sortNode_.call(self, self.rootNode_, sortInfos);
	                            //self.hierarchy(cachedHierachyInfo);
	                        }
	                    } else {
	                        cachedGds = self.groupInfos_;
	                        clearGroupStates_.call(self);
	
	                        var sortMappings = [];
	                        var i = 0;
	                        var len = 0;
	                        if (self.indexMappings_) {
	                            for (i = 0, len = self.indexMappings_.length; i < len; i++) {
	                                sortMappings[i] = self.indexMappings_[i];
	                            }
	                        } else {
	                            for (i = 0, len = self.getDimension(); i < len; i++) {
	                                sortMappings[i] = i;
	                            }
	                        }
	
	                        var sortColumns = {};
	                        _.forEach(sortInfos, function(sortInfo) {
	                            if (!sortInfo.hasOwnProperty('ascending')) {
	                                sortInfo.ascending = true;
	                            } else {
	                                sortInfo.ascending = !!sortInfo.ascending;
	                            }
	                            sortColumns[sortInfo.field] = self.dataColumns_.findColumn(sortInfo.field) || self.calcColumns_.findColumn(sortInfo.field);
	                        });
	                        sortMappings.sort(function(index1, index2) {
	                            for (var i = 0, sortLen = sortInfos.length; i < sortLen; i++) {
	                                // get values
	                                var sd = sortInfos[i];
	                                var sortCol = sortColumns[sd.field];
	                                var v1;
	                                var v2;
	                                if (sortCol) {
	                                    //v1 = self.dataColumns_.sourceCollection[index1];
	                                    //v2 = self.dataColumns_.sourceCollection[index2];
	                                    v1 = getSingleValue_.call(self, sortCol, index1);
	                                    v2 = getSingleValue_.call(self, sortCol, index2);
	                                    if (sd.converter) {
	                                        v1 = sd.converter(v1);
	                                        v2 = sd.converter(v2);
	                                    }
	                                }
	
	                                // check for NaN (isNaN returns true for NaN but also for non-numbers)
	                                if (v1 !== v1) {
	                                    v1 = null;
	                                }
	                                if (v2 !== v2) {
	                                    v2 = null;
	                                }
	
	                                // ignore case when sorting  (but add the original string to keep the
	                                // strings different and the sort consistent, 'aa' between 'AA' and 'bb')
	                                if (_.isString(v1)) {
	                                    v1 = v1.toLowerCase() + v1;
	                                }
	                                if (_.isString(v2)) {
	                                    v2 = v2.toLowerCase() + v2;
	                                }
	
	                                // compare the values (at last!)
	                                var cmp = (v1 < v2) ? -1 : (v1 > v2) ? +1 : 0;
	                                if (cmp !== 0) {
	                                    return sd.ascending ? +cmp : -cmp;
	                                }
	                            }
	                            return 0;
	                        });
	
	                        self.indexMappings_ = sortMappings;
	                        if (cachedGds) {
	                            self.group(cachedGds);
	                        }
	                    }
	                }
	            },
	
	            group: function(groupInfos) {
	                var self = this;
	                self.groupInfos_ = groupInfos;
	                self.groups_ = null;
	
	                var cachedHierachyInfo = self.hierarchyInfo_;
	                clearHierachyStates_.call(self);
	
	                if (!groupInfos || groupInfos.length === 0) {
	                    self.groups_ = null;
	                    if (cachedHierachyInfo) {
	                        self.hierarchy(cachedHierachyInfo);
	                    }
	                    return null;
	                }
	                self.groups_ = createCalcGroup_.call(self, groupInfos);
	                if (cachedHierachyInfo) {
	                    var bottomGroups = self.groups_.getBottomGroups();
	                    if (bottomGroups && bottomGroups.length > 0) {
	                        _.forEach(bottomGroups, function(bottomGroup) {
	                            bottomGroup.hierarchy(cachedHierachyInfo);
	                        });
	                    }
	                }
	                onGoupsUpdated_.call(self);
	                return self.groups_;
	            },
	
	            hierarchy: function(hierarchyInfo) {
	                var self = this;
	                self.hierarchyInfo_ = hierarchyInfo;
	                self.rootNode_ = null;
	                if (!hierarchyInfo || !hierarchyInfo.hasOwnProperty('parentField') || !hierarchyInfo.hasOwnProperty('keyField')) {
	                    self.rootNode_ = null;
	                    return null;
	                }
	
	                if (self.groups_) {
	                    var bottomGroups = self.groups_.getBottomGroups();
	                    if (bottomGroups && bottomGroups.length > 0) {
	                        _.forEach(bottomGroups, function(bottomGroup) {
	                            bottomGroup.hierarchy(self.hierarchyInfo_);
	                        });
	                    }
	                } else {
	                    var root = createCalcGroup_.call(self, [{field: hierarchyInfo.parentField}]);
	                    if (root && root.groups && root.groups.length > 0) {
	                        var groups = root.groups;
	                        var keyColObj = self.findColumn(hierarchyInfo.keyField);
	                        var firstGroup = _.find(groups, _.matchesProperty('name', undefined));
	                        if (!firstGroup) {
	                            self.rootNode_ = null;
	                            return null;
	                        }
	                        var rootNode = new CalcNode_(self, -1, null, false);
	                        createTree_.call(self, firstGroup, rootNode, groups, keyColObj);
	                        self.rootNode_ = rootNode;
	                        if (self.sortInfos_) {
	                            sortNode_.call(self, self.rootNode_, self.sortInfos_);
	                        }
	                        //self.cachedNodeStatus_ = {};
	                        return self.rootNode_;
	                    }
	                }
	                return null;
	            },
	
	            // the new states is based on current filter, so this method will ignore current filtered out rows
	            // and only overlap the states to current rowStates_
	            overlapFilterStates: function(states) {
	                var self = this;
	                if (_.isArray(states)) {
	                    var dimension = self.getDimension();
	                    var overlapIndex = 0;
	                    var len = states.length;
	                    self.indexMappings_ = [];
	                    for (var i = 0; i < dimension; i++) {
	                        if (self.rowStates_[i] !== false) {
	                            if (overlapIndex >= len) {
	                                break;
	                            }
	                            self.rowStates_[i] = states[overlapIndex];
	                            overlapIndex++;
	                        }
	                        if (self.rowStates_[i]) {
	                            self.indexMappings_.push(i);
	                        }
	                    }
	                }
	            },
	
	            overlapFilterSingleState: function(states, currentRow) {
	                var self = this;
	                if (!_.isArray(states) && currentRow > -1) {
	                    var sRow = mapToSourceRow_.call(self, currentRow);
	                    if (self.rowStates_[sRow] !== false) {
	                        self.rowStates_[sRow] = states;
	                        if (states === false) {
	                            if (self.indexMappings_) {
	                                self.indexMappings_.splice(currentRow, 1);
	                            } else {
	                                self.indexMappings_ = [];
	                                for (var i = 0, len = self.getDimension(); i < len; i++) {
	                                    if (self.rowStates_[i] !== false) {
	                                        self.indexMappings_.push(i);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            },
	
	            getRowItem: function(row) {
	                var self = this;
	                if (self.groups_) {
	                    return self.groups_.getItem(row);
	                } else if (self.rootNode_) {
	                    return self.rootNode_.getItem(row);
	                } else {
	                    return self.getRowItem_(row);
	                }
	            },
	
	            getDataRowItem: function(row) {
	                var self = this;
	                row = mapToSourceRow_.call(self, row);
	                return self.dataColumns_.getRowItem(row);
	            },
	
	            getCalcRowItem: function(row) {
	                var self = this;
	                var srcRow = mapToSourceRow_.call(self, row);
	                var calcRowItem = getCalcRowItem_.call(self, srcRow);
	                return calcRowItem;
	            },
	
	            getValues: function(column, group, internal) {
	                var self = this;
	                var colObj = column;
	                //if (_.isString(column)) {
	                //    colObj = self.findColumn(column);
	                //}
	                //if (!colObj) {
	                //    return;
	                //}
	                var values = [];
	                var rowIndex;
	                var value;
	                var rowCount;
	                if (self.boundGroup_) {
	                    group = self.boundGroup_;
	                }
	                var indexMappings = self.indexMappings_;
	                if (group && _.isArray(group) && group.length > 0) {
	                    var indexes = getIndexMappingIndexes.call(self, group);
	                    for (var index = 0, len = indexes.length; index < len; index++) {
	                        rowIndex = indexMappings ? indexMappings[indexes[index]] : indexes[index];
	                        if (self.rowStates_[rowIndex] !== false) {
	                            value = getSingleValue_.call(self, colObj, rowIndex, internal);
	                            values.push(value);
	                        }
	                    }
	                } else {
	                    if (indexMappings) {
	                        for (var i = 0, len1 = indexMappings.length; i < len1; i++) {
	                            value = getSingleValue_.call(this, colObj, indexMappings[i], internal);
	                            values.push(value);
	                        }
	                    } else {
	                        for (rowIndex = 0, rowCount = self.getDimension(); rowIndex < rowCount; rowIndex++) {
	                            value = getSingleValue_.call(this, colObj, rowIndex, internal);
	                            values.push(value);
	                        }
	                    }
	                }
	                return values;
	            },
	
	            getValue: function(column, index, internal) {
	                var self = this;
	                var colObj = column;
	                //if (_.isString(column)) {
	                //    colObj = self.findColumn(column);
	                //}
	                //if (!colObj) {
	                //    return;
	                //}
	                index = mapToSourceRow_.call(self, index);
	                return getSingleValue_.call(this, colObj, index, internal);
	            },
	
	            addRowItem: function(index, item) { // jshint ignore:line
	
	            },
	
	            removeRowItem: function(index) { // jshint ignore:line
	
	            },
	
	            getDimension: function() {
	                return this.dataColumns_.getDimension();
	            },
	
	            getGroupPath: function(row) {
	                var self = this;
	                if (!self.groups_) {
	                    return [];
	                }
	                var path = [];
	                findRowInGroup_.call(self, self.groups_, row, path);
	                if (path.length === 0) {
	                    return;
	                }
	                return path;
	            },
	
	            bindGroup: function(group) {
	                this.boundGroup_ = group;
	            },
	
	            unbindGroup: function() {
	                delete this.boundGroup_;
	            },
	
	            clone: function() {
	                var self = this;
	                var cloneObj = new CalcTableModel(null);
	                cloneObj.dataColumns_ = self.dataColumns_;
	                cloneObj.calcColumns_ = self.calcColumns_;
	                cloneObj.columns_ = _.clone(self.columns_, true);
	                cloneObj.rowStates_ = _.clone(self.rowStates_);
	                cloneObj.filterStates_ = _.clone(self.filterStates_);
	                cloneObj.groups_ = self.groups_;
	                cloneObj.indexMappings_ = _.clone(self.indexMappings_, true);
	                cloneObj.rootNode_ = self.rootNode_;
	                return cloneObj;
	            },
	
	            reproduce: function() {
	                var self = this;
	                var reproducedObj = new CalcTableModel(null);
	                reproducedObj.dataColumns_ = self.dataColumns_;
	                reproducedObj.calcColumns_ = self.calcColumns_;
	                reproducedObj.columns_ = _.clone(self.columns_, true);
	                reproducedObj.rowStates_ = [];
	                reproducedObj.rowStates_.length = self.getDimension();
	                reproducedObj.filter = null;
	                reproducedObj.filterStates_ = null;
	                reproducedObj.groups_ = self.groups_;
	                reproducedObj.rootNode_ = self.rootNode_;
	                return reproducedObj;
	            },
	
	            reproduceWithColumns: function(columns) {
	                var self = this;
	                var reproducedObj = new CalcTableModel(null);
	                var columnNames = self.columns_;
	                var validColumns = [];
	                var index;
	                columnNames = _.map(columnNames, function(columnName) {
	                    return columnName.name;
	                });
	                reproducedObj.dataColumns_ = self.dataColumns_;
	                reproducedObj.calcColumns_ = self.calcColumns_;
	                _.forEach(columns, function(column) {
	                    if ((index = _.indexOf(columnNames, column)) > -1) {
	                        validColumns.push(self.columns_[index]);
	                    }
	                });
	                reproducedObj.columns_ = validColumns;
	                reproducedObj.rowStates_ = [];
	                reproducedObj.rowStates_.length = self.getDimension();
	                reproducedObj.filter = null;
	                reproducedObj.filterStates_ = null;
	                reproducedObj.groups_ = _.clone(self.groups_, true);
	                return reproducedObj;
	            },
	
	            beginUseGroup: function() {
	                var self = this;
	                var groupObj = {
	                    groups: self.groups_,
	                    groupInfos: self.groupInfos_
	                };
	                if (self.backupGroups_) {
	                    self.backupGroups_.push(groupObj);
	                } else {
	                    self.backupGroups_ = [groupObj];
	                }
	            },
	
	            endUseGroup: function() {
	                var self = this;
	                if (self.backupGroups_ && self.backupGroups_.length > 0) {
	                    var groupObj = self.backupGroups_.pop();
	                    self.groups_ = groupObj.groups;
	                    self.groupInfos_ = groupObj.groupInfos;
	                }
	            },
	
	            getGroups: function() {
	                return this.groups_;
	            },
	
	            getRootNode: function() {
	                return this.rootNode_;
	            },
	
	            updateGroups: function() {
	                var self = this;
	                self.group(self.groupInfos_);
	                onGoupsUpdated_.call(self);
	            },
	
	            findColumn: function(column) {
	                var self = this;
	                return self.dataColumns_.findColumn(column) || self.calcColumns_.findColumn(column);
	            },
	
	            toArray: function(group) {
	                var self = this;
	                if (self.boundGroup_) {
	                    group = self.boundGroup_;
	                }
	                var rowIndex;
	                var rowCount;
	                var rows = [];
	                if (group && _.isArray(group) && group.length > 0) {
	                    var indexes = getIndexMappingIndexes.call(self, group);
	                    for (var index = 0, len = indexes.length; index < len; index++) {
	                        rowIndex = indexes[index];
	                        rows.push(self.getRowItem(rowIndex));
	                    }
	                } else {
	                    var indexMappings = self.indexMappings_;
	                    if (indexMappings) {
	                        for (var i = 0, len1 = indexMappings.length; i < len1; i++) {
	                            rows.push(self.getRowItem(i));
	                        }
	                    } else {
	                        for (rowIndex = 0, rowCount = self.getDimension(); rowIndex < rowCount; rowIndex++) {
	                            rows.push(self.getRowItem(rowIndex));
	                        }
	                    }
	                }
	                return rows;
	            },
	
	            mapToSourceRow: function(viewRow) {
	                return mapToSourceRow_.call(this, viewRow);
	            },
	
	            mapToViewRow: function(sourceRow) {
	                return mapToViewRow_.call(this, sourceRow);
	            },
	
	            isFilterOut: function(srcRow) {
	                return this.rowStates_[srcRow] === false;
	            },
	
	            getRowItem_: function(row) {
	                var self = this;
	                var srcRow = row;
	                if (self.indexMappings_ && row >= 0 && row < self.indexMappings_.length) {
	                    srcRow = self.indexMappings_[row];
	                }
	                var dataItem = self.dataColumns_.getRowItem(srcRow);
	                var calcItem = getCalcRowItem_.call(self, srcRow);
	                if (calcItem) {
	                    return new RowItem_(dataItem, calcItem, srcRow);
	                } else {
	                    return dataItem;
	                }
	            },
	
	            beginContextManipulate: function() {
	                var self = this;
	                var contextStatusObj = {
	                    groups: self.groups_,
	                    groupInfos: self.groupInfos_,
	                    rowStates: self.rowStates_,
	                    filterStates: self.filterStates_,
	                    indexMappings: self.indexMappings_
	                };
	                if (self.backupAllStatus_) {
	                    self.backupAllStatus_.push(contextStatusObj);
	                } else {
	                    self.backupAllStatus_ = [contextStatusObj];
	                }
	                clearAllStates_.call(self);
	            },
	
	            endContextManipulate: function() {
	                var self = this;
	                if (self.backupAllStatus_ && self.backupAllStatus_.length > 0) {
	                    var contextStatusObj = self.backupAllStatus_.pop();
	                    self.groups_ = contextStatusObj.groups;
	                    self.groupInfos_ = contextStatusObj.groupInfos;
	                    self.rowStates_ = contextStatusObj.rowStates;
	                    self.filterStates_ = contextStatusObj.filterStates;
	                    self.indexMappings_ = contextStatusObj.indexMappings;
	                }
	            }
	        };
	
	        function getCalcRowItem_(srcRow) {
	            var self = this;
	            var calcRowItem = {};
	            var calcColumns = self.calcColumns_.getColumns();
	            if (calcColumns.length === 0) {
	                return null;
	            }
	            _.forEach(calcColumns, function(calcColObj) {
	                var value = self.calcColumns_.getValue(calcColObj, srcRow);
	                calcRowItem[calcColObj.name] = value;
	            });
	            return calcRowItem;
	        }
	
	        function createCalcGroup_(groupInfos) {
	            var self = this;
	            if (!_.isArray(groupInfos)) {
	                return null;
	            }
	            var root = new CalcGroup_(self, null, -1, false);
	            var rowCount = self.getRowCount();
	            //root.itemCount = rowCount;
	            root.path = [];
	            var groups;
	            var parent;
	            var i;
	            var level;
	            var levels = groupInfos.length;
	            var gd;
	            var name;
	            var last;
	            var group;
	            var path;
	            for (i = 0; i < rowCount; ++i) {
	                groups = root.groups;
	                parent = root;
	                path = [];
	                for (level = 0; level < levels; ++level) {
	                    gd = groupInfos[level];
	                    name = getGroupNameFromItemIndex_.call(self, gd, i);
	                    last = level === levels - 1;
	                    group = getCalcGroup_.call(self, parent, name, level, last);
	                    //++group.itemCount;
	                    // move on to the next group
	                    group.parent = parent;
	                    parent = group;
	                    groups = group.groups;
	                }
	                group.items.push(i);
	            }
	            return root;
	        }
	
	        function getGroupNameFromItemIndex_(groupDescription, index) {
	            var self = this;
	            var colObj = self.findColumn(groupDescription.field);
	            if (colObj) {
	                var value = self.getValue(colObj, index, false);
	                if (_.isFunction(groupDescription.converter)) {
	                    return groupDescription.converter(value);
	                }
	                if (value === null || value === undefined) {
	                    return undefined;
	                }
	                return value;
	            }
	            return null;
	        }
	
	        function getCalcGroup_(parent, name, level, isBottomLevel) {
	            var groups = parent.groups;
	            for (var i = 0; i < groups.length; i++) {
	                if (groups[i].name === name) {
	                    return groups[i];
	                }
	            }
	            // not found, create new group
	            var group = new CalcGroup_(this, name, level, isBottomLevel);
	            group.path = parent.path.concat(groups.length);
	            groups.push(group);
	            return group;
	        }
	
	        function RowItem_(dataItem, calcItem, srcIndex) {
	            var self = this;
	            self.dataItem_ = dataItem;
	            self.calcItem_ = calcItem;
	            self.sourceIndex_ = srcIndex;
	
	            if (dataItem) {
	                var dataKeys = _.keys(dataItem);
	                _.forEach(dataKeys, function(key) {
	                    objectDefineProperty(self, key, {
	                        get: function() {
	                            return dataItem[key];
	                        },
	                        set: function(value) {
	                            dataItem[key] = value;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                });
	            }
	
	            if (calcItem) {
	                var calcKeys = _.keys(calcItem);
	                _.forEach(calcKeys, function(key) {
	                    objectDefineProperty(self, key, {
	                        get: function() {
	                            return calcItem[key];
	                        },
	                        set: function(value) {
	                            calcItem[key] = value;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                });
	            }
	
	            objectDefineProperty(self, 'sourceIndex', {
	                get: function() {
	                    return this.sourceIndex_;
	                },
	                enumerable: true,
	                configurable: true
	            });
	        }
	
	        function findRowInGroup_(group, row, path) {
	            if (group.isBottomLevel) {
	                return group.items.indexOf(row) !== -1;
	            } else if (group.groups) {
	                for (var i = 0, len = group.groups.length; i < len; i++) {
	                    var found = findRowInGroup_(group.groups[i], row, path);
	                    if (found) {
	                        path.splice(0, 0, i);
	                        return found;
	                    }
	                }
	            }
	
	        }
	
	        // while set filter, the invisible column will always keep invisible, but the visible columns may change to invisible
	        // so while set filer, only check the visible columns is ok.
	        function updateStatesOnSetFilterStates_() {
	            var self = this;
	            var rowCount = self.getDimension();
	            self.indexMappings_ = [];
	            for (var row = 0; row < rowCount; row++) {
	                updateRowState_.call(self, row);
	                if (self.rowStates_[row]) {
	                    self.indexMappings_.push(row);
	                }
	            }
	        }
	
	        function updateRowState_(row) {
	            var self = this;
	            var filterState = self.filterStates_ === null || self.filterStates_[row] !== false;
	            self.rowStates_[row] = filterState;
	        }
	
	        function getSingleValue_(colObj, srcIndex, internal) {
	            var self = this;
	            var value;
	            if (colObj.type === CalcHelper.DATA_COLUMN) {
	                //value = self.dataColumns_.sourceCollection[index][colObj.name];
	                value = self.dataColumns_.getValue(srcIndex, colObj);
	            } else { // calc column
	                if (internal) {
	                    value = colObj.values[srcIndex];
	                } else {
	                    value = self.calcColumns_.getValue(colObj, srcIndex);
	                }
	            }
	            return value;
	        }
	
	        function getIndexMappingIndexes(groupPath) {
	            var self = this;
	            var group = getGroup_(self.groups_, groupPath);
	            if (group) {
	                var indexes;
	                try {
	                    indexes = group.getIndexMappingIndexes();
	                } catch (e) {
	                    console.log(e);
	                }
	                return indexes;
	            }
	            return null;
	        }
	
	        function getGroup_(rootGroup, groupPath) {
	            var currentGroup = rootGroup;
	            for (var i = 0, len = groupPath.length; i < len; i++) {
	                var index = groupPath[i];
	                var groups = currentGroup.groups;
	                if (groups && index < groups.length) {
	                    currentGroup = groups[index];
	                } else {
	                    return null;
	                }
	            }
	            return currentGroup;
	        }
	
	        function onGoupsUpdated_() {
	            var self = this;
	            var calcColumns = self.calcColumns_.getColumns();
	            _.forEach(calcColumns, function(calcCol) {
	                self.calcColumns_.dirty(calcCol, -1);
	            });
	        }
	
	        function mapToSourceRow_(row) {
	            var self = this;
	            var index = row;
	            // during grouping or hierachying, the groups_ and rootNode_ will be first set null, so the index does not need to be transformed by group and tree
	            if (self.groups_) {
	                var groupInfo = self.groups_.searchChildGroup(row);
	                if (groupInfo) {
	                    index = groupInfo.group.items[groupInfo.relativeIndex];
	                } else {
	                    index = -1;
	                }
	            } else if (self.rootNode_) {
	                var node = self.rootNode_.findNode(row);
	                if (node) {
	                    index = node.itemIndex;
	                } else {
	                    index = -1;
	                }
	            }
	
	            if (self.indexMappings_ && index >= 0 && index < self.indexMappings_.length) {
	                return self.indexMappings_[index];
	            }
	            return index;
	        }
	
	        function mapToViewRow_(row) {
	            var self = this;
	            var index = row;
	            if (self.indexMappings_) {
	                index = self.indexMappings_.indexOf(row);
	            }
	
	            if (index !== -1) {
	                var mappingIndexes;
	                if (self.groups_) {
	                    mappingIndexes = self.groups_.getIndexMappingIndexes();
	                    return mappingIndexes.indexOf(index);
	                } else if (self.rootNode_) {
	                    mappingIndexes = self.rootNode_.getIndexMappingIndexes();
	                    return mappingIndexes.indexOf(index);
	                }
	            }
	            return index;
	        }
	
	        function clearAllStates_() {
	            var self = this;
	            clearFilterStates_.call(self);
	            clearGroupStates_.call(self);
	            clearHierachyStates_.call(self);
	        }
	
	        function clearFilterStates_() {
	            var self = this;
	            var rowCount = self.dataColumns_.getDimension();
	            self.filterExpr_ = null;
	            self.rowStates_ = [];
	            self.rowStates_.length = rowCount;
	            self.filterStates_ = null;
	            self.indexMappings_ = null;
	        }
	
	        function clearGroupStates_() {
	            var self = this;
	            self.groups_ = null;
	            self.groupInfos_ = null;
	        }
	
	        function clearHierachyStates_() {
	            var self = this;
	            self.rootNode_ = null;
	            self.hierachyInfo_ = null;
	        }
	
	        function createTree_(group, parentNode, groups, keyColObj) {
	            var self = this;
	            for (var i = 0; i < group.itemCount; i++) {
	                new CalcNode_(self, group.items[i], parentNode, self.hierarchyInfo_.collapsed);
	            }
	            var nodes = parentNode.children;
	            if (nodes.length > 0) {
	                for (var j = 0; j < nodes.length; j++) {
	                    var node = nodes[j];
	                    var index = node.itemIndex;
	                    var srcIndex = index;
	                    var indexMappings = self.indexMappings_;
	                    if (indexMappings && index >= 0 && index < indexMappings.length) {
	                        srcIndex = indexMappings[index];
	                    }
	                    var keyValue = getSingleValue_.call(self, keyColObj, srcIndex);
	                    node.value = keyValue;
	                    //if (self.cachedNodeStatus_.hasOwnProperty(keyValue)) {
	                    //    node.collapsed = self.cachedNodeStatus_[keyValue];
	                    //}
	                    var childGroup = _.find(groups, _.matchesProperty('name', keyValue));
	                    if (childGroup) {
	                        createTree_.call(self, childGroup, node, groups, keyColObj);
	                    }
	                }
	            }
	        }
	
	        CalcTableModel.createTree_ = createTree_;
	
	        function sortNode_(node, sortInfos, sortColumns) {
	            var self = this;
	            if (!sortColumns) {
	                sortColumns = {};
	                _.forEach(sortInfos, function(sortInfo) {
	                    if (!sortInfo.hasOwnProperty('ascending')) {
	                        sortInfo.ascending = true;
	                    } else {
	                        sortInfo.ascending = !!sortInfo.ascending;
	                    }
	                    sortColumns[sortInfo.field] = self.dataColumns_.findColumn(sortInfo.field) || self.calcColumns_.findColumn(sortInfo.field);
	                });
	            }
	            node.children.sort(function(node1, node2) {
	                for (var i = 0, sortLen = sortInfos.length; i < sortLen; i++) {
	                    // get values
	                    var sd = sortInfos[i];
	                    var sortCol = sortColumns[sd.field];
	                    var v1;
	                    var v2;
	                    if (sortCol) {
	                        var srcIndex1 = self.indexMappings_ ? self.indexMappings_[node1.itemIndex] : node1.itemIndex;
	                        var srcIndex2 = self.indexMappings_ ? self.indexMappings_[node2.itemIndex] : node2.itemIndex;
	                        v1 = getSingleValue_.call(self, sortCol, srcIndex1);
	                        v2 = getSingleValue_.call(self, sortCol, srcIndex2);
	                        if (sd.converter) {
	                            v1 = sd.converter(v1);
	                            v2 = sd.converter(v2);
	                        }
	                    }
	
	                    // check for NaN (isNaN returns true for NaN but also for non-numbers)
	                    if (v1 !== v1) {
	                        v1 = null;
	                    }
	                    if (v2 !== v2) {
	                        v2 = null;
	                    }
	
	                    // ignore case when sorting  (but add the original string to keep the
	                    // strings different and the sort consistent, 'aa' between 'AA' and 'bb')
	                    if (_.isString(v1)) {
	                        v1 = v1.toLowerCase() + v1;
	                    }
	                    if (_.isString(v2)) {
	                        v2 = v2.toLowerCase() + v2;
	                    }
	
	                    // compare the values (at last!)
	                    var cmp = (v1 < v2) ? -1 : (v1 > v2) ? +1 : 0;
	                    if (cmp !== 0) {
	                        return sd.ascending ? +cmp : -cmp;
	                    }
	                }
	                return 0;
	            });
	            if (node.children.length > 0) {
	                _.forEach(node.children, function(childNode) {
	                    sortNode_.call(self, childNode, sortInfos, sortColumns);
	                });
	            }
	        }
	
	        CalcTableModel.sortNode_ = sortNode_;
	
	        return CalcTableModel;
	    })();
	    CalcModels.CalcTableModel = CalcTableModel;
	
	    var DataColumnsModel = (function() {
	        function DataColumnsModel(dataSource, columnDefs) {
	            var self = this;
	            self.dataSource = dataSource;
	            var srcArray;
	            var dimension;
	            if (_.isArray(dataSource)) {
	                srcArray = dataSource;
	            } else if (dataSource.getSourceArray) {
	                srcArray = dataSource.getSourceArray();
	            }
	            if (srcArray) {
	                self.sourceCollection = srcArray;
	                dimension = srcArray.length;
	            } else if (dataSource.getDimension) {
	                dimension = dataSource.getDimension();
	            }
	
	            var defaultCols = getDefaultColumns_.call(self);
	            if (dataSource.getColumns || columnDefs) {
	                var columns = (dataSource.getColumns && dataSource.getColumns()) || columnDefs;
	                self.columns = _.map(columns, function(col) {
	                    var dirtyStates = [];
	                    dirtyStates.length = dimension;
	                    if (col.name && col.field) {
	                        return {
	                            name: col.name,
	                            field: col.field,
	                            type: CalcHelper.DATA_COLUMN,
	                            dirtyStates: dirtyStates,
	                            dirty: false,
	                            dataType: undefined
	                        };
	                    }
	                });
	                if (defaultCols) {
	                    _.forEach(defaultCols, function(defCol) {
	                        if (!_.find(self.columns, _.matchesProperty('field', defCol.field))) {
	                            self.columns.push(defCol);
	                        }
	                    });
	                }
	            }
	            if (!self.columns || self.columns.length === 0) {
	                self.columns = defaultCols;
	            }
	        }
	
	        DataColumnsModel.prototype = {
	            getRowItem: function(row) {
	                var self = this;
	                var item;
	                if (self.sourceCollection) {
	                    item = self.sourceCollection[row];
	                } else if (self.getDataItem()) {
	                    item = self.getDataItem(row);
	                }
	                if (item) {
	                    return item;
	                } else {
	                    throw 'can not find the item at index ' + row;
	                }
	            },
	
	            getDimension: function() {
	                var self = this;
	                if (self.sourceCollection) {
	                    return self.sourceCollection.length;
	                } else if (self.dataSource.getDimension) {
	                    return self.dataSource.getDimension();
	                }
	                return 0;
	            },
	
	            getValue: function(row, column) {
	                var self = this;
	                var colObj = column;
	                //if (_.isString(column)) {
	                //    colObj = self.findColumn(column);
	                //}
	                //if (!colObj) {
	                //    return;
	                //}
	                var field = colObj.field;
	                var value;
	                if (self.sourceCollection) {
	                    try {
	                        value = self.sourceCollection[row][field];
	                    } catch (e) {
	                        console.log(e);
	                    }
	                } else if (self.dataSource.getDataItem) {
	                    var item = self.dataSource.getDataItem(row);
	                    if (item) {
	                        value = item[field];
	                    }
	                }
	                var converter = colObj.converter;
	                if (!converter || !_.isFunction(converter)) {
	                    return value;
	                }
	                return converter(value);
	            },
	
	            findColumn: function(column) {
	                return _.find(this.columns, _.matchesProperty('name', column));
	            },
	
	            hasDirty: function(column) {
	                var self = this;
	                var colObj = self.findColumn(column);
	                if (!colObj) {
	                    return false;
	                }
	                var states = colObj.dirtyStates;
	                for (var i = 0, len = states.length; i < len; i++) {
	                    if (states[i] === true) {
	                        return true;
	                    }
	                }
	                return false;
	            },
	
	            dirty: function(column, index) {
	                markDirty_.call(this, column, index, true);
	            },
	
	            unDirty: function(column, index) {
	                markDirty_.call(this, column, index, false);
	            }
	        };
	
	        function markDirty_(column, index, state) {
	            var self = this;
	            var colObj = column;
	            if (_.isString(column)) {
	                colObj = self.findColumn(column);
	            }
	            if (!colObj) {
	                return;
	            }
	            if (index >= 0 && index < self.getDimension()) {
	                colObj.dirtyStates[index] = state;
	            } else if (index === -1) {
	                if (state) {
	                    _.fill(colObj.dirtyStates, true);
	                } else {
	                    var dirtyStates = [];
	                    dirtyStates.length = self.getDimension();
	                    colObj.dirtyStates = dirtyStates;
	                }
	            }
	        }
	
	        function getDefaultColumns_() {
	            var self = this;
	            var sourceCollection = self.sourceCollection;
	            var firstItem;
	            if (sourceCollection && sourceCollection.length > 0) {
	                firstItem = sourceCollection[0];
	            } else if (sourceCollection && sourceCollection.getDataItem) {
	                firstItem = sourceCollection.getDataItem(0);
	            }
	            if (firstItem) {
	                var dimension = self.getDimension();
	                return _.map(_.keys(firstItem), function(key) {
	                    var dirtyStates = [];
	                    dirtyStates.length = dimension;
	                    return {
	                        name: key,
	                        field: key,
	                        type: CalcHelper.DATA_COLUMN,
	                        dirtyStates: dirtyStates,
	                        dirty: false,
	                        dataType: undefined
	                    };
	                });
	            }
	            return null;
	        }
	
	        return DataColumnsModel;
	    })();
	    CalcModels.DataColumnsModel = DataColumnsModel;
	
	    var CalcColumnsModel = (function() {
	        function CalcColumnsModel(calcSource) {
	            var self = this;
	            self.calcSource_ = calcSource;
	            self.name = calcSource.name;
	            self.columns_ = [];
	            self.parser_ = calcSource.getParser();
	            self.evaluator_ = calcSource.getEvaluator();
	            //if (columns) {
	            //    _.forEach(columns, function(column) {
	            //        addColumn_.call(self, column.name, column.field);
	            //    });
	            //}
	        }
	
	        CalcColumnsModel.prototype = {
	            addColumn: function(column, formula) {
	                return addColumn_.call(this, column, formula);
	            },
	
	            removeColumn: function(column) {
	                _.remove(this.columns_, _.matchesProperty('name', column));
	            },
	
	            getValues: function(column) {
	                var self = this;
	                var colObj = column;
	                //if (_.isString(column)) {
	                //    colObj = self.findColumn(column);
	                //}
	                //if (!colObj) {
	                //    return null;
	                //}
	                if (self.hasDirty(colObj)) {
	                    self.calculateColumn(colObj);
	                }
	                return colObj.values;
	            },
	
	            getValue: function(column, index) {
	                var self = this;
	                var colObj = column;
	                //if (_.isString(column)) {
	                //    colObj = self.findColumn(column);
	                //}
	                //if (!colObj) {
	                //    return null;
	                //}
	                if (colObj.dirtyStates[index] !== false) {
	                    self.calculateValue(column, index);
	                }
	                return colObj.values[index];
	            },
	
	            calculateValue: function(column, index) {
	                var self = this;
	                var colObj = column;
	                if (_.isString(column)) {
	                    colObj = self.findColumn(column);
	                }
	                if (!colObj) {
	                    return null;
	                }
	                calculateColumn_.call(this, colObj, index, false);
	            },
	
	            calculateColumn: function(column, force) {
	                var self = this;
	                var colObj = column;
	                if (_.isString(column)) {
	                    colObj = self.findColumn(column);
	                }
	                if (!colObj) {
	                    return null;
	                }
	                calculateColumn_.call(this, colObj, -1, force);
	            },
	
	            findColumn: function(column) {
	                return _.find(this.columns_, _.matchesProperty('name', column));
	            },
	
	            getColumns: function() {
	                return this.columns_;
	            },
	
	            hasDirty: function(column) {
	                //var self = this;
	                var colObj = column;
	                //if (_.isString(column)) {
	                //    colObj = self.findColumn(column);
	                //}
	                //if (!colObj) {
	                //    return null;
	                //}
	                var states = colObj.dirtyStates;
	                for (var i = 0, len = states.length; i < len; i++) {
	                    if (states[i] !== false) {
	                        return true;
	                    }
	                }
	                return false;
	            },
	
	            dirty: function(column, index, newFormula) {
	                var self = this;
	                var colObj = column;
	                //if (_.isString(column)) {
	                //    colObj = self.findColumn(column);
	                //}
	                //if (!colObj) {
	                //    return;
	                //}
	                if (newFormula && colObj.formula !== newFormula) {
	                    updateColumnFormula.call(self, colObj, newFormula);
	                } else {
	                    var dimension = self.calcSource_.getDimension();
	                    if (index >= 0 && index < dimension) {
	                        colObj.dirtyStates[index] = true;
	                    } else if (index === -1) {
	                        var dirtyStates = [];
	                        dirtyStates.length = dimension;
	                        colObj.dirtyStates = dirtyStates;
	                    }
	                }
	            },
	
	            updateColumnFormula: function(column, newFormula) {
	                var self = this;
	                var colObj = self.findColumn(column);
	                if (colObj) {
	                    if (!newFormula) {
	                        newFormula = colObj.formula;
	                    }
	                    updateColumnFormula.call(self, colObj, newFormula);
	                }
	            }
	        };
	
	        function addColumn_(column, formula) {
	            var self = this;
	            var rowCount = self.calcSource_.getDimension();
	            var values = [];
	            var dirtyStates = [];
	            values.length = rowCount;
	            dirtyStates.length = rowCount;
	            var context = new CalcContext.ParserContext(self.calcSource_);
	            var expression = self.parser_.parse(formula, context);
	            if (!expression) {
	                return null;
	            }
	            var depends = CalcHelper.resolveDepends(expression, self.calcSource_);
	            var calcColumn = {
	                name: column,
	                type: CalcHelper.CALC_COLUMN,
	                formula: formula,
	                expression: expression,
	                values: values,
	                dirtyStates: dirtyStates,
	                depends: depends,
	                isCalculating: false,
	                dirty: false
	            };
	            self.columns_.push(calcColumn);
	            return calcColumn;
	        }
	
	        function calculateColumn_(column, index, force) {
	            var self = this;
	            var colObj = column;
	            column = colObj.name;
	            var dirtyStates;
	            var isDepDirty = false;
	            var fieldsModel = self.calcSource_.getModel(CalcHelper.CALC_FIELD);
	            var dataColsModel = self.calcSource_.getModel(CalcHelper.DATA_COLUMN);
	            var i;
	            var len;
	            var depends;
	            colObj.isCalculating = true;
	            try {
	                var calculatingStack = [];
	                calculatingStack.push({type: CalcHelper.CALC_COLUMN, table: self.name, column: column});
	                while (calculatingStack.length !== 0) {
	                    var topCalcDep = calculatingStack[calculatingStack.length - 1];
	                    var topCalcObj = CalcHelper.getCalcObj(topCalcDep, self.calcSource_);
	                    if (topCalcObj === null) {
	                        calculatingStack.pop();
	                        continue;
	                    }
	                    var hasDirtyDepends = false;
	                    depends = topCalcObj.depends;
	                    if (depends) {
	                        for (i = 0, len = depends.length; i < len; i++) {
	                            var depCalcObj = CalcHelper.getCalcObj(depends[i], self.calcSource_);
	                            if (depCalcObj) {
	                                var depDirtyIndex = depends[i].aggContext ? -1 : index;
	                                isDepDirty = false;
	                                if (depDirtyIndex === -1) {
	                                    if ((depCalcObj.type === CalcHelper.CALC_FIELD && depCalcObj.dirty) ||
	                                            (depCalcObj.type === CalcHelper.DATA_COLUMN && dataColsModel.hasDirty(depCalcObj)) ||
	                                            (depCalcObj.type === CalcHelper.CALC_COLUMN && self.hasDirty(depCalcObj))) {
	                                        isDepDirty = true;
	                                    }
	                                } else {
	                                    if (depCalcObj.type === CalcHelper.DATA_COLUMN) {
	                                        dirtyStates = depCalcObj.dirtyStates;
	                                        if (dirtyStates[depDirtyIndex] === true) {
	                                            isDepDirty = true;
	                                        }
	                                    } else if (depCalcObj.type === CalcHelper.CALC_COLUMN) {
	                                        dirtyStates = depCalcObj.dirtyStates;
	                                        if (dirtyStates[depDirtyIndex] !== false) {
	                                            isDepDirty = true;
	                                        }
	
	                                    } else if (depCalcObj.type === CalcHelper.CALC_FIELD) {
	                                        if (depCalcObj.dirty !== false) {
	                                            isDepDirty = true;
	                                        }
	                                    }
	                                }
	                            }
	                            if (isDepDirty) {
	                                calculatingStack.push(depends[i]);
	                                hasDirtyDepends = true;
	                            }
	                        }
	                    }
	                    if (!hasDirtyDepends) {
	                        if (topCalcDep.type === CalcHelper.CALC_COLUMN) {
	                            calculateColumnInternal_.call(this, topCalcObj, topCalcDep.aggContext ? -1 : index, force);
	                            calculatingStack.pop();
	                        } else if (topCalcDep.type === CalcHelper.CALC_FIELD && fieldsModel) {
	                            fieldsModel.calculateField(topCalcObj.name);
	                            calculatingStack.pop();
	                        } else if (topCalcDep.type === CalcHelper.DATA_COLUMN) {
	                            dataColsModel.unDirty(topCalcObj.name, index);
	                            calculatingStack.pop();
	                        }
	                    }
	                }
	
	            } catch (e) {
	                if (e) {
	                    console.log('calculate exception thrown!');
	                    console.log(e.message);
	                    console.log(e.stack);
	                }
	            } finally {
	                colObj.isCalculating = false;
	            }
	        }
	
	        function calculateColumnInternal_(colObj, index, force) {
	            var self = this;
	            if (index === -1) {
	                if (colObj.dirty) { // hasn't been calculated, so calculate all is more efficient.
	                    calculateValues_.call(this, colObj);
	                } else { // has already calculated all once, so now only need to calculate the dirty items.
	                    var rowCount = self.calcSource_.getDimension();
	                    for (var row = 0; row < rowCount; row++) {
	                        if (force || colObj.dirtyStates[row] !== false) {
	                            calculateSingleValue_.call(self, colObj, row);
	                        }
	                    }
	                }
	            } else {
	                if (force || colObj.dirtyStates[index] !== false) {
	                    calculateSingleValue_.call(self, colObj, index);
	                }
	            }
	        }
	
	        function calculateSingleValue_(colObj, index) {
	            var self = this;
	            if (colObj.type === CalcHelper.CALC_COLUMN) {
	                var calcSource = self.calcSource_;
	                var calcTable = calcSource.getModel(CalcHelper.CALC_TABLE);
	                var context = new CalcContext.EvaluateContext(calcSource);
	                context.currentRowInternal_ = index;
	                calcTable.beginContextManipulate();
	                var result = self.evaluator_.evaluateExpression(colObj.expression, context);
	                if (CalcHelper.columnRef(result) && index !== -1) {
	                    result = result.getValue(index);
	                }
	                colObj.values[index] = result;
	                colObj.dirtyStates[index] = false;
	                calcTable.endContextManipulate();
	            }
	        }
	
	        function calculateValues_(colObj) {
	            var self = this;
	            if (colObj.type === CalcHelper.CALC_COLUMN) {
	                var calcSource = self.calcSource_;
	                var calcTable = calcSource.getModel(CalcHelper.CALC_TABLE);
	                var context = new CalcContext.EvaluateContext(self.calcSource_);
	                context.currentRowInternal_ = -1;
	                calcTable.beginContextManipulate();
	                var values = self.evaluator_.evaluateExpression(colObj.expression, context);
	                for (var i = 0, len = values.length; i < len; i++) {
	                    var srcRow = self.calcSource_.mapToSourceRow(i);
	                    colObj.values[srcRow] = values[i];
	                    colObj.dirtyStates[srcRow] = false;
	                }
	                calcTable.endContextManipulate();
	            }
	        }
	
	        function updateColumnFormula(colObj, newFormula) {
	            var self = this;
	            colObj.formula = newFormula;
	            var context = new CalcContext.ParserContext(self.calcSource_);
	            var expression = self.parser_.parse(newFormula, context);
	            colObj.expression = expression;
	            if (!expression) {
	                colObj.depends = null;
	            } else {
	                var depends = CalcHelper.resolveDepends(expression, self.calcSource_);
	                colObj.depends = depends;
	            }
	
	            var dirtyStates = [];
	            dirtyStates.length = self.calcSource_.getDimension();
	            colObj.dirtyStates = dirtyStates;
	        }
	
	        return CalcColumnsModel;
	    })();
	    CalcModels.CalcColumnsModel = CalcColumnsModel;
	
	    var CalcFieldsModel = (function() {
	        function CalcFieldsModel(calcSource) {
	            var self = this;
	            self.calcSource_ = calcSource;
	            self.parser_ = calcSource.getParser();
	            self.evaluator_ = calcSource.getEvaluator();
	            self.calcFields_ = [];
	        }
	
	        CalcFieldsModel.prototype = {
	            addField: function(name, formula) {
	                var self = this;
	                var context = new CalcContext.ParserContext(self.calcSource_);
	                var expression = self.parser_.parse(formula, context);
	                if (!expression) {
	                    return null;
	                }
	                var depends = CalcHelper.resolveDepends(expression, self.calcSource_);
	                var calcField = {
	                    name: name,
	                    type: CalcHelper.CALC_FIELD,
	                    formula: formula,
	                    expression: expression,
	                    value: undefined,
	                    dirty: true,
	                    depends: depends,
	                    isCalculating: false
	                };
	                self.calcFields_.push(calcField);
	                return calcField;
	            },
	
	            removeField: function(name) {
	                var calcField = _.remove(this.calcFields_, function(field) {
	                    return field.name === name;
	                });
	                return calcField;
	            },
	
	            calculateField: function(name, groupPath) {
	                var self = this;
	                var calcField = self.findField(name);
	                if (calcField.isCalculating) {
	                    return;
	                }
	
	                var calcColsModel = self.calcSource_.getModel(CalcHelper.CALC_COLUMN);
	                var dataColsModel = self.calcSource_.getModel(CalcHelper.DATA_COLUMN);
	                var i;
	                var len;
	                var depends;
	                calcField.isCalculating = true;
	                try {
	                    var calculatingStack = [];
	                    calculatingStack.push({type: CalcHelper.CALC_FIELD, name: name});
	                    while (calculatingStack.length !== 0) {
	                        var topCalcDep = calculatingStack[calculatingStack.length - 1];
	                        var topCalcObj = CalcHelper.getCalcObj(topCalcDep, self.calcSource_);
	                        if (topCalcObj === null) {
	                            calculatingStack.pop();
	                            continue;
	                        }
	                        var hasDirtyDepends = false;
	                        depends = topCalcObj.depends;
	                        if (depends) {
	                            for (i = 0, len = depends.length; i < len; i++) {
	                                var depCalcObj = CalcHelper.getCalcObj(depends[i], self.calcSource_);
	                                var isDpeDirty = false;
	                                if (depCalcObj) {
	                                    if ((depCalcObj.type === CalcHelper.CALC_FIELD && depCalcObj.dirty) ||
	                                            (depCalcObj.type === CalcHelper.DATA_COLUMN && dataColsModel.hasDirty(depCalcObj)) ||
	                                            (depCalcObj.type === CalcHelper.CALC_COLUMN && calcColsModel.hasDirty(depCalcObj))) {
	                                        isDpeDirty = true;
	                                    }
	
	                                    if (isDpeDirty) {
	                                        calculatingStack.push(depends[i]);
	                                        hasDirtyDepends = true;
	                                    }
	                                }
	                            }
	                        }
	                        if (!hasDirtyDepends) {
	                            if (topCalcDep.type === CalcHelper.CALC_COLUMN && calcColsModel) {
	                                calcColsModel.calculateColumn(topCalcObj.name);
	                                calculatingStack.pop();
	                            } else if (topCalcDep.type === CalcHelper.DATA_COLUMN && dataColsModel) {
	                                dataColsModel.unDirty(topCalcObj.name, -1);
	                                calculatingStack.pop();
	                            } else if (topCalcDep.type === CalcHelper.CALC_FIELD) {
	                                calculateFieldInternal_.call(this, topCalcObj, groupPath);
	                                calculatingStack.pop();
	                            }
	                        }
	                    }
	
	                } catch (e) {
	                    if (e) {
	                        console.log('calculate exception thrown!');
	                        console.log(e.message);
	                        console.log(e.stack);
	                    }
	                } finally {
	                    calcField.isCalculating = false;
	                }
	            },
	
	            findField: function(name) {
	                return _.find(this.calcFields_, _.matchesProperty('name', name));
	            },
	
	            getValue: function(name, groupPath) {
	                var self = this;
	                var calcFieldObj = self.findField(name);
	                if (calcFieldObj) {
	                    if (calcFieldObj.dirty) {
	                        self.calculateField(name, groupPath);
	                    }
	                    return calcFieldObj.value;
	                }
	            },
	
	            getFields: function() {
	                return this.calcFields_;
	            },
	
	            dirty: function(field) {
	                var self = this;
	                var calcField = field;
	                if (_.isString(field)) {
	                    calcField = self.findField(field);
	                }
	                if (calcField) {
	                    calcField.dirty = true;
	                }
	            }
	        };
	
	        function calculateFieldInternal_(calcFieldObj, groupPath) {
	            var self = this;
	            if (calcFieldObj.dirty) {
	                var context = new CalcContext.EvaluateContext(self.calcSource_, undefined, groupPath);
	                context.currentRowInternal_ = -1;
	                calcFieldObj.value = self.evaluator_.evaluateExpression(calcFieldObj.expression, context);
	                calcFieldObj.dirty = false;
	            }
	        }
	
	        return CalcFieldsModel;
	    })();
	    CalcModels.CalcFieldsModel = CalcFieldsModel;
	
	    var CalcGroupFieldsModel = (function() {
	        function CalcGroupFieldsModel(calcSource) {
	            var self = this;
	            self.calcSource_ = calcSource;
	            self.parser_ = calcSource.getParser();
	            self.evaluator_ = calcSource.getEvaluator();
	            self.calcFields_ = [];
	            initGroups_.call(self);
	        }
	
	        CalcGroupFieldsModel.prototype = {
	            addField: function(name, formula) {
	                var self = this;
	                var context = new CalcContext.ParserContext(self.calcSource_);
	                var expression = self.parser_.parse(formula, context);
	                if (!expression) {
	                    return null;
	                }
	                var depends = CalcHelper.resolveDepends(expression, self.calcSource_);
	                var fieldObj = {
	                    name: name,
	                    type: CalcHelper.CALC_G_FIELD,
	                    formula: formula,
	                    expression: expression,
	                    value: undefined,
	                    dirty: true,
	                    depends: depends,
	                    isCalculating: false
	                };
	                var calcField = {};
	                _.merge(calcField, self.rootGroupField_, fieldObj);
	                self.calcFields_.push(calcField);
	                return calcField;
	            },
	
	            calculateField: function(name, groupPath) {
	                var self = this;
	                var calcField = self.findField(name);
	                if (calcField.isCalculating) {
	                    return;
	                }
	
	                var fieldsModel = self.calcSource_.getModel(CalcHelper.CALC_FIELD);
	                var calcColsModel = self.calcSource_.getModel(CalcHelper.CALC_COLUMN);
	                var dataColsModel = self.calcSource_.getModel(CalcHelper.DATA_COLUMN);
	                var i;
	                var len;
	                var depends;
	                calcField.isCalculating = true;
	                try {
	                    var calculatingStack = [];
	                    calculatingStack.push({type: CalcHelper.CALC_G_FIELD, name: name});
	                    while (calculatingStack.length !== 0) {
	                        var topCalcDep = calculatingStack[calculatingStack.length - 1];
	                        var topCalcObj = CalcHelper.getCalcObj(topCalcDep, self.calcSource_);
	                        if (topCalcObj === null) {
	                            calculatingStack.pop();
	                            continue;
	                        }
	                        var hasDirtyDepends = false;
	                        depends = topCalcObj.depends;
	                        if (depends) {
	                            for (i = 0, len = depends.length; i < len; i++) {
	                                var depCalcObj = CalcHelper.getCalcObj(depends[i], self.calcSource_);
	                                var isDpeDirty = false;
	                                if (depCalcObj) {
	                                    if ((depCalcObj.type === CalcHelper.CALC_FIELD && depCalcObj.dirty) ||
	                                            (depCalcObj.type === CalcHelper.DATA_COLUMN && dataColsModel.hasDirty(depCalcObj)) ||
	                                            (depCalcObj.type === CalcHelper.CALC_COLUMN && calcColsModel.hasDirty(depCalcObj))) {
	                                        isDpeDirty = true;
	                                    }
	
	                                    if (isDpeDirty) {
	                                        calculatingStack.push(depends[i]);
	                                        hasDirtyDepends = true;
	                                    }
	                                }
	                            }
	                        }
	                        if (!hasDirtyDepends) {
	                            if (topCalcDep.type === CalcHelper.CALC_COLUMN && calcColsModel) {
	                                calcColsModel.calculateColumn(topCalcObj.name);
	                                calculatingStack.pop();
	                            } else if (topCalcDep.type === CalcHelper.CALC_FIELD && fieldsModel) {
	                                fieldsModel.calculateField(topCalcObj.name);
	                                calculatingStack.pop();
	                            } else if (topCalcDep.type === CalcHelper.DATA_COLUMN && dataColsModel) {
	                                dataColsModel.unDirty(topCalcObj.name, -1);
	                                calculatingStack.pop();
	                            } else if (topCalcDep.type === CalcHelper.CALC_G_FIELD) {
	                                calculateGroupFieldInternal_.call(self, topCalcObj, groupPath);
	                                calculatingStack.pop();
	                            }
	                        }
	                    }
	
	                } catch (e) {
	                    if (e) {
	                        console.log('calculate exception thrown!');
	                        console.log(e.message);
	                        console.log(e.stack);
	                    }
	                } finally {
	                    calcField.isCalculating = false;
	                }
	            },
	
	            findField: function(name) {
	                return _.find(this.calcFields_, _.matchesProperty('name', name));
	            },
	
	            getValue: function(name, groupPath) {
	                var self = this;
	                var rootGroupFieldObj = self.findField(name);
	                var groupFieldObj = findGroupField_.call(self, rootGroupFieldObj, groupPath);
	                if (groupFieldObj) {
	                    if (groupFieldObj.dirty) {
	                        self.calculateField(name, groupPath);
	                    }
	                    return groupFieldObj.value;
	                }
	                return;
	            },
	
	            getFields: function() {
	                return this.calcFields_;
	            },
	
	            updateGroups: function() {
	                var self = this;
	                initGroups_.call(self);
	                if (self.calcFields_ && self.rootGroupField_) {
	                    _.forEach(self.calcFields_, function(calcField) {
	                        calcField.fields = _.clone(self.rootGroupField_.fields, true);
	                        calcField.dirty = true;
	                    });
	                }
	            },
	
	            dirty: function(field) {
	                var self = this;
	                var calcField = field;
	                if (_.isString(field)) {
	                    calcField = self.findField(field);
	                }
	                if (calcField) {
	                    dirtyFields_.call(self, calcField);
	                }
	            }
	        };
	
	        function initGroups_() {
	            var self = this;
	            var rootGroup = self.calcSource_.getGroups();
	            if (rootGroup) {
	                self.rootGroupField_ = {value: undefined};
	                resolveGroups_.call(self, rootGroup, self.rootGroupField_);
	            }
	        }
	
	        function resolveGroups_(group, groupField) {
	            if (group.groups) {
	                if (!groupField.fields) {
	                    groupField.fields = [];
	                }
	                _.forEach(group.groups, function(subGroup) {
	                    var subField = {value: undefined, dirty: true};
	                    groupField.fields.push(subField);
	                    resolveGroups_(subGroup, subField);
	                });
	            }
	        }
	
	        function findGroupField_(rootFieldObj, groupPath) {
	            //var self = this;
	            var currentField = rootFieldObj;
	            if (!currentField) {
	                return;
	            }
	            for (var i = 0, len = groupPath.length; i < len; i++) {
	                var index = groupPath[i];
	                var fields = currentField.fields;
	                if (fields && index < fields.length) {
	                    currentField = fields[index];
	                } else {
	                    return null;
	                }
	            }
	            return currentField;
	        }
	
	        function calculateGroupFieldInternal_(rootFieldObj, groupPath) {
	            var self = this;
	            var groupFieldObj = findGroupField_.call(self, rootFieldObj, groupPath);
	            if (groupFieldObj && groupFieldObj.dirty) {
	                var context = new CalcContext.EvaluateContext(self.calcSource_, undefined, groupPath);
	                context.currentRowInternal_ = -1;
	                groupFieldObj.value = self.evaluator_.evaluateExpression(rootFieldObj.expression, context);
	                groupFieldObj.dirty = false;
	            }
	        }
	
	        function dirtyFields_(calcField) {
	            var self = this;
	            calcField.dirty = true;
	            var subFields = calcField.fields;
	            if (subFields) {
	                for (var i = 0, len = subFields.length; i < len; i++) {
	                    dirtyFields_.call(self, subFields[i]);
	                }
	            }
	        }
	
	        return CalcGroupFieldsModel;
	    })();
	    CalcModels.CalcGroupFieldsModel = CalcGroupFieldsModel;
	
	    module.exports = CalcModels;
	})();


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 *
	 * SpreadJS Library 1.0.0
	 * http://wijmo.com/
	 *
	 * Copyright(c) GrapeCity, Inc.  All rights reserved.
	 *
	 * Licensed under the Wijmo Commercial License. Also available under the GNU GPL Version 3 license.
	 * licensing@wijmo.com
	 * http://wijmo.com/widgets/license/
	 *
	 *
	 **/
	
	(function() {
	    'use strict';
	    var Calc = __webpack_require__(9);
	    var CalcModels = __webpack_require__(16);
	    var CalcHelper = __webpack_require__(14);
	    var CalcEvaluator = __webpack_require__(13);
	    var CalcParser = __webpack_require__(11).Parser;
	    var CalcContext = __webpack_require__(10);
	
	    var CalcSource = (function() {
	        function CalcSource(name, dataSource, columnDefs) {
	            if (name && dataSource) {
	                var self = this;
	                self.name = name;
	                self.dataSource = dataSource;
	                var dataColumns;
	                if (columnDefs) {
	                    dataColumns = _.filter(columnDefs, function(column) {
	                        return column.field && !_.startsWith(_.trim(column.field), '=');
	                    });
	                }
	                self.dataColumns_ = new CalcModels.DataColumnsModel(dataSource, dataColumns);
	                self.calcColumns_ = new CalcModels.CalcColumnsModel(self);
	                self.calcTable_ = new CalcModels.CalcTableModel(self, self.dataColumns_, self.calcColumns_);
	                self.calcFields_ = new CalcModels.CalcFieldsModel(self);
	                self.calcGroupFields_ = new CalcModels.CalcGroupFieldsModel(self);
	                if (columnDefs) {
	                    _.forEach(columnDefs, function(column) {
	                        if (column.field && _.startsWith(_.trim(column.field), '=')) {
	                            self.calcColumns_.addColumn(column.name, column.field);
	                        }
	                    });
	                }
	            }
	        }
	
	        CalcSource.prototype = {
	            getName: function() {
	                return this.name;
	            },
	            getRowItem: function(row) {
	                return this.calcTable_.getRowItem(row);
	            },
	            hasColumn: function(column) {
	                var self = this;
	                return !!self.calcTable_.findColumn(column);
	            },
	            hasField: function(field) {
	                var self = this;
	                return !!self.calcFields_.findField(field);
	            },
	            addCalcColumn: function(name, formula) {
	                this.calcColumns_.addColumn(name, formula);
	            },
	            addCalcField: function(name, formula) {
	                var self = this;
	                self.calcFields_.addField(name, formula);
	                var unknownExprColumns = getUnknownExpressionColumns.call(self);
	                if (unknownExprColumns.length > 0) {
	                    _.forEach(unknownExprColumns, function(col) {
	                        self.calcColumns_.updateColumnFormula(col);
	                    });
	                }
	            },
	            removeCalcField: function(name) {
	                return this.calcFields_.removeField(name);
	            },
	            getCalcFieldValue: function(name) {
	                return this.calcFields_.getValue(name);
	            },
	            addCalcGroupField: function(name, formula) {
	                this.calcGroupFields_.addField(name, formula);
	            },
	
	            addRowItem: function(item, srcIndex) { // jshint ignore:line
	                var self = this;
	                var addIndex = srcIndex ? srcIndex : self.getDimension();
	                var srcCollection = self.dataColumns_.sourceCollection;
	                if (srcCollection) {
	                    if (srcCollection.addItem && _.isFunction(srcCollection.addItem)) {
	                        srcCollection.addItem(item, addIndex);
	                    } else if (_.isArray(srcCollection)) {
	                        srcCollection.splice(addIndex, 0, item);
	                    }
	                }
	                var allColumns = self.dataColumns_.columns.concat(self.calcColumns_.columns_);
	                _.forEach(allColumns, function(colObj) {
	                    if (colObj.prototype === CalcHelper.CALC_COLUMN) {
	                        colObj.values.splice(addIndex, 0, undefined);
	                    }
	                    colObj.dirtyStates.splice(addIndex, 0, true);
	                    dirtyColumn_.call(self, colObj, srcIndex);
	                });
	            },
	
	            removeRowItem: function(srcIndex) { // jshint ignore:line
	                var self = this;
	                var dimension = self.getDimension();
	                var srcCollection = self.dataColumns_.sourceCollection;
	                if (srcCollection) {
	                    if (srcCollection.removeItem && _.isFunction(srcCollection.removeItem)) {
	                        srcCollection.removeItem(srcIndex);
	                    } else if (_.isArray(srcCollection)) {
	                        srcCollection.splice(srcIndex, 1);
	                    }
	                }
	                var allColumns = self.dataColumns_.columns.concat(self.calcColumns_.columns_);
	                _.forEachRight(allColumns, function(colObj) {
	                    if (colObj.prototype === CalcHelper.CALC_COLUMN) {
	                        colObj.values.splice(srcIndex, 1);
	                    }
	                    colObj.dirtyStates.splice(srcIndex, 1);
	                    dirtyColumn_.call(self, colObj, dimension);// dirty last inexisting item
	                });
	            },
	
	            filter: function(expression) {
	                var self = this;
	                self.calcTable_.filter(expression);
	                self.calcFields_.calcFields_.forEach(function(calcfield) {
	                    self.dirtyField(calcfield.name);
	                });
	                self.calcGroupFields_.updateGroups();
	            },
	            sort: function(sortds) {
	                var self = this;
	                self.calcTable_.sort(sortds);
	                self.calcGroupFields_.updateGroups();
	            },
	            group: function(gds) {
	                var self = this;
	                var groups = self.calcTable_.group(gds);
	                self.calcGroupFields_.updateGroups();
	                return groups;
	            },
	            hierarchy: function(hierarchyInfo) {
	                return this.calcTable_.hierarchy(hierarchyInfo);
	            },
	
	            getCalcGroupFieldValue: function(name, groupPath) {
	                return this.calcGroupFields_.getValue(name, groupPath);
	            },
	            getValues: function(column, group) {
	                var self = this;
	                var colObj = self.findColumn(column);
	                if (colObj) {
	                    return this.calcTable_.getValues(colObj, group, false);
	                }
	                return null;
	            },
	            getValue: function(column, index) {
	                var self = this;
	                var colObj = self.findColumn(column);
	                if (colObj) {
	                    return this.calcTable_.getValue(colObj, index, false);
	                }
	                return null;
	            },
	            getRowCount: function() {
	                return this.calcTable_.getRowCount();
	            },
	            getDimension: function() {
	                return this.calcTable_.getDimension();
	            },
	            findColumn: function(column) {
	                var self = this;
	                return self.findDataColumn(column) || self.findCalcColumn(column);
	            },
	            findDataColumn: function(name) {
	                return this.dataColumns_.findColumn(name);
	            },
	            findCalcColumn: function(name) {
	                return this.calcColumns_.findColumn(name);
	            },
	            findCalcField: function(name) {
	                return this.calcFields_.findField(name);
	            },
	            findCalcGroupField: function(name) {
	                return this.calcGroupFields_.findField(name);
	            },
	            getFieldValue: function(name) {
	                if (this.calcFields_) {
	                    return this.calcFields_.getValue(name);
	                }
	            },
	            getDataType: function(column) {
	                var colObj = this.calcTable_.findColumn(column);
	                if (colObj) {
	                    return colObj.dataType;
	                }
	            },
	            getParser: function() {
	                return new CalcParser(Calc.parseOption);
	            },
	            getEvaluator: function() {
	                return new CalcEvaluator();
	            },
	            getParserContext: function() {
	                return new CalcContext.ParserContext(this);
	            },
	            getEvaluatorContext: function(row, groupPath) {
	                return new CalcContext.EvaluateContext(this, row, groupPath);
	            },
	            getGroups: function() {
	                return this.calcTable_.getGroups();
	            },
	            getRootNode: function() {
	                return this.calcTable_.getRootNode();
	            },
	            create: function(name, dataSource) {
	                return new CalcSource(name, dataSource);
	            },
	            clone: function() {
	                var self = this;
	                var clonedObj = new CalcSource();
	                clonedObj.name = self.name;
	                clonedObj.dataSource = self.dataSource;
	                clonedObj.dataColumns_ = self.dataColumns_;
	                clonedObj.calcColumns_ = self.calcColumns_;
	                clonedObj.calcTable_ = self.calcTable_.clone();
	                clonedObj.calcFields_ = self.calcFields_;
	                clonedObj.calcGroupFields_ = self.calcGroupFields_;
	                return clonedObj;
	            },
	            reproduce: function() {
	                var self = this;
	                var reproducedObj = new CalcSource();
	                reproducedObj.name = self.name;
	                reproducedObj.dataSource = self.dataSource;
	                reproducedObj.dataColumns_ = self.dataColumns_;
	                reproducedObj.calcColumns_ = self.calcColumns_;
	                reproducedObj.calcTable_ = self.calcTable_.reproduce();
	                reproducedObj.calcFields_ = self.calcFields_;
	                reproducedObj.calcGroupFields_ = self.calcGroupFields_;
	                return reproducedObj;
	            },
	            reproduceWithColumns: function(columns) {
	                var self = this;
	                var reproducedObj = new CalcSource();
	                reproducedObj.name = self.name;
	                reproducedObj.dataSource = self.dataSource;
	                reproducedObj.dataColumns_ = self.dataColumns_;
	                reproducedObj.calcColumns_ = self.calcColumns_;
	                reproducedObj.calcTable_ = self.calcTable_.reproduceWithColumns(columns);
	                reproducedObj.calcFields_ = self.calcFields_;
	                reproducedObj.calcGroupFields_ = self.calcGroupFields_;
	                return reproducedObj;
	            },
	            bindGroup: function(groupPath) {
	                return this.calcTable_.bindGroup(groupPath);
	            },
	            unbindGroup: function() {
	                return this.calcTable_.unbindGroup();
	            },
	            getGroupPath: function(row) {
	                return this.calcTable_.getGroupPath(row);
	            },
	            overlapFilterStates_: function(filterStates) {
	                var self = this;
	                self.calcTable_.overlapFilterStates(filterStates);
	                self.calcGroupFields_.updateGroups();
	            },
	            overlapFilterSingleState_: function(filterStates, currentRow) {
	                var self = this;
	                self.calcTable_.overlapFilterSingleState(filterStates, currentRow);
	            },
	            getModel: function(type) {
	                var self = this;
	                switch (type) {
	                    case CalcHelper.DATA_COLUMN:
	                        return self.dataColumns_;
	                    case CalcHelper.CALC_COLUMN:
	                        return self.calcColumns_;
	                    case CalcHelper.CALC_TABLE:
	                        return self.calcTable_;
	                    case CalcHelper.CALC_FIELD:
	                        return self.calcFields_;
	                    case CalcHelper.CALC_G_FIELD:
	                        return self.calcGroupFields_;
	                }
	            },
	            dirtyColumn: function(column, index, newFormula) {
	                var self = this;
	                var col = self.findColumn(column);
	                if (!col) {
	                    return;
	                }
	                if (_.isUndefined(index)) {
	                    index = -1;
	                }
	                var srcIndex = self.calcTable_.mapToSourceRow(index);
	                var wholeColumnChanged = dirtyColumn_.call(self, col, srcIndex, newFormula);
	                return index === -1 || wholeColumnChanged;
	            },
	            dirtyColumns: function() {
	                var self = this;
	                var calcColumns = self.calcColumns_.getColumns();
	                _.forEach(calcColumns, function(calcColumn) {
	                    dirtyColumn_.call(self, calcColumn, -1);
	                });
	            },
	            dirtyField: function(name) {
	                var self = this;
	                var field = self.findCalcField(name);
	                if (!field) {
	                    return;
	                }
	                self.calcFields_.dirty(name);
	                var listeners = findListenersRecursively_.call(self, {calc: field, index: -1});
	                dirtyListeners_.call(self, listeners);
	            },
	            dirtyFields: function() {
	                var self = this;
	                var fields = self.calcFields_.getFields();
	                _.forEach(fields, function(field) {
	                    self.calcFields_.dirty(field);
	                    var listeners = findListenersRecursively_.call(self, {calc: field, index: -1});
	                    dirtyListeners_.call(self, listeners);
	                });
	            },
	            dirtyAll: function() {
	                this.dirtyColumns();
	                this.dirtyFields();
	            },
	            toArray: function(group) {
	                return this.calcTable_.toArray(group);
	            },
	
	            mapToSourceRow: function(row) {
	                return this.calcTable_.mapToSourceRow(row);
	            },
	            mapToViewRow: function(row) {
	                return this.calcTable_.mapToViewRow(row);
	            },
	            isFilterOut: function(srcRow) {
	                return this.calcTable_.isFilterOut(srcRow);
	            }
	        };
	
	        function dirtyColumn_(col, srcIndex, newFormula) {
	            var self = this;
	            if (col.type === CalcHelper.DATA_COLUMN) {
	                self.dataColumns_.dirty(col, srcIndex);
	            } else if (col.type === CalcHelper.CALC_COLUMN) {
	                self.calcColumns_.dirty(col, -1, newFormula);
	            }
	            var listeners = findListenersRecursively_.call(self, {calc: col, index: srcIndex});
	            dirtyListeners_.call(self, listeners);
	            return _.any(listeners, function(listener) {
	                return listener.calc.type === CalcHelper.CALC_COLUMN && listener.index === -1;
	            });
	        }
	
	        function findListenersRecursively_(calcListener) {
	            var self = this;
	            var listeners = findListeners_.call(self, calcListener);
	            if (listeners.length > 0) {
	                _.forEach(listeners, function(listener) {
	                    var deepListeners = findListenersRecursively_.call(self, listener);
	                    listeners = listeners.concat(deepListeners);
	                });
	            }
	            return listeners;
	        }
	
	        function findListeners_(calcListener) {
	            var self = this;
	            var listeners = [];
	            var calcCols = self.calcColumns_.getColumns();
	            _.forEach(calcCols, function(calcCol) {
	                if (isInDepends_.call(self, calcListener.calc, calcCol)) {
	                    if (isCalcInAgg_(calcListener.calc, calcCol.expression)) {
	                        listeners.push({calc: calcCol, index: -1});
	                    } else {
	                        listeners.push({calc: calcCol, index: calcListener.index});
	                    }
	                }
	            });
	            var calcFields = self.calcFields_.getFields();
	            _.forEach(calcFields, function(calcField) {
	                if (isInDepends_.call(self, calcListener.calc, calcField)) {
	                    listeners.push({calc: calcField, index: -1});
	                }
	            });
	            var calcGroupFields = self.calcGroupFields_.getFields();
	            _.forEach(calcGroupFields, function(calcField) {
	                if (isInDepends_.call(self, calcListener.calc, calcField)) {
	                    listeners.push({calc: calcField, index: -1});
	                }
	            });
	            return listeners;
	        }
	
	        function isInDepends_(calc1, calc2) {
	            var self = this;
	            var depends = calc2.depends;
	            for (var i = 0, len = depends.length; i < len; i++) {
	                if (isDepend_.call(self, calc1, depends[i])) {
	                    return true;
	                }
	            }
	        }
	
	        function isDepend_(calc, depend) {
	            if (depend.type === calc.type) {
	                var type = depend.type;
	                if ((type === CalcHelper.CALC_COLUMN && depend.column === calc.name) ||
	                        (type === CalcHelper.DATA_COLUMN && depend.column === calc.name) ||
	                        (type === CalcHelper.CALC_FIELD && depend.name === calc.name)) {
	                    return true;
	                } else {
	                    return false;
	                }
	            }
	        }
	
	        function isCalcInAgg_(calc, expr) {
	            if (CalcHelper.aggFn(expr)) {
	                return true;
	            }
	
	            if (CalcHelper.binaryExpr(expr)) {
	                var result = isCalcInAgg_(calc, expr.left);
	                if (result) {
	                    return true;
	                }
	                return isCalcInAgg_(calc, expr.right);
	            } else if (CalcHelper.fnExpr(expr)) {
	                if (CalcHelper.aggFn(expr)) {
	                    return true;
	                } else {
	                    var args = expr.args;
	                    if (args && args.length > 0) {
	                        return _.any(args, function(argExpr) {
	                            return isCalcInAgg_(calc, argExpr);
	                        });
	                    }
	                }
	            }
	            return false;
	        }
	
	        function dirtyListeners_(listeners) {
	            var self = this;
	            _.forEach(listeners, function(listener) {
	                var calc = listener.calc;
	                var index = listener.index;
	                var type = calc.type;
	                switch (type) {
	                    case CalcHelper.DATA_COLUMN:
	                        if (listener.index !== undefined) {
	                            self.dataColumns_.dirty(calc, index);
	                        }
	                        break;
	                    case CalcHelper.CALC_COLUMN:
	                        if (listener.index !== undefined) {
	                            self.calcColumns_.dirty(calc, index);
	                        }
	                        break;
	                    case CalcHelper.CALC_FIELD:
	                        self.calcFields_.dirty(calc);
	                        break;
	                    case CalcHelper.CALC_G_FIELD:
	                        self.calcGroupFields_.dirty(calc);
	                        break;
	                }
	            });
	        }
	
	        function getUnknownExpressionColumns() {
	            var self = this;
	            var columns = [];
	            var calcColumns = self.calcColumns_.getColumns();
	            if (calcColumns) {
	                _.forEach(calcColumns, function(calcCol) {
	                    var result = containsUnknownExpression.call(self, calcCol.expression);
	                    if (result) {
	                        columns.push(calcCol.name);
	                    }
	                });
	            }
	            return columns;
	        }
	
	        function containsUnknownExpression(expr) {
	            if (!expr) {
	                return false;
	            }
	            if (CalcHelper.unknowExpr(expr)) {
	                return true;
	            } else if (CalcHelper.binaryExpr(expr)) {
	                if (containsUnknownExpression(expr.left) ||
	                        containsUnknownExpression(expr.right)) {
	                    return true;
	                }
	                return false;
	            } else if (CalcHelper.fnExpr(expr)) {
	                var args = expr.args;
	                if (args && args.length > 0) {
	                    for (var i = 0, len = args.length; i < len; i++) {
	                        if (containsUnknownExpression(args[i])) {
	                            return true;
	                        }
	                    }
	                }
	                return false;
	            } else {
	                return false;
	            }
	        }
	
	        return CalcSource;
	    })();
	
	    module.exports = {
	        CalcSource: CalcSource
	    };
	})();


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 *
	 * SpreadJS Library 1.0.0
	 * http://wijmo.com/
	 *
	 * Copyright(c) GrapeCity, Inc.  All rights reserved.
	 *
	 * Licensed under the Wijmo Commercial License. Also available under the GNU GPL Version 3 license.
	 * licensing@wijmo.com
	 * http://wijmo.com/widgets/license/
	 *
	 *
	 **/
	
	(function() {
	    'use strict';
	    var CalcSource = __webpack_require__(17);
	    var CalcModels = __webpack_require__(16);
	
	    var objectDefineProperty = Object.defineProperty;
	
	    var EventHandler = (function() {
	        function EventHandler(handler, self) {
	            this.handler = handler;
	            this.self = self;
	        }
	
	        return EventHandler;
	    })();
	
	    var Event = (function() {
	        function Event() {
	            this._handlers = [];
	        }
	
	        Event.prototype.addHandler = function(handler, self) {
	            this._handlers.push(new EventHandler(handler, self));
	        };
	
	        Event.prototype.removeHandler = function(handler, self) {
	            for (var i = 0; i < this._handlers.length; i++) {
	                var l = this._handlers[i];
	                if (l.handler === handler && l.self === self) {
	                    this._handlers.splice(i, 1);
	                    break;
	                }
	            }
	        };
	
	        Event.prototype.removeAllHandlers = function() {
	            this._handlers.length = 0;
	        };
	
	        Event.prototype.raise = function(sender, args) {
	            if (typeof args === 'undefined') {
	                args = null;
	            }
	            for (var i = 0; i < this._handlers.length; i++) {
	                var l = this._handlers[i];
	                l.handler.call(l.self, sender, args);
	            }
	        };
	
	        Object.defineProperty(Event.prototype, 'hasHandlers', {
	            /**
	             * Gets a value that indicates whether this event has any handlers.
	             */
	            get: function() {
	                return this._handlers.length > 0;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        return Event;
	    })();
	
	    var CalcCollectionGroup = (function() {
	        /**
	         * Initializes a new instance of a @see:CollectionViewGroup.
	         *
	         * @param groupDescriptor @see:GroupDescription that owns the new group.
	         * @param name Name of the new group.
	         * @param level Level of the new group.
	         * @param isBottomLevel Whether this group has any subgroups.
	         * @param collapsed Whether this group is collapsed or not
	         */
	        function CalcCollectionGroup(calcCollection, groupDescriptor, calcGroup) {
	            var self = this;
	            self._calcCollection = calcCollection;
	            self._gd = groupDescriptor;
	            self._calcGroup = calcGroup;
	            self._collapsed = groupDescriptor ? !!groupDescriptor.collapsed : false;
	            self._groups = [];
	            var hds = calcCollection.hierarchyDescriptor;
	            if (calcGroup.isBottomLevel && calcGroup.rootNode && hds) {
	                self._rootNode = CalcCollection.createCVTree_(calcGroup.rootNode, hds);
	            }
	        }
	
	        //cvgPrototype.toGlobalIndex = function(localIndex) {
	        //    return this._calcGroup.toGlobalIndex(localIndex);
	        //};        //cvgPrototype.toGlobalIndex = function(localIndex) {
	        //    return this._calcGroup.toGlobalIndex(localIndex);
	        //};
	
	        CalcCollectionGroup.prototype = {
	            getItem: function(localIndex) {
	                var self = this;
	                if (self._rootNode) {
	                    return self._rootNode.getItem(localIndex);
	                } else {
	                    return self._calcGroup.getItem(localIndex);
	                }
	            },
	            getItems: function() {
	                var self = this;
	                if (self._rootNode) {
	                    return self._rootNode.getItems();
	                } else {
	                    return this._calcGroup.getItems();
	                }
	            },
	            toSourceRow: function(localIndex) {
	                var self = this;
	                if (self._rootNode) {
	                    return self._rootNode.toSourceRow(localIndex);
	                } else {
	                    return this._calcGroup.toSourceIndex(localIndex);
	                }
	            },
	            updateTree_: function() {
	                var self = this;
	                updateTree_(self, self._calcCollection.hierarchyDescriptor);
	            }
	        };
	
	        var cvgPrototype = CalcCollectionGroup.prototype;
	
	        objectDefineProperty(cvgPrototype, 'name', {
	            /*
	             * Gets the name of this group.
	             */
	            get: function() {
	                return this._calcGroup.name;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        objectDefineProperty(cvgPrototype, 'collapsed', {
	            /*
	             * Gets the name of this group.
	             */
	            get: function() {
	                return this._collapsed;
	            },
	            set: function(value) {
	                this._collapsed = value;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        objectDefineProperty(cvgPrototype, 'parent', {
	            /*
	             * Gets the name of this group.
	             */
	            get: function() {
	                return this._parent;
	            },
	            set: function(value) {
	                this._parent = value;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        objectDefineProperty(cvgPrototype, 'level', {
	            /*
	             * Gets the level of this group.
	             */
	            get: function() {
	                return this._calcGroup.level;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        objectDefineProperty(cvgPrototype, 'isBottomLevel', {
	            /*
	             * Gets a value that indicates whether this group has any subgroups.
	             */
	            get: function() {
	                return this._calcGroup.isBottomLevel;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        objectDefineProperty(cvgPrototype, 'itemCount', {
	            /*
	             * Gets an array containing the items included in this group (including all subgroups).
	             */
	            get: function() {
	                return this._calcGroup.itemCount;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        objectDefineProperty(cvgPrototype, 'groups', {
	            /*
	             * Gets an array containing the this group's subgroups.
	             */
	            get: function() {
	                return this._groups;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        objectDefineProperty(cvgPrototype, 'groupDescriptor', {
	            /*
	             * Gets the @see:GroupDescription that owns this group.
	             */
	            get: function() {
	                return this._gd;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        objectDefineProperty(cvgPrototype, 'rootNode', {
	            /*
	             * Gets the @see:GroupDescription that owns this group.
	             */
	            get: function() {
	                return this._rootNode;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        objectDefineProperty(cvgPrototype, 'isHierarchical', {
	            /*
	             * Gets the name of the property that is used to determine which
	             * group an item belongs to.
	             */
	            get: function() {
	                var self = this;
	                var result = false;
	                traversalBottomGroups_(self, function(cvGroup) {
	                    if (cvGroup.rootNode) {
	                        result = true;
	                        return true;
	                    }
	                });
	                return result;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        function updateTree_(cvGroup, hds) {
	            traversalBottomGroups_(cvGroup, function(cvGroup) {
	                var calcGroup = cvGroup._calcGroup;
	                if (calcGroup.rootNode) {
	                    cvGroup._rootNode = CalcCollection.createCVTree_(calcGroup.rootNode, hds);
	                }
	            });
	        }
	
	        function traversalBottomGroups_(cvGroup, callback) {
	            if (cvGroup.isBottomLevel) {
	                var stop = callback(cvGroup);
	                if (stop) {
	                    return;
	                }
	            } else {
	                _.forEach(cvGroup.groups, function(subGroup) {
	                    traversalBottomGroups_(subGroup, callback);
	                });
	            }
	        }
	
	        return CalcCollectionGroup;
	    })();
	
	    var CalcCollectionNode = (function() {
	        function CalcCollectionNode(calcNode) {
	            var self = this;
	            self._calcNode = calcNode;
	            self._parent = null;
	            self._children = [];
	        }
	
	        CalcCollectionNode.offsetUnit = 20;
	
	        CalcCollectionNode.prototype = {
	            getItem: function(relativeIndex) {
	                var self = this;
	                var item = null;
	                var node = CalcModels.CalcNode_.findNode_(self, relativeIndex);
	                if (node) {
	                    item = node._calcNode.getItem();
	                    item.node = node;
	                }
	                return item;
	            },
	            getItems: function(option) {
	                return this._calcNode.getItems(option);
	            },
	            expandAll: function() {
	                this._calcNode.expandAll();
	            },
	            collapseAll: function() {
	                this._calcNode.collapseAll();
	            },
	            findNode: function(relativeIndex) {
	                return CalcModels.CalcNode_.findNode_(this, relativeIndex);
	            },
	            toSourceRow: function(relativeIndex) {
	                return this._calcNode.toSourceIndex(relativeIndex);
	            },
	            toJSON: function() {
	
	            }
	        };
	        var cvgPrototype = CalcCollectionNode.prototype;
	
	        objectDefineProperty(cvgPrototype, 'collapsed', {
	            /*
	             * Gets the name of this group.
	             */
	            get: function() {
	                return this._calcNode.collapsed;
	            },
	            set: function(value) {
	                this._calcNode.collapsed = value;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        objectDefineProperty(cvgPrototype, 'parent', {
	            /*
	             * Gets the name of this group.
	             */
	            get: function() {
	                return this._parent;
	            },
	            set: function(value) {
	                this._parent = value;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        objectDefineProperty(cvgPrototype, 'level', {
	            /*
	             * Gets the level of this group.
	             */
	            get: function() {
	                return this._calcNode.level;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        objectDefineProperty(cvgPrototype, 'children', {
	            /*
	             * Gets an array containing the this group's subgroups.
	             */
	            get: function() {
	                return this._children;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        objectDefineProperty(cvgPrototype, 'value', {
	            /*
	             * Gets an array containing the this group's subgroups.
	             */
	            get: function() {
	                return this._calcNode.value;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        objectDefineProperty(cvgPrototype, 'nodeCount', {
	            /*
	             * Gets an array containing the this group's subgroups.
	             */
	            get: function() {
	                return this._calcNode.nodeCount;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        objectDefineProperty(cvgPrototype, 'offset', {
	            /*
	             * Gets an array containing the this group's subgroups.
	             */
	            get: function() {
	                return this.level * CalcCollectionNode.offsetUnit;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        return CalcCollectionNode;
	    })();
	
	    var Filter = (function() {
	        var Filter = function(calcCollection, expr) {
	            var self = this;
	            self.expr_ = expr;
	            self.calcCollection_ = calcCollection;
	        };
	
	        Filter.prototype = {
	            and: function(expr) {
	                var self = this;
	                self.expr_ = self.expr_ ? '((' + self.expr_ + ')&&(' + expr + '))' : expr;
	                return self;
	            },
	            or: function(expr) {
	                var self = this;
	                self.expr_ = self.expr_ ? '((' + self.expr_ + ')||(' + expr + '))' : expr;
	                return self;
	            },
	            do: function() {
	                var self = this;
	                self.calcCollection_.filterExpression = self.expr_;
	            },
	            clear: function() {
	                this.expr_ = null;
	                return this;
	            }
	        };
	
	        return Filter;
	    })();
	
	    var CalcCollection = (function() {
	        function CalcCollection(sourceCollection, columnDefs) {
	            var self = this;
	            self.sourceCollection_ = sourceCollection;
	            self.calcSource_ = new CalcSource.CalcSource('__default', sourceCollection, columnDefs);
	            self.sortds_ = [];
	            self.gds_ = [];
	            self.hds_ = null;
	            self.groups_ = null;
	            self.rootNode_ = null;
	
	            self.filterObj_ = null;
	
	            self.getDefaults = null;
	            self.collectionChanged = new Event();
	        }
	
	        CalcCollection.prototype = {
	            getItem: function(row) {
	                var self = this;
	                if (self.rootGroup_) {
	                    return self.rootGroup_.getItem(row);
	                } else if (self.rootNode_) {
	                    return self.rootNode_.getItem(row);
	                } else {
	                    return self.calcSource.getRowItem(row);
	                }
	            },
	            addItem: function(item, srcRow) {
	                var self = this;
	                self.calcSource_.addRowItem(item, srcRow);
	                self.refresh();
	                raiseCollectionChanged_.call(self, {action: 'addItem', data: {item: item, row: srcRow}});
	            },
	            removeItem: function(srcRow) {
	                var self = this;
	                self.calcSource_.removeRowItem(srcRow);
	                self.refresh();
	                raiseCollectionChanged_.call(self, {action: 'removeItem', data: {row: srcRow}});
	            },
	            filter: function(expression) {
	                var self = this;
	                if (!self.filterObj_) {
	                    self.filterObj_ = new Filter(self, expression);
	                }
	                if (expression) {
	                    self.filterObj_.expr_ = expression;
	                }
	                return self.filterObj_;
	            },
	            refresh: function() {
	                var self = this;
	                if (self.filterExpr_) {
	                    filter_.call(self, self.filterExpr_);
	                } else if (self.sortds_ && self.sortds_.length > 0) {
	                    sort_.call(self, self.sortds_);
	                } else if (self.gds_ && self.gds_.length > 0) {
	                    group_.call(self, self.gds_);
	                } else if (self.hds_ && self.hds_.length > 0) {
	                    hierarchy_.call(self, self.hds_);
	                }
	            },
	            addCalcField: function(name, formula) {
	                var self = this;
	                self.calcSource_.addCalcField(name, formula);
	                raiseCollectionChanged_.call(self, {action: 'addCalcField'});
	            },
	            getCalcField: function(name) {
	                var self = this;
	                var calcSource = self.calcSource_;
	                if (calcSource) {
	                    var fieldObj = calcSource.findCalcField(name);
	                    if (fieldObj) {
	                        var value = calcSource.getCalcFieldValue(name);
	                        return {name: name, formula: fieldObj.formula, value: value};
	                    }
	                }
	                return null;
	            },
	            removeCalcField: function(name) {
	                var self = this;
	                self.calcSource_.removeCalcField(name);
	                raiseCollectionChanged_.call(self, {action: 'removeCalcField'});
	            },
	            toSourceRow: function(viewRow) {
	                return this.calcSource_.mapToSourceRow(viewRow);
	            },
	            calculate: function(formula, evaluatorContext) {
	                var calcSource = this.calcSource_;
	                var parserContext = calcSource.getParserContext();
	                if (!evaluatorContext) {
	                    evaluatorContext = calcSource.getEvaluatorContext();
	                }
	                return calcSource.getEvaluator().evaluateFormula(formula, parserContext, evaluatorContext);
	            }
	        };
	        var calcCollectionProto = CalcCollection.prototype;
	
	        objectDefineProperty(calcCollectionProto, 'filterExpression', {
	            /*
	             * Gets the name of the property that is used to determine which
	             * group an item belongs to.
	             */
	            get: function() {
	                return this.filterExpr_;
	            },
	            set: function(value) {
	                var self = this;
	                self.filterExpr_ = value;
	                filter_.call(self, value);
	                raiseCollectionChanged_.call(self, {action: 'filter'});
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        objectDefineProperty(calcCollectionProto, 'sortDescriptors', {
	            /*
	             * Gets the name of the property that is used to determine which
	             * group an item belongs to.
	             */
	            get: function() {
	                return this.sortds_;
	            },
	            set: function(value) {
	                var self = this;
	                var result = null;
	                if (value) {
	                    var sortInfos = _.isArray(value) ? value : [value];
	                    result = preProcessSortInfos_.call(self, sortInfos);
	                }
	                self.sortds_ = result;
	                sort_.call(self, result);
	                raiseCollectionChanged_.call(self, {action: 'sort'});
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        objectDefineProperty(calcCollectionProto, 'groupDescriptors', {
	            /*
	             * Gets the name of the property that is used to determine which
	             * group an item belongs to.
	             */
	            get: function() {
	                return this.gds_;
	            },
	            set: function(value) {
	                var self = this;
	                var result = null;
	                if (value) {
	                    var groupingInfos = _.isArray(value) ? value : [value];
	                    result = preProcessGroupInfos_.call(self, groupingInfos);
	                }
	                self.gds_ = result;
	                group_.call(self, result);
	                raiseCollectionChanged_.call(self, {action: 'group'});
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        objectDefineProperty(calcCollectionProto, 'itemCount', {
	            /*
	             * Gets the name of the property that is used to determine which
	             * group an item belongs to.
	             */
	            get: function() {
	                var self = this;
	                if (self.rootNode_) {
	                    return self.rootNode_.nodeCount;
	                } else if (self.rootGroup_) {
	                    return self.rootGroup_.itemCount;
	                } else {
	                    return this.calcSource.getRowCount();
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        objectDefineProperty(calcCollectionProto, 'hierarchyDescriptor', {
	            /*
	             * Gets the name of the property that is used to determine which
	             * group an item belongs to.
	             */
	            get: function() {
	                return this.hds_;
	            },
	            set: function(value) {
	                var self = this;
	                self.hds_ = _.clone(value);
	                if (!value.hasOwnProperty('collapsed')) {
	                    self.hds_.collapsed = true;
	                }
	                hierarchy_.call(self, value);
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        objectDefineProperty(calcCollectionProto, 'sourceCollection', {
	            get: function() {
	                return this.sourceCollection_;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        objectDefineProperty(calcCollectionProto, 'groups', {
	            get: function() {
	                return this.groups_;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        objectDefineProperty(calcCollectionProto, 'nodes', {
	            get: function() {
	                if (this.rootNode_ && this.rootNode_.children.length > 0) {
	                    return this.rootNode_.children;
	                }
	                return null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        objectDefineProperty(calcCollectionProto, 'rootNode', {
	            get: function() {
	                return this.rootNode_;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        objectDefineProperty(calcCollectionProto, 'calcSource', {
	            get: function() {
	                return this.calcSource_;
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        objectDefineProperty(calcCollectionProto, 'isHierarchical', {
	            /*
	             * Gets the name of the property that is used to determine which
	             * group an item belongs to.
	             */
	            get: function() {
	                var self = this;
	                return self.rootNode_ || (self.rootGroup_ && self.rootGroup_.isHierarchical);
	            },
	            enumerable: true,
	            configurable: true
	        });
	
	        function filter_(expression) {
	            var self = this;
	            self.calcSource_.filter(expression);
	            if (self.gds_) {
	                updateGroup_.call(self);
	            }
	            if (self.hds_) {
	                updateTree_.call(self);
	            }
	        }
	
	        function sort_(collectionSds) {
	            var self = this;
	            var calcSds = toCalcSds_.call(self, collectionSds);
	            self.calcSource_.sort(calcSds);
	            if (self.gds_) {
	                updateGroup_.call(self);
	            }
	            if (self.hds_) {
	                updateTree_.call(self);
	            }
	        }
	
	        function group_(collectionGds) {
	            var self = this;
	            var calcGds = toCalcGds_.call(self, collectionGds);
	            self.rootCalcGroup_ = self.calcSource_.group(calcGds);
	            updateGroup_.call(self);
	            if (self.hds_) {
	                updateTree_.call(self);
	            }
	        }
	
	        function hierarchy_(hierarchyInfo) {
	            var self = this;
	            self.rootCalcNode_ = self.calcSource_.hierarchy(hierarchyInfo);
	            updateTree_.call(self);
	        }
	
	        function updateTree_() {
	            var self = this;
	            if (self.rootGroup_) {
	                self.rootGroup_.updateTree_();
	            } else {
	                self.rootCalcNode_ = self.calcSource_.getRootNode();
	                self.rootNode_ = createCVTree_(self.rootCalcNode_, self.hds_);
	            }
	        }
	
	        function updateGroup_() {
	            var self = this;
	            self.rootCalcGroup_ = self.calcSource_.getGroups();
	            if (self.rootCalcGroup_) {
	                self.rootGroup_ = createCVGroup_.call(self, self.rootCalcGroup_);
	                self.groups_ = self.rootGroup_.groups;
	            } else {
	                self.rootGroup_ = null;
	                self.groups_ = null;
	            }
	        }
	
	        function toCalcSds_(collectionSds) {
	            if (!collectionSds) {
	                return undefined;
	            }
	            return _.map(collectionSds, function(sds) {
	                var converter = sds.converter;
	                var calcsds = {field: sds.field, ascending: sds.ascending};
	                if (converter) {
	                    calcsds.converter = converter;
	                }
	                return calcsds;
	            });
	        }
	
	        function toCalcGds_(collectionGds) {
	            if (!collectionGds) {
	                return undefined;
	            }
	            return _.map(collectionGds, function(gd) {
	                var converter = gd.converter;
	                var calcGd = {field: gd.field};
	                if (converter) {
	                    calcGd.converter = converter;
	                }
	                return calcGd;
	            });
	        }
	
	        function createCVGroup_(calcGroup) {
	            var self = this;
	            var level = calcGroup.level;
	            var cvGds;
	            if (level >= 0) {
	                cvGds = self.gds_[level];
	            }
	            var cvGroup = new CalcCollectionGroup(self, cvGds, calcGroup);
	            if (!calcGroup.isBottomLevel) {
	                var subCvGroups = _.map(calcGroup.groups, function(subCalcGroup) {
	                    var subCvGroup = createCVGroup_.call(self, subCalcGroup);
	                    if (level !== -1) { //no parent for the first groups
	                        subCvGroup.parent = cvGroup;
	                    }
	                    return subCvGroup;
	                });
	                for (var i = 0, len = subCvGroups.length; i < len; i++) {
	                    cvGroup.groups.push(subCvGroups[i]);
	                }
	            }
	            return cvGroup;
	        }
	
	        function raiseCollectionChanged_(args) {
	            this.collectionChanged.raise(this, args);
	        }
	
	        function preProcessGroupInfos_(groupInfos) {
	            var self = this;
	            var allStrings = _.all(groupInfos, function(item) {
	                return _.isString(item);
	            });
	            var allObjects = _.all(groupInfos, function(item) {
	                return _.isObject(item);
	            });
	
	            if (!allObjects) {
	                if (!allStrings) {
	                    return console && console.error && console.error('Can not mixing use the string of column ID and group setting object');
	                } else {
	                    groupInfos = _.map(groupInfos, function(item) {
	                        return {field: item};
	                    });
	                }
	            }
	            var getDefaults = self.getDefaults;
	            var defaults = getDefaults && _.isFunction(getDefaults) ? getDefaults() : null;
	            if (defaults && defaults.group) {
	                var defaultGroupInfo = defaults.group;
	                var gds = [];
	                for (var i = 0, len = groupInfos.length; i < len; i++) {
	                    var groupInfo = groupInfos[i];
	                    groupInfo.header = _.defaults(groupInfo.header || {}, defaultGroupInfo.header);
	                    groupInfo.footer = _.defaults(groupInfo.footer || {}, defaultGroupInfo.footer);
	                    groupInfo = _.defaults(groupInfo, defaultGroupInfo);
	                    gds.push(groupInfo);
	                }
	                return gds;
	            } else {
	                return groupInfos;
	            }
	        }
	
	        function preProcessSortInfos_(sortInfos) {
	            var allStrings = _.all(sortInfos, function(item) {
	                return _.isString(item);
	            });
	            var allObjects = _.all(sortInfos, function(item) {
	                return _.isObject(item);
	            });
	
	            if (!allObjects) {
	                if (!allStrings) {
	                    return console && console.error && console.error('Can not mixing use the string of column ID and sort setting object');
	                } else {
	                    sortInfos = _.map(sortInfos, function(item) {
	                        return {field: item};
	                    });
	                }
	            }
	            return sortInfos;
	        }
	
	        function createCVTree_(calcNode, hds) {
	            var cvNode = new CalcCollectionNode(calcNode, !!hds.collapsed);
	            var childCvNodes = _.map(calcNode.children, function(childCalcNode) {
	                var childCvNode = createCVTree_(childCalcNode, hds);
	                childCvNode.parent = cvNode;
	                return childCvNode;
	            });
	            for (var i = 0, len = childCvNodes.length; i < len; i++) {
	                cvNode._children.push(childCvNodes[i]);
	            }
	            return cvNode;
	        }
	
	        CalcCollection.createCVTree_ = createCVTree_;
	
	        return CalcCollection;
	    })();
	
	    module.exports = {
	        CalcCollection: CalcCollection
	    };
	})();


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    module.exports = {
	        Functions: {}
	    };
	}());


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	// jscs:disable validateJSDoc
	/*
	 *
	 * SpreadJS Library 1.0.0
	 * http://wijmo.com/
	 *
	 * Copyright(c) GrapeCity, Inc.  All rights reserved.
	 *
	 * Licensed under the Wijmo Commercial License. Also available under the GNU GPL Version 3 license.
	 * licensing@wijmo.com
	 * http://wijmo.com/widgets/license/
	 *
	 *
	 **/
	(function() {
	    /* jshint ignore:start */
	    'use strict';
	    var spread = {};
	    module.exports = spread;
	
	    var _ENStringResource = (function() {
	        function _ENStringResource() {
	        }
	
	        _ENStringResource.Exp_InvalidArgument = 'Invalid argument';
	        _ENStringResource.Exp_InvalidCast = 'InvalidCastException';
	        _ENStringResource.Exp_NotSupport = 'NotSupportException';
	        _ENStringResource.Exp_FormulaInvalid = 'The formula you typed contains an invalid char: ';
	        _ENStringResource.Exp_InvalidTokenAt = 'invalid token at ';
	        _ENStringResource.Exp_InvalidArrayAt = 'Invalid array at ';
	        _ENStringResource.Exp_InvalidCellReference = 'Invalid cell reference or name at ';
	        _ENStringResource.Exp_InvalidFunctionName = 'Invalid function name';
	        _ENStringResource.Exp_InvalidOverrideFunction = 'Cannot override built-in function';
	        _ENStringResource.Exp_OverrideNotAllowed = 'Attempt to override function while override is not allowed';
	        _ENStringResource.Exp_NoSyntax = 'no syntax "';
	        _ENStringResource.Exp_MatchSyntax = '"to match the syntax "';
	        _ENStringResource.SingleQuotesFullStop = '".';
	        _ENStringResource.SingleQuote = '';
	        _ENStringResource.Exp_IsValid = '" is invalid.';
	        _ENStringResource.Exp_InvalidArray = 'Invalid array';
	        _ENStringResource.AtIndexOn = '" at index on ';
	        _ENStringResource.FullStop = '.';
	        _ENStringResource.SingleQuoteAt = '" at ';
	
	        return _ENStringResource;
	    })();
	    spread._ENStringResource = _ENStringResource;
	
	    spread.SR = _ENStringResource;
	
	    /* jshint ignore:end */
	})();

/***/ }
/******/ ])
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBmZjFlZjc5ZWZhNzY4NzZkZDFhYiIsIndlYnBhY2s6Ly8vLi9hcHAvc2NyaXB0cy9ncmlkL2dyaWQuanMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NjcmlwdHMvZ3JpZC9ldmVudC5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvc2NyaXB0cy9ncmlkL2RvbVV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NjcmlwdHMvZ3JpZC9nY1V0aWxzLmpzIiwid2VicGFjazovLy8uL2FwcC9zY3JpcHRzL2dyaWQvVG91Y2guanMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NjcmlwdHMvZ3JpZC9lZGl0aW5nSGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvc2NyaXB0cy9ncmlkL2xheW91dEVuZ2luZXMvZ3JpZExheW91dEVuZ2luZS5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvc2NyaXB0cy9ncmlkL2NhbGMvY2FsYy5lbnRyeS5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvc2NyaXB0cy9ncmlkL2RvVC5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvc2NyaXB0cy9ncmlkL2NhbGMvY29tbW9uLmpzIiwid2VicGFjazovLy8uL2FwcC9zY3JpcHRzL2dyaWQvY2FsYy9jYWxjQ29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvc2NyaXB0cy9ncmlkL2NhbGMvcGFyc2VyLmpzIiwid2VicGFjazovLy8uL2FwcC9zY3JpcHRzL2dyaWQvY2FsYy9leHByZXNzaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvc2NyaXB0cy9ncmlkL2NhbGMvZXZhbHVhdG9yLmpzIiwid2VicGFjazovLy8uL2FwcC9zY3JpcHRzL2dyaWQvY2FsYy9jYWxjSGVscGVyLmpzIiwid2VicGFjazovLy8uL2FwcC9zY3JpcHRzL2dyaWQvY2FsYy9jYWxjTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvc2NyaXB0cy9ncmlkL2NhbGMvY2FsY01vZGVscy5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvc2NyaXB0cy9ncmlkL2NhbGMvY2FsY1NvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvc2NyaXB0cy9ncmlkL2NhbGMvY2FsY0NvbGxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NjcmlwdHMvZ3JpZC9jYWxjL2NhbGNGdW5jdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NjcmlwdHMvZ3JpZC9jYWxjL3N0cmluZ1Jlc291cmNlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdDOzs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLGFBQWE7QUFDNUIsZ0JBQWUsMkJBQTJCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQW9CO0FBQ3BCLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBaUQsWUFBWTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtTUFBa00sR0FBRyxvQkFBb0I7QUFDek47O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNEQUFxRCxZQUFZO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsWUFBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFnRDtBQUNoRDtBQUNBO0FBQ0EsMEJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3Qiw4REFBNkQsMENBQTBDO0FBQ3ZHO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUI7QUFDdkI7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7O0FBRVg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBeUQsU0FBUztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQW9ELFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBb0QsU0FBUztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQTZELFlBQVk7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF1RCxZQUFZO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsK0NBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCLFdBQVc7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBOztBQUVBLFVBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFlBQVk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBd0QsWUFBWTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXVELFlBQVk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBLFVBQVM7QUFDVDtBQUNBLGlEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsOENBQTZDLG1FQUFtRTtBQUNoSCxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUFzRCxnQ0FBZ0M7QUFDdEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FB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QUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7Ozs7QUM5MUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7Ozs7O0FDNU5EO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQix5Q0FBd0MsS0FBSyxXQUFXLFVBQVU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QjtBQUN2QjtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCLHlDQUF3QyxLQUFLLFdBQVcsVUFBVTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxnQkFBZ0I7QUFDbkQ7QUFDQSx3Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMEM7QUFDMUMsa0JBQWlCO0FBQ2pCLHNDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1FQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLGlEQUFnRDtBQUNoRCxtREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwREFBeUQsZ0NBQWdDO0FBQ3pGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBFQUF5RTtBQUN6RSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOzs7Ozs7O0FDbGJMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUIsY0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxZQUFZO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdEQUErQztBQUMvQztBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxnQkFBZ0I7QUFDbkQ7QUFDQSxjQUFhO0FBQ2IseUNBQXdDLGlCQUFpQixTQUFTLEdBQUcsZ0RBQWdEO0FBQ3JILGNBQWE7QUFDYjtBQUNBO0FBQ0EsaURBQWdELFNBQVM7QUFDekQ7QUFDQSxpREFBZ0QsOENBQThDLFVBQVUsR0FBRyx1REFBdUQ7QUFDbEs7QUFDQTtBQUNBLGNBQWE7QUFDYiw4Q0FBNkMsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxZQUFZO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2R0FBNEc7QUFDNUcsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQThELFlBQVk7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsdUNBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsRUFBQzs7Ozs7OztBQ3YyQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQiw0Q0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQWtELFNBQVM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE0RCxhQUFhLFNBQVMsYUFBYSxjQUFjO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE0RCxhQUFhLFNBQVMsYUFBYSxjQUFjO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakIsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLG9CQUFvQjtBQUMzRCxrQkFBaUI7QUFDakI7QUFDQTtBQUNBLDRDQUEyQywyQkFBMkI7QUFDdEUsc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxtRkFBa0YsdUJBQXVCO0FBQ3pHLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0EsdUVBQXNFLGlCQUFpQixHQUFHO0FBQzFGLDhEQUE2RCxxQkFBcUIsV0FBVyxJQUFJLFVBQVUsR0FBRyxzQkFBc0IsK0JBQStCLFNBQVMsSUFBSSxRQUFRLElBQUk7QUFDNUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF3RCxZQUFZO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBbUQsaUNBQWlDLHFCQUFxQix1QkFBdUI7QUFDaEk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMERBQXlELHVCQUF1Qix5QkFBeUIsa0JBQWtCLGdCQUFnQjtBQUMzSSxvREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSwyREFBMEQsU0FBUztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckIscUVBQW9FLFNBQVM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLHNGQUFxRixXQUFXO0FBQ2hHO0FBQ0E7QUFDQSx3R0FBdUc7QUFDdkcsa0NBQWlDLDRDQUE0QyxpQkFBaUIsdUJBQXVCLFlBQVksR0FBRyx3QkFBd0IsV0FBVyxLQUFLLFVBQVU7O0FBRXRMLGNBQWE7QUFDYixrSEFBaUgsNkJBQTZCO0FBQzlJOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLGdCQUFnQiwwQkFBMEI7QUFDdkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0RBQThELFVBQVU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCOztBQUV6QjtBQUNBLDBDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUM7QUFDakMsOEJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QixzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQSxxQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QixzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWlFLFlBQVk7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFvRCxRQUFRO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUEsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9MQUFtTCxpQkFBaUIsZ0JBQWdCO0FBQ3BOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkRBQTBELFNBQVM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBOEUsbUJBQW1CO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFIQUFvSDtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsU0FBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMEQsU0FBUztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQW9ELFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQWtHLHdCQUF3QixzQkFBc0Isb0JBQW9CLGtCQUFrQjtBQUN0TDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQWtFLFVBQVU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlEQUF3RCxhQUFhLFNBQVMsYUFBYSxjQUFjO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUErRCxxQkFBcUI7QUFDcEY7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUEsd0NBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQSxvREFBbUQsVUFBVTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQixrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsbURBQWtELGlCQUFpQjtBQUNuRTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZEQUE0RCxlQUFlO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkRBQTRELFlBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7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O0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFL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QjtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBLGtCQUFpQiw0QkFBNEI7QUFDN0M7QUFDQSx3RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQiw0QkFBNEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsWUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsT0FBTztBQUM5Qix3QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsNkJBQTZCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLE9BQU87QUFDOUIsd0JBQXVCLDZCQUE2QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixPQUFPO0FBQzlCLHdCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsT0FBTztBQUM5Qix3QkFBdUIsT0FBTztBQUM5Qix3QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsT0FBTztBQUM5QjtBQUNB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QSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFrQyxxREFBcUQ7QUFDdkYsY0FBYTtBQUNiLG1DQUFrQyxXQUFXO0FBQzdDLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSxFQUFDOzs7Ozs7O0FDNUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWE7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QTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQW9ELFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNB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QUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakIsMERBQXlELFNBQVM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0EsaUNBQWdDO0FBQ2hDLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF3RCxTQUFTO0FBQ2pFO0FBQ0EseUVBQXdFO0FBQ3hFLHlFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBLGlDQUFnQztBQUNoQyxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLHVEQUFzRCxTQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7Ozs7O0FDajRCRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7Ozs7QUNORDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQSxFQUFDLEkiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlZpZXdzXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkdjU3ByZWFkXCJdID0gcm9vdFtcIkdjU3ByZWFkXCJdIHx8IHt9LCByb290W1wiR2NTcHJlYWRcIl1bXCJWaWV3c1wiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIFxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvblxuICoqLyIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIGZmMWVmNzllZmE3Njg3NmRkMWFiXG4gKiovIiwiKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50JykuRXZlbnQ7XG4gICAgdmFyIEdyaWRMYXlvdXRFbmdpbmUgPSByZXF1aXJlKCcuL2xheW91dEVuZ2luZXMvZ3JpZExheW91dEVuZ2luZScpO1xuICAgIC8vdmFyIGNvbGxlY3Rpb25zID0gcmVxdWlyZSgnLi9jb2xsZWN0aW9uVmlldycpO1xuICAgIHZhciBkb21VdGlsID0gcmVxdWlyZSgnLi9kb21VdGlsJyk7XG4gICAgdmFyIGdjVXRpbHMgPSByZXF1aXJlKCcuL2djVXRpbHMnKTtcbiAgICB2YXIgVG91Y2hXcmFwcGVyID0gcmVxdWlyZSgnLi9Ub3VjaCcpO1xuICAgIHZhciBlZGl0aW5nSGFuZGxlciA9IHJlcXVpcmUoJy4vZWRpdGluZ0hhbmRsZXInKTtcbiAgICB2YXIgTUFYU0NST0xMQUJMRVZFUlRJQ0FMT0ZGU0VUID0gMTAwO1xuICAgIHZhciBNQVhGRUVEQkFDS09GRlNFVCA9IDQwO1xuICAgIHZhciB0b3VjaFN0YXR1cztcbiAgICB2YXIgaW5lcnRpYWxNb3ZlU3RhdHVzO1xuICAgIHZhciBpbmVydGlhbE1vdmV0aW1lU3BhbiA9IDE2O1xuICAgIHZhciBpbnN0YW5jZXNCeVJlYWN0Um9vdElEID0ge307XG4gICAgdmFyIHNjcm9sbFBhbmVsWkluZGV4Y2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgdmFyIFZJRVdQT1JUID0gJ3ZpZXdwb3J0JztcbiAgICB2YXIgUElOTkVEX1ZJRVdQT1JUID0gJ3Bpbm5lZExlZnRWaWV3cG9ydCc7XG4gICAgdmFyIFBJTk5FRF9SSUdIVF9WSUVXUE9SVCA9ICdwaW5uZWRSaWdodFZpZXdwb3J0JztcbiAgICB2YXIgR1JPVVBfSEVBREVSID0gJ2dyb3VwSGVhZGVyJztcbiAgICB2YXIgR1JPVVBfRk9PVEVSID0gJ2dyb3VwRm9vdGVyJztcbiAgICB2YXIgR1JPVVBfQ09OVEVOVCA9ICdncm91cENvbnRlbnQnO1xuXG4gICAgdmFyIENhbGMgPSByZXF1aXJlKCcuL2NhbGMvY2FsYy5lbnRyeScpO1xuICAgIHZhciBjb2xsZWN0aW9ucyA9IENhbGMuQ29sbGVjdGlvbnM7XG4gICAgLy9mb3IgSUU5XG4gICAgaWYgKHdpbmRvdyAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICB2YXIgbGFzdFRpbWVfID0gMDtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgY3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHZhciB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZV8pKTtcbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGltZVRvQ2FsbCk7XG4gICAgICAgICAgICBsYXN0VGltZV8gPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdyAmJiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2luZG93LkN1c3RvbUV2ZW50ID0gZnVuY3Rpb24oZXZlbnQsIHBhcmFtcykge1xuICAgICAgICAgICAgdmFyIGV2dDtcbiAgICAgICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7XG4gICAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICAgICAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuICAgICAgICAgICAgcmV0dXJuIGV2dDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgZ3JpZCBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lciBDb250YWluZXIgbm9kZSB0aGUgZ3JpZCB3aWxsIGF0dGFjaGVkXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0YSBBbiBhcnJheSBvZiBvYmplY3RzIGZvciBncmlkIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb25maWcgQW4gYXJyYXkgb2YgY29sdW1uIGRlZmluaXRpb25zIG9yIGEgSlNPTiBvYmplY3QgdXNlZCB0byBkZXNlcmlsemUgdGhlIGdyaWRcbiAgICAgKiBAcGFyYW0geyhHcmlkLkxheW91dEVuZ2luZXxPYmplY3QpfSBvcHRpb25zIEFuIGxheW91dEVuZ2luZSBpbnN0YW5jZSBvciBvcHRpb25zIG9iamVjdCB3aGljaCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGlzZSBhIEdyaWQuR3JpZExheW91dEVuZ2luZSBpbnN0YW5jZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBHY0dyaWQgPSBmdW5jdGlvbihjb250YWluZXIsIGRhdGEsIGNvbmZpZywgb3B0aW9ucykge1xuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHY0dyaWQgbmVlZCBhIHZhbGlkIGNvbnRhaW5lciB0byBob3N0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciB1aWQgPSBNYXRoLnJvdW5kKDEwMDAwMDAgKiBNYXRoLnJhbmRvbSgpKTtcbiAgICAgICAgc2VsZi51aWQgPSAnZ2MtJyArIHVpZDtcbiAgICAgICAgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFt1aWRdID0gdGhpcztcblxuICAgICAgICBzZWxmLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcblxuICAgICAgICB2YXIganNvbk9iamVjdDtcbiAgICAgICAgaWYgKGNvbmZpZyAmJiAhZ2NVdGlscy5pc1VuZGVmaW5lZChjb25maWcudmVyc2lvbikpIHtcbiAgICAgICAgICAgIGpzb25PYmplY3QgPSBnY1V0aWxzLmRlc2VyaWFsaXplT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgICAgICBzZWxmLmNvbHVtbnNDb25maWdfID0ganNvbk9iamVjdC5jb2x1bW5zO1xuICAgICAgICAgICAgc2VsZi5jb2x1bW5zID0gc2VsZi5mbGF0dGVybkNvbHVtbnNfKHNlbGYuY29sdW1uc0NvbmZpZ18pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5jb2x1bW5zQ29uZmlnXyA9IGNvbmZpZztcbiAgICAgICAgICAgIC8vd2lsbCBiZSBpbml0aWFsaXplZCBkdXJpbmcgbGF5b3V0IGVuZ2luZSBpbml0aWFsaXphdGlvblxuICAgICAgICAgICAgc2VsZi5jb2x1bW5zID0gY29uZmlnID8gc2VsZi5mbGF0dGVybkNvbHVtbnNfKGNvbmZpZykgOiBfLm1hcChfLmtleXMoKGRhdGEgJiYgZGF0YVswXSkgfHwgW10pLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpZDoga2V5LFxuICAgICAgICAgICAgICAgICAgICBjYXB0aW9uOiBrZXksXG4gICAgICAgICAgICAgICAgICAgIGRhdGFGaWVsZDoga2V5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvL2FkZCByZW1haW5pbmcgZGF0YSBwcm9wZXJ0aWVzIGFzIGhpZGRlbiBjb2x1bW5cbiAgICAgICAgICAgIHZhciB0ZW1wQ29sO1xuICAgICAgICAgICAgXy5lYWNoKF8ua2V5cygoZGF0YSAmJiBkYXRhWzBdKSB8fCBbXSksIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIGlmICghZ2V0Q29sQnlEYXRhRmllbGRfLmNhbGwoc2VsZiwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wQ29sID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcHRpb246IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFGaWVsZDoga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogODBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb2x1bW5zLnB1c2godGVtcENvbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbHVtbnNDb25maWdfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbHVtbnNDb25maWdfLnB1c2godGVtcENvbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgICAgIHNlbGYuY29sVHJlZV8gPSB7fTtcbiAgICAgICAgICAgICAgICBidWlsZENvbHVtbkRlZlRyZWVfKGNvbmZpZywgbnVsbCwgc2VsZi5jb2xUcmVlXyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuY29sdW1uc0NvbmZpZ18gPSBzZWxmLmNvbHVtbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmRhdGEgPSBuZXcgY29sbGVjdGlvbnMuQ2FsY0NvbGxlY3Rpb24oZGF0YSwgXy5tYXAoc2VsZi5jb2x1bW5zLCBmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiB7bmFtZTogY29sdW1uLmlkLCBmaWVsZDogY29sdW1uLmRhdGFGaWVsZH07XG4gICAgICAgIH0pKTtcblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGxlbmd0aDtcbiAgICAgICAgaWYgKHNlbGYuZGF0YS5pdGVtQ291bnQpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gc2VsZi5kYXRhLnNvdXJjZUNvbGxlY3Rpb25bMF07XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBjb2xzID0gc2VsZi5jb2x1bW5zO1xuICAgICAgICAgICAgICAgIHZhciBjb2w7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gY29scy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb2wgPSBjb2xzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbC5kYXRhVHlwZSAmJiBjb2wuZGF0YUZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2wuZGF0YVR5cGUgPSBnY1V0aWxzLmdldFR5cGUoaXRlbVtjb2wuZGF0YUZpZWxkXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLm9uTW91c2VDbGljayA9IG5ldyBFdmVudCgpO1xuICAgICAgICBzZWxmLm9uTW91c2VEYkNsaWNrID0gbmV3IEV2ZW50KCk7XG4gICAgICAgIHNlbGYub25Nb3VzZURvd24gPSBuZXcgRXZlbnQoKTtcbiAgICAgICAgc2VsZi5vbk1vdXNlVXAgPSBuZXcgRXZlbnQoKTtcbiAgICAgICAgc2VsZi5vbk1vdXNlTW92ZSA9IG5ldyBFdmVudCgpO1xuICAgICAgICBzZWxmLm9uTW91c2VXaGVlbCA9IG5ldyBFdmVudCgpO1xuICAgICAgICBzZWxmLm9uS2V5RG93biA9IG5ldyBFdmVudCgpO1xuICAgICAgICBzZWxmLmVkaXRpbmcgPSBuZXcgRXZlbnQoKTtcbiAgICAgICAgc2VsZi5vblRvdWNoU3RhcnRfID0gbmV3IEV2ZW50KCk7XG4gICAgICAgIHNlbGYub25Ub3VjaE1vdmVfID0gbmV3IEV2ZW50KCk7XG4gICAgICAgIHNlbGYub25Ub3VjaEVuZF8gPSBuZXcgRXZlbnQoKTtcbiAgICAgICAgLy9XaGVuIEkgcHJldmVudCBtb3VzZSBldmVudCB3aGlsZSBwcm9jZXNzIHRvdWNoIGV2ZW50Lml0IHdvcmtzIHdlbGwgb24gY2hyb21lIGJ1dCBhbHNvIGZpcmUgbmF0aXZlIGNsaWNrIGV2ZW50IG9uIElFLlxuICAgICAgICAvL3NvIEkgb25seSBmaXJlIHRhcCBldmVudCBvbiBjaHJvbWUuIC1UaW1cbiAgICAgICAgc2VsZi5vblRhcF8gPSBuZXcgRXZlbnQoKTtcbiAgICAgICAgc2VsZi5vblN3aXBlXyA9IG5ldyBFdmVudCgpO1xuICAgICAgICAvL2luIGZhY3QsdG91Y2ggc2Nyb2xsIGlzIGhhbmRsZWQgYnkgZ3JpZC5CdXQgaW4gc29tZSBjYXNlLCBpdCBuZWVkcyBjaGFuY2UgdG8gY2xlYXIgY2FjaGUgZGF0YS5cbiAgICAgICAgc2VsZi5vblRvdWNoU2Nyb2xsXyA9IG5ldyBFdmVudCgpO1xuXG4gICAgICAgIHNlbGYub25TY3JvbGxPdmVyXyA9IG5ldyBFdmVudCgpO1xuXG4gICAgICAgIGlmIChqc29uT2JqZWN0KSB7XG4gICAgICAgICAgICBzZWxmLmxheW91dEVuZ2luZSA9IGdldExheW91dEVuZ2luZV8oanNvbk9iamVjdC5sYXlvdXRFbmdpbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBvcHRpb25zICYmIG9wdGlvbnMubmFtZTtcbiAgICAgICAgICAgIHNlbGYubGF5b3V0RW5naW5lID0gKG5hbWUgJiYgZ2NVdGlscy5pc1N0cmluZyhuYW1lKSAmJiBuYW1lLmxlbmd0aCA+IDEyICYmIG5hbWUuc2xpY2UoLTEyKS50b0xvd2VyQ2FzZSgpID09PSAnbGF5b3V0ZW5naW5lJykgPyBvcHRpb25zIDogbmV3IEdyaWRMYXlvdXRFbmdpbmUoXy5kZWZhdWx0cyhvcHRpb25zIHx8IHt9LCB7YWxsb3dFZGl0aW5nOiBmYWxzZX0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYub3B0aW9ucyA9IHNlbGYubGF5b3V0RW5naW5lLm9wdGlvbnM7XG4gICAgICAgIHZhciBkZWZhdWx0VGVtcGxhdGUgPSBzZWxmLm9wdGlvbnMucm93VGVtcGxhdGU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLm9wdGlvbnMsICdyb3dUZW1wbGF0ZScsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRUZW1wbGF0ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRUZW1wbGF0ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9pdCdzIHVzdWFsbHkgY2hhbmdlIHRoZSB0ZW1wbGF0ZSBkdXJpbmcgbGF5b3V0L2dyb3VwIHN0cmF0ZWd5IGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgLy9hcyB0aGUgcmVzdWx0LCB0aGUgc2l6ZSBvZiB0aGUgdGVtcGxhdGUgbWF5YmUgZGlmZmVyZW50IGFuZCBjb2x1bW4gc2l6ZSBtYXkgY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VGVtcGxhdGUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sYXlvdXRFbmdpbmUuaGFuZGxlVGVtcGxhdGVDaGFuZ2VfKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2VsZi5pbml0KCk7XG5cbiAgICAgICAgc2VsZi5zY3JvbGxPZmZzZXQgPSBzZWxmLmdldEluaXRpYWxTY3JvbGxPZmZzZXQoKTtcblxuICAgICAgICAvL2NyZWF0ZSByZW5kZXIgY29tcG9uZW50c1xuICAgICAgICAvL3JlbmRlciBlYWNoIGNvbXBvbmVudHNcbiAgICAgICAgc2VsZi5zY3JvbGxhYmxlRWxlbWVudHNfID0gW107XG4gICAgICAgIHNlbGYubGFzdFJlbmRlcmVkUm93c18gPSB7fTtcblxuICAgICAgICBidWlsZERvbVRyZWVfLmNhbGwoc2VsZik7XG4gICAgICAgIC8vY2FjaGUgdGhlIGV2ZW50IGhhbmRsZXJzIHNpbmNlIC5iaW5kIHdpbGwgY3JlYXRlIGEgbmV3IGZ1bmN0aW9uLlxuICAgICAgICBzZWxmLmhhbmRsZUNsaWNrRm5fID0gaGFuZGxlQ2xpY2suYmluZChzZWxmKTtcbiAgICAgICAgc2VsZi5oYW5kbGVEYkNsaWNrRm5fID0gaGFuZGxlRG91YmxlQ2xpY2suYmluZChzZWxmKTtcbiAgICAgICAgc2VsZi5oYW5kbGVNb3VzZURvd25Gbl8gPSBoYW5kbGVNb3VzZURvd24uYmluZChzZWxmKTtcbiAgICAgICAgc2VsZi5oYW5kbGVNb3VzZU1vdmVGbl8gPSBoYW5kbGVNb3VzZU1vdmUuYmluZChzZWxmKTtcbiAgICAgICAgc2VsZi5oYW5kbGVNb3VzZVVwRm5fID0gaGFuZGxlTW91c2VVcC5iaW5kKHNlbGYpO1xuICAgICAgICBzZWxmLmhhbmRsZUtleURvd25Gbl8gPSBoYW5kbGVLZXlEb3duLmJpbmQoc2VsZik7XG4gICAgICAgIHNlbGYuaGFuZGxlV2hlZWxGbl8gPSBoYW5kbGVNb3VzZVdoZWVsLmJpbmQoc2VsZik7XG4gICAgICAgIHNlbGYuaGFuZGxlU2Nyb2xsRm5fID0gaGFuZGxlU2Nyb2xsXy5iaW5kKHNlbGYpO1xuICAgICAgICBzZWxmLmhhbmRsZVdpbmRvd1Jlc2l6ZUZuXyA9IGhhbmRsZVdpbmRvd1Jlc2l6ZV8uYmluZChzZWxmKTtcbiAgICAgICAgc2VsZi5oYW5kbGVUb3VjaFN0YXJ0Rm5fID0gaGFuZGxlVG91Y2hTdGFydF8uYmluZChzZWxmKTtcbiAgICAgICAgc2VsZi5oYW5kbGVUb3VjaE1vdmVGbl8gPSBoYW5kbGVUb3VjaE1vdmVfLmJpbmQoc2VsZik7XG4gICAgICAgIHNlbGYuaGFuZGxlVG91Y2hFbmRGbl8gPSBoYW5kbGVUb3VjaEVuZF8uYmluZChzZWxmKTtcbiAgICAgICAgc2VsZi5oYW5kbGVJbmVydGlhTW92ZUZuXyA9IGhhbmRsZUluZXJ0aWFNb3ZlXy5iaW5kKHNlbGYpO1xuICAgICAgICBzZWxmLmNoYW5nZVNjcm9sbFBhbmVsWkluZGV4Rm5fID0gY2hhbmdlQmFja1Njcm9sbFBhbmVsWkluZGV4LmJpbmQoc2VsZik7XG4gICAgICAgIHNlbGYuaGFuZGxlRGVib3VuY2VNb3VzZVdoZWVsRm5fID0gXy5kZWJvdW5jZShzZWxmLmNoYW5nZVNjcm9sbFBhbmVsWkluZGV4Rm5fLCA1MDApO1xuICAgICAgICBzZWxmLmhhbmRsZVNjcm9sbE92ZXJGbl8gPSBoYW5kbGVTY29sbE92ZXJfLmJpbmQoc2VsZik7XG4gICAgICAgIHNlbGYuaGFuZGxlRGVib3VuY2VTY3JvbGxPdmVyRm5fID0gXy5kZWJvdW5jZShzZWxmLmhhbmRsZVNjcm9sbE92ZXJGbl8sIDIwMCk7XG4gICAgICAgIHNlbGYuaXNUb3VjaE1vZGUgPSB3aW5kb3cuUG9pbnRlckV2ZW50IHx8IHdpbmRvdy5NU1BvaW50ZXJFdmVudCB8fCAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgICAgICAgcmVnaXN0ZXJFdmVudHNfLmNhbGwodGhpcyk7XG4gICAgfTtcblxuICAgIEdjR3JpZC5wcm90b3R5cGUgPSB7XG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgLy9hZGp1c3Qgc2VsZi5jb250YWluZXJcbiAgICAgICAgICAgIC8vcGFyc2UgY29sdW1uIGV4cHJlc2lvbiwgZm9ybWF0dGVycyBoZXJlXG5cbiAgICAgICAgICAgIHNlbGYuY29sRm9ybWF0dGVyc18gPSB7fTtcbiAgICAgICAgICAgIGlmICghZ2NVdGlscy5pc1VuZGVmaW5lZE9yTnVsbChHY0dyaWQpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5FeGNlbEZvcm1hdHRlcl8gPSBHY0dyaWQuUGx1Z2lucyAmJiBHY0dyaWQuUGx1Z2lucy5Gb3JtYXR0ZXIgJiYgR2NHcmlkLlBsdWdpbnMuRm9ybWF0dGVyLkV4Y2VsRm9ybWF0dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXy5lYWNoKHNlbGYuY29sdW1ucywgZnVuY3Rpb24oY29sKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbCAmJiBjb2wuZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3JtYXR0ZXIgPSBjb2wuZm9ybWF0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sSWQgPSBjb2wuaWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnY1V0aWxzLmlzU3RyaW5nKGZvcm1hdHRlcikgJiYgc2VsZi5FeGNlbEZvcm1hdHRlcl8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29sRm9ybWF0dGVyc19bY29sSWRdID0gbmV3IHNlbGYuRXhjZWxGb3JtYXR0ZXJfKGZvcm1hdHRlcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2NVdGlscy5pc0Z1bmN0aW9uKGZvcm1hdHRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29sRm9ybWF0dGVyc19bY29sSWRdID0gZm9ybWF0dGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNlbGYuZGF0YS5nZXREZWZhdWx0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwOiBzZWxmLmxheW91dEVuZ2luZS5nZXRHcm91cEluZm9EZWZhdWx0c18oKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmZpbHRlckV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBzZWxmLmRhdGEuZmlsdGVyRXhwcmVzc2lvbiA9IHNlbGYub3B0aW9ucy5maWx0ZXJFeHByZXNzaW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLnNvcnRpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgc29ydERlc2NyaXB0b3JzID0gXy5jbG9uZShzZWxmLm9wdGlvbnMuc29ydGluZywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgXy5yZW1vdmUoc29ydERlc2NyaXB0b3JzLCBmdW5jdGlvbihzb3J0SW5mbykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2NVdGlscy5pc1VuZGVmaW5lZE9yTnVsbChzb3J0SW5mby5hc2NlbmRpbmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlbGYuZGF0YS5zb3J0RGVzY3JpcHRvcnMgPSBzb3J0RGVzY3JpcHRvcnM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMuZ3JvdXBpbmcpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmRhdGEuZ3JvdXBEZXNjcmlwdG9ycyA9IHNlbGYub3B0aW9ucy5ncm91cGluZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5oaWVyYXJjaHlEZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kYXRhLmhpZXJhcmNoeURlc2NyaXB0b3IgPSBzZWxmLm9wdGlvbnMuaGllcmFyY2h5RGVzY3JpcHRvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWRpdGluZ0hhbmRsZXIuaW5pdChzZWxmKTtcbiAgICAgICAgICAgIHNlbGYuZWRpdGluZ0hhbmRsZXIgPSBlZGl0aW5nSGFuZGxlcjtcbiAgICAgICAgICAgIHNlbGYubGF5b3V0RW5naW5lLmluaXQoc2VsZik7XG5cbiAgICAgICAgICAgIHVwZGF0ZUdyb3VwU3RyYXRlZ3lfLmNhbGwoc2VsZik7XG5cbiAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMuZ3JvdXBhYmxlIHx8IHNlbGYuZGF0YS5ncm91cHMpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmdyb3VwSW5mb3NfID0gW107XG4gICAgICAgICAgICAgICAgc2VsZi51cGRhdGVHcm91cEluZm9zXygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIHZhciBsZW5ndGg7XG4gICAgICAgICAgICB2YXIgY29sO1xuXG4gICAgICAgICAgICBpbml0QnVpbGRJbkFjdGlvbnNfLmNhbGwoc2VsZik7XG4gICAgICAgICAgICBzZWxmLmNvbHVtbkFjdGlvbnNfID0ge307XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmNvbHVtbnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb2wgPSBzZWxmLmNvbHVtbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNvbC5hY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb2x1bW5BY3Rpb25zX1tjb2wuaWRdID0gXy5tYXAoZ2NVdGlscy5pc0FycmF5KGNvbC5hY3Rpb24pID8gY29sLmFjdGlvbiA6IFtjb2wuYWN0aW9uXSwgY3JlYXRlQ29sdW1uQWN0aW9uXy5iaW5kKHNlbGYpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGluaXRDRV8uY2FsbChzZWxmKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy9UT0RPOiByZW1vdmUgZ2V0RGF0YUl0ZW0gbGF0ZXJcbiAgICAgICAgLy9nZXREYXRhSXRlbTJfOiBmdW5jdGlvbihncm91cCwgcm93KSB7XG4gICAgICAgIC8vICAgIHJldHVybiB0aGlzLmdldERhdGFJdGVtKGdyb3VwID8gZ3JvdXAuaXRlbU1hcHBpbmdzW3Jvd10gOiByb3cpO1xuICAgICAgICAvL30sXG5cbiAgICAgICAgZ2V0RGF0YUl0ZW06IGZ1bmN0aW9uKHJvdykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZWxmLmRhdGE7XG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5nZXRJdGVtKHJvdyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Rm9ybWF0dGVkRGF0YUl0ZW06IGZ1bmN0aW9uKHJvdykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGRhdGFJdGVtID0gc2VsZi5nZXREYXRhSXRlbShyb3cpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuZm9ybWF0RGF0YUl0ZW0oZGF0YUl0ZW0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZvcm1hdERhdGFJdGVtOiBmdW5jdGlvbihkYXRhSXRlbSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgbGVuO1xuICAgICAgICAgICAgdmFyIGNvbDtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHNlbGYuY29sdW1ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbCA9IHNlbGYuY29sdW1uc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoY29sKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IGNvbC5kYXRhRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnY1V0aWxzLmlzU3RyaW5nKGZpZWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbC5pc0NhbGNDb2x1bW5fKSB7ICAvLyBjYWxjdWxhdGVkIGNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3AgPSBjb2wuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBkYXRhSXRlbVtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIGJvdW5kIGNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5zcGxpdCgnLCcpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wID0gY29sLmRhdGFGaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBkYXRhSXRlbVtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xGb3JtYXR0ZXIgPSBzZWxmLmNvbEZvcm1hdHRlcnNfW2NvbC5pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sRm9ybWF0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuRXhjZWxGb3JtYXR0ZXJfICYmIChjb2xGb3JtYXR0ZXIgaW5zdGFuY2VvZiBzZWxmLkV4Y2VsRm9ybWF0dGVyXykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gY29sRm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChnY1V0aWxzLmlzRnVuY3Rpb24oY29sRm9ybWF0dGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbcHJvcF0gPSBjb2xGb3JtYXR0ZXIoe3ZhbHVlOiB2YWx1ZSwgaXRlbTogZGF0YUl0ZW0sIGNvbERlZjogY29sfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhSXRlbS5ub2RlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm5vZGUgPSBkYXRhSXRlbS5ub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IHRoZSBsYXlvdXQgaW5mb1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGF5b3V0SW5mbzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXRFbmdpbmUuZ2V0TGF5b3V0SW5mbygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFJlbmRlckluZm86IGZ1bmN0aW9uKG9wdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0RW5naW5lLmdldFJlbmRlckluZm8ob3B0aW9uKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaG93U2Nyb2xsUGFuZWw6IGZ1bmN0aW9uKGFyZWEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheW91dEVuZ2luZS5zaG93U2Nyb2xsUGFuZWwoYXJlYSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNTY3JvbGxhYmxlQXJlYV86IGZ1bmN0aW9uKGFyZWEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheW91dEVuZ2luZS5pc1Njcm9sbGFibGVBcmVhXyhhcmVhKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRTY3JvbGxQYW5lbFJlbmRlckluZm86IGZ1bmN0aW9uKGFyZWEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheW91dEVuZ2luZS5nZXRTY3JvbGxQYW5lbFJlbmRlckluZm8oYXJlYSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0SW5pdGlhbFNjcm9sbE9mZnNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXlvdXRFbmdpbmUuZ2V0SW5pdGlhbFNjcm9sbE9mZnNldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxheW91dEVuZ2luZS5nZXRJbml0aWFsU2Nyb2xsT2Zmc2V0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogMFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy9cbiAgICAgICAgLy9oYW5kbGVFZGl0aW5nS2V5RG93bjogZnVuY3Rpb24oZSkge1xuICAgICAgICAvLyAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIC8vICAgIHZhciBLZXkgPSBnY1V0aWxzLktleTtcbiAgICAgICAgLy8gICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgICAgLy8gICAgICAgIGNhc2UgS2V5LlVwOlxuICAgICAgICAvLyAgICAgICAgY2FzZSBLZXkuRG93bjpcbiAgICAgICAgLy8gICAgICAgIGNhc2UgS2V5LkxlZnQ6XG4gICAgICAgIC8vICAgICAgICBjYXNlIEtleS5SaWdodDpcbiAgICAgICAgLy8gICAgICAgIGNhc2UgS2V5LlBhZ2VVcDpcbiAgICAgICAgLy8gICAgICAgIGNhc2UgS2V5LlBhZ2VEb3duOlxuICAgICAgICAvLyAgICAgICAgY2FzZSBLZXkuSG9tZTpcbiAgICAgICAgLy8gICAgICAgIGNhc2UgS2V5LkVuZDpcbiAgICAgICAgLy8gICAgICAgICAgICBpZiAoIXNlbGYuaXNGdWxsRWRpdCkge1xuICAgICAgICAvLyAgICAgICAgICAgICAgICBzZWxmLnN0b3BDZWxsRWRpdGluZygpO1xuICAgICAgICAvLyAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vICAgICAgICAgICAgfVxuICAgICAgICAvLyAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gICAgICAgICAgICBzZWxmLnRyaWdnZXJfKHNlbGYuY2VsbEVkaXRpbmcsIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgcm93OiBzZWxmLmFjdGl2ZVJvdyxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgY29sOiBzZWxmLmFjdGl2ZUNvbHVtbixcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgZWRpdGluZ1RleHQ6IHNlbGYuY3VycmVudEVkaXRvci5nZXRWYWx1ZSgpXG4gICAgICAgIC8vICAgICAgICAgICAgfSk7XG4gICAgICAgIC8vICAgIH1cbiAgICAgICAgLy99LFxuICAgICAgICAvL1xuICAgICAgICAvL2hhbmRsZUFjdGl2ZUNlbGxQb3NpdGlvbkNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgLy8gICAgaWYgKCFzZWxmLmFjdGl2ZUNlbGxOb2RlKSB7XG4gICAgICAgIC8vICAgICAgICByZXR1cm47XG4gICAgICAgIC8vICAgIH1cbiAgICAgICAgLy8gICAgaWYgKHNlbGYuY3VycmVudEVkaXRvcikge1xuICAgICAgICAvLyAgICAgICAgaWYgKCFkb21VdGlsLmNvbnRhaW5zKHNlbGYuY29udGFpbmVyLCBzZWxmLmFjdGl2ZUNlbGxOb2RlKSkge1xuICAgICAgICAvLyAgICAgICAgICAgIHNlbGYuc3RvcENlbGxFZGl0aW5nKCk7XG4gICAgICAgIC8vICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyAgICAgICAgfVxuICAgICAgICAvLyAgICAgICAgaWYgKHNlbGYuY3VycmVudEVkaXRvci5hcmdzLnBvc2l0aW9uKSB7XG4gICAgICAgIC8vICAgICAgICAgICAgdmFyIGNlbGxOb2RlT2Zmc2V0ID0gZG9tVXRpbC5vZmZzZXQoc2VsZi5hY3RpdmVDZWxsTm9kZSk7XG4gICAgICAgIC8vICAgICAgICAgICAgdmFyIGdyaWRPZmZzZXQgPSBkb21VdGlsLm9mZnNldChzZWxmLmNvbnRhaW5lcik7XG4gICAgICAgIC8vICAgICAgICAgICAgc2VsZi5jdXJyZW50RWRpdG9yLmFyZ3MucG9zaXRpb24gPSB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgIHRvcDogY2VsbE5vZGVPZmZzZXQudG9wIC0gZ3JpZE9mZnNldC50b3AsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgIGxlZnQ6IGNlbGxOb2RlT2Zmc2V0LmxlZnQgLSBncmlkT2Zmc2V0LmxlZnRcbiAgICAgICAgLy8gICAgICAgICAgICB9O1xuICAgICAgICAvLyAgICAgICAgfVxuICAgICAgICAvLyAgICB9XG4gICAgICAgIC8vfSxcblxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgdW5SZWdpc3RlckV2ZW50c18uY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgLy9UT0RPOiBkZXN0cm95IHN0dWZmcyBpZiBuZWVkZWQuXG4gICAgICAgICAgICBlZGl0aW5nSGFuZGxlci5kZXN0cm95KHNlbGYpO1xuICAgICAgICAgICAgaWYgKHNlbGYubGF5b3V0RW5naW5lKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5sYXlvdXRFbmdpbmUuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHNlbGYubGF5b3V0RW5naW5lID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZi51aWQpKTtcbiAgICAgICAgICAgIGRlbGV0ZSBpbnN0YW5jZXNCeVJlYWN0Um9vdElEW3NlbGYudWlkLnNsaWNlKDMpXTtcbiAgICAgICAgICAgIHNlbGYuY29sdW1uQWN0aW9uc18gPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZUdyb3VwSW5mb3NfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VsZi5kYXRhO1xuICAgICAgICAgICAgaWYgKGRhdGEuZ3JvdXBzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5ncm91cEluZm9zXyA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgIHZhciBsZW47XG4gICAgICAgICAgICAgICAgc2VsZi5ncm91cEluZm9zXyA9IHNlbGYuZ3JvdXBJbmZvc18gfHwgW107XG4gICAgICAgICAgICAgICAgc2VsZi5ncm91cEluZm9zXy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmdyb3Vwcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBkYXRhLmdyb3Vwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5ncm91cEluZm9zXy5wdXNoKGNyZWF0ZUdyb3VwSW5mb18uY2FsbCh0aGlzLCBkYXRhLmdyb3Vwc1tpXSwgW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sYXlvdXRFbmdpbmUuaW5pdEdyb3VwSW5mb3NIZWlnaHRfKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZVRlbXBsYXRlXzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbGF5b3V0RW5naW5lID0gdGhpcy5sYXlvdXRFbmdpbmU7XG4gICAgICAgICAgICBsYXlvdXRFbmdpbmUuY2xlYXJSZW5kZXJDYWNoZV8oKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW52YWxpZGF0ZSBlbnRpcmUgY29udHJvbC5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSByZWJ1aWxkRE9NVHJlZSAgcmVidWlsZCBlbnRpcmUgRE9NIHRyZWUgb3Igbm90LiBJZiBpdCdzIHRydWUsXG4gICAgICAgICAqIGl0IHdpbGwgcmVtb3ZlIHRoZSBvbGQgRE9NIHRyZWUgYW5kIGluc2VydCBhIG5ldyBvbmUsIG90aGVyd2lzZSwgaXQgd2lsbCB1cGRhdGUgb2xkXG4gICAgICAgICAqIERPTSB0cmVlIGNvbnRhaW5lciBhbmQgcmVmcmVzaCBlYWNoIGxheW91dCBhcmVhLlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlLlxuICAgICAgICAgKi9cbiAgICAgICAgaW52YWxpZGF0ZTogZnVuY3Rpb24ocmVidWlsZERPTVRyZWUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBzY3JvbGxQYW5lbDtcbiAgICAgICAgICAgIHZhciBsYXlvdXRFbmdpbmUgPSBzZWxmLmxheW91dEVuZ2luZTtcbiAgICAgICAgICAgIHNlbGYuY29udGFpbmVySW5mb18gPSBudWxsO1xuICAgICAgICAgICAgbGF5b3V0RW5naW5lLmNsZWFyUmVuZGVyQ2FjaGVfKCk7XG4gICAgICAgICAgICB1cGRhdGVHcm91cFN0cmF0ZWd5Xy5jYWxsKHNlbGYpO1xuICAgICAgICAgICAgc2VsZi51cGRhdGVHcm91cEluZm9zXygpO1xuXG4gICAgICAgICAgICBpZiAoZ2NVdGlscy5pc1VuZGVmaW5lZE9yTnVsbChyZWJ1aWxkRE9NVHJlZSkpIHtcbiAgICAgICAgICAgICAgICByZWJ1aWxkRE9NVHJlZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWJ1aWxkRE9NVHJlZSA9ICEhcmVidWlsZERPTVRyZWU7XG5cbiAgICAgICAgICAgIGlmIChyZWJ1aWxkRE9NVHJlZSkge1xuICAgICAgICAgICAgICAgIC8vY2xlYXIgcmVuZGVyIGNhY2hlXG4gICAgICAgICAgICAgICAgc2VsZi5sYXN0UmVuZGVyZWRSb3dzXyA9IHt9O1xuICAgICAgICAgICAgICAgIHVuUmVnaXN0ZXJTY3JvbGxFdmVudF8uY2FsbChzZWxmKTtcbiAgICAgICAgICAgICAgICBidWlsZERvbVRyZWVfLmNhbGwoc2VsZik7XG4gICAgICAgICAgICAgICAgdmFyIGluaXRTY3JvbGxPZmZzZXQgPSBsYXlvdXRFbmdpbmUuZ2V0SW5pdGlhbFNjcm9sbE9mZnNldCgpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNjcm9sbE9mZnNldC50b3AgIT09IGluaXRTY3JvbGxPZmZzZXQudG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFBhbmVsID0gZG9tVXRpbC5nZXRFbGVtZW50KCcjJyArIHNlbGYudWlkICsgJyAuZ2MtZ3JpZC12aWV3cG9ydC1zY3JvbGwtcGFuZWwuc2Nyb2xsLXRvcCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsUGFuZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFBhbmVsLnNjcm9sbFRvcCA9IHNlbGYuc2Nyb2xsT2Zmc2V0LnRvcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zY3JvbGxPZmZzZXQubGVmdCAhPT0gaW5pdFNjcm9sbE9mZnNldC5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFBhbmVsID0gZG9tVXRpbC5nZXRFbGVtZW50KCcjJyArIHNlbGYudWlkICsgJyAuZ2MtZ3JpZC12aWV3cG9ydC1zY3JvbGwtcGFuZWwuc2Nyb2xsLWxlZnQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbFBhbmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxQYW5lbC5zY3JvbGxMZWZ0ID0gc2VsZi5zY3JvbGxPZmZzZXQubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWdpc3RlclNjcm9sbEV2ZW50Xy5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVsZW1lbnQ7XG4gICAgICAgICAgICB2YXIgcmVuZGVySW5mbztcbiAgICAgICAgICAgIHZhciBzZWxlY3RvcjtcbiAgICAgICAgICAgIHZhciBsYXlvdXRJbm8gPSBzZWxmLmdldExheW91dEluZm8oKTtcbiAgICAgICAgICAgIF8ua2V5cyhsYXlvdXRJbm8pLm1hcChmdW5jdGlvbihhcmVhKSB7XG4gICAgICAgICAgICAgICAgLy91cGRhdGUgc2Nyb2xsIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNob3dTY3JvbGxQYW5lbChhcmVhKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHNlbGYudWlkICsgJy0nICsgYXJlYSArICctc2Nyb2xsJztcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVySW5mbyA9IHNlbGYuZ2V0U2Nyb2xsUGFuZWxSZW5kZXJJbmZvKGFyZWEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVuZGVySW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBnY1V0aWxzLmNyZWF0ZU1hcmt1cEZvclN0eWxlcyhyZW5kZXJJbmZvLm91dGVyRGl2U3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNoaWxkTm9kZXNbMF0uc3R5bGUuY3NzVGV4dCA9IGdjVXRpbHMuY3JlYXRlTWFya3VwRm9yU3R5bGVzKHJlbmRlckluZm8uaW5uZXJEaXZTdHlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBzZWxmLnVpZCArICctJyArIGFyZWEgKyAnLXNjcm9sbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxhYmxlRWxlbWVudHNfLnB1c2goaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBodG1sID0gJzxkaXYgaWQ9XCInICsgaWQgKyAnXCIgY2xhc3M9XCInICsgcmVuZGVySW5mby5vdXRlckRpdkNzc0NsYXNzICsgJ1wiJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVuZGVySW5mby5vdXRlckRpdkNzc0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJyBzdHlsZT1cIicgKyBnY1V0aWxzLmNyZWF0ZU1hcmt1cEZvclN0eWxlcyhyZW5kZXJJbmZvLm91dGVyRGl2U3R5bGUpICsgJ1wiJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPjxkaXYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZW5kZXJJbmZvLmlubmVyRGl2U3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnIHN0eWxlPVwiJyArIGdjVXRpbHMuY3JlYXRlTWFya3VwRm9yU3R5bGVzKHJlbmRlckluZm8uaW5uZXJEaXZTdHlsZSkgKyAnXCInO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc+PC9kaXY+PC9kaXY+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsQmFyRWxlbWVudCA9IGRvbVV0aWwuY3JlYXRlRWxlbWVudChodG1sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnICsgc2VsZi51aWQgKyAnIC5nYy1ncmlkLWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNjcm9sbEJhckVsZW1lbnQsIHBhcmVudE5vZGUuZmlyc3RFbGVtZW50Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWxmLnVpZCArICctJyArIGFyZWEgKyAnLXNjcm9sbCc7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJJbmZvID0gc2VsZi5nZXRTY3JvbGxQYW5lbFJlbmRlckluZm8oYXJlYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVuZGVySW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGdjVXRpbHMuY3JlYXRlTWFya3VwRm9yU3R5bGVzKHJlbmRlckluZm8ub3V0ZXJEaXZTdHlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY2hpbGROb2Rlc1swXS5zdHlsZS5jc3NUZXh0ID0gZ2NVdGlscy5jcmVhdGVNYXJrdXBGb3JTdHlsZXMocmVuZGVySW5mby5pbm5lckRpdlN0eWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy91cGRhdGUgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgcmVuZGVySW5mbyA9IHNlbGYuZ2V0UmVuZGVySW5mbyh7XG4gICAgICAgICAgICAgICAgICAgIGFyZWE6IGFyZWEsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFRvcDogc2VsZi5zY3JvbGxPZmZzZXQudG9wLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0OiBzZWxmLnNjcm9sbE9mZnNldC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlUm93czogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVuZGVySW5mbykge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHNlbGYudWlkICsgJy0nICsgYXJlYTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gZ2NVdGlscy5jcmVhdGVNYXJrdXBGb3JTdHlsZXMocmVuZGVySW5mby5vdXRlckRpdlN0eWxlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgKz0gJy1pbm5lcic7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBnY1V0aWxzLmNyZWF0ZU1hcmt1cEZvclN0eWxlcyhyZW5kZXJJbmZvLmlubmVyRGl2U3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvL3VwZGF0ZSBjb250YWluZXIgYW5kIGNsZWFyIGNhY2hlZCBpdGVtc1xuICAgICAgICAgICAgXy5rZXlzKGxheW91dElubykubWFwKGZ1bmN0aW9uKGFyZWEpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlZnJlc2goYXJlYSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmcmVzaCB0aGUgc3BlY2lmaWVkIHBhcnQgb2YgdGhlIGdyaWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmVhIFdoaWNoIHBhcnQgbmVlZHMgdG8gYmUgcmVmcmVzaFxuICAgICAgICAgKiAvXG4gICAgICAgICAvLyovXG4gICAgICAgIHJlZnJlc2g6IGZ1bmN0aW9uKGFyZWEpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciByb3dzO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgbGVuO1xuICAgICAgICAgICAgdmFyIHJlbmRlclJhbmdlID0gc2VsZi5sYXlvdXRFbmdpbmUuZ2V0UmVuZGVyUmFuZ2VfKHtcbiAgICAgICAgICAgICAgICBhcmVhOiBhcmVhLFxuICAgICAgICAgICAgICAgIG9mZnNldFRvcDogc2VsZi5zY3JvbGxPZmZzZXQudG9wLFxuICAgICAgICAgICAgICAgIG9mZnNldExlZnQ6IHNlbGYuc2Nyb2xsT2Zmc2V0LmxlZnRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgaW5uZXJFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZi51aWQgKyAnLScgKyBhcmVhICsgJy1pbm5lcicpO1xuICAgICAgICAgICAgaWYgKHJlbmRlclJhbmdlKSB7XG4gICAgICAgICAgICAgICAgc2V0VHJhbnNmb3JtKGlubmVyRWxlbWVudCwgcmVuZGVyUmFuZ2UubGVmdCwgcmVuZGVyUmFuZ2UudG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZW5kZXJSYW5nZSkge1xuICAgICAgICAgICAgICAgIHJvd3MgPSByZW5kZXJSYW5nZS5yZW5kZXJlZFJvd3MgfHwgW107XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RSZW5kZXJlZFJvd3MgPSBzZWxmLmxhc3RSZW5kZXJlZFJvd3NfW2FyZWFdO1xuICAgICAgICAgICAgICAgIHZhciBuZXdSZW5kZXJlZFJvd3MgPSBfLnBsdWNrKHJvd3MsICdrZXknKTtcbiAgICAgICAgICAgICAgICB2YXIgb3BlcmF0aW9ucyA9IGZpbmRNaW5pbXVtT3BlcmF0aW9uc18obGFzdFJlbmRlcmVkUm93cywgbmV3UmVuZGVyZWRSb3dzKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5mbztcbiAgICAgICAgICAgICAgICB2YXIga2V5O1xuICAgICAgICAgICAgICAgIC8vdmFyIHN0eWxlO1xuICAgICAgICAgICAgICAgIC8vdmFyIGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIHZhciBvcDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBvcGVyYXRpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wID0gb3BlcmF0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChvcC5vcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2luc2VydCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gZmluZFJvdyhyb3dzLCBvcC5pdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvID0gc2VsZi5sYXlvdXRFbmdpbmUuZ2V0UmVuZGVyUm93SW5mb18oa2V5LCBhcmVhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gc2VsZi5yZW5kZXJSb3dfKGluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyRWxlbWVudC5hcHBlbmRDaGlsZChkaXYuY2hpbGROb2Rlc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGxhc3RSZW5kZXJlZFJvd3Nbb3AuaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyRWxlbWVudC5yZW1vdmVDaGlsZChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChrZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3VwZGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gZmluZFJvdyhyb3dzLCBsYXN0UmVuZGVyZWRSb3dzW29wLmluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbyA9IHNlbGYubGF5b3V0RW5naW5lLmdldFJlbmRlclJvd0luZm9fKGtleSwgYXJlYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IHNlbGYucmVuZGVyUm93XyhpbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lckVsZW1lbnQucmVwbGFjZUNoaWxkKGRpdi5jaGlsZE5vZGVzWzBdLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChrZXkua2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyZXBsYWNlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkSXRlbUtleSA9IGxhc3RSZW5kZXJlZFJvd3Nbb3AuaW5kZXhbMF1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdJdGVtS2V5ID0gZmluZFJvdyhyb3dzLCBuZXdSZW5kZXJlZFJvd3Nbb3AuaW5kZXhbMV1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvID0gc2VsZi5sYXlvdXRFbmdpbmUuZ2V0UmVuZGVyUm93SW5mb18obmV3SXRlbUtleSwgYXJlYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IHNlbGYucmVuZGVyUm93XyhpbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lckVsZW1lbnQucmVwbGFjZUNoaWxkKGRpdi5jaGlsZE5vZGVzWzBdLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvbGRJdGVtS2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxmLmxhc3RSZW5kZXJlZFJvd3NfW2FyZWFdID0gbmV3UmVuZGVyZWRSb3dzO1xuICAgICAgICAgICAgICAgIGRpdiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2Nyb2xsUmVuZGVyUGFydF86IGZ1bmN0aW9uKGFyZWEpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciByb3dzO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgbGVuO1xuICAgICAgICAgICAgLy9pZiAoZ2NVdGlscy5pc1VuZGVmaW5lZE9yTnVsbChyZWJ1aWxkUm93Q29udGVudERPTVRyZWUpKSB7XG4gICAgICAgICAgICAvLyAgICByZWJ1aWxkUm93Q29udGVudERPTVRyZWUgPSB0cnVlO1xuICAgICAgICAgICAgLy99XG4gICAgICAgICAgICAvL3JlYnVpbGRSb3dDb250ZW50RE9NVHJlZSA9ICEhcmVidWlsZFJvd0NvbnRlbnRET01UcmVlO1xuXG4gICAgICAgICAgICB2YXIgcmVuZGVyUmFuZ2UgPSBzZWxmLmxheW91dEVuZ2luZS5nZXRSZW5kZXJSYW5nZV8oe1xuICAgICAgICAgICAgICAgIGFyZWE6IGFyZWEsXG4gICAgICAgICAgICAgICAgb2Zmc2V0VG9wOiBzZWxmLnNjcm9sbE9mZnNldC50b3AsXG4gICAgICAgICAgICAgICAgb2Zmc2V0TGVmdDogc2VsZi5zY3JvbGxPZmZzZXQubGVmdFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBpbm5lckVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxmLnVpZCArICctJyArIGFyZWEgKyAnLWlubmVyJyk7XG4gICAgICAgICAgICBzZXRUcmFuc2Zvcm0oaW5uZXJFbGVtZW50LCByZW5kZXJSYW5nZS5sZWZ0LCByZW5kZXJSYW5nZS50b3ApO1xuXG4gICAgICAgICAgICBpZiAocmVuZGVyUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByb3dzID0gcmVuZGVyUmFuZ2UucmVuZGVyZWRSb3dzIHx8IFtdO1xuICAgICAgICAgICAgICAgIHZhciBsYXN0UmVuZGVyZWRSb3dzID0gc2VsZi5sYXN0UmVuZGVyZWRSb3dzX1thcmVhXTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3UmVuZGVyZWRSb3dzID0gXy5wbHVjayhyb3dzLCAna2V5Jyk7XG4gICAgICAgICAgICAgICAgdmFyIG9wZXJhdGlvbnMgPSBmaW5kU2Nyb2xsTWluaW11bU9wZXJhdGlvbnMobGFzdFJlbmRlcmVkUm93cywgbmV3UmVuZGVyZWRSb3dzKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5mbztcbiAgICAgICAgICAgICAgICB2YXIga2V5O1xuICAgICAgICAgICAgICAgIC8vdmFyIHN0eWxlO1xuICAgICAgICAgICAgICAgIC8vdmFyIGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIHZhciBvcDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBvcGVyYXRpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wID0gb3BlcmF0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChvcC5vcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2luc2VydCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gZmluZFJvdyhyb3dzLCBvcC5pbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbyA9IHNlbGYubGF5b3V0RW5naW5lLmdldFJlbmRlclJvd0luZm9fKGtleSwgYXJlYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IHNlbGYucmVuZGVyUm93XyhpbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lckVsZW1lbnQuYXBwZW5kQ2hpbGQoZGl2LmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBvcC5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lubmVyRWxlbWVudC5yZW1vdmVDaGlsZChpbm5lckVsZW1lbnQucXVlcnlTZWxlY3RvcignLicgKyBrZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyRWxlbWVudC5yZW1vdmVDaGlsZChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChrZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlcGxhY2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGRJdGVtS2V5ID0gb3AuaW5kZXhbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0l0ZW1LZXkgPSBmaW5kUm93KHJvd3MsIG9wLmluZGV4WzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvID0gc2VsZi5sYXlvdXRFbmdpbmUuZ2V0UmVuZGVyUm93SW5mb18obmV3SXRlbUtleSwgYXJlYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IHNlbGYucmVuZGVyUm93XyhpbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbm5lckVsZW1lbnQucmVwbGFjZUNoaWxkKGRpdi5jaGlsZE5vZGVzWzBdLCBpbm5lckVsZW1lbnQucXVlcnlTZWxlY3RvcignLicgKyBvbGRJdGVtS2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJFbGVtZW50LnJlcGxhY2VDaGlsZChkaXYuY2hpbGROb2Rlc1swXSwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob2xkSXRlbUtleSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZi5sYXN0UmVuZGVyZWRSb3dzX1thcmVhXSA9IG5ld1JlbmRlcmVkUm93cztcbiAgICAgICAgICAgICAgICBkaXYgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vVE9ETzogcmVmYWN0b3JpbmcgaXQgbGF0ZXIuXG4gICAgICAgIC8vVE9ETzogQnkgaW5uZXJIVE1MIHNlcmlhbGl6aXRpb24gd2lsbCBsb3NlIGNhbnZhcyBpbmZvLiBTbyBlZGl0aW5nIHNwYXJrbGluZSBmb3JtdWxhIGlzIHdyb25nLiBJJ2xsIGZpeCBpdCBsYXRlci4gLUphY2tzb25cbiAgICAgICAgcmVmcmVzaFJvd186IGZ1bmN0aW9uKGFyZWEsIGdyb3VwUGF0aCwgcm93KSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgaW5uZXJFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZi51aWQgKyAnLScgKyBhcmVhICsgJy1pbm5lcicpO1xuICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdmFyIGluZm87XG4gICAgICAgICAgICBpZiAoaW5uZXJFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHNlbGYudWlkICsgJy1yJyArIHJvdztcbiAgICAgICAgICAgICAgICBpbmZvID0gc2VsZi5sYXlvdXRFbmdpbmUuZ2V0UmVuZGVyUm93SW5mb18oe1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHJvdyxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBzZWxmLm9wdGlvbnMucm93SGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBncm91cFBhdGhcbiAgICAgICAgICAgICAgICB9LCBhcmVhKTtcbiAgICAgICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gc2VsZi5yZW5kZXJSb3dfKGluZm8pO1xuICAgICAgICAgICAgICAgIGlubmVyRWxlbWVudC5yZXBsYWNlQ2hpbGQoZGl2LmNoaWxkTm9kZXNbMF0sIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlZnJlc2hTY3JvbGxCYXJfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBsYXlvdXRJbmZvID0gc2VsZi5sYXlvdXRFbmdpbmUuZ2V0TGF5b3V0SW5mbygpO1xuICAgICAgICAgICAgdmFyIHNlbGVjdG9yO1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQ7XG4gICAgICAgICAgICB2YXIgcmVuZGVySW5mbztcbiAgICAgICAgICAgIF8ua2V5cyhsYXlvdXRJbmZvKS5tYXAoZnVuY3Rpb24oYXJlYSkge1xuICAgICAgICAgICAgICAgIC8vdXBkYXRlIHNjcm9sbCBjb250YWluZXJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zaG93U2Nyb2xsUGFuZWwoYXJlYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWxmLnVpZCArICctJyArIGFyZWEgKyAnLXNjcm9sbCc7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckluZm8gPSBzZWxmLmdldFNjcm9sbFBhbmVsUmVuZGVySW5mbyhhcmVhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbmRlckluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gZ2NVdGlscy5jcmVhdGVNYXJrdXBGb3JTdHlsZXMocmVuZGVySW5mby5vdXRlckRpdlN0eWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jaGlsZE5vZGVzWzBdLnN0eWxlLmNzc1RleHQgPSBnY1V0aWxzLmNyZWF0ZU1hcmt1cEZvclN0eWxlcyhyZW5kZXJJbmZvLmlubmVyRGl2U3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gc2VsZi51aWQgKyAnLScgKyBhcmVhICsgJy1zY3JvbGwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2Nyb2xsYWJsZUVsZW1lbnRzXy5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaHRtbCA9ICc8ZGl2IGlkPVwiJyArIGlkICsgJ1wiIGNsYXNzPVwiJyArIHJlbmRlckluZm8ub3V0ZXJEaXZDc3NDbGFzcyArICdcIic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbmRlckluZm8ub3V0ZXJEaXZDc3NDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sICs9ICcgc3R5bGU9XCInICsgZ2NVdGlscy5jcmVhdGVNYXJrdXBGb3JTdHlsZXMocmVuZGVySW5mby5vdXRlckRpdlN0eWxlKSArICdcIic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJz48ZGl2JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVuZGVySW5mby5pbm5lckRpdlN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJyBzdHlsZT1cIicgKyBnY1V0aWxzLmNyZWF0ZU1hcmt1cEZvclN0eWxlcyhyZW5kZXJJbmZvLmlubmVyRGl2U3R5bGUpICsgJ1wiJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPjwvZGl2PjwvZGl2Pic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbEJhckVsZW1lbnQgPSBkb21VdGlsLmNyZWF0ZUVsZW1lbnQoaHRtbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjJyArIHNlbGYudWlkICsgJyAuZ2MtZ3JpZC1jb250YWluZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JvbGxCYXJFbGVtZW50LCBwYXJlbnROb2RlLmZpcnN0RWxlbWVudENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gc2VsZi51aWQgKyAnLScgKyBhcmVhICsgJy1zY3JvbGwnO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVySW5mbyA9IHNlbGYuZ2V0U2Nyb2xsUGFuZWxSZW5kZXJJbmZvKGFyZWEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbmRlckluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBnY1V0aWxzLmNyZWF0ZU1hcmt1cEZvclN0eWxlcyhyZW5kZXJJbmZvLm91dGVyRGl2U3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNoaWxkTm9kZXNbMF0uc3R5bGUuY3NzVGV4dCA9IGdjVXRpbHMuY3JlYXRlTWFya3VwRm9yU3R5bGVzKHJlbmRlckluZm8uaW5uZXJEaXZTdHlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Um93VGVtcGxhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0RW5naW5lLmdldFJvd1RlbXBsYXRlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBqc29uT2JqID0ge307XG4gICAgICAgICAgICBqc29uT2JqLnZlcnNpb24gPSAnMC4xJztcbiAgICAgICAgICAgIGpzb25PYmoubGF5b3V0RW5naW5lID0gc2VsZi5sYXlvdXRFbmdpbmUudG9KU09OKCk7XG4gICAgICAgICAgICBqc29uT2JqLmNvbHVtbnMgPSBnY1V0aWxzLnNlcmlhbGl6ZU9iamVjdChzZWxmLmNvbHVtbnNDb25maWdfKTtcblxuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IHt9O1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGdyb3VwRGVzY3JpcHRvcnMgPSBzZWxmLmRhdGEuZ3JvdXBEZXNjcmlwdG9ycztcbiAgICAgICAgICAgIGlmIChncm91cERlc2NyaXB0b3JzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGdyb3VwRGVzY3JpcHRvcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBzLnB1c2goZ2NVdGlscy5zZXJpYWxpemVPYmplY3QoZ3JvdXBEZXNjcmlwdG9yc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uLmdyb3VwaW5nID0gZ3JvdXBzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmRhdGEuZmlsdGVyRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIG9wdGlvbi5maWx0ZXIgPSBzZWxmLmRhdGEuZmlsdGVyRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGpzb25PYmoubGF5b3V0RW5naW5lLm9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbiwganNvbk9iai5sYXlvdXRFbmdpbmUub3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4ganNvbk9iajtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDb250YWluZXJJbmZvXzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAvL0ZpeCBidWcsIHdlIG5lZWQgY29uc2lkZXIgY3NzIHNldHRpbmdzIGluIC5nYy1ncmlkIGNsYXNzXG4gICAgICAgICAgICBzZWxmLmNvbnRhaW5lci5jbGFzc05hbWUgKz0gJyBnYy1ncmlkJztcblxuICAgICAgICAgICAgc2VsZi5jb250YWluZXJJbmZvXyA9IHtcbiAgICAgICAgICAgICAgICBjb250ZW50UmVjdDogZG9tVXRpbC5nZXRDb250ZW50UmVjdChzZWxmLmNvbnRhaW5lcilcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHNlbGYuY29udGFpbmVyLmNsYXNzTmFtZSA9IHNlbGYuY29udGFpbmVyLmNsYXNzTmFtZS5yZXBsYWNlKCdnYy1ncmlkJywgJycpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY29udGFpbmVySW5mb187XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0R3JvdXBJbmZvXzogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgbGVuO1xuICAgICAgICAgICAgdmFyIGdyb3VwSW5mb3MgPSB0aGlzLmdyb3VwSW5mb3NfO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRHcm91cCA9IGdyb3VwSW5mb3NbcGF0aFswXV07XG4gICAgICAgICAgICBmb3IgKGkgPSAxLCBsZW4gPSBwYXRoLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEdyb3VwID0gY3VycmVudEdyb3VwLmNoaWxkcmVuW3BhdGhbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRHcm91cDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRBY3Rpb25IYW5kbGVyXzogZnVuY3Rpb24oY29sdW1uSWQsIG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGlmIChzZWxmLmJ1aWxkSW5BY3Rpb25zX1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSAnZWRpdCcgJiYgZWRpdGluZ0hhbmRsZXIuaXNFZGl0aW5nXykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmJ1aWxkSW5BY3Rpb25zX1tuYW1lXS5oYW5kbGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbEFjdGlvbnMgPSBzZWxmLmNvbHVtbkFjdGlvbnNfW2NvbHVtbklkXTtcbiAgICAgICAgICAgIGlmIChjb2xBY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFjdGlvbjtcbiAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGNvbEFjdGlvbnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gY29sQWN0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbi5uYW1lID09PSBuYW1lICYmIGFjdGlvbi5oYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uLmhhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBzdGFydEVkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGhpdEluZm8gPSBzZWxmLmxheW91dEVuZ2luZSAmJiBzZWxmLmxheW91dEVuZ2luZS5oaXRUZXN0SW5mb187XG4gICAgICAgICAgICBpZiAoIWhpdEluZm8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdWlSb3dJbmRleDtcbiAgICAgICAgICAgIHZhciBncm91cEluZm8gPSBudWxsO1xuICAgICAgICAgICAgdmFyIGhpdEdyb3VwSW5mbyA9IGhpdEluZm8uZ3JvdXBJbmZvO1xuICAgICAgICAgICAgaWYgKGhpdEdyb3VwSW5mbykge1xuICAgICAgICAgICAgICAgIHVpUm93SW5kZXggPSBoaXRHcm91cEluZm8ucm93O1xuICAgICAgICAgICAgICAgIGdyb3VwSW5mbyA9IHNlbGYuZ2V0R3JvdXBJbmZvXyhoaXRHcm91cEluZm8ucGF0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVpUm93SW5kZXggPSBoaXRJbmZvLnJvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpc0VkaXRpbmcgPSBlZGl0aW5nSGFuZGxlci5zdGFydEVkaXRpbmcoc2VsZiwgZ3JvdXBJbmZvLCB1aVJvd0luZGV4KTtcbiAgICAgICAgICAgIGlmIChzZWxmLmhhc0VkaXRBY3Rpb25fICYmIGlzRWRpdGluZykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUVkaXRpbmdCdXR0b25WYWx1ZS5jYWxsKHNlbGYsICdzYXZlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNFZGl0aW5nO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0b3BFZGl0aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGlmIChlZGl0aW5nSGFuZGxlci5pc0VkaXRpbmdfKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaGFzRWRpdEFjdGlvbl8pIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlRWRpdGluZ0J1dHRvblZhbHVlLmNhbGwoc2VsZiwgJ2VkaXQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVkaXRpbmdIYW5kbGVyLnN0b3BFZGl0aW5nKHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNhbmNlbEVkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHNlbGYuaGFzRWRpdEFjdGlvbl8pIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVFZGl0aW5nQnV0dG9uVmFsdWUuY2FsbChzZWxmLCAnZWRpdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWRpdGluZ0hhbmRsZXIudW5Nb3VudEVkaXRvcnMoc2VsZik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0U2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoc2VsZi5sYXlvdXRFbmdpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5sYXlvdXRFbmdpbmUuZ2V0U2VsZWN0aW9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlclJvd186IGZ1bmN0aW9uKHJvdykge1xuICAgICAgICAgICAgdmFyIHJvd1JlbmRlckluZm8gPSByb3cucmVuZGVySW5mbztcbiAgICAgICAgICAgIHZhciBzZXJpYWxpemVkID0gJzxkaXYnICsgKHJvdy5rZXkgPyAoJyBpZD1cIicgKyByb3cua2V5ICsgJ1wiJykgOiAnJykgKyAocm93LmlzUm93Um9sZSA/ICcgcm9sZT1cInJvd1wiJyA6ICcnKSArIChyb3cuc2VsZWN0ZWQgPyAnIGFpcmEtc2VsZWN0ZWQ9XCJ0cnVlXCInIDogJycpO1xuICAgICAgICAgICAgaWYgKHJvd1JlbmRlckluZm8uc3R5bGUpIHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkICs9ICcgc3R5bGU9XCInICsgZ2NVdGlscy5jcmVhdGVNYXJrdXBGb3JTdHlsZXMocm93UmVuZGVySW5mby5zdHlsZSkgKyAnXCInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvd1JlbmRlckluZm8uY3NzQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkICs9ICcgY2xhc3M9XCInICsgcm93UmVuZGVySW5mby5jc3NDbGFzcyArIChyb3cuc2VsZWN0ZWQgPyAnIGdjLXNlbGVjdGVkJyA6ICcnKSArICdcIic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXJpYWxpemVkICs9ICc+JztcbiAgICAgICAgICAgIGlmIChyb3dSZW5kZXJJbmZvLnJlbmRlcmVkSFRNTCkge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQgKz0gcm93UmVuZGVySW5mby5yZW5kZXJlZEhUTUw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXJpYWxpemVkICs9ICc8L2Rpdj4nO1xuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Q29sQnlJZF86IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICB2YXIgY29scyA9IHRoaXMuY29sdW1ucztcbiAgICAgICAgICAgIHZhciBjb2w7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29scy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbCA9IGNvbHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNvbC5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0NvbFZpc2libGVfOiBmdW5jdGlvbihjb2wsIHBpbm5lZCkge1xuICAgICAgICAgICAgaWYgKCFjb2wudmlzaWJsZSB8fCBjb2wucGlubmVkICE9PSBwaW5uZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29sVHJlZSA9IHRoaXMuY29sVHJlZV87XG4gICAgICAgICAgICBpZiAoY29sVHJlZSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBjb2xUcmVlW2NvbFRyZWVbY29sLmlkXS5wYXJlbnRdO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXR1cyA9IHBpbm5lZCA9PT0gJ2xlZnQnID8gcGFyZW50LnBpbm5lZFN0YXR1cyA6IChwaW5uZWQgPT09ICdyaWdodCcgPyBwYXJlbnQucGlubmVkUmlnaHRTdGF0dXMgOiBwYXJlbnQuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5pc0NvbGxhcHNlZCAmJiBjb2wuaGVhZGVyR3JvdXBTaG93ID09PSAnZXhwYW5kZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0YXR1cy5pc0NvbGxhcHNlZCAmJiBjb2wuaGVhZGVyR3JvdXBTaG93ID09PSAnY29sbGFwc2VkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmxhdHRlcm5Db2x1bW5zXzogZnVuY3Rpb24oY29sc0NvbmZpZykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgXy5lYWNoKGNvbHNDb25maWcsIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoJ2RhdGFGaWVsZCcpIHx8IG9iai5oYXNPd25Qcm9wZXJ0eSgnYWN0aW9uJykgfHwgb2JqLmhhc093blByb3BlcnR5KCdhc3luY1JlbmRlcicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9iaik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvYmouaGFzT3duUHJvcGVydHkoJ2NvbHVtbnMnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHNlbGYuZmxhdHRlcm5Db2x1bW5zXyhvYmouY29sdW1ucykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBpbnNlcnRDb2x1bW5zXzogZnVuY3Rpb24oY29sdW1ucykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgbGVuO1xuICAgICAgICAgICAgdmFyIGNvbDtcbiAgICAgICAgICAgIGlmICghZ2NVdGlscy5pc0FycmF5KGNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY29sdW1ucyA9IFtjb2x1bW5zXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpdGVtID0gc2VsZi5kYXRhLnNvdXJjZUNvbGxlY3Rpb25bMF07XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb2x1bW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29sID0gY29sdW1uc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbC5jb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbCA9IF8uZGVmYXVsdHMoY29sLCBfLmRlZmF1bHRzKHNlbGYubGF5b3V0RW5naW5lLmdldENvbHVtbkRlZmF1bHRzXygpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogY29sLmRhdGFGaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcHRpb246IGNvbC5kYXRhRmllbGRcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRDb2xzXy5jYWxsKHNlbGYsIGNvbC5jb2x1bW5zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29sLnZpc2libGVXaWR0aCA9IGNvbC53aWR0aDtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbC5kYXRhVHlwZSAmJiBjb2wuZGF0YUZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbC5kYXRhVHlwZSA9IGdjVXRpbHMuZ2V0VHlwZShpdGVtW2NvbC5kYXRhRmllbGRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbC5mb3JtYXQgJiYgY29sLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xJZCA9IGNvbC5pZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvcm1hdHRlciA9IGNvbC5mb3JtYXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnY1V0aWxzLmlzU3RyaW5nKGZvcm1hdHRlcikgJiYgc2VsZi5FeGNlbEZvcm1hdHRlcl8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29sRm9ybWF0dGVyc19bY29sSWRdID0gbmV3IHNlbGYuRXhjZWxGb3JtYXR0ZXJfKGZvcm1hdHRlcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2NVdGlscy5pc0Z1bmN0aW9uKGZvcm1hdHRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29sRm9ybWF0dGVyc19bY29sSWRdID0gZm9ybWF0dGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb2wuYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29sdW1uQWN0aW9uc19bY29sLmlkXSA9IF8ubWFwKGdjVXRpbHMuaXNBcnJheShjb2wuYWN0aW9uKSA/IGNvbC5hY3Rpb24gOiBbY29sLmFjdGlvbl0sIGNyZWF0ZUNvbHVtbkFjdGlvbl8uYmluZChzZWxmKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfLnN0YXJ0c1dpdGgoXy50cmltKGNvbC5kYXRhRmllbGQpLCAnPScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbC5pc0NhbGNDb2x1bW5fID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kYXRhLmNhbGNTb3VyY2VfLmFkZENhbGNDb2x1bW4oY29sLmlkLCBjb2wuZGF0YUZpZWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5jb2x1bW5zQ29uZmlnXy5wdXNoKGNvbCk7XG4gICAgICAgICAgICAgICAgc2VsZi5jb2x1bW5zLnB1c2goY29sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbFRyZWVfKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb2xUcmVlXyA9IHt9O1xuICAgICAgICAgICAgICAgIGJ1aWxkQ29sdW1uRGVmVHJlZV8oc2VsZi5jb2x1bW5zQ29uZmlnXywgbnVsbCwgc2VsZi5jb2xUcmVlXyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWxmLmxheW91dEVuZ2luZS51cGRhdGVTdGFydFNpemVfKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5sYXlvdXRFbmdpbmUudXBkYXRlU3RhcnRTaXplXygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5pbnZhbGlkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0Q29sQnlEYXRhRmllbGRfKGRhdGFGaWVsZCkge1xuICAgICAgICB2YXIgY29scyA9IHRoaXMuY29sdW1ucztcbiAgICAgICAgdmFyIGNvbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbCA9IGNvbHNbaV07XG4gICAgICAgICAgICBpZiAoY29sLmRhdGFGaWVsZCA9PT0gZGF0YUZpZWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0Q29sc18oY29scykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbGVuO1xuICAgICAgICB2YXIgY29sO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb2xzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb2wgPSBjb2xzW2ldO1xuICAgICAgICAgICAgaWYgKCFjb2wuY29sdW1ucykge1xuICAgICAgICAgICAgICAgIGNvbCA9IF8uZGVmYXVsdHMoY29sLCBfLmRlZmF1bHRzKHNlbGYubGF5b3V0RW5naW5lLmdldENvbHVtbkRlZmF1bHRzXygpLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBjb2wuZGF0YUZpZWxkLFxuICAgICAgICAgICAgICAgICAgICBjYXB0aW9uOiBjb2wuZGF0YUZpZWxkXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbml0Q29sc18uY2FsbChzZWxmLCBjb2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRDb2x1bW5EZWZUcmVlXyhjb2xzQ29uZmlnLCBwYXJlbnQsIGNvbHVtbkRlZlRyZWUpIHtcbiAgICAgICAgXy5lYWNoKGNvbHNDb25maWcsIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eSgnZGF0YUZpZWxkJykgfHwgb2JqLmhhc093blByb3BlcnR5KCdhY3Rpb24nKSB8fCBvYmouaGFzT3duUHJvcGVydHkoJ2FzeW5jUmVuZGVyJykpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5EZWZUcmVlW29iai5pZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogcGFyZW50XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqLmhhc093blByb3BlcnR5KCdjb2x1bW5zJykpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5EZWZUcmVlW29iai5jYXB0aW9uXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0ljb246IHNob3dDb2xsYXBzZUljb24ob2JqLCAnbm9uZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNDb2xsYXBzZWQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGlubmVkU3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93SWNvbjogc2hvd0NvbGxhcHNlSWNvbihvYmosICdsZWZ0JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0NvbGxhcHNlZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwaW5uZWRSaWdodFN0YXR1czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0ljb246IHNob3dDb2xsYXBzZUljb24ob2JqLCAncmlnaHQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29sbGFwc2VkOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJ1aWxkQ29sdW1uRGVmVHJlZV8ob2JqLmNvbHVtbnMsIG9iai5jYXB0aW9uLCBjb2x1bW5EZWZUcmVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzUGlubmVkT3JVbnBpbm5lZENvbHVtbl8oY29scywgcGlubmVkKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbGVuO1xuICAgICAgICB2YXIgY29sO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNvbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbCA9IGNvbHNbaV07XG4gICAgICAgICAgICBpZiAoY29sLmNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBoYXNQaW5uZWRPclVucGlubmVkQ29sdW1uXyhjb2wuY29sdW1ucywgcGlubmVkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY29sLnBpbm5lZCA9PT0gcGlubmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hvd0NvbGxhcHNlSWNvbihjb2wsIHBpbm5lZCkge1xuICAgICAgICB2YXIgY29scyA9IGNvbC5jb2x1bW5zO1xuICAgICAgICB2YXIgbGVuID0gY29scy5sZW5ndGg7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbGVuMiA9IGxlbjtcbiAgICAgICAgdmFyIHNob3dDb3VudCA9IDA7XG4gICAgICAgIHZhciBoaWRkZW5Db3VudCA9IDA7XG4gICAgICAgIHZhciBsZW4zID0gMDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjI7IGkrKykge1xuICAgICAgICAgICAgY29sID0gY29sc1tpXTtcbiAgICAgICAgICAgIGlmICghY29sLmNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICBjb2wucGlubmVkID0gY29sLnBpbm5lZCB8fCAnbm9uZSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgoY29sLmNvbHVtbnMgJiYgaGFzUGlubmVkT3JVbnBpbm5lZENvbHVtbl8oY29sLmNvbHVtbnMsIHBpbm5lZCkpIHx8IChjb2wucGlubmVkID09PSBwaW5uZWQgJiYgY29sLmhlYWRlckdyb3VwU2hvdyAhPT0gJ2V4cGFuZGVkJykpIHtcbiAgICAgICAgICAgICAgICBzaG93Q291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICBsZW4zICs9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbC5waW5uZWQgPT09IHBpbm5lZCAmJiBjb2wuaGVhZGVyR3JvdXBTaG93ID09PSAnZXhwYW5kZWQnKSB7XG4gICAgICAgICAgICAgICAgaGlkZGVuQ291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICBsZW4zICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvd0NvdW50ID09PSBsZW4zIHx8IGhpZGRlbkNvdW50ID09PSBsZW4zKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy9mdW5jdGlvbiBmbGF0dGVybkNvbHVtbnNfKGNvbHNDb25maWcpIHtcbiAgICAvLyAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgLy8gICAgXy5lYWNoKGNvbHNDb25maWcsIGZ1bmN0aW9uKG9iaikge1xuICAgIC8vICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KCdkYXRhRmllbGQnKSB8fCBvYmouaGFzT3duUHJvcGVydHkoJ2FjdGlvbicpKSB7XG4gICAgLy8gICAgICAgICAgICByZXN1bHQucHVzaChvYmopO1xuICAgIC8vICAgICAgICB9IGVsc2UgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eSgnY29sdW1ucycpKSB7XG4gICAgLy8gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGZsYXR0ZXJuQ29sdW1uc18ob2JqLmNvbHVtbnMpKTtcbiAgICAvLyAgICAgICAgfVxuICAgIC8vICAgIH0pO1xuICAgIC8vICAgIHJldHVybiByZXN1bHQ7XG4gICAgLy99XG5cbiAgICAvL1RPRE86IGhhbmRsZSB0aGUgYWN0aW9uIGNvbHVtbiBpbiBncm91cFxuICAgIGZ1bmN0aW9uIHVwZGF0ZUVkaXRpbmdCdXR0b25WYWx1ZSh2YWx1ZSkge1xuICAgICAgICB2YXIgZWRpdGluZ0luZm8gPSBlZGl0aW5nSGFuZGxlci5lZGl0aW5nSW5mb187XG4gICAgICAgIHZhciBzZWxlY3Rpb25QYXJ0ID0gZWRpdGluZ0luZm8uZ3JvdXAgPyAoJy1ncicgKyBlZGl0aW5nSW5mby5ncm91cC5qb2luKCdfJykgKyAnLXInICsgZWRpdGluZ0luZm8ucm93SW5kZXgpIDogKCctcicgKyBlZGl0aW5nSW5mby5yb3dJbmRleCk7XG4gICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignIycgKyB0aGlzLnVpZCArIHNlbGVjdGlvblBhcnQgKyAnIC5nYy1hY3Rpb24tYXJlYSBidXR0b25bZGF0YS1hY3Rpb249XCJlZGl0XCJdJyk7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29sdW1uQWN0aW9uXyhpdGVtKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGlzU3RyID0gZ2NVdGlscy5pc1N0cmluZyhpdGVtKTtcbiAgICAgICAgdmFyIG5hbWUgPSBpc1N0ciA/IGl0ZW0gOiBpdGVtLm5hbWU7XG4gICAgICAgIGlmICghaXNTdHIgJiYgc2VsZi5idWlsZEluQWN0aW9uc19bbmFtZV0gJiYgaXRlbS5oYW5kbGVyKSB7XG4gICAgICAgICAgICBzZWxmLmJ1aWxkSW5BY3Rpb25zX1tuYW1lXS5oYW5kbGVyID0gaXRlbS5oYW5kbGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09PSAnZWRpdCcpIHtcbiAgICAgICAgICAgIHNlbGYuaGFzRWRpdEFjdGlvbl8gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09PSAnY2FuY2VsJykge1xuICAgICAgICAgICAgc2VsZi5oYXNDYW5jZWxBY3Rpb25fID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTdHIgPyB7bmFtZTogaXRlbX0gOiBpdGVtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmRSb3cocm93cywgcm93S2V5KSB7XG4gICAgICAgIHJldHVybiBfLmZpbmQocm93cywgZnVuY3Rpb24ocm93KSB7XG4gICAgICAgICAgICByZXR1cm4gcm93LmtleSA9PT0gcm93S2V5O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWxlbWVudCwgbGVmdCwgdG9wKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoZ2V0VHJhbnNmb3JtUHJvTmFtZSgpLCBnZXRUcmFuc2Zvcm1Qcm9WYWx1ZShsZWZ0LCB0b3ApKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1Qcm9OYW1lKCkge1xuICAgICAgICByZXR1cm4gKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignTVNJRScpICE9PSAtMSB8fCBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKCdUcmlkZW50LycpID4gMCB8fCBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9GaXJlZm94L2kpKSA/ICd0cmFuc2Zvcm0nIDogJy13ZWJraXQtdHJhbnNmb3JtJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1Qcm9WYWx1ZShsZWZ0LCB0b3ApIHtcbiAgICAgICAgdG9wID0gdG9wICsgJ3B4JztcbiAgICAgICAgbGVmdCA9IGxlZnQgKyAncHgnO1xuICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZTNkKCcgKyBsZWZ0ICsgJywnICsgdG9wICsgJywgMHB4KSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TGF5b3V0RW5naW5lXyhsYXlvdXRFbmdpbmVJbmZvKSB7XG4gICAgICAgIHZhciBuYW1lID0gbGF5b3V0RW5naW5lSW5mby5uYW1lO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGxheW91dEVuZ2luZUluZm8ub3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ncm91cFN0cmF0ZWd5KSB7XG4gICAgICAgICAgICB2YXIgc3RyYXRlZ3kgPSBvcHRpb25zLmdyb3VwU3RyYXRlZ3k7XG4gICAgICAgICAgICBpZiAoZ2NVdGlscy5pc1N0cmluZyhzdHJhdGVneS5uYW1lKSAmJiBHY0dyaWQgJiYgR2NHcmlkLlBsdWdpbnMgJiYgR2NHcmlkLlBsdWdpbnNbc3RyYXRlZ3kubmFtZV0pIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmdyb3VwU3RyYXRlZ3kgPSBuZXcgR2NHcmlkLlBsdWdpbnNbc3RyYXRlZ3kubmFtZV0ob3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdjVXRpbHMuaXNTdHJpbmcobmFtZSkgJiYgR2NHcmlkICYmIEdjR3JpZC5QbHVnaW5zICYmIEdjR3JpZC5QbHVnaW5zW25hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdjR3JpZC5QbHVnaW5zW25hbWVdKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgR3JpZExheW91dEVuZ2luZShvcHRpb25zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmlnZ2VyXyhldmVudCwgc2VuZGVyLCBlKSB7XG4gICAgICAgIGUgPSBlIHx8IHt9O1xuICAgICAgICByZXR1cm4gZXZlbnQucmFpc2Uoc2VuZGVyLCBlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVHcm91cEluZm9fKGdyb3VwLCBwYXRoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHIgPSB7XG4gICAgICAgICAgICBkYXRhOiBncm91cCxcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICBpc0JvdHRvbUxldmVsOiBncm91cC5pc0JvdHRvbUxldmVsXG4gICAgICAgIH07XG4gICAgICAgIGlmICghZ3JvdXAuaXNCb3R0b21MZXZlbCkge1xuICAgICAgICAgICAgci5jaGlsZHJlbiA9IF8ubWFwKGdyb3VwLmdyb3VwcywgZnVuY3Rpb24oc3ViR3JvdXAsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUdyb3VwSW5mb18uY2FsbChzZWxmLCBzdWJHcm91cCwgcGF0aC5jb25jYXQoW2luZGV4XSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJFdmVudHNfKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBzZWxmLmNvbnRhaW5lcjtcbiAgICAgICAgaWYgKCFjb250YWluZXIudGFiSW5kZXggfHwgY29udGFpbmVyLnRhYkluZGV4IDwgMCkgeyAvL09ubHkgZm9jdXNhYmxlIGVsZW1lbnQgY2FuIGJlIGJvdW5kIGtleWRvd24gZXZlbnQuXG4gICAgICAgICAgICBjb250YWluZXIudGFiSW5kZXggPSAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHNlbGYuaGFuZGxlQ2xpY2tGbl8pO1xuICAgICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBzZWxmLmhhbmRsZURiQ2xpY2tGbl8pO1xuICAgICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgc2VsZi5oYW5kbGVNb3VzZURvd25Gbl8pO1xuICAgICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHNlbGYuaGFuZGxlTW91c2VVcEZuXyk7XG4gICAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBzZWxmLmhhbmRsZU1vdXNlTW92ZUZuXyk7XG4gICAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgc2VsZi5oYW5kbGVLZXlEb3duRm5fKTtcbiAgICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgc2VsZi5oYW5kbGVXaGVlbEZuXyk7XG4gICAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHNlbGYuaGFuZGxlRGVib3VuY2VNb3VzZVdoZWVsRm5fKTtcblxuICAgICAgICBzZWxmLm9uU2Nyb2xsT3Zlcl8uYWRkSGFuZGxlcihzZWxmLmhhbmRsZURlYm91bmNlU2Nyb2xsT3ZlckZuXyk7XG5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHNlbGYuaGFuZGxlV2luZG93UmVzaXplRm5fKTtcbiAgICAgICAgcmVnaXN0ZXJTY3JvbGxFdmVudF8uY2FsbChzZWxmKTtcbiAgICAgICAgcmVnaXN0ZXJUb3VjaEV2ZW50Xy5jYWxsKHNlbGYpO1xuXG4gICAgICAgIHNlbGYuZGF0YS5jb2xsZWN0aW9uQ2hhbmdlZC5hZGRIYW5kbGVyKGhhbmRsZUNvbGxlY3Rpb25DaGFuZ2VkXywgc2VsZik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hhbmdlU2Nyb2xsUGFuZWxaaW5kZXgoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCFzY3JvbGxQYW5lbFpJbmRleGNoYW5nZWQpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZi51aWQgKyAnLXZpZXdwb3J0LXNjcm9sbCcpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlWyd6LWluZGV4J10gPSAyMDAwMDtcbiAgICAgICAgICAgICAgICBzY3JvbGxQYW5lbFpJbmRleGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hhbmdlQmFja1Njcm9sbFBhbmVsWkluZGV4KCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChzY3JvbGxQYW5lbFpJbmRleGNoYW5nZWQpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZi51aWQgKyAnLXZpZXdwb3J0LXNjcm9sbCcpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KCd6LWluZGV4Jyk7XG4gICAgICAgICAgICAgICAgc2Nyb2xsUGFuZWxaSW5kZXhjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxpbmdfID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1blJlZ2lzdGVyRXZlbnRzXygpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gc2VsZi5jb250YWluZXI7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHNlbGYuaGFuZGxlQ2xpY2tGbl8pO1xuICAgICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBzZWxmLmhhbmRsZURiQ2xpY2tGbl8pO1xuICAgICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgc2VsZi5oYW5kbGVNb3VzZURvd25Gbl8pO1xuICAgICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHNlbGYuaGFuZGxlTW91c2VVcEZuXyk7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZU1vdmUnLCBzZWxmLmhhbmRsZU1vdXNlTW92ZUZuXyk7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgc2VsZi5oYW5kbGVLZXlEb3duRm5fKTtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgc2VsZi5oYW5kbGVXaGVlbEZuXyk7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIHNlbGYuaGFuZGxlRGVib3VuY2VNb3VzZVdoZWVsRm5fKTtcblxuICAgICAgICBzZWxmLm9uU2Nyb2xsT3Zlcl8ucmVtb3ZlSGFuZGxlcihzZWxmLmhhbmRsZURlYm91bmNlU2Nyb2xsT3ZlckZuXyk7XG5cbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHNlbGYuaGFuZGxlV2luZG93UmVzaXplRm5fKTtcbiAgICAgICAgdW5SZWdpc3RlclNjcm9sbEV2ZW50Xy5jYWxsKHNlbGYpO1xuICAgICAgICB1blJlZ2lzdGVyVG91Y2hFdmVudC5jYWxsKHNlbGYpO1xuXG4gICAgICAgIHNlbGYuZGF0YS5jb2xsZWN0aW9uQ2hhbmdlZC5yZW1vdmVIYW5kbGVyKHNlbGYuaGFuZGxlQ29sbGVjdGlvbkNoYW5nZWRGbl8pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuUmVnaXN0ZXJTY3JvbGxFdmVudF8oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGVsZW1lbnQ7XG4gICAgICAgIF8uZWFjaChzZWxmLnNjcm9sbGFibGVFbGVtZW50c18sIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpdGVtKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzZWxmLmhhbmRsZVNjcm9sbEZuXyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgICAgIHNlbGYuc2Nyb2xsYWJsZUVsZW1lbnRzXy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkRG9tVHJlZV8oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHJlbmRlcmVkUm93cztcbiAgICAgICAgdmFyIGxheW91dEluZm8gPSBzZWxmLmdldExheW91dEluZm8oKTtcbiAgICAgICAgdmFyIGh0bWwgPSAnPGRpdiByb2xlPVwiZ3JpZFwiIGlkPVwiJyArIHNlbGYudWlkICsgJ1wiY2xhc3M9XCInICsgKHNlbGYub3B0aW9ucy5jbGFzc05hbWUgPyBzZWxmLm9wdGlvbnMuY2xhc3NOYW1lIDogJ2djLWdyaWQnKSArICdcIj48ZGl2IGNsYXNzPVwiZ2MtZ3JpZC1jb250YWluZXJcIj4nO1xuICAgICAgICB2YXIgcmVuZGVySW5mbztcbiAgICAgICAgdmFyIHJvd3M7XG4gICAgICAgIHZhciBpbm5lckRpdlN0eWxlO1xuICAgICAgICBzZWxmLnNjcm9sbGFibGVFbGVtZW50c18ubGVuZ3RoID0gMDtcbiAgICAgICAgXy5rZXlzKGxheW91dEluZm8pLm1hcChmdW5jdGlvbihhcmVhKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5zaG93U2Nyb2xsUGFuZWwoYXJlYSkpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJJbmZvID0gc2VsZi5nZXRTY3JvbGxQYW5lbFJlbmRlckluZm8oYXJlYSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlbmRlckluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gc2VsZi51aWQgKyAnLScgKyBhcmVhICsgJy1zY3JvbGwnO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbGFibGVFbGVtZW50c18ucHVzaChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxkaXYgaWQ9XCInICsgaWQgKyAnXCIgY2xhc3M9XCInICsgcmVuZGVySW5mby5vdXRlckRpdkNzc0NsYXNzICsgJ1wiJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbmRlckluZm8ub3V0ZXJEaXZDc3NDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnIHN0eWxlPVwiJyArIGdjVXRpbHMuY3JlYXRlTWFya3VwRm9yU3R5bGVzKHJlbmRlckluZm8ub3V0ZXJEaXZTdHlsZSkgKyAnXCInO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJz48ZGl2JztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbmRlckluZm8uaW5uZXJEaXZTdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnIHN0eWxlPVwiJyArIGdjVXRpbHMuY3JlYXRlTWFya3VwRm9yU3R5bGVzKHJlbmRlckluZm8uaW5uZXJEaXZTdHlsZSkgKyAnXCInO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJz48L2Rpdj48L2Rpdj4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy93aGVuIHRoZSBhcmVhIGRvZXMgbm90IHNob3cgc2Nyb2xsIHBhbmVsLGluIG9yZGVyIHRvIHNob3cgYWxsIGNvbnRlbnQgb2YgYXJlYSxcbiAgICAgICAgICAgICAgICAvL3Nob3VsZCByZXNldCBzY3JvbGxvZmZzZXQuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaXNTY3JvbGxhYmxlQXJlYV8gJiYgc2VsZi5pc1Njcm9sbGFibGVBcmVhXyhhcmVhKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5sYXlvdXRFbmdpbmUuZ2V0SW5pdGlhbFNjcm9sbE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxPZmZzZXQgPSBzZWxmLmxheW91dEVuZ2luZS5nZXRJbml0aWFsU2Nyb2xsT2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbE9mZnNldC50b3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxPZmZzZXQubGVmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW5kZXJJbmZvID0gc2VsZi5nZXRSZW5kZXJJbmZvKHtcbiAgICAgICAgICAgICAgICBhcmVhOiBhcmVhLFxuICAgICAgICAgICAgICAgIG9mZnNldFRvcDogc2VsZi5zY3JvbGxPZmZzZXQudG9wLFxuICAgICAgICAgICAgICAgIG9mZnNldExlZnQ6IHNlbGYuc2Nyb2xsT2Zmc2V0LmxlZnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVuZGVyZWRSb3dzID0gc2VsZi5sYXN0UmVuZGVyZWRSb3dzX1thcmVhXSA9IChzZWxmLmxhc3RSZW5kZXJlZFJvd3NfW2FyZWFdIHx8IFtdKTtcbiAgICAgICAgICAgIGlmIChyZW5kZXJJbmZvKSB7XG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPGRpdiBpZD1cIicgKyBzZWxmLnVpZCArICctJyArIGFyZWEgKyAnXCInO1xuICAgICAgICAgICAgICAgIGlmIChyZW5kZXJJbmZvLm91dGVyRGl2U3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnIHN0eWxlPVwiJyArIGdjVXRpbHMuY3JlYXRlTWFya3VwRm9yU3R5bGVzKHJlbmRlckluZm8ub3V0ZXJEaXZTdHlsZSkgKyAnXCInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVuZGVySW5mby5vdXRlckRpdkNzc0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJyBjbGFzcz1cIicgKyByZW5kZXJJbmZvLm91dGVyRGl2Q3NzQ2xhc3MgKyAnXCInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBodG1sICs9ICc+PGRpdiBpZD1cIicgKyBzZWxmLnVpZCArICctJyArIGFyZWEgKyAnLWlubmVyXCInO1xuICAgICAgICAgICAgICAgIGlmIChyZW5kZXJJbmZvLmlubmVyRGl2U3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJEaXZTdHlsZSA9IGdjVXRpbHMuY3JlYXRlTWFya3VwRm9yU3R5bGVzKHJlbmRlckluZm8uaW5uZXJEaXZTdHlsZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlbmRlckluZm8uaW5uZXJEaXZUcmFuc2xhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJEaXZTdHlsZSArPSBnZXRUcmFuc2Zvcm1Qcm9OYW1lKCkgKyAnOicgKyBnZXRUcmFuc2Zvcm1Qcm9WYWx1ZShyZW5kZXJJbmZvLmlubmVyRGl2VHJhbnNsYXRlLmxlZnQsIHJlbmRlckluZm8uaW5uZXJEaXZUcmFuc2xhdGUudG9wKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5uZXJEaXZTdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICcgc3R5bGU9XCInICsgaW5uZXJEaXZTdHlsZSArICdcIic7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlbmRlckluZm8uaW5uZXJEaXZDc3NDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICcgY2xhc3M9XCInICsgcmVuZGVySW5mby5pbm5lckRpdkNzc0NsYXNzICsgJ1wiJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPic7XG4gICAgICAgICAgICAgICAgcm93cyA9IHJlbmRlckluZm8ucmVuZGVyZWRSb3dzIHx8IFtdO1xuICAgICAgICAgICAgICAgIF8uZWFjaChyb3dzLCBmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRSb3dzLnB1c2gocm93LmtleSk7XG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gc2VsZi5yZW5kZXJSb3dfKHJvdyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBodG1sICs9ICc8L2Rpdj48L2Rpdj4nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuICAgICAgICBodG1sICs9ICc8L2Rpdj48L2Rpdj4nO1xuXG4gICAgICAgIHNlbGYuY29udGFpbmVyLmlubmVySFRNTCA9IGh0bWw7XG5cbiAgICAgICAgc3RhcnRBc3luY1JlbmRlcl8uY2FsbChzZWxmKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydEFzeW5jUmVuZGVyXyhzY3JvbGxEaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY29sdW1ucyA9IHNlbGYuY29sdW1ucztcbiAgICAgICAgdmFyIGNvbHVtbkRlZjtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW5ndGg7XG4gICAgICAgIHZhciBuZWVkQXN5blJlbmRlciA9IGZhbHNlO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBjb2x1bW5zLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb2x1bW5EZWYgPSBjb2x1bW5zW2ldO1xuICAgICAgICAgICAgaWYgKGNvbHVtbkRlZi5hc3luY1JlbmRlciB8fCBoYXNTcGFya2xpbmUoY29sdW1uRGVmKSkge1xuICAgICAgICAgICAgICAgIG5lZWRBc3luUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5lZWRBc3luUmVuZGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5hc3luUm93c18gPSB7fTtcbiAgICAgICAgdmFyIHJlbmRlcmVkUm93cyA9IHNlbGYubGFzdFJlbmRlcmVkUm93c187XG4gICAgICAgIF8uZWFjaChbVklFV1BPUlQsIFBJTk5FRF9WSUVXUE9SVCwgUElOTkVEX1JJR0hUX1ZJRVdQT1JUXSwgZnVuY3Rpb24oYXJlYSkge1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVkUm93c1thcmVhXSkge1xuICAgICAgICAgICAgICAgIHNlbGYuYXN5blJvd3NfW2FyZWFdID0gZ2V0R2xvYmFsSW5kZXhCeUlEXy5jYWxsKHNlbGYsIHJlbmRlcmVkUm93c1thcmVhXSwgYXJlYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2FjY29yZGluZyB0byBzY3JvbGwgZGlyZWN0aW9uIHRvIGNoYW5nZWQgcmVuZGVyaW5nIHNlcXVlbmNlXG4gICAgICAgICAgICBpZiAoc2Nyb2xsRGlyZWN0aW9uID09PSAnZG93bicgJiYgc2VsZi5hc3luUm93c19bYXJlYV0pIHtcbiAgICAgICAgICAgICAgICBzZWxmLmFzeW5Sb3dzX1thcmVhXSA9IHNlbGYuYXN5blJvd3NfW2FyZWFdLnJldmVyc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2VsZi5hc3luSW5kZXhfID0gMDtcbiAgICAgICAgc2VsZi5hc3luUmVuZGVyVGltZXJfID0gc2V0VGltZW91dChhc3luY1JlbmRlclJvd3NfLmJpbmQodGhpcyksIDMwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc3luY1JlbmRlclJvd3NfKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbGVuZ3RoO1xuICAgICAgICB2YXIgcm93SW5kZXg7XG4gICAgICAgIHZhciByb3dFbGVtZW50O1xuICAgICAgICB2YXIgY29udGFpbmVyO1xuICAgICAgICB2YXIgY29sdW1uRGVmO1xuICAgICAgICB2YXIgY29sdW1ucyA9IHNlbGYuY29sdW1ucztcbiAgICAgICAgdmFyIHJvd3MgPSBzZWxmLmFzeW5Sb3dzXztcbiAgICAgICAgdmFyIGlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB2YXIgcm93RGF0YSA9IG51bGw7XG4gICAgICAgIHZhciByb3dBcnI7XG4gICAgICAgIHZhciByb3dJbmZvO1xuICAgICAgICB2YXIgc3BhcmtsaW5lT2JqO1xuICAgICAgICB2YXIgY2FsY1NvdXJjZSA9IHNlbGYuZGF0YS5jYWxjU291cmNlO1xuICAgICAgICB2YXIgZm9ybXVsYTtcbiAgICAgICAgXy5lYWNoKFtWSUVXUE9SVCwgUElOTkVEX1ZJRVdQT1JULCBQSU5ORURfUklHSFRfVklFV1BPUlRdLCBmdW5jdGlvbihhcmVhKSB7XG4gICAgICAgICAgICByb3dBcnIgPSByb3dzW2FyZWFdO1xuICAgICAgICAgICAgaWYgKHJvd0FyciAmJiBzZWxmLmFzeW5JbmRleF8gPCByb3dBcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByb3dJbmZvID0gcm93QXJyW3NlbGYuYXN5bkluZGV4X107XG4gICAgICAgICAgICAgICAgcm93RWxlbWVudCA9IGdldFJvd0VsZW1lbnRfLmNhbGwoc2VsZiwgcm93SW5mbywgYXJlYSk7XG4gICAgICAgICAgICAgICAgaWYgKHJvd0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvd0luZm8uZ3JvdXBBcmVhICYmIHJvd0luZm8uZ3JvdXBBcmVhID09PSBHUk9VUF9DT05URU5UKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dJbmRleCA9IHNlbGYuZ2V0R3JvdXBJbmZvXyhyb3dJbmZvLnBhdGgpLmRhdGEudG9Tb3VyY2VSb3cocm93SW5mby5yb3cpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93SW5kZXggPSByb3dJbmZvLnJvdztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWdjVXRpbHMuaXNVbmRlZmluZWQocm93SW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dEYXRhID0gc2VsZi5nZXREYXRhSXRlbShyb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gY29sdW1ucy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BhcmtsaW5lT2JqID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5EZWYgPSBjb2x1bW5zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd0luZm8uZ3JvdXBBcmVhID09PSBHUk9VUF9IRUFERVIgfHwgcm93SW5mby5ncm91cEFyZWEgPT09IEdST1VQX0ZPT1RFUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHJvd0VsZW1lbnQucXVlcnlTZWxlY3RvcignLmdjLWdyb3VwLXNwYXJrbGluZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm11bGEgPSBjb250YWluZXIgJiYgY29udGFpbmVyLmdldEF0dHJpYnV0ZSgnZGF0YS1mb3JtdWxhJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm11bGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhcmtsaW5lT2JqID0gY2FsY1NvdXJjZS5nZXRFdmFsdWF0b3IoKS5ldmFsdWF0ZUZvcm11bGEoY29udGFpbmVyLmdldEF0dHJpYnV0ZSgnZGF0YS1mb3JtdWxhJyksIGNhbGNTb3VyY2UuZ2V0UGFyc2VyQ29udGV4dCgpLCBjYWxjU291cmNlLmdldEV2YWx1YXRvckNvbnRleHQoLTEsIHJvd0luZm8ucGF0aCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWZvcm11bGEnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHJvd0VsZW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtY29sdW1uPScgKyBjb2x1bW5EZWYuaWQgKyAnXSAuZ2MtY2VsbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYXJrbGluZU9iaiA9IHJvd0RhdGFbY29sdW1uRGVmLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGFya2xpbmVPYmogaW5zdGFuY2VvZiBHY0dyaWQuUGx1Z2lucy5TcGFya2xpbmUuQmFzZVNwYXJrbGluZSAmJiBjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFya2xpbmVPYmoucGFpbnQoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW5EZWYuYXN5bmNSZW5kZXIgJiYgY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uRGVmLmFzeW5jUmVuZGVyKHJvd0RhdGEsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNSdW5uaW5nKSB7XG4gICAgICAgICAgICBzZWxmLmFzeW5JbmRleF8rKztcbiAgICAgICAgICAgIHNlbGYuYXN5blJlbmRlclRpbWVyXyA9IHNldFRpbWVvdXQoYXN5bmNSZW5kZXJSb3dzXy5iaW5kKHRoaXMpLCAzMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNTcGFya2xpbmUoY29sdW1uKSB7XG4gICAgICAgIHZhciBzcGFya2xpbmVOYW1lcyA9IFtcbiAgICAgICAgICAgICdQSUVTUEFSS0xJTkUnLFxuICAgICAgICAgICAgJ0xJTkVTUEFSS0xJTkUnLFxuICAgICAgICAgICAgJ0NPTFVNTlNQQVJLTElORScsXG4gICAgICAgICAgICAnV0lOTE9TU1NQQVJLTElORSdcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzcGFya2xpbmVOYW1lcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmFtZSA9ICc9JyArIHNwYXJrbGluZU5hbWVzW2ldO1xuICAgICAgICAgICAgaWYgKGNvbHVtbi5pc0NhbGNDb2x1bW5fKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5kYXRhRmllbGQuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2x1bW4uZ3JvdXBIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uLmdyb3VwSGVhZGVyLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sdW1uLmdyb3VwRm9vdGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5ncm91cEZvb3Rlci5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEdsb2JhbEluZGV4QnlJRF8ocm93S2V5cywgYXJlYSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghcm93S2V5cyB8fCAhcm93S2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1aWQgPSBzZWxmLnVpZDtcbiAgICAgICAgdmFyIHByZWZpeCA9IHVpZCArICctJyArIChhcmVhID09PSBQSU5ORURfVklFV1BPUlQgPyAncCcgOiAoYXJlYSA9PT0gUElOTkVEX1JJR0hUX1ZJRVdQT1JUID8gJ3ByJyA6ICcnKSk7XG4gICAgICAgIHZhciBoYXNHcm91cCA9IHNlbGYuZGF0YS5ncm91cHMgJiYgc2VsZi5kYXRhLmdyb3Vwcy5sZW5ndGggPiAwO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbGVuZ3RoO1xuICAgICAgICB2YXIgcGF0aDtcbiAgICAgICAgdmFyIHJvd0luZGV4O1xuXG4gICAgICAgIGlmIChoYXNHcm91cCkge1xuICAgICAgICAgICAgdmFyIGhlYWRlclByZWZpeCA9IHByZWZpeCArICdnaCc7XG4gICAgICAgICAgICB2YXIgZm9vdGVyUHJlZml4ID0gcHJlZml4ICsgJ2dmJztcbiAgICAgICAgICAgIHZhciBjb250ZW50UHJlZml4ID0gcHJlZml4ICsgJ2dyJztcbiAgICAgICAgICAgIHZhciBncm91cEFyZWE7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSByb3dLZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gcm93S2V5c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LmluZGV4T2YoY29udGVudFByZWZpeCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSBrZXkuc3Vic3RyKGNvbnRlbnRQcmVmaXgubGVuZ3RoLCBrZXkuaW5kZXhPZignLXInKSAtIGNvbnRlbnRQcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgcm93SW5kZXggPSAra2V5LnN1YnN0cihrZXkuaW5kZXhPZignLXInKSArIDIpO1xuICAgICAgICAgICAgICAgICAgICBncm91cEFyZWEgPSBHUk9VUF9DT05URU5UO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5LmluZGV4T2YoaGVhZGVyUHJlZml4KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IGtleS5zdWJzdHIoaGVhZGVyUHJlZml4Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwQXJlYSA9IEdST1VQX0hFQURFUjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleS5pbmRleE9mKGZvb3RlclByZWZpeCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSBrZXkuc3Vic3RyKGZvb3RlclByZWZpeC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBncm91cEFyZWEgPSBHUk9VUF9GT09URVI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcm93OiByb3dJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogcGF0aC5zcGxpdCgnXycpLFxuICAgICAgICAgICAgICAgICAgICBncm91cEFyZWE6IGdyb3VwQXJlYVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJlZml4ID0gcHJlZml4ICsgJ3InO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gcm93S2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGtleSA9IHJvd0tleXNbaV07XG4gICAgICAgICAgICAgICAgcm93SW5kZXggPSAra2V5LnN1YnN0cihwcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHJvdzogcm93SW5kZXhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFJvd0VsZW1lbnRfKHJvd0luZm8sIGFyZWEpIHtcbiAgICAgICAgdmFyIHVpZCA9IHRoaXMudWlkO1xuICAgICAgICB2YXIgc2VsZWN0b3I7XG4gICAgICAgIHZhciBwcmVmaXggPSBhcmVhID09PSBQSU5ORURfVklFV1BPUlQgPyAncCcgOiAoYXJlYSA9PT0gUElOTkVEX1JJR0hUX1ZJRVdQT1JUID8gJ3ByJyA6ICcnKTtcbiAgICAgICAgaWYgKHJvd0luZm8uZ3JvdXBBcmVhKSB7XG4gICAgICAgICAgICBpZiAocm93SW5mby5ncm91cEFyZWEgPT09IEdST1VQX0NPTlRFTlQgJiYgcm93SW5mby5yb3cgPj0gMCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gdWlkICsgJy0nICsgcHJlZml4ICsgJ2dyJyArIHJvd0luZm8ucGF0aC5qb2luKCdfJykgKyAnLXInICsgcm93SW5mby5yb3c7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJvd0luZm8uZ3JvdXBBcmVhID09PSBHUk9VUF9GT09URVIpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHVpZCArICctJyArIHByZWZpeCArICdnZicgKyByb3dJbmZvLnBhdGguam9pbignXycpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyb3dJbmZvLmdyb3VwQXJlYSA9PT0gR1JPVVBfSEVBREVSKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB1aWQgKyAnLScgKyBwcmVmaXggKyAnZ2gnICsgcm93SW5mby5wYXRoLmpvaW4oJ18nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyb3dJbmZvLnJvdyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB1aWQgKyAnLScgKyBwcmVmaXggKyAncicgKyByb3dJbmZvLnJvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0b3IgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxlY3RvcikgOiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyU2Nyb2xsRXZlbnRfKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIF8uZWFjaChzZWxmLnNjcm9sbGFibGVFbGVtZW50c18sIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGl0ZW0pLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHNlbGYuaGFuZGxlU2Nyb2xsRm5fKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJUb3VjaEV2ZW50XygpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gc2VsZi5jb250YWluZXI7XG5cbiAgICAgICAgVG91Y2hXcmFwcGVyKGNvbnRhaW5lcikub24oJ3RvdWNoc3RhcnQnLCBzZWxmLmhhbmRsZVRvdWNoU3RhcnRGbl8pO1xuICAgICAgICBUb3VjaFdyYXBwZXIoY29udGFpbmVyKS5vbigndG91Y2htb3ZlJywgc2VsZi5oYW5kbGVUb3VjaE1vdmVGbl8pO1xuICAgICAgICBUb3VjaFdyYXBwZXIoY29udGFpbmVyKS5vbigndG91Y2hlbmQnLCBzZWxmLmhhbmRsZVRvdWNoRW5kRm5fKTtcbiAgICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2luZXJ0aWFtb3ZlJywgXy50aHJvdHRsZShzZWxmLmhhbmRsZUluZXJ0aWFNb3ZlRm5fLCBpbmVydGlhbE1vdmV0aW1lU3BhbikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuUmVnaXN0ZXJUb3VjaEV2ZW50KCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBzZWxmLmNvbnRhaW5lcjtcblxuICAgICAgICBUb3VjaFdyYXBwZXIoY29udGFpbmVyKS5vZmYoJ3RvdWNoc3RhcnQnLCBzZWxmLmhhbmRsZVRvdWNoU3RhcnRGbl8pO1xuICAgICAgICBUb3VjaFdyYXBwZXIoY29udGFpbmVyKS5vZmYoJ3RvdWNobW92ZScsIHNlbGYuaGFuZGxlVG91Y2hNb3ZlRm5fKTtcbiAgICAgICAgVG91Y2hXcmFwcGVyKGNvbnRhaW5lcikub2ZmKCd0b3VjaGVuZCcsIHNlbGYuaGFuZGxlVG91Y2hFbmRGbl8pO1xuICAgICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5lcnRpYW1vdmUnLCBzZWxmLmhhbmRsZUluZXJ0aWFNb3ZlRm5fKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0XyhlKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmVzZXRTdGF0dXMuY2FsbChzZWxmKTtcbiAgICAgICAgdG91Y2hTdGF0dXMudG91Y2hFdmVudEluZm8gPSBbe1xuICAgICAgICAgICAgdGltZVN0YXA6IChuZXcgRGF0ZSgpLmdldFRpbWUoKSksXG4gICAgICAgICAgICB4OiBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVgsXG4gICAgICAgICAgICB5OiBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVlcbiAgICAgICAgfV07XG5cbiAgICAgICAgaWYgKGUuY2FuY2VsYWJsZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdG91Y2hTdGF0dXMudG91Y2hTdGFydEhpdEluZm8gPSBzZWxmLmxheW91dEVuZ2luZS5oaXRUZXN0KHtcbiAgICAgICAgICAgIHBhZ2VYOiBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVgsXG4gICAgICAgICAgICBwYWdlWTogZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZXG4gICAgICAgIH0pO1xuICAgICAgICB0cmlnZ2VyXyhzZWxmLm9uVG91Y2hTdGFydF8sIHNlbGYsIGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZV8oZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChlLmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyaWdnZXJfKHNlbGYub25Ub3VjaE1vdmVfLCBzZWxmLCBlKTtcbiAgICAgICAgaWYgKGUuaGFuZGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpbHRlck1lc3NhZ2UoZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRldGVjdFRvdWNoQWN0aW9uLmNhbGwoc2VsZiwgZSk7XG5cbiAgICAgICAgaWYgKHRvdWNoU3RhdHVzLnRvdWNoQWN0aW9uID09PSAncGluY2gnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAodG91Y2hTdGF0dXMudG91Y2hBY3Rpb24gPT09ICdzY3JvbGwnIHx8IHRvdWNoU3RhdHVzLnRvdWNoQWN0aW9uID09PSAnc3dpcGVzdGFydCcgfHwgdG91Y2hTdGF0dXMudG91Y2hBY3Rpb24gPT09ICdzd2lwZW1vdmluZycpIHtcbiAgICAgICAgICAgIGlmIChzaG91bGRQcm9jZXNzTW92ZV8oKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YVggPSB0b3VjaFN0YXR1cy50b3VjaEV2ZW50SW5mb1swXS54IC0gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YVkgPSB0b3VjaFN0YXR1cy50b3VjaEV2ZW50SW5mb1swXS55IC0gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IHRvdWNoU3RhdHVzLm1vdmVEaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyA/IGRlbHRhWCA6IGRlbHRhWTtcblxuICAgICAgICAgICAgICAgIGlmICh0b3VjaFN0YXR1cy50b3VjaEFjdGlvbiA9PT0gJ3Njcm9sbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5TY3JvbGwoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdG91Y2hTdGF0dXMuc3RvcEluZXJ0aWFNb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcl8oc2VsZi5vblRvdWNoU2Nyb2xsXywgc2VsZiwgZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmhhbmRsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEdyaWQuY2FsbChzZWxmLCBlLCB0b3VjaFN0YXR1cy5zdGFydE9mZnNldC5sZWZ0LCB0b3VjaFN0YXR1cy5zdGFydE9mZnNldC50b3AsIGRlbHRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG91Y2hTdGF0dXMudG91Y2hBY3Rpb24gPT09ICdzd2lwZXN0YXJ0JyB8fCB0b3VjaFN0YXR1cy50b3VjaEFjdGlvbiA9PT0gJ3N3aXBlbW92aW5nJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhblN3aXBlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJhaXNlU3dpcGVFdmVudF8uY2FsbChzZWxmLCBlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0b3VjaFN0YXR1cy50b3VjaEV2ZW50SW5mby5wdXNoKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lU3RhcDogKG5ldyBEYXRlKCkpLmdldFRpbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoRW5kXyhlKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKGUuY2FuY2VsYWJsZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJpZ2dlcl8oc2VsZi5vblRvdWNoRW5kXywgc2VsZiwgZSk7XG4gICAgICAgIC8vaWYgKGUuaGFuZGxlZCkge1xuICAgICAgICAvLyAgICByZXR1cm47XG4gICAgICAgIC8vfVxuXG4gICAgICAgIGRldGVjdFRvdWNoQWN0aW9uLmNhbGwoc2VsZiwgZSwgdHJ1ZSk7XG4gICAgICAgIGlmICh0b3VjaFN0YXR1cy50b3VjaEFjdGlvbiA9PT0gJ3BpbmNoJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKHRvdWNoU3RhdHVzLnRvdWNoQWN0aW9uID09PSAndGFwJykge1xuICAgICAgICAgICAgaWYgKFRvdWNoV3JhcHBlcigpLnNob3VsZFJhaXNlVGFwRXZlbnQoKSkge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJfKHNlbGYub25UYXBfLCBzZWxmLCB7cGFnZVg6IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVgsIHBhZ2VZOiBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYudGFwUG9pbnRfID0gZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0b3VjaFN0YXR1cy50b3VjaEFjdGlvbiA9PT0gJ3N3aXBlZW5kJykge1xuICAgICAgICAgICAgaWYgKCFjYW5Td2lwZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmFpc2VTd2lwZUV2ZW50Xy5jYWxsKHNlbGYsIGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHRvdWNoU3RhdHVzLnRvdWNoQWN0aW9uID09PSAnc2Nyb2xsJykge1xuICAgICAgICAgICAgaWYgKCFjYW5TY3JvbGwoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG91Y2hTdGF0dXMuc3RvcEluZXJ0aWFNb3ZlID0gZmFsc2U7XG4gICAgICAgICAgICBpbmVydGlhbE1vdmVTdGF0dXMgPSB7fTtcbiAgICAgICAgICAgIGluZXJ0aWFsTW92ZVN0YXR1cy52ID0gZ2V0SW5lcnRpYWxTdGFydFZlbG9jaXR5KHRvdWNoU3RhdHVzLm1vdmVEaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyA/IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggOiBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZKTtcbiAgICAgICAgICAgIGluZXJ0aWFsTW92ZVN0YXR1cy5kZWNlbGVyYXRpb24gPSAoaW5lcnRpYWxNb3ZlU3RhdHVzLnYgPCAwID8gMSA6IC0xKSAqIDAuMDAwNjtcbiAgICAgICAgICAgIGluZXJ0aWFsTW92ZVN0YXR1cy52ID0gTWF0aC5hYnMoaW5lcnRpYWxNb3ZlU3RhdHVzLnYpID4gMi4wID8gKGluZXJ0aWFsTW92ZVN0YXR1cy52IDwgMCA/IC0yLjAgOiAyLjApIDogaW5lcnRpYWxNb3ZlU3RhdHVzLnY7XG4gICAgICAgICAgICBpbmVydGlhbE1vdmVTdGF0dXMuZWxlbWVudCA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICAgICAgaW5lcnRpYWxNb3ZlU3RhdHVzLm1vdmVJbnRlcnZhbCA9IHNldEludGVydmFsKHJhaXNlSW5lcnRpYU1vdmUsIGluZXJ0aWFsTW92ZXRpbWVTcGFuKTtcbiAgICAgICAgICAgIGluZXJ0aWFsTW92ZVN0YXR1cy50b3BsZWZ0RGVsdGEgPSAwO1xuICAgICAgICAgICAgaW5lcnRpYWxNb3ZlU3RhdHVzLnJpZ2h0Ym90dG9tRGVsdGEgPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlSW5lcnRpYU1vdmVfKGUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcm93SGVpZ2h0ID0gc2VsZi5vcHRpb25zLnJvd0hlaWdodDtcbiAgICAgICAgdmFyIG5vd1YgPSBpbmVydGlhbE1vdmVTdGF0dXMudiArIGluZXJ0aWFsTW92ZXRpbWVTcGFuICogaW5lcnRpYWxNb3ZlU3RhdHVzLmRlY2VsZXJhdGlvbjtcbiAgICAgICAgdmFyIHZpc1plcm8gPSBpbmVydGlhbE1vdmVTdGF0dXMuZGVjZWxlcmF0aW9uICogbm93ViA+IDA7XG4gICAgICAgIHZhciBpc0hvcml6b250YWwgPSB0b3VjaFN0YXR1cy5tb3ZlRGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCc7XG4gICAgICAgIHZhciBsYXlvdXRJbmZvID0gc2VsZi5sYXlvdXRFbmdpbmUuZ2V0TGF5b3V0SW5mbygpO1xuICAgICAgICB2YXIgdmlld1BvcnRJbmZvID0gbGF5b3V0SW5mby52aWV3cG9ydDtcbiAgICAgICAgaWYgKCF2aWV3UG9ydEluZm8pIHtcbiAgICAgICAgICAgIGlmIChpbmVydGlhbE1vdmVTdGF0dXMubW92ZUludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbmVydGlhbE1vdmVTdGF0dXMubW92ZUludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZWZ0VG9wID0gaXNIb3Jpem9udGFsID8gc2VsZi5zY3JvbGxPZmZzZXQubGVmdCA6IHNlbGYuc2Nyb2xsT2Zmc2V0LnRvcDtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGlzSG9yaXpvbnRhbCA/IHZpZXdQb3J0SW5mby53aWR0aCA6IHZpZXdQb3J0SW5mby5oZWlnaHQ7XG4gICAgICAgIHZhciByaWdodEJvdHRvbSA9IGlzSG9yaXpvbnRhbCA/IHNlbGYuc2Nyb2xsT2Zmc2V0LmxlZnQgKyBsZW5ndGggOiBzZWxmLnNjcm9sbE9mZnNldC50b3AgKyBsZW5ndGg7XG4gICAgICAgIHZhciBtYXhMZWZ0VG9wID0gLU1BWEZFRURCQUNLT0ZGU0VUO1xuICAgICAgICB2YXIgY29udGVudGxlbmd0aCA9IGlzSG9yaXpvbnRhbCA/IHZpZXdQb3J0SW5mby5jb250ZW50V2lkdGggOiB2aWV3UG9ydEluZm8uY29udGVudEhlaWdodDtcbiAgICAgICAgdmFyIG1heFJpZ2h0Qm90dG9tID0gY29udGVudGxlbmd0aCArIE1BWEZFRURCQUNLT0ZGU0VUO1xuICAgICAgICB2YXIgc2Nyb2xsYWJsZSA9IGNvbnRlbnRsZW5ndGggPiBsZW5ndGg7XG4gICAgICAgIHZhciBiYXNlbGVmdCA9IHNlbGYuc2Nyb2xsT2Zmc2V0LmxlZnQ7XG4gICAgICAgIHZhciBiYXNldG9wID0gc2VsZi5zY3JvbGxPZmZzZXQudG9wO1xuXG4gICAgICAgIGlmICh2aXNaZXJvKSB7XG4gICAgICAgICAgICB0b3VjaFN0YXR1cy5zdG9wSW5lcnRpYU1vdmUgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCF2aXNaZXJvICYmIChsZWZ0VG9wIDwgbWF4TGVmdFRvcCB8fCByaWdodEJvdHRvbSA+IG1heFJpZ2h0Qm90dG9tKSkge1xuICAgICAgICAgICAgdG91Y2hTdGF0dXMuc3RvcEluZXJ0aWFNb3ZlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3VjaFN0YXR1cy5zdG9wSW5lcnRpYU1vdmUpIHtcbiAgICAgICAgICAgIGlmIChsZWZ0VG9wIDwgMCB8fCAhc2Nyb2xsYWJsZSkge1xuICAgICAgICAgICAgICAgIGJhc2VsZWZ0ID0gaXNIb3Jpem9udGFsID8gMCA6IHNlbGYuc2Nyb2xsT2Zmc2V0LmxlZnQ7XG4gICAgICAgICAgICAgICAgYmFzZXRvcCA9IGlzSG9yaXpvbnRhbCA/IHNlbGYuc2Nyb2xsT2Zmc2V0LnRvcCA6IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0Qm90dG9tID4gY29udGVudGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGJhc2VsZWZ0ID0gaXNIb3Jpem9udGFsID8gY29udGVudGxlbmd0aCAtIHZpZXdQb3J0SW5mby53aWR0aCA6IHNlbGYuc2Nyb2xsT2Zmc2V0LmxlZnQ7XG4gICAgICAgICAgICAgICAgYmFzZXRvcCA9IGlzSG9yaXpvbnRhbCA/IHNlbGYuc2Nyb2xsT2Zmc2V0LnRvcCA6IGNvbnRlbnRsZW5ndGggLSB2aWV3UG9ydEluZm8uaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2Nyb2xsR3JpZC5jYWxsKHNlbGYsIGUsIGJhc2VsZWZ0LCBiYXNldG9wLCAwKTtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW5lcnRpYWxNb3ZlU3RhdHVzLm1vdmVJbnRlcnZhbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVsdGEgPSAobm93ViArIGluZXJ0aWFsTW92ZVN0YXR1cy52KSAvIDIgKiBpbmVydGlhbE1vdmV0aW1lU3BhbjtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRlbHRhIDwgMCA/IC0xIDogMTtcbiAgICAgICAgZGVsdGEgPSBNYXRoLmFicyhNYXRoLmZsb29yKGRlbHRhKSk7XG4gICAgICAgIHZhciBtaW5WYWx1ZSA9IChyb3dIZWlnaHQgLyAzKSAqIDI7XG4gICAgICAgIHZhciBtYXhWYWx1ZSA9IChyb3dIZWlnaHQgLyAzKSAqIDQ7XG5cbiAgICAgICAgaWYgKGRlbHRhID4gbWluVmFsdWUgJiYgZGVsdGEgPCBtYXhWYWx1ZSkge1xuICAgICAgICAgICAgZGVsdGEgPSBtaW5WYWx1ZSAqIGRpcmVjdGlvbjtcbiAgICAgICAgICAgIGluZXJ0aWFsTW92ZVN0YXR1cy52ID0gZGVsdGEgLyBpbmVydGlhbE1vdmV0aW1lU3BhbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhID0gZGVsdGEgKiBkaXJlY3Rpb247XG4gICAgICAgICAgICBpbmVydGlhbE1vdmVTdGF0dXMudiA9IG5vd1Y7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVmdFRvcCA8IDApIHtcbiAgICAgICAgICAgIGluZXJ0aWFsTW92ZVN0YXR1cy50b3BsZWZ0RGVsdGEgKz0gZGVsdGE7XG4gICAgICAgICAgICBiYXNlbGVmdCA9IGlzSG9yaXpvbnRhbCA/IDAgOiBzZWxmLnNjcm9sbE9mZnNldC5sZWZ0O1xuICAgICAgICAgICAgYmFzZXRvcCA9IGlzSG9yaXpvbnRhbCA/IHNlbGYuc2Nyb2xsT2Zmc2V0LnRvcCA6IDA7XG4gICAgICAgICAgICBzY3JvbGxHcmlkLmNhbGwoc2VsZiwgZSwgYmFzZWxlZnQsIGJhc2V0b3AsIGluZXJ0aWFsTW92ZVN0YXR1cy50b3BsZWZ0RGVsdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0Qm90dG9tID4gY29udGVudGxlbmd0aCAmJiBzY3JvbGxhYmxlKSB7XG4gICAgICAgICAgICBpbmVydGlhbE1vdmVTdGF0dXMucmlnaHRib3R0b21EZWx0YSArPSBkZWx0YTtcbiAgICAgICAgICAgIGJhc2VsZWZ0ID0gaXNIb3Jpem9udGFsID8gY29udGVudGxlbmd0aCAtIHZpZXdQb3J0SW5mby53aWR0aCA6IHNlbGYuc2Nyb2xsT2Zmc2V0LmxlZnQ7XG4gICAgICAgICAgICBiYXNldG9wID0gaXNIb3Jpem9udGFsID8gc2VsZi5zY3JvbGxPZmZzZXQudG9wIDogY29udGVudGxlbmd0aCAtIHZpZXdQb3J0SW5mby5oZWlnaHQ7XG4gICAgICAgICAgICBzY3JvbGxHcmlkLmNhbGwoc2VsZiwgZSwgYmFzZWxlZnQsIGJhc2V0b3AsIGluZXJ0aWFsTW92ZVN0YXR1cy5yaWdodGJvdHRvbURlbHRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjcm9sbEdyaWQuY2FsbChzZWxmLCBlLCBzZWxmLnNjcm9sbE9mZnNldC5sZWZ0LCBzZWxmLnNjcm9sbE9mZnNldC50b3AsIGRlbHRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJhaXNlU3dpcGVFdmVudF8oZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBpc0hvcml6b250YWwgPSB0b3VjaFN0YXR1cy5tb3ZlRGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCc7XG4gICAgICAgIHZhciBpc1N3aXBlRW5kID0gdG91Y2hTdGF0dXMudG91Y2hBY3Rpb24gPT09ICdzd2lwZWVuZCc7XG4gICAgICAgIHZhciBub3dMb2NhdGlvbiA9IGlzSG9yaXpvbnRhbCA/IChpc1N3aXBlRW5kID8gZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCA6IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCkgOiAoaXNTd2lwZUVuZCA/IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkgOiBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVkpO1xuICAgICAgICBlLnN3aXBlU3RhdHVzID0gdG91Y2hTdGF0dXMudG91Y2hBY3Rpb247XG4gICAgICAgIGUubW92ZURpc3RhbmNlID0gaXNIb3Jpem9udGFsID8gKHRvdWNoU3RhdHVzLnRvdWNoRXZlbnRJbmZvWzBdLnggLSBub3dMb2NhdGlvbikgOiAodG91Y2hTdGF0dXMudG91Y2hFdmVudEluZm9bMF0ueSAtIG5vd0xvY2F0aW9uKTtcbiAgICAgICAgZS52ZWxvY2l0eSA9IGdldEluZXJ0aWFsU3RhcnRWZWxvY2l0eShub3dMb2NhdGlvbik7XG4gICAgICAgIHRyaWdnZXJfKHNlbGYub25Td2lwZV8sIHNlbGYsIGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblNjcm9sbCgpIHtcbiAgICAgICAgdmFyIGhpdEluZm8gPSB0b3VjaFN0YXR1cy50b3VjaFN0YXJ0SGl0SW5mbztcbiAgICAgICAgdmFyIGluUGlubmVkVmlld1BvcnQgPSBoaXRJbmZvICYmIGhpdEluZm8uYXJlYSAmJiBoaXRJbmZvLmFyZWEuaW5kZXhPZigncGlubmVkJykgPiAtMTtcbiAgICAgICAgaWYgKGluUGlubmVkVmlld1BvcnQgJiYgdG91Y2hTdGF0dXMubW92ZURpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Td2lwZSgpIHtcbiAgICAgICAgdmFyIGhpdEluZm8gPSB0b3VjaFN0YXR1cy50b3VjaFN0YXJ0SGl0SW5mbztcbiAgICAgICAgdmFyIGluUGlubmVkVmlld1BvcnQgPSBoaXRJbmZvICYmIGhpdEluZm8uYXJlYSAmJiBoaXRJbmZvLmFyZWEuaW5kZXhPZigncGlubmVkJykgPiAtMTtcbiAgICAgICAgaWYgKGluUGlubmVkVmlld1BvcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoaXRJbmZvICYmIGhpdEluZm8uYXJlYSA9PT0gJ3ZpZXdwb3J0JyAmJiBoaXRJbmZvLnJvdyA9PT0gLTEgJiYgaGl0SW5mby5jb2x1bW4gPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoaGl0SW5mby5ncm91cEluZm8gJiYgKGhpdEluZm8uZ3JvdXBJbmZvLmFyZWEgPT09ICdncm91cEhlYWRlcicgfHwgaGl0SW5mby5ncm91cEluZm8uYXJlYSA9PT0gJ2dyb3VwRm9vdGVyJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG91bGRQcm9jZXNzTW92ZV8oKSB7XG4gICAgICAgIHZhciBwcmV2aW91c0V2ZW50SW5mbyA9IHRvdWNoU3RhdHVzLnRvdWNoRXZlbnRJbmZvW3RvdWNoU3RhdHVzLnRvdWNoRXZlbnRJbmZvLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgcHJvY2Vzc01vdmUgPSAoKG5ldyBEYXRlKCkuZ2V0VGltZSgpKSAtIHByZXZpb3VzRXZlbnRJbmZvLnRpbWVTdGFwKSA+IDEwMDAgLyA4MCB8fCB0b3VjaFN0YXR1cy50b3VjaEV2ZW50SW5mby5sZW5ndGggPT09IDE7XG5cbiAgICAgICAgcmV0dXJuIHByb2Nlc3NNb3ZlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJhaXNlSW5lcnRpYU1vdmUoKSB7XG4gICAgICAgIGlmICghdG91Y2hTdGF0dXMuc3RvcEluZXJ0aWFNb3ZlKSB7XG4gICAgICAgICAgICB2YXIgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KCdpbmVydGlhbW92ZScsIHtidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlfSk7XG4gICAgICAgICAgICBpbmVydGlhbE1vdmVTdGF0dXMuZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNldFN0YXR1cygpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0b3VjaFN0YXR1cyA9IHt9O1xuICAgICAgICB0b3VjaFN0YXR1cy5zdG9wSW5lcnRpYU1vdmUgPSB0cnVlO1xuICAgICAgICB0b3VjaFN0YXR1cy5zdGFydE9mZnNldCA9IHNlbGYuc2Nyb2xsT2Zmc2V0O1xuICAgICAgICB0b3VjaFN0YXR1cy5zdG9wRmVlZEJhY2sgPSB0cnVlO1xuXG4gICAgICAgIGlmIChpbmVydGlhbE1vdmVTdGF0dXMpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW5lcnRpYWxNb3ZlU3RhdHVzLm1vdmVJbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi50YXBQb2ludF8gPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRldGVjdFRvdWNoQWN0aW9uKGUsIHRvdWNoRW5kKSB7XG4gICAgICAgIHZhciB0b3VjaFN0YXJ0RXZlbnQgPSB0b3VjaFN0YXR1cy50b3VjaEV2ZW50SW5mbztcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAodG91Y2hTdGFydEV2ZW50KSB7XG4gICAgICAgICAgICBpZiAodG91Y2hFbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAodG91Y2hTdGFydEV2ZW50WzBdLnggPT09IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggJiYgdG91Y2hTdGFydEV2ZW50WzBdLnkgPT09IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2hTdGF0dXMudG91Y2hBY3Rpb24gPSAndGFwJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRvdWNoU3RhdHVzLnRvdWNoQWN0aW9uID09PSAnc3dpcGVtb3ZpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoU3RhdHVzLnRvdWNoQWN0aW9uID0gJ3N3aXBlZW5kJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB0b3VjaFN0YXR1cy50b3VjaEFjdGlvbiA9ICdwaW5jaCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b3VjaFN0YXR1cy50b3VjaEFjdGlvbiA9PT0gJ3N3aXBlc3RhcnQnIHx8IHRvdWNoU3RhdHVzLnRvdWNoQWN0aW9uID09PSAnc3dpcGVtb3ZpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoU3RhdHVzLnRvdWNoQWN0aW9uID0gJ3N3aXBlbW92aW5nJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRvdWNoU3RhdHVzLnRvdWNoQWN0aW9uID09PSAnc2Nyb2xsJykge1xuICAgICAgICAgICAgICAgICAgICB0b3VjaFN0YXR1cy50b3VjaEFjdGlvbiA9ICdzY3JvbGwnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdXBkYXRlTW92ZURpcmVjdGlvbihlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhWCA9IHRvdWNoU3RhdHVzLnRvdWNoRXZlbnRJbmZvWzBdLnggLSBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YVkgPSB0b3VjaFN0YXR1cy50b3VjaEV2ZW50SW5mb1swXS55IC0gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMuYWxsb3dTd2lwZSAmJiBzZWxmLmxheW91dEVuZ2luZS5jYW5Eb1N3aXBlXyh0b3VjaFN0YXR1cy5tb3ZlRGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYubGF5b3V0RW5naW5lLmNhblN0YXJ0U3dpcGVfKGRlbHRhWCwgZGVsdGFZKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdWNoU3RhdHVzLnRvdWNoQWN0aW9uID0gJ3N3aXBlc3RhcnQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG91Y2hTdGF0dXMudG91Y2hBY3Rpb24gPSAnc2Nyb2xsJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbHRlck1lc3NhZ2UoZSkge1xuICAgICAgICB2YXIgdG91Y2hTdGFydEV2ZW50ID0gdG91Y2hTdGF0dXMudG91Y2hFdmVudEluZm87XG4gICAgICAgIGlmICh0b3VjaFN0YXJ0RXZlbnQpIHtcbiAgICAgICAgICAgIGlmICh0b3VjaFN0YXJ0RXZlbnRbMF0ueCA9PT0gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYICYmIHRvdWNoU3RhcnRFdmVudFswXS55ID09PSBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEluZXJ0aWFsU3RhcnRWZWxvY2l0eShub3dMb2NhdGlvbikge1xuICAgICAgICB2YXIgaW5kZXggPSB0b3VjaFN0YXR1cy50b3VjaEV2ZW50SW5mby5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgbGFzdEV2ZW50ID0gdG91Y2hTdGF0dXMudG91Y2hFdmVudEluZm9baW5kZXhdO1xuICAgICAgICB2YXIgbG9jYXRpb24gPSB0b3VjaFN0YXR1cy5tb3ZlRGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyBsYXN0RXZlbnQueCA6IGxhc3RFdmVudC55O1xuICAgICAgICB2YXIgbm93VGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cbiAgICAgICAgd2hpbGUgKGxvY2F0aW9uID09PSBub3dMb2NhdGlvbikge1xuICAgICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbGFzdEV2ZW50ID0gdG91Y2hTdGF0dXMudG91Y2hFdmVudEluZm9baW5kZXhdO1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gdG91Y2hTdGF0dXMubW92ZURpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gbGFzdEV2ZW50LnggOiBsYXN0RXZlbnQueTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChsb2NhdGlvbiAtIG5vd0xvY2F0aW9uKSAvIChub3dUaW1lIC0gbGFzdEV2ZW50LnRpbWVTdGFwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVNb3ZlRGlyZWN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0b3VjaFN0YXR1cy5tb3ZlRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWDtcbiAgICAgICAgICAgIHZhciB5ID0gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdG91Y2hTdGF0dXMudG91Y2hFdmVudEluZm8ubGVuZ3RoIC0gMTtcblxuICAgICAgICAgICAgdmFyIGxhc3RFdmVudEluZm8gPSB0b3VjaFN0YXR1cy50b3VjaEV2ZW50SW5mb1tpbmRleF07XG4gICAgICAgICAgICB2YXIgbW92ZVggPSB4IC0gbGFzdEV2ZW50SW5mby54O1xuICAgICAgICAgICAgdmFyIG1vdmVZID0geSAtIGxhc3RFdmVudEluZm8ueTtcblxuICAgICAgICAgICAgaWYgKG1vdmVYID09PSBtb3ZlWSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG91Y2hTdGF0dXMubW92ZURpcmVjdGlvbiA9IE1hdGguYWJzKG1vdmVZKSA+IE1hdGguYWJzKG1vdmVYKSA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjcm9sbEdyaWQoZSwgbGVmdCwgdG9wLCBkZWx0YSkge1xuICAgICAgICBpZiAodG91Y2hTdGF0dXMubW92ZURpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICBzY3JvbGxHcmlkSG9yaXpvbnRhbC5jYWxsKHRoaXMsIGUsIGxlZnQsIHRvcCwgZGVsdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2Nyb2xsR3JpZFZlcnRpY2FsLmNhbGwodGhpcywgZSwgbGVmdCwgdG9wLCBkZWx0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY3JvbGxHcmlkSG9yaXpvbnRhbChlLCBsZWZ0LCB0b3AsIGRlbHRhKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGxheW91dEluZm8gPSBzZWxmLmxheW91dEVuZ2luZS5nZXRMYXlvdXRJbmZvKCk7XG4gICAgICAgIHZhciB2aWV3UG9ydEluZm8gPSBsYXlvdXRJbmZvLnZpZXdwb3J0O1xuICAgICAgICBpZiAoIXZpZXdQb3J0SW5mbykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHZpZXdQb3J0SW5mby53aWR0aDtcbiAgICAgICAgdmFyIGNvbnRlbnRMZW5ndGggPSB2aWV3UG9ydEluZm8uY29udGVudFdpZHRoO1xuICAgICAgICB2YXIgc2Nyb2xsYWJsZSA9IGNvbnRlbnRMZW5ndGggPiBsZW5ndGg7XG4gICAgICAgIGxlZnQgKz0gZGVsdGE7XG5cbiAgICAgICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICAgICAgICBsZWZ0ID0gR2V0Qm91bmRhcnlWYWxldShsZWZ0KTtcbiAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICsgbGVuZ3RoID4gY29udGVudExlbmd0aCAmJiBzY3JvbGxhYmxlKSB7XG4gICAgICAgICAgICBsZWZ0ID0gY29udGVudExlbmd0aCAtIGxlbmd0aCArIEdldEJvdW5kYXJ5VmFsZXUobGVmdCArIGxlbmd0aCAtIGNvbnRlbnRMZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5zY3JvbGxPZmZzZXQgPSB7XG4gICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgIGxlZnQ6IGxlZnRcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRlbHRhKSB7XG4gICAgICAgICAgICBzZWxmLnNjb2xsRGlyZWN0aW9uID0gZGVsdGEgPiAwID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgICAgICBlLnNjcm9sbERpcmVjdGlvbiA9IHNlbGYuc2NvbGxEaXJlY3Rpb247XG4gICAgICAgIHNlbGYubGF5b3V0RW5naW5lLmhhbmRsZVNjcm9sbChlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY3JvbGxHcmlkVmVydGljYWwoZSwgbGVmdCwgdG9wLCBkZWx0YSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBsYXlvdXRJbmZvID0gc2VsZi5sYXlvdXRFbmdpbmUuZ2V0TGF5b3V0SW5mbygpO1xuICAgICAgICB2YXIgdmlld1BvcnRJbmZvID0gbGF5b3V0SW5mby52aWV3cG9ydDtcbiAgICAgICAgaWYgKCF2aWV3UG9ydEluZm8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuZ3RoID0gdmlld1BvcnRJbmZvLmhlaWdodDtcbiAgICAgICAgdmFyIGNvbnRlbnRIZWlnaHQgPSB2aWV3UG9ydEluZm8uY29udGVudEhlaWdodDtcbiAgICAgICAgdmFyIHNjcm9sbGFibGUgPSBjb250ZW50SGVpZ2h0ID4gbGVuZ3RoO1xuICAgICAgICB0b3AgKz0gZGVsdGE7XG5cbiAgICAgICAgaWYgKHRvcCA8IDApIHtcbiAgICAgICAgICAgIHRvcCA9IEdldEJvdW5kYXJ5VmFsZXUodG9wKTtcbiAgICAgICAgfSBlbHNlIGlmICh0b3AgKyBsZW5ndGggPiBjb250ZW50SGVpZ2h0ICYmIHNjcm9sbGFibGUpIHtcbiAgICAgICAgICAgIHRvcCA9IGNvbnRlbnRIZWlnaHQgLSBsZW5ndGggKyBHZXRCb3VuZGFyeVZhbGV1KHRvcCArIGxlbmd0aCAtIGNvbnRlbnRIZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5zY3JvbGxPZmZzZXQgPSB7XG4gICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgIGxlZnQ6IGxlZnRcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRlbHRhKSB7XG4gICAgICAgICAgICBzZWxmLnNjb2xsRGlyZWN0aW9uID0gZGVsdGEgPiAwID8gJ3VwJyA6ICdkb3duJztcbiAgICAgICAgfVxuICAgICAgICBlLnNjcm9sbERpcmVjdGlvbiA9IHNlbGYuc2NvbGxEaXJlY3Rpb247XG4gICAgICAgIHNlbGYubGF5b3V0RW5naW5lLmhhbmRsZVNjcm9sbChlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBHZXRCb3VuZGFyeVZhbGV1KHZhbHVlKSB7XG4gICAgICAgIHZhciBfdHJhbnNsYXRlT2Zmc2V0WSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gR2V0Qm91bmRhcnlGYWN0b3IoTWF0aC5hYnMoX3RyYW5zbGF0ZU9mZnNldFkpLCBNQVhTQ1JPTExBQkxFVkVSVElDQUxPRkZTRVQpICogKF90cmFuc2xhdGVPZmZzZXRZID4gMCA/IDEgOiAtMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gR2V0Qm91bmRhcnlGYWN0b3IoaW5wdXQsIGJvdW5kYXJ5KSB7XG4gICAgICAgIHJldHVybiAtYm91bmRhcnkgLyAoaW5wdXQgLyBib3VuZGFyeSArIDEuMCkgKyBib3VuZGFyeTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVDbGljayhlKSB7XG4gICAgICAgIHZhciBncmlkID0gdGhpcztcbiAgICAgICAgdmFyIHRhcFBvaW50ID0gZ3JpZC50YXBQb2ludF87XG4gICAgICAgIGlmICh0YXBQb2ludCkge1xuICAgICAgICAgICAgaWYgKHRhcFBvaW50LnBhZ2VYID09PSBlLnBhZ2VYICYmIHRhcFBvaW50LnBhZ2VZID09PSBlLnBhZ2VZICYmIHRhcFBvaW50LnRhcmdldCA9PT0gZS50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyXyh0aGlzLm9uVGFwXywgZ3JpZCwge3BhZ2VYOiB0YXBQb2ludC5wYWdlWCwgcGFnZVk6IHRhcFBvaW50LnBhZ2VZfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJfKHRoaXMub25Nb3VzZUNsaWNrLCB0aGlzLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyaWQudGFwUG9pbnRfID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyaWdnZXJfKHRoaXMub25Nb3VzZUNsaWNrLCB0aGlzLCBlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZURvdWJsZUNsaWNrKGUpIHtcbiAgICAgICAgdHJpZ2dlcl8odGhpcy5vbk1vdXNlRGJDbGljaywgdGhpcywgZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlTW91c2VVcChlKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgc2VsZi5zY3JvbGxpbmdfID0gZmFsc2U7XG4gICAgICAgIHRyaWdnZXJfKHNlbGYub25Nb3VzZVVwLCBzZWxmLCBlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oZSkge1xuICAgICAgICB0cmlnZ2VyXyh0aGlzLm9uTW91c2VEb3duLCB0aGlzLCBlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZVdoZWVsKGUpIHtcbiAgICAgICAgY2hhbmdlU2Nyb2xsUGFuZWxaaW5kZXguY2FsbCh0aGlzKTtcbiAgICAgICAgdHJpZ2dlcl8odGhpcy5vbk1vdXNlV2hlZWwsIHRoaXMsIGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZShlKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCFzZWxmLnNjcm9sbGluZ18pIHtcbiAgICAgICAgICAgIHRyaWdnZXJfKHNlbGYub25Nb3VzZU1vdmUsIHNlbGYsIGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlS2V5RG93bihlKSB7XG4gICAgICAgIHRyaWdnZXJfKHRoaXMub25LZXlEb3duLCB0aGlzLCBlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVXaW5kb3dSZXNpemVfKCkge1xuICAgICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTY3JvbGxfKGUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgIHZhciBzY3JvbGxEaXJlY3Rpb247XG4gICAgICAgIGlmICghc2VsZi5sYXlvdXRFbmdpbmUuaXNSZXNpemluZ0NvbF8pIHtcbiAgICAgICAgICAgIHNlbGYuc2Nyb2xsaW5nXyA9IHRydWU7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAoIWdjVXRpbHMuaXNVbmRlZmluZWQoc2VsZi5hc3luUmVuZGVyVGltZXJfKSkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChzZWxmLmFzeW5SZW5kZXJUaW1lcl8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdpbmRvdyAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsRGlyZWN0aW9uID0gc2VsZi5zY3JvbGxPZmZzZXQudG9wID4gdGFyZ2V0LnNjcm9sbFRvcCA/ICdkb3duJyA6ICd1cCc7XG4gICAgICAgICAgICAgICAgICAgIGUuc2Nyb2xsRGlyZWN0aW9uID0gc2Nyb2xsRGlyZWN0aW9uO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSB0YXJnZXQuY2xhc3NOYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lLmluZGV4T2YoJ3Njcm9sbC10b3AnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbE9mZnNldC50b3AgPSB0YXJnZXQuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUuaW5kZXhPZignc2Nyb2xsLWxlZnQnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbE9mZnNldC5sZWZ0ID0gdGFyZ2V0LnNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzZWxmLmxheW91dEVuZ2luZS5oYW5kbGVTY3JvbGwoZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVDb2xsZWN0aW9uQ2hhbmdlZF8oKSB7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVNjb2xsT3Zlcl8oc2VuZGVyLCBhcmdzKSB7XG4gICAgICAgIHN0YXJ0QXN5bmNSZW5kZXJfLmNhbGwodGhpcywgYXJncy5zY3JvbGxEaXJlY3Rpb24pO1xuICAgIH1cblxuICAgIC8vZmluZHMgdGhlIG1pbmltdW0gc3RlcCB0byB1cGRhdGUgb3JpZ2luYWxDb2xsZWN0aW9uIHRvIHRhcmdldENvbGxlY3Rpb25cbiAgICBmdW5jdGlvbiBmaW5kTWluaW11bU9wZXJhdGlvbnNfKG9yaWdpbmFsQ29sbGVjdGlvbiwgdGFyZ2V0Q29sbGVjdGlvbikge1xuICAgICAgICB2YXIgbjEgPSBvcmlnaW5hbENvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgICB2YXIgbjIgPSB0YXJnZXRDb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgICAgdmFyIG9wZXJhdGlvbiA9IFtdO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGo7XG4gICAgICAgIHZhciBtaW5kaXMgPSBbXTtcblxuICAgICAgICBpZiAobjEgPT09IDApIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246ICdpbnNlcnQnLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgaXRlbTogdGFyZ2V0Q29sbGVjdGlvbltpXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobjIgPT09IDApIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246ICdkZWxldGUnLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogbjEgLSBpIC0gMVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8PSBuMTsgaSsrKSB7XG4gICAgICAgICAgICBtaW5kaXNbaV0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPD0gbjE7IGkrKykge1xuICAgICAgICAgICAgbWluZGlzW2ldWzBdID0gaTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPD0gbjI7IGkrKykge1xuICAgICAgICAgICAgbWluZGlzWzBdW2ldID0gaTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPD0gbjE7IGkrKykge1xuICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8PSBuMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsQ29sbGVjdGlvbltpIC0gMV0gPT09IHRhcmdldENvbGxlY3Rpb25baiAtIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbmRpc1tpXVtqXSA9IG1pbmRpc1tpIC0gMV1baiAtIDFdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbmRpc1tpXVtqXSA9IE1hdGgubWluKG1pbmRpc1tpIC0gMV1bal0gKyAxLCBtaW5kaXNbaV1baiAtIDFdICsgMSwgbWluZGlzW2kgLSAxXVtqIC0gMV0gKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpID0gbjE7XG4gICAgICAgIGogPSBuMjtcbiAgICAgICAgd2hpbGUgKGkgPj0gMSB8fCBqID49IDEpIHtcbiAgICAgICAgICAgIGlmIChpID49IDEgJiYgaiA+PSAxICYmIChvcmlnaW5hbENvbGxlY3Rpb25baSAtIDFdID09PSB0YXJnZXRDb2xsZWN0aW9uW2ogLSAxXSkpIHtcbiAgICAgICAgICAgICAgICBpID0gaSAtIDE7XG4gICAgICAgICAgICAgICAgaiA9IGogLSAxO1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiAndXBkYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA+PSAxICYmIChtaW5kaXNbaV1bal0gPT09IG1pbmRpc1tpIC0gMV1bal0gKyAxKSkge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiAnZGVsZXRlJyxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGkgLSAxXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaSA9IGkgLSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChqID49IDEgJiYgKG1pbmRpc1tpXVtqXSA9PT0gbWluZGlzW2ldW2ogLSAxXSArIDEpKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246ICdpbnNlcnQnLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgaXRlbTogdGFyZ2V0Q29sbGVjdGlvbltqIC0gMV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBqID0gaiAtIDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgPj0gMSAmJiBqID49IDEpIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogJ3JlcGxhY2UnLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogW2kgLSAxLCBqIC0gMV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpID0gaSAtIDE7XG4gICAgICAgICAgICAgICAgaiA9IGogLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcGVyYXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluZFNjcm9sbE1pbmltdW1PcGVyYXRpb25zKG9yaWdpbmFsQ29sbGVjdGlvbiwgdGFyZ2V0Q29sbGVjdGlvbikge1xuICAgICAgICAvL3ZhciBzMSA9IF8uZGlmZmVyZW5jZShvcmlnaW5hbENvbGxlY3Rpb24sIHRhcmdldENvbGxlY3Rpb24pO1xuICAgICAgICAvL3ZhciBzMiA9IF8uZGlmZmVyZW5jZSh0YXJnZXRDb2xsZWN0aW9uLCBvcmlnaW5hbENvbGxlY3Rpb24pO1xuICAgICAgICAvL3ZhciBpO1xuICAgICAgICAvL3ZhciBsZW4gPSBNYXRoLm1pbihzMS5sZW5ndGgsIHMyLmxlbmd0aCk7XG4gICAgICAgIC8vdmFyIG9wZXJhdGlvbiA9IFtdO1xuICAgICAgICAvL2ZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyAgICBvcGVyYXRpb24ucHVzaCh7XG4gICAgICAgIC8vICAgICAgICBvcGVyYXRpb246ICdyZXBsYWNlJyxcbiAgICAgICAgLy8gICAgICAgIGluZGV4OiBbczFbaV0sIHMyW2ldXVxuICAgICAgICAvLyAgICB9KTtcbiAgICAgICAgLy99XG4gICAgICAgIC8vXG4gICAgICAgIC8vZm9yICg7IGkgPCBzMS5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyAgICBvcGVyYXRpb24ucHVzaCh7XG4gICAgICAgIC8vICAgICAgICBvcGVyYXRpb246ICdkZWxldGUnLFxuICAgICAgICAvLyAgICAgICAgaW5kZXg6IHMxW2ldXG4gICAgICAgIC8vICAgIH0pO1xuICAgICAgICAvL31cbiAgICAgICAgLy9cbiAgICAgICAgLy9pID0gbGVuO1xuICAgICAgICAvL1xuICAgICAgICAvL2ZvciAoOyBpIDwgczIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gICAgb3BlcmF0aW9uLnB1c2goe1xuICAgICAgICAvLyAgICAgICAgb3BlcmF0aW9uOiAnaW5zZXJ0JyxcbiAgICAgICAgLy8gICAgICAgIGluZGV4OiBzMltpXVxuICAgICAgICAvLyAgICB9KTtcbiAgICAgICAgLy99XG4gICAgICAgIC8vcmV0dXJuIG9wZXJhdGlvbjtcbiAgICAgICAgdmFyIHMxID0gb3JpZ2luYWxDb2xsZWN0aW9uO1xuICAgICAgICB2YXIgczIgPSB0YXJnZXRDb2xsZWN0aW9uO1xuICAgICAgICB2YXIgbjEgPSBzMS5sZW5ndGg7XG4gICAgICAgIHZhciBuMiA9IHMyLmxlbmd0aDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgaiA9IDA7XG4gICAgICAgIHZhciBvcGVyYXRpb24gPSBbXTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gczIuaW5kZXhPZihzMVswXSk7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gczEuaW5kZXhPZihzMlswXSk7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHBvc2l0aW9uOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogJ2RlbGV0ZScsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBzMVtpXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICg7IGogPCBwb3NpdGlvbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246ICdpbnNlcnQnLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogczJbal1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChpIDwgbjEgJiYgaiA8IG4yKSB7XG4gICAgICAgICAgICBpZiAoczFbaV0gIT09IHMyW2pdKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDsgaSA8IG4xOyBpKyspIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbi5wdXNoKHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246ICdkZWxldGUnLFxuICAgICAgICAgICAgICAgIGluZGV4OiBzMVtpXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDsgaiA8IG4yOyBqKyspIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbi5wdXNoKHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246ICdpbnNlcnQnLFxuICAgICAgICAgICAgICAgIGluZGV4OiBzMltqXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3BlcmF0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUdyb3VwU3RyYXRlZ3lfKHNlbGYpIHtcbiAgICAgICAgdmFyIGdyaWQgPSBzZWxmLmdyaWQ7XG4gICAgICAgIHZhciBncm91cFN0cmF0ZWd5T2JqID0gc2VsZi5vcHRpb25zLmdyb3VwU3RyYXRlZ3k7XG4gICAgICAgIGlmIChncmlkLmRhdGEuZ3JvdXBzICYmIGdyb3VwU3RyYXRlZ3lPYmopIHtcbiAgICAgICAgICAgIHZhciBzdHJhdGVneSA9IGdyb3VwU3RyYXRlZ3lPYmoubmFtZTtcbiAgICAgICAgICAgIHZhciBncm91cEluZm9zID0gZ3JpZC5kYXRhLmdyb3VwRGVzY3JpcHRvcnM7XG4gICAgICAgICAgICBpZiAoc3RyYXRlZ3kudG9Mb3dlckNhc2UoKSA9PT0gJ2NhbGVuZGFyc3RyYXRlZ3knICYmXG4gICAgICAgICAgICAgICAgKGdyb3VwSW5mb3MubGVuZ3RoICE9PSAxIHx8IGdyaWQuZ2V0Q29sQnlJZF8oZ3JvdXBJbmZvc1swXS5maWVsZCkuZGF0YVR5cGUgIT09ICdkYXRlJykpIHtcbiAgICAgICAgICAgICAgICAvKmpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICAgICAgICAgICAgICBjb25zb2xlICYmIGNvbnNvbGUuZXJyb3IgJiYgY29uc29sZS5lcnJvcignY2FsZW5kYXIgc3RyYXRlZ3kgY2FuIG9ubHkgYmUgdXNlZCBpbiB0aGUgY2FzZSB0aGF0IHRoZXJlIGlzIG9ubHkgb25lIGxldmVsIGdyb3VwIGFuZCB0aGUgZGF0YSB0eXBlIG9mIHRoZSBncm91cGluZyBjb2x1bW4gaXMgW29iamVjdCBEYXRlXScpO1xuICAgICAgICAgICAgICAgIC8qanNoaW50IGlnbm9yZTplbmQgKi9cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5ncm91cFN0cmF0ZWd5XyA9IGdyb3VwU3RyYXRlZ3lPYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuZ3JvdXBTdHJhdGVneV8pIHtcbiAgICAgICAgICAgIHNlbGYuZ3JvdXBTdHJhdGVneV8uaW5pdChncmlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYucmVnaXN0ZUV2ZW50c18oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUdyb3VwU3RyYXRlZ3lfKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBsYXlvdXRFbmdpbmUgPSBzZWxmLmxheW91dEVuZ2luZTtcbiAgICAgICAgdmFyIGdyb3VwU3RyYXRlZ3lPYmogPSBzZWxmLm9wdGlvbnMuZ3JvdXBTdHJhdGVneTtcbiAgICAgICAgaWYgKGxheW91dEVuZ2luZS5ncm91cFN0cmF0ZWd5Xykge1xuICAgICAgICAgICAgLy9yZW1vdmVcbiAgICAgICAgICAgIGlmIChnY1V0aWxzLmlzVW5kZWZpbmVkT3JOdWxsKGdyb3VwU3RyYXRlZ3lPYmopKSB7XG4gICAgICAgICAgICAgICAgbGF5b3V0RW5naW5lLmdyb3VwU3RyYXRlZ3lfLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbGF5b3V0RW5naW5lLmdyb3VwU3RyYXRlZ3lfO1xuICAgICAgICAgICAgICAgIGxheW91dEVuZ2luZS5yZWdpc3RlRXZlbnRzXygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL3RoZSBzYW1lIG5hbWVcbiAgICAgICAgICAgICAgICBpZiAobGF5b3V0RW5naW5lLmdyb3VwU3RyYXRlZ3lfLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gZ3JvdXBTdHJhdGVneU9iai5uYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld09wdG9ucyA9IGdyb3VwU3RyYXRlZ3lPYmoub3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9sZE9wdGlvbnMgPSBsYXlvdXRFbmdpbmUuZ3JvdXBTdHJhdGVneV8ub3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KGdjVXRpbHMuc2VyaWFsaXplT2JqZWN0KG5ld09wdG9ucykpICE9PSBKU09OLnN0cmluZ2lmeShnY1V0aWxzLnNlcmlhbGl6ZU9iamVjdChvbGRPcHRpb25zKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dEVuZ2luZS5ncm91cFN0cmF0ZWd5Xy5vcHRpb25zID0gbmV3T3B0b25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0RW5naW5lLmdyb3VwU3RyYXRlZ3lfLmNsZWFyUmVuZGVyQ2FjaGVfKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvL3RoZSBvdGhlciBuZXcgZ3JvdXAgc3RyYXRleVxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRFbmdpbmUuZ3JvdXBTdHJhdGVneV8uZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbGF5b3V0RW5naW5lLmdyb3VwU3RyYXRlZ3lfO1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVHcm91cFN0cmF0ZWd5XyhsYXlvdXRFbmdpbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghZ2NVdGlscy5pc1VuZGVmaW5lZE9yTnVsbChzZWxmLm9wdGlvbnMuZ3JvdXBTdHJhdGVneSkpIHtcbiAgICAgICAgICAgIGxheW91dEVuZ2luZS51blJlZ2lzdGVFdmVudHNfKCk7XG4gICAgICAgICAgICBjcmVhdGVHcm91cFN0cmF0ZWd5XyhsYXlvdXRFbmdpbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGF5b3V0RW5naW5lLnVuUmVnaXN0ZUV2ZW50c18oKTtcbiAgICAgICAgICAgIGxheW91dEVuZ2luZS5yZWdpc3RlRXZlbnRzXygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY29udHJvbCB0aGF0IGlzIGhvc3RlZCBpbiBhIGdpdmVuIERPTSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIFRoZSBET00gZWxlbWVudCB0aGF0IGlzIGhvc3RpbmcgdGhlIGNvbnRyb2wuXG4gICAgICogQHJldHVybnMgQ29udHJvbFxuICAgICAqL1xuICAgIEdjR3JpZC5nZXRDb250cm9sQnlFbGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIGdyaWROb2RlID0gbm9kZS5xdWVyeVNlbGVjdG9yKCdbcm9sZT1cImdyaWRcIl0nKTtcbiAgICAgICAgICAgIGlmIChncmlkTm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IGdyaWROb2RlLmlkO1xuICAgICAgICAgICAgICAgIGlmIChpZC5zbGljZSgwLCAzKSA9PT0gJ2djLScgJiYgaWQubGVuZ3RoID4gMyAmJiAhaXNOYU4oaWQuc2xpY2UoMykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZXNCeVJlYWN0Um9vdElEWysoaWQuc2xpY2UoMykpXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgLy88ZWRpdG9yLWZvbGQgZGVzYz1cIkNhbGMgRW5naW5lXCI+XG4gICAgZnVuY3Rpb24gaW5pdENFXygpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBfLmZvckVhY2goc2VsZi5jb2x1bW5zLCBmdW5jdGlvbihjb2xPYmopIHtcbiAgICAgICAgICAgIHZhciBkYXRhRmllbGQgPSBjb2xPYmouZGF0YUZpZWxkO1xuICAgICAgICAgICAgaWYgKF8uc3RhcnRzV2l0aChfLnRyaW0oZGF0YUZpZWxkKSwgJz0nKSkge1xuICAgICAgICAgICAgICAgIGNvbE9iai5pc0NhbGNDb2x1bW5fID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvL2NhbGNTb3VyY2UuYWRkQ2FsY0NvbHVtbihjb2xPYmouaWQsIGRhdGFGaWVsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLy88L2VkaXRvci1mb2xkPlxuXG4gICAgZnVuY3Rpb24gaW5pdEJ1aWxkSW5BY3Rpb25zXygpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBzZWxmLmJ1aWxkSW5BY3Rpb25zXyA9IHtcbiAgICAgICAgICAgICdlZGl0Jzoge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdlZGl0JyxcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuY2xvc2VBY3Rpb25Db2x1bW5QYW5lbCgpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnN0YXJ0RWRpdGluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnY2FuY2VsJzoge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdjYW5jZWwnLFxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5jbG9zZUFjdGlvbkNvbHVtblBhbmVsKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2FuY2VsRWRpdGluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgR2NHcmlkOiBHY0dyaWQsXG4gICAgICAgIENhbGM6IENhbGNcbiAgICB9O1xufSgpKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9hcHAvc2NyaXB0cy9ncmlkL2dyaWQuanNcbiAqKiBtb2R1bGUgaWQgPSAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSB7XG4gICAgICAgICAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgICAgICAgIGRbcF0gPSBiW3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkge1xuICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gICAgICAgIH1cblxuICAgICAgICBfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZTtcbiAgICAgICAgZC5wcm90b3R5cGUgPSBuZXcgX18oKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV2ZW50IGhhbmRsZXIgKHByaXZhdGUgY2xhc3MpXG4gICAgICovXG4gICAgdmFyIEV2ZW50SGFuZGxlciA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyKGhhbmRsZXIsIHNlbGYpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgICAgICB0aGlzLnNlbGYgPSBzZWxmO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEV2ZW50SGFuZGxlcjtcbiAgICB9KSgpO1xuXG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBldmVudC5cbiAgICAgKlxuICAgICAqIFdpam1vIGV2ZW50cyBhcmUgc2ltaWxhciB0byAuTkVUIGV2ZW50cy4gQW55IGNsYXNzIG1heSBkZWZpbmUgZXZlbnRzIGJ5XG4gICAgICogZGVjbGFyaW5nIHRoZW0gYXMgZmllbGRzLiBBbnkgY2xhc3MgbWF5IHN1YnNjcmliZSB0byBldmVudHMgdXNpbmcgdGhlXG4gICAgICogZXZlbnQncyBAc2VlOmFkZEhhbmRsZXIgbWV0aG9kLCBvciB1bnN1YnNjcmliZSB1c2luZyB0aGUgQHNlZTpyZW1vdmVIYW5kbGVyXG4gICAgICogbWV0aG9kLlxuICAgICAqXG4gICAgICogV2lqbW8gZXZlbnQgaGFuZGxlcnMgdGFrZSB0d28gcGFyYW1ldGVyczogPGk+c2VuZGVyPC9pPiBhbmQgPGk+YXJnczwvaT4uXG4gICAgICogVGhlIGZpcnN0IGlzIHRoZSBvYmplY3QgdGhhdCByYWlzZWQgdGhlIGV2ZW50LCBhbmQgdGhlIHNlY29uZCBpcyBhbiBvYmplY3RcbiAgICAgKiB0aGF0IGNvbnRhaW5zIHRoZSB0aGUgZXZlbnQgcGFyYW1ldGVycy5cbiAgICAgKlxuICAgICAqIENsYXNzZXMgdGhhdCBkZWZpbmUgZXZlbnRzIGZvbGxvdyB0aGUgLk5FVCBwYXR0ZXJuIHdoZXJlIGZvciBldmVyeSBldmVudFxuICAgICAqIHRoZXJlIGlzIGFuIDxpPm9uW0VWRU5UTkFNRV08L2k+IG1ldGhvZCB0aGF0IHJhaXNlcyB0aGUgZXZlbnQuIFRoaXMgcGF0dGVyblxuICAgICAqIGFsbG93cyBkZXJpdmVkIGNsYXNzZXMgdG8gb3ZlcnJpZGUgdGhlIDxpPm9uW0VWRU5UTkFNRV08L2k+IG1ldGhvZCBhbmRcbiAgICAgKiBoYW5kbGUgdGhlIGV2ZW50IGJlZm9yZSBhbmQvb3IgYWZ0ZXIgdGhlIGJhc2UgY2xhc3MgcmFpc2VzIHRoZSBldmVudC5cbiAgICAgKiBEZXJpdmVkIGNsYXNzZXMgbWF5IGV2ZW4gc3VwcHJlc3MgdGhlIGV2ZW50IGJ5IG5vdCBjYWxsaW5nIHRoZSBiYXNlIGNsYXNzXG4gICAgICogaW1wbGVtZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSwgdGhlIFR5cGVTY3JpcHQgY29kZSBiZWxvdyBvdmVycmlkZXMgdGhlIDxiPm9uVmFsdWVDaGFuZ2VkPC9iPlxuICAgICAqIGV2ZW50IGZvciBhIGNvbnRyb2wgdG8gcGVyZm9ybSBzb21lIHByb2Nlc3NpbmcgYmVmb3JlIGFuZCBhZnRlciB0aGVcbiAgICAgKiA8Yj52YWx1ZUNoYW5nZWQ8L2I+IGV2ZW50IGZpcmVzOlxuICAgICAqIDxwcmU+XG4gICAgICogICAvLyBvdmVycmlkZSBiYXNlIGNsYXNzXG4gICAgICogICBvblZhbHVlQ2hhbmdlZChlOiBFdmVudEFyZ3MpIHtcbiAgICAqICAgLy8gZXhlY3V0ZSBzb21lIGNvZGUgYmVmb3JlIHRoZSBldmVudCBmaXJlc1xuICAgICogICBjb25zb2xlLmxvZygnYWJvdXQgdG8gZmlyZSB2YWx1ZUNoYW5nZWQnKTtcbiAgICAqICAgLy8gb3B0aW9uYWxseSwgY2FsbCBiYXNlIGNsYXNzIHRvIGZpcmUgdGhlIGV2ZW50XG4gICAgKiAgIHN1cGVyLm9uVmFsdWVDaGFuZ2VkKGUpO1xuICAgICogICAvLyBleGVjdXRlIHNvbWUgY29kZSBhZnRlciB0aGUgZXZlbnQgZmlyZWRcbiAgICAqICAgY29uc29sZS5sb2coJ3ZhbHVlQ2hhbmdlZCBldmVudCBqdXN0IGZpcmVkJyk7XG4gICAgKiB9XG4gICAgICogPC9wcmU+XG4gICAgICovXG4gICAgdmFyIEV2ZW50ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBFdmVudCgpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIGhhbmRsZXIgdG8gdGhpcyBldmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGhhbmRsZXIgRnVuY3Rpb24gaW52b2tlZCB3aGVuIHRoZSBldmVudCBpcyByYWlzZWQuXG4gICAgICAgICAqIEBwYXJhbSBzZWxmIE9iamVjdCB0aGF0IGRlZmluZXMgdGhlIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICogKGFjY2Vzc2libGUgYXMgJ3RoaXMnIGZyb20gdGhlIGhhbmRsZXIgY29kZSkuXG4gICAgICAgICAqL1xuICAgICAgICBFdmVudC5wcm90b3R5cGUuYWRkSGFuZGxlciA9IGZ1bmN0aW9uKGhhbmRsZXIsIHNlbGYpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzLnB1c2gobmV3IEV2ZW50SGFuZGxlcihoYW5kbGVyLCBzZWxmKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYSBoYW5kbGVyIGZyb20gdGhpcyBldmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGhhbmRsZXIgRnVuY3Rpb24gaW52b2tlZCB3aGVuIHRoZSBldmVudCBpcyByYWlzZWQuXG4gICAgICAgICAqIEBwYXJhbSBzZWxmIE9iamVjdCB0aGF0IGRlZmluZXMgdGhlIGV2ZW50IGhhbmRsZXIgKGFjY2Vzc2libGUgYXMgJ3RoaXMnIGZyb20gdGhlIGhhbmRsZXIgY29kZSkuXG4gICAgICAgICAqL1xuICAgICAgICBFdmVudC5wcm90b3R5cGUucmVtb3ZlSGFuZGxlciA9IGZ1bmN0aW9uKGhhbmRsZXIsIHNlbGYpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IHRoaXMuX2hhbmRsZXJzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChsLmhhbmRsZXIgPT09IGhhbmRsZXIgJiYgbC5zZWxmID09PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGFsbCBoYW5kbGVycyBhc3NvY2lhdGVkIHdpdGggdGhpcyBldmVudC5cbiAgICAgICAgICovXG4gICAgICAgIEV2ZW50LnByb3RvdHlwZS5yZW1vdmVBbGxIYW5kbGVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmFpc2VzIHRoaXMgZXZlbnQsIGNhdXNpbmcgYWxsIGFzc29jaWF0ZWQgaGFuZGxlcnMgdG8gYmUgaW52b2tlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHNlbmRlciBTb3VyY2Ugb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0gYXJncyBFdmVudCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgRXZlbnQucHJvdG90eXBlLnJhaXNlID0gZnVuY3Rpb24oc2VuZGVyLCBhcmdzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgYXJncyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2hhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGwgPSB0aGlzLl9oYW5kbGVyc1tpXTtcbiAgICAgICAgICAgICAgICBsLmhhbmRsZXIuY2FsbChsLnNlbGYsIHNlbmRlciwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgJ2hhc0hhbmRsZXJzJywge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGlzIGV2ZW50IGhhcyBhbnkgaGFuZGxlcnMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZXJzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEV2ZW50O1xuICAgIH0pKCk7XG4gICAgLyoqXG4gICAgICogQmFzZSBjbGFzcyBmb3IgZXZlbnQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIHZhciBFdmVudEFyZ3MgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIEV2ZW50QXJncygpIHtcbiAgICAgICAgfVxuXG4gICAgICAgIEV2ZW50QXJncy5lbXB0eSA9IG5ldyBFdmVudEFyZ3MoKTtcbiAgICAgICAgcmV0dXJuIEV2ZW50QXJncztcbiAgICB9KSgpO1xuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYXJndW1lbnRzIGZvciBjYW5jZWxsYWJsZSBldmVudHMuXG4gICAgICovXG4gICAgdmFyIENhbmNlbEV2ZW50QXJncyA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICAgICAgLypqc2hpbnQgLVcwMDQgKi9cbiAgICAgICAgX19leHRlbmRzKENhbmNlbEV2ZW50QXJncywgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQ2FuY2VsRXZlbnRBcmdzKCkge1xuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyBhIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGV2ZW50IHNob3VsZCBiZSBjYW5jZWxlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5jYW5jZWwgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBDYW5jZWxFdmVudEFyZ3M7XG4gICAgfSkoRXZlbnRBcmdzKTtcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGFyZ3VtZW50cyBmb3IgcHJvcGVydHkgY2hhbmdlIGV2ZW50cy5cbiAgICAgKi9cbiAgICB2YXIgUHJvcGVydHlDaGFuZ2VkRXZlbnRBcmdzID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgICAgICAvKmpzaGludCAtVzAwNCAqL1xuICAgICAgICBfX2V4dGVuZHMoUHJvcGVydHlDaGFuZ2VkRXZlbnRBcmdzLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBAc2VlOlByb3BlcnR5Q2hhbmdlZEV2ZW50QXJncy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5TmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2hvc2UgdmFsdWUgY2hhbmdlZC5cbiAgICAgICAgICogQHBhcmFtIG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgb2YgdGhlIHByb3BlcnR5LlxuICAgICAgICAgKiBAcGFyYW0gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBQcm9wZXJ0eUNoYW5nZWRFdmVudEFyZ3MocHJvcGVydHlOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fbmFtZSA9IHByb3BlcnR5TmFtZTtcbiAgICAgICAgICAgIHRoaXMuX29sZFZhbCA9IG9sZFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fbmV3VmFsID0gbmV3VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvcGVydHlDaGFuZ2VkRXZlbnRBcmdzLnByb3RvdHlwZSwgJ3Byb3BlcnR5TmFtZScsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2hvc2UgdmFsdWUgY2hhbmdlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm9wZXJ0eUNoYW5nZWRFdmVudEFyZ3MucHJvdG90eXBlLCAnb2xkVmFsdWUnLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgdGhlIG9sZCB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29sZFZhbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm9wZXJ0eUNoYW5nZWRFdmVudEFyZ3MucHJvdG90eXBlLCAnbmV3VmFsdWUnLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgdGhlIG5ldyB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25ld1ZhbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvcGVydHlDaGFuZ2VkRXZlbnRBcmdzO1xuICAgIH0pKEV2ZW50QXJncyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgRXZlbnQ6IEV2ZW50LFxuICAgICAgICBFdmVudEhhbmRsZXI6IEV2ZW50SGFuZGxlcixcbiAgICAgICAgRXZlbnRBcmdzOiBFdmVudEFyZ3MsXG4gICAgICAgIENhbmNlbEV2ZW50QXJnczogQ2FuY2VsRXZlbnRBcmdzLFxuICAgICAgICBQcm9wZXJ0eUNoYW5nZWRFdmVudEFyZ3M6IFByb3BlcnR5Q2hhbmdlZEV2ZW50QXJnc1xuICAgIH07XG59KCkpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2FwcC9zY3JpcHRzL2dyaWQvZXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGdjVXRpbHMgPSByZXF1aXJlKCcuL2djVXRpbHMnKTtcblxuICAgIHZhciBkb21VdGlsID0ge307XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGVsZW1lbnQgZnJvbSBhbiBIVE1MIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBodG1sIEhUTUwgZnJhZ21lbnQgdG8gY29udmVydCBpbnRvIGFuIEhUTUxFbGVtZW50LlxuICAgICAqIEByZXR1cm4gVGhlIG5ldyBlbGVtZW50LlxuICAgICAqL1xuXG4gICAgLy9yZW1vdmUgYWxsIGNvbW1lbnRzIGFuZCB3aGl0ZXNwYWNlIG9ubHkgdGV4dCBub2Rlc1xuICAgIGZ1bmN0aW9uIGNsZWFuKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5jaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IG4rKykgeyAvL2RvIHJld3JpdGUgaXQgdG8gZm9yKHZhciBuPTAsbGVuPVhYWDtpPGxlbjspXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZE5vZGVzW25dO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gOCB8fCAoY2hpbGQubm9kZVR5cGUgPT09IDMgJiYgIS9cXFMvLnRlc3QoY2hpbGQubm9kZVZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkb21VdGlsLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbihodG1sKSB7XG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZGl2LmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIHZhciByID0gZGl2LmNoaWxkcmVuWzBdO1xuICAgICAgICBkaXYgPSBudWxsO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuXG4gICAgZG9tVXRpbC5jcmVhdGVUZW1wbGF0ZUVsZW1lbnQgPSBmdW5jdGlvbihodG1sKSB7XG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZGl2LmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIHZhciByID0gZGl2LmNoaWxkcmVuWzBdO1xuICAgICAgICBjbGVhbihyKTtcbiAgICAgICAgcmV0dXJuIGRpdjtcbiAgICB9O1xuXG4gICAgZG9tVXRpbC5nZXRFbGVtZW50SW5uZXJUZXh0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5pbm5lckhUTUwucmVwbGFjZSgvJmFtcDsvZywgJyYnKS5yZXBsYWNlKC8mbHQ7L2csICc8JykucmVwbGFjZSgvJmd0Oy9nLCAnPicpO1xuICAgIH07XG5cbiAgICBkb21VdGlsLmdldEVsZW1lbnRPdXRlclRleHQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50Lm91dGVySFRNTC5yZXBsYWNlKC8mYW1wOy9nLCAnJicpLnJlcGxhY2UoLyZsdDsvZywgJzwnKS5yZXBsYWNlKC8mZ3Q7L2csICc+Jyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGFuIGVsZW1lbnQgaGFzIGEgY2xhc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGUgRWxlbWVudCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIENsYXNzIHRvIGNoZWNrIGZvci5cbiAgICAgKi9cbiAgICBkb21VdGlsLmhhc0NsYXNzID0gZnVuY3Rpb24oZSwgY2xhc3NOYW1lKSB7XG4gICAgICAgIC8vIG5vdGU6IHVzaW5nIGUuZ2V0QXR0cmlidXRlKCdjbGFzcycpIGluc3RlYWQgb2YgZS5jbGFzc05hbWVzXG4gICAgICAgIC8vIHNvIHRoaXMgd29ya3Mgd2l0aCBTVkcgYXMgd2VsbCBhcyByZWd1bGFyIEhUTUwgZWxlbWVudHMuXG4gICAgICAgIGlmIChlICYmIGUuZ2V0QXR0cmlidXRlKSB7XG4gICAgICAgICAgICB2YXIgcnggPSBuZXcgUmVnRXhwKCdcXFxcYicgKyBjbGFzc05hbWUgKyAnXFxcXGInKTtcbiAgICAgICAgICAgIHJldHVybiBlICYmIHJ4LnRlc3QoZS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gYW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZSBFbGVtZW50IHRoYXQgd2lsbCBoYXZlIHRoZSBjbGFzcyByZW1vdmVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgQ2xhc3MgdG8gcmVtb3ZlIGZvcm0gdGhlIGVsZW1lbnQuXG4gICAgICovXG4gICAgZG9tVXRpbC5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uKGUsIGNsYXNzTmFtZSkge1xuICAgICAgICAvLyBub3RlOiB1c2luZyBlLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSBpbnN0ZWFkIG9mIGUuY2xhc3NOYW1lc1xuICAgICAgICAvLyBzbyB0aGlzIHdvcmtzIHdpdGggU1ZHIGFzIHdlbGwgYXMgcmVndWxhciBIVE1MIGVsZW1lbnRzLlxuICAgICAgICBpZiAoZSAmJiBlLnNldEF0dHJpYnV0ZSAmJiBkb21VdGlsLmhhc0NsYXNzKGUsIGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgIHZhciByeCA9IG5ldyBSZWdFeHAoJ1xcXFxzP1xcXFxiJyArIGNsYXNzTmFtZSArICdcXFxcYicsICdnJyk7XG4gICAgICAgICAgICB2YXIgY24gPSBlLmdldEF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNuLnJlcGxhY2UocngsICcnKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNsYXNzIHRvIGFuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGUgRWxlbWVudCB0aGF0IHdpbGwgaGF2ZSB0aGUgY2xhc3MgYWRkZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSBDbGFzcyB0byBhZGQgdG8gdGhlIGVsZW1lbnQuXG4gICAgICovXG4gICAgZG9tVXRpbC5hZGRDbGFzcyA9IGZ1bmN0aW9uKGUsIGNsYXNzTmFtZSkge1xuICAgICAgICAvLyBub3RlOiB1c2luZyBlLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSBpbnN0ZWFkIG9mIGUuY2xhc3NOYW1lc1xuICAgICAgICAvLyBzbyB0aGlzIHdvcmtzIHdpdGggU1ZHIGFzIHdlbGwgYXMgcmVndWxhciBIVE1MIGVsZW1lbnRzLlxuICAgICAgICBpZiAoZSAmJiBlLnNldEF0dHJpYnV0ZSAmJiAhZG9tVXRpbC5oYXNDbGFzcyhlLCBjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICB2YXIgY24gPSBlLmdldEF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNuID8gY24gKyAnICcgKyBjbGFzc05hbWUgOiBjbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgb3IgcmVtb3ZlcyBhIGNsYXNzIHRvIG9yIGZyb20gYW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZSBFbGVtZW50IHRoYXQgd2lsbCBoYXZlIHRoZSBjbGFzcyBhZGRlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIENsYXNzIHRvIGFkZCBvciByZW1vdmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBhZGRPclJlbW92ZSBXaGV0aGVyIHRvIGFkZCBvciByZW1vdmUgdGhlIGNsYXNzLlxuICAgICAqL1xuICAgIGRvbVV0aWwudG9nZ2xlQ2xhc3MgPSBmdW5jdGlvbihlLCBjbGFzc05hbWUsIGFkZE9yUmVtb3ZlKSB7XG4gICAgICAgIGlmIChhZGRPclJlbW92ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZG9tVXRpbC5hZGRDbGFzcyhlLCBjbGFzc05hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9tVXRpbC5yZW1vdmVDbGFzcyhlLCBjbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vICoqIGpRdWVyeSByZXBsYWNlbWVudCBtZXRob2RzXG4gICAgLyoqXG4gICAgICogR2V0cyBhbiBlbGVtZW50IGZyb20gYSBqUXVlcnktc3R5bGUgc2VsZWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8c3RyaW5nfSBzZWxlY3RvciBBbiBlbGVtZW50LCBhIHNlbGVjdG9yIHN0cmluZywgb3IgYSBqUXVlcnkgb2JqZWN0LlxuICAgICAqL1xuICAgIGRvbVV0aWwuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICAgIGlmIChzZWxlY3RvciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdjVXRpbHMuaXNTdHJpbmcoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGFuIEhUTUwgZWxlbWVudCBjb250YWlucyBhbm90aGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnQgUGFyZW50IGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBjaGlsZCBDaGlsZCBlbGVtZW50LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBhcmVudCBlbGVtZW50IGNvbnRhaW5zIHRoZSBjaGlsZCBlbGVtZW50LlxuICAgICAqL1xuICAgIGRvbVV0aWwuY29udGFpbnMgPSBmdW5jdGlvbihwYXJlbnQsIGNoaWxkKSB7XG4gICAgICAgIGZvciAodmFyIGUgPSBjaGlsZDsgZTsgZSA9IGUucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGUgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBjb29yZGluYXRlcyBvZiBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAqL1xuICAgIGRvbVV0aWwub2Zmc2V0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6IHJlY3QudG9wICsgZWxlbWVudC5zY3JvbGxUb3AgKyB3aW5kb3cucGFnZVlPZmZzZXQsXG4gICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyBlbGVtZW50LnNjcm9sbExlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXRcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIG9mIGFuIGVsZW1lbnQgaW4gcGFnZSBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgc2ltaWxhciB0byB0aGUgPGI+Z2V0Qm91bmRpbmdDbGllbnRSZWN0PC9iPiBmdW5jdGlvbixcbiAgICAgKiBleGNlcHQgdGhhdCB1c2VzIHdpbmRvdyBjb29yZGluYXRlcywgd2hpY2ggY2hhbmdlIHdoZW4gdGhlXG4gICAgICogZG9jdW1lbnQgc2Nyb2xscy5cbiAgICAgKi9cbiAgICBkb21VdGlsLmdldEVsZW1lbnRSZWN0ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgcmMgPSBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogcmMubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgIHRvcDogcmMudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0LFxuICAgICAgICAgICAgd2lkdGg6IHJjLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiByYy5oZWlnaHRcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpbm5lciBjb250ZW50IHJlY3RhbmdsZSBvZiBpbnB1dCBlbGVtZW50LlxuICAgICAqIFBhZGRpbmcgYW5kIGJveC1zaXppbmcgaXMgY29uc2lkZXJlZC5cbiAgICAgKiBUaGUgcmVzdWx0IGlzIHRoZSBhY3R1YWwgcmVjdGFuZ2xlIHRvIHBsYWNlIGNoaWxkIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIGUgcmVwcmVzZW50IHRoZSBlbGVtZW50XG4gICAgICovXG4gICAgZG9tVXRpbC5nZXRDb250ZW50UmVjdCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHJjID0gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5nZXRTdHlsZShlKTtcbiAgICAgICAgdmFyIG1lYXN1cmVtZW50cyA9IFtcbiAgICAgICAgICAgICdwYWRkaW5nTGVmdCcsXG4gICAgICAgICAgICAncGFkZGluZ1JpZ2h0JyxcbiAgICAgICAgICAgICdwYWRkaW5nVG9wJyxcbiAgICAgICAgICAgICdwYWRkaW5nQm90dG9tJyxcbiAgICAgICAgICAgICdib3JkZXJMZWZ0V2lkdGgnLFxuICAgICAgICAgICAgJ2JvcmRlclJpZ2h0V2lkdGgnLFxuICAgICAgICAgICAgJ2JvcmRlclRvcFdpZHRoJyxcbiAgICAgICAgICAgICdib3JkZXJCb3R0b21XaWR0aCdcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIHNpemUgPSB7fTtcbiAgICAgICAgbWVhc3VyZW1lbnRzLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgICAgdmFyIG51bSA9IHBhcnNlRmxvYXQoc3R5bGVbcHJvcF0pO1xuICAgICAgICAgICAgc2l6ZVtwcm9wXSA9ICFpc05hTihudW0pID8gbnVtIDogMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwYWRkaW5nV2lkdGggPSBzaXplLnBhZGRpbmdMZWZ0ICsgc2l6ZS5wYWRkaW5nUmlnaHQ7XG4gICAgICAgIHZhciBwYWRkaW5nSGVpZ2h0ID0gc2l6ZS5wYWRkaW5nVG9wICsgc2l6ZS5wYWRkaW5nQm90dG9tO1xuICAgICAgICB2YXIgYm9yZGVyV2lkdGggPSBzaXplLmJvcmRlckxlZnRXaWR0aCArIHNpemUuYm9yZGVyUmlnaHRXaWR0aDtcbiAgICAgICAgdmFyIGJvcmRlckhlaWdodCA9IHNpemUuYm9yZGVyVG9wV2lkdGggKyBzaXplLmJvcmRlckJvdHRvbVdpZHRoO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogcmMubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldCArIHNpemUuYm9yZGVyTGVmdFdpZHRoICsgc2l6ZS5wYWRkaW5nTGVmdCxcbiAgICAgICAgICAgIHRvcDogcmMudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0ICsgc2l6ZS5ib3JkZXJUb3BXaWR0aCArIHNpemUucGFkZGluZ1RvcCxcbiAgICAgICAgICAgIHdpZHRoOiByYy53aWR0aCAtIHBhZGRpbmdXaWR0aCAtIGJvcmRlcldpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiByYy5oZWlnaHQgLSBwYWRkaW5nSGVpZ2h0IC0gYm9yZGVySGVpZ2h0XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1vZGlmaWVzIHRoZSBzdHlsZSBvZiBhbiBlbGVtZW50IGJ5IGFwcGx5aW5nIHRoZSBwcm9wZXJ0aWVzIHNwZWNpZmllZCBpbiBhbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGUgRWxlbWVudCB3aG9zZSBzdHlsZSB3aWxsIGJlIG1vZGlmaWVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjc3MgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIHN0eWxlIHByb3BlcnRpZXMgdG8gYXBwbHkgdG8gdGhlIGVsZW1lbnQuXG4gICAgICovXG4gICAgZG9tVXRpbC5zZXRDc3MgPSBmdW5jdGlvbihlLCBjc3MpIHtcbiAgICAgICAgdmFyIHMgPSBlLnN0eWxlO1xuICAgICAgICBmb3IgKHZhciBwIGluIGNzcykge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGNzc1twXTtcbiAgICAgICAgICAgIGlmIChnY1V0aWxzLmlzTnVtYmVyKHZhbCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocC5tYXRjaCgvd2lkdGh8aGVpZ2h0fGxlZnR8dG9wfHJpZ2h0fGJvdHRvbXxzaXplfHBhZGRpbmd8bWFyZ2luJy9pKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgKz0gJ3B4JzsgLy8gZGVmYXVsdCB1bml0IGZvciBnZW9tZXRyeSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc1twXSA9IHZhbC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGRvbVV0aWwuZ2V0U2Nyb2xsYmFyU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZG9tVXRpbC5zY3JvbGxiYXJTaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9tVXRpbC5zY3JvbGxiYXJTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpdiA9IGRvbVV0aWwuY3JlYXRlRWxlbWVudCgnPGRpdiBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlOyB0b3A6LTEwMDAwcHg7IGxlZnQ6LTEwMDAwcHg7IHdpZHRoOjEwMHB4OyBoZWlnaHQ6MTAwcHg7IG92ZXJmbG93OnNjcm9sbDtcIj48L2Rpdj4nKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICBkb21VdGlsLnNjcm9sbGJhclNpemUgPSB7XG4gICAgICAgICAgICB3aWR0aDogZGl2Lm9mZnNldFdpZHRoIC0gZGl2LmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBkaXYub2Zmc2V0SGVpZ2h0IC0gZGl2LmNsaWVudEhlaWdodFxuICAgICAgICB9O1xuICAgICAgICBkaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkaXYpO1xuXG4gICAgICAgIHJldHVybiBkb21VdGlsLnNjcm9sbGJhclNpemU7XG4gICAgfTtcblxuICAgIGRvbVV0aWwuZ2V0U3R5bGUgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHZhciBmbiA9IGdldENvbXB1dGVkU3R5bGUgfHwgd2luZG93LmdldENvbXB1dGVkU3R5bGU7XG4gICAgICAgIGlmIChlbGVtZW50ICYmIGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4oZWxlbWVudCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIGRvbVV0aWwuZ2V0U3R5bGVWYWx1ZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHN0eWxlUHJvcGVydHkpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gZG9tVXRpbC5nZXRTdHlsZShlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIHN0eWxlID8gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShzdHlsZVByb3BlcnR5KSA6IG51bGw7XG4gICAgfTtcblxuICAgIGRvbVV0aWwuR2V0TWF4U3VwcG9ydGVkQ1NTSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChkb21VdGlsLm1heFN1cHBvcnRlZENTU0hlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvbVV0aWwubWF4U3VwcG9ydGVkQ1NTSGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGggPSAxMDAwMDAwO1xuICAgICAgICB2YXIgdGVzdFVwVG8gPSA2MDAwMDAwICogMTAwMDtcbiAgICAgICAgdmFyIGRpdiA9IGRvbVV0aWwuY3JlYXRlRWxlbWVudCgnPGRpdiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiLz4nKTtcbiAgICAgICAgdmFyIHRlc3Q7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHRlc3QgPSBoICsgNTAwMDAwOyAvLyogMjtcbiAgICAgICAgICAgIGRpdi5zdHlsZS5oZWlnaHQgPSB0ZXN0ICsgJ3B4JztcbiAgICAgICAgICAgIGlmICh0ZXN0ID4gdGVzdFVwVG8gfHwgZGl2Lm9mZnNldEhlaWdodCAhPT0gdGVzdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaCA9IHRlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICAgICAgZG9tVXRpbC5tYXhTdXBwb3J0ZWRDU1NIZWlnaHQgPSBoO1xuICAgICAgICByZXR1cm4gZG9tVXRpbC5tYXhTdXBwb3J0ZWRDU1NIZWlnaHQ7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZG9tVXRpbDtcbn0oKSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXBwL3NjcmlwdHMvZ3JpZC9kb21VdGlsLmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgVU5ERUZJTkVEID0gJ3VuZGVmaW5lZCc7XG4gICAgdmFyIGdjVXRpbHMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZSh2YWwsIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZih2YWwpID09PSB0eXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGEgdmFsdWUgdG8gYSB0eXBlIGlmIHBvc3NpYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIGNhc3QuXG4gICAgICogQHBhcmFtIHR5cGUgVHlwZSBvciBpbnRlcmZhY2UgbmFtZSB0byBjYXN0IHRvLlxuICAgICAqIEByZXR1cm4gVGhlIHZhbHVlIHBhc3NlZCBpbiBpZiB0aGUgY2FzdCB3YXMgc3VjY2Vzc2Z1bCwgbnVsbCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJ5Q2FzdCh2YWx1ZSwgdHlwZSkge1xuICAgICAgICAvLyBudWxsIGRvZXNuJ3QgaW1wbGVtZW50IGFueXRoaW5nXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZE9yTnVsbCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGVzdCBmb3IgaW50ZXJmYWNlIGltcGxlbWVudGF0aW9uIChJUXVlcnlJbnRlcmZhY2UpXG4gICAgICAgIGlmIChpc1N0cmluZyh0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUuaW1wbGVtZW50c0ludGVyZmFjZSkgJiYgdmFsdWUuaW1wbGVtZW50c0ludGVyZmFjZSh0eXBlKSA/IHZhbHVlIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlZ3VsYXIgdHlwZSB0ZXN0XG4gICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIHR5cGUgPyB2YWx1ZSA6IG51bGw7XG4gICAgfVxuXG4gICAgZ2NVdGlscy50cnlDYXN0ID0gdHJ5Q2FzdDtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBhbiBvYmplY3QgaXMgYSBwcmltaXRpdmUgdHlwZSAoc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIG9yIGRhdGUpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIHRlc3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKHZhbHVlKSB8fCBpc051bWJlcih2YWx1ZSkgfHwgaXNCb29sZWFuKHZhbHVlKSB8fCBpc0RhdGUodmFsdWUpO1xuICAgIH1cblxuICAgIGdjVXRpbHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBhbiBvYmplY3QgaXMgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gdGVzdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2hlY2tUeXBlKHZhbHVlLCAnc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgZ2NVdGlscy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgc3RyaW5nIGlzIG51bGwsIGVtcHR5LCBvciB3aGl0ZXNwYWNlIG9ubHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gdGVzdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbE9yV2hpdGVTcGFjZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXNVbmRlZmluZWRPck51bGwodmFsdWUpID8gdHJ1ZSA6IHZhbHVlLnJlcGxhY2UoL1xccy9nLCAnJykubGVuZ3RoIDwgMTtcbiAgICB9XG5cbiAgICBnY1V0aWxzLmlzVW5kZWZpbmVkT3JOdWxsT3JXaGl0ZVNwYWNlID0gaXNVbmRlZmluZWRPck51bGxPcldoaXRlU3BhY2U7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gb2JqZWN0IGlzIGEgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIHRlc3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrVHlwZSh2YWx1ZSwgJ251bWJlcicpO1xuICAgIH1cblxuICAgIGdjVXRpbHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBhbiBvYmplY3QgaXMgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byB0ZXN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgPT09IE1hdGgucm91bmQodmFsdWUpO1xuICAgIH1cblxuICAgIGdjVXRpbHMuaXNJbnQgPSBpc0ludDtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBhbiBvYmplY3QgaXMgYSBCb29sZWFuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIHRlc3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjaGVja1R5cGUodmFsdWUsICdib29sZWFuJyk7XG4gICAgfVxuXG4gICAgZ2NVdGlscy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gb2JqZWN0IGlzIGEgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gdGVzdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjaGVja1R5cGUodmFsdWUsICdmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGdjVXRpbHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gb2JqZWN0IGlzIHVuZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byB0ZXN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjaGVja1R5cGUodmFsdWUsIFVOREVGSU5FRCk7XG4gICAgfVxuXG4gICAgZ2NVdGlscy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIG9iamVjdCBpcyBhIERhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gdGVzdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4odmFsdWUuZ2V0VGltZSgpKTtcbiAgICB9XG5cbiAgICBnY1V0aWxzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBhbiBvYmplY3QgaXMgYW4gQXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gdGVzdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5O1xuICAgIH1cblxuICAgIGdjVXRpbHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gb2JqZWN0IGlzIGFuIG9iamVjdCAoYXMgb3Bwb3NlZCB0byBhIHZhbHVlIHR5cGUgb3IgYSBkYXRlKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byB0ZXN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhaXNVbmRlZmluZWRPck51bGwodmFsdWUpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgIWlzRGF0ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZ2NVdGlscy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdHlwZSBvZiBhIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIHRlc3QuXG4gICAgICogQHJldHVybiBBIEBzZWU6RGF0YVR5cGUgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSB0eXBlIG9mIHRoZSB2YWx1ZSBwYXNzZWQgaW4uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VHlwZSh2YWx1ZSkge1xuICAgICAgICBpZiAoaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCb29sZWFuKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdib29sZWFuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2FycmF5JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGdjVXRpbHMuZ2V0VHlwZSA9IGdldFR5cGU7XG5cbiAgICBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc1VuZGVmaW5lZCh2YWx1ZSkgfHwgaXNOdWxsKHZhbHVlKTtcbiAgICB9XG5cbiAgICBnY1V0aWxzLmlzTnVsbCA9IGlzTnVsbDtcbiAgICBnY1V0aWxzLmlzVW5kZWZpbmVkT3JOdWxsID0gaXNVbmRlZmluZWRPck51bGw7XG5cbiAgICAvL1RPRE86IHJldmlldyB0aGlzIG1ldGhvZCBhZnRlciBmb3JtbXR0ZXIgaW1wbGVtZW50YXRpb24gZG9uZS5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSB0eXBlIG9mIGEgdmFsdWUuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgdGhlIG9yaWdpbmFsIHZhbHVlIGlzIHJldHVybmVkLiBUbyBjaGVjayBpZiBhXG4gICAgICogY29udmVyc2lvbiBzdWNjZWVkZWQsIHlvdSBzaG91bGQgY2hlY2sgdGhlIHR5cGUgb2YgdGhlIHJldHVybmVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHR5cGUgQHNlZTpEYXRhVHlwZSB0byBjb252ZXJ0IHRoZSB2YWx1ZSB0by5cbiAgICAgKiBAcmV0dXJuIFRoZSBjb252ZXJ0ZWQgdmFsdWUsIG9yIHRoZSBvcmlnaW5hbCB2YWx1ZSBpZiBhIGNvbnZlcnNpb24gd2FzIG5vdCBwb3NzaWJsZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGFuZ2VUeXBlKHZhbHVlLCB0eXBlKSB7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWRPck51bGwodmFsdWUpKSB7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgLy8gY29udmVydCBzdHJpbmdzIHRvIG51bWJlcnMsIGRhdGVzLCBvciBib29sZWFuc1xuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG51bSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzTmFOKG51bSkgPyB2YWx1ZSA6IG51bTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjb252ZXJ0IGFueXRoaW5nIHRvIHN0cmluZ1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2NVdGlscy5jaGFuZ2VUeXBlID0gY2hhbmdlVHlwZTtcbiAgICAvL1xuICAgIC8vLyoqXG4gICAgLy8gKiBSZXBsYWNlcyBlYWNoIGZvcm1hdCBpdGVtIGluIGEgc3BlY2lmaWVkIHN0cmluZyB3aXRoIHRoZSB0ZXh0IGVxdWl2YWxlbnQgb2YgYW5cbiAgICAvLyAqIG9iamVjdCdzIHZhbHVlLlxuICAgIC8vICpcbiAgICAvLyAqIFRoZSBmdW5jdGlvbiB3b3JrcyBieSByZXBsYWNpbmcgcGFydHMgb2YgdGhlIDxiPmZvcm1hdFN0cmluZzwvYj4gd2l0aCB0aGUgcGF0dGVyblxuICAgIC8vICogJ3tuYW1lOmZvcm1hdH0nIHdpdGggcHJvcGVydGllcyBvZiB0aGUgPGI+ZGF0YTwvYj4gcGFyYW1ldGVyLiBGb3IgZXhhbXBsZTpcbiAgICAvLyAqXG4gICAgLy8gKiA8cHJlPlxuICAgIC8vICogdmFyIGRhdGEgPSB7IG5hbWU6ICdKb2UnLCBhbW91bnQ6IDEyMzQ1NiB9O1xuICAgIC8vICogdmFyIG1zZyA9IHdpam1vLmZvcm1hdCgnSGVsbG8ge25hbWV9LCB5b3Ugd29uIHthbW91bnQ6bjJ9IScsIGRhdGEpO1xuICAgIC8vICogPC9wcmU+XG4gICAgLy8gKlxuICAgIC8vICogVGhlIG9wdGlvbmFsIDxiPmZvcm1hdEZ1bmN0aW9uPC9iPiBhbGxvd3MgeW91IHRvIGN1c3RvbWl6ZSB0aGUgY29udGVudCBieSBwcm92aWRpbmdcbiAgICAvLyAqIGNvbnRleHQtc2Vuc2l0aXZlIGZvcm1hdHRpbmcuIElmIHByb3ZpZGVkLCB0aGUgZm9ybWF0IGZ1bmN0aW9uIGdldHMgY2FsbGVkIGZvciBlYWNoXG4gICAgLy8gKiBmb3JtYXQgZWxlbWVudCBhbmQgZ2V0cyBwYXNzZWQgdGhlIGRhdGEgb2JqZWN0LCB0aGUgcGFyYW1ldGVyIG5hbWUsIHRoZSBmb3JtYXQsXG4gICAgLy8gKiBhbmQgdGhlIHZhbHVlOyBpdCBzaG91bGQgcmV0dXJuIGFuIG91dHB1dCBzdHJpbmcuIEZvciBleGFtcGxlOlxuICAgIC8vICpcbiAgICAvLyAqIDxwcmU+XG4gICAgLy8gKiB2YXIgZGF0YSA9IHsgbmFtZTogJ0pvZScsIGFtb3VudDogMTIzNDU2IH07XG4gICAgLy8gKiB2YXIgbXNnID0gd2lqbW8uZm9ybWF0KCdIZWxsbyB7bmFtZX0sIHlvdSB3b24ge2Ftb3VudDpuMn0hJywgZGF0YSxcbiAgICAvLyAqICAgICAgICAgICAgIGZ1bmN0aW9uIChkYXRhLCBuYW1lLCBmbXQsIHZhbCkge1xuICAgIC8vKiAgICAgICAgICAgICAgIGlmICh3aWptby5pc1N0cmluZyhkYXRhW25hbWVdKSkge1xuICAgIC8vKiAgICAgICAgICAgICAgICAgICB2YWwgPSB3aWptby5lc2NhcGVIdG1sKGRhdGFbbmFtZV0pO1xuICAgIC8vKiAgICAgICAgICAgICAgIH1cbiAgICAvLyogICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgIC8vKiAgICAgICAgICAgICB9KTtcbiAgICAvLyAqIDwvcHJlPlxuICAgIC8vICpcbiAgICAvLyAqIEBwYXJhbSBmb3JtYXQgQSBjb21wb3NpdGUgZm9ybWF0IHN0cmluZy5cbiAgICAvLyAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIG9iamVjdCB1c2VkIHRvIGJ1aWxkIHRoZSBzdHJpbmcuXG4gICAgLy8gKiBAcGFyYW0gZm9ybWF0RnVuY3Rpb24gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdXNlZCB0byBmb3JtYXQgaXRlbXMgaW4gY29udGV4dC5cbiAgICAvLyAqIEByZXR1cm4gVGhlIGZvcm1hdHRlZCBzdHJpbmcuXG4gICAgLy8gKi9cbiAgICAvL2Z1bmN0aW9uIGZvcm1hdChmb3JtYXQsIGRhdGEsIGZvcm1hdEZ1bmN0aW9uKSB7XG4gICAgLy8gICAgZm9ybWF0ID0gYXNTdHJpbmcoZm9ybWF0KTtcbiAgICAvLyAgICByZXR1cm4gZm9ybWF0LnJlcGxhY2UoL1xceyguKj8pKDooLio/KSk/XFx9L2csIGZ1bmN0aW9uIChtYXRjaCwgbmFtZSwgeCwgZm10KSB7XG4gICAgLy8gICAgICAgIHZhciB2YWwgPSBtYXRjaDtcbiAgICAvLyAgICAgICAgaWYgKG5hbWUgJiYgbmFtZVswXSAhPSAneycgJiYgZGF0YSkge1xuICAgIC8vICAgICAgICAgICAgLy8gZ2V0IHRoZSB2YWx1ZVxuICAgIC8vICAgICAgICAgICAgdmFsID0gZGF0YVtuYW1lXTtcbiAgICAvL1xuICAgIC8vICAgICAgICAgICAgLy8gYXBwbHkgc3RhdGljIGZvcm1hdFxuICAgIC8vICAgICAgICAgICAgaWYgKGZtdCkge1xuICAgIC8vICAgICAgICAgICAgICAgIHZhbCA9IHdpam1vLkdsb2JhbGl6ZS5mb3JtYXQodmFsLCBmbXQpO1xuICAgIC8vICAgICAgICAgICAgfVxuICAgIC8vXG4gICAgLy8gICAgICAgICAgICAvLyBhcHBseSBmb3JtYXQgZnVuY3Rpb25cbiAgICAvLyAgICAgICAgICAgIGlmIChmb3JtYXRGdW5jdGlvbikge1xuICAgIC8vICAgICAgICAgICAgICAgIHZhbCA9IGZvcm1hdEZ1bmN0aW9uKGRhdGEsIG5hbWUsIGZtdCwgdmFsKTtcbiAgICAvLyAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgfVxuICAgIC8vICAgICAgICByZXR1cm4gdmFsID09IG51bGwgPyAnJyA6IHZhbDtcbiAgICAvLyAgICB9KTtcbiAgICAvL31cbiAgICAvL2djVXRpbHMuZm9ybWF0ID0gZm9ybWF0O1xuXG4gICAgLyoqXG4gICAgICogQ2xhbXBzIGEgdmFsdWUgYmV0d2VlbiBhIG1pbmltdW0gYW5kIGEgbWF4aW11bS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBPcmlnaW5hbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gbWluIE1pbmltdW0gYWxsb3dlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gbWF4IE1heGltdW0gYWxsb3dlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZE9yTnVsbCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWRPck51bGwobWF4KSAmJiB2YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbWF4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZE9yTnVsbChtaW4pICYmIHZhbHVlIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtaW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGdjVXRpbHMuY2xhbXAgPSBjbGFtcDtcblxuICAgIC8qKlxuICAgICAqIENvcGllcyB0aGUgcHJvcGVydGllcyBmcm9tIGFuIG9iamVjdCB0byBhbm90aGVyLlxuICAgICAqXG4gICAgICogVGhlIGRlc3RpbmF0aW9uIG9iamVjdCBtdXN0IGRlZmluZSBhbGwgdGhlIHByb3BlcnRpZXMgZGVmaW5lZCBpbiB0aGUgc291cmNlLFxuICAgICAqIG9yIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRzdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSBzcmMgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weShkc3QsIHNyYykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgICAgICAgICBhc3NlcnQoa2V5IGluIGRzdCwgJ1Vua25vd24ga2V5IFwiJyArIGtleSArICdcIi4nKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNyY1trZXldO1xuICAgICAgICAgICAgaWYgKCFkc3QuX2NvcHkgfHwgIWRzdC5fY29weShrZXksIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkgJiYgZHN0W2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29weShkc3Rba2V5XSwgdmFsdWUpOyAvLyBjb3B5IHN1Yi1vYmplY3RzXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZHN0W2tleV0gPSB2YWx1ZTsgLy8gYXNzaWduIHZhbHVlc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdjVXRpbHMuY29weSA9IGNvcHk7XG5cbiAgICAvKipcbiAgICAgKiBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIGEgY29uZGl0aW9uIGlzIGZhbHNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmRpdGlvbiBDb25kaXRpb24gZXhwZWN0ZWQgdG8gYmUgdHJ1ZS5cbiAgICAgKiBAcGFyYW0gbXNnIE1lc3NhZ2Ugb2YgdGhlIGV4Y2VwdGlvbiBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCB0cnVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1zZykge1xuICAgICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgJyoqIEFzc2VydGlvbiBmYWlsZWQgaW4gV2lqbW86ICcgKyBtc2c7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnY1V0aWxzLmFzc2VydCA9IGFzc2VydDtcblxuICAgIC8qKlxuICAgICAqIEFzc2VydHMgdGhhdCBhIHZhbHVlIGlzIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIFZhbHVlIHN1cHBvc2VkIHRvIGJlIGEgc3RyaW5nLlxuICAgICAqIEBwYXJhbSBudWxsT0sgV2hldGhlciBudWxsIHZhbHVlcyBhcmUgYWNjZXB0YWJsZS5cbiAgICAgKiBAcmV0dXJuIFRoZSBzdHJpbmcgcGFzc2VkIGluLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzU3RyaW5nKHZhbHVlLCBudWxsT0spIHtcbiAgICAgICAgaWYgKGNoZWNrVHlwZShudWxsT0ssIFVOREVGSU5FRCkpIHtcbiAgICAgICAgICAgIG51bGxPSyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KChudWxsT0sgJiYgaXNVbmRlZmluZWRPck51bGwodmFsdWUpKSB8fCBpc1N0cmluZyh2YWx1ZSksICdTdHJpbmcgZXhwZWN0ZWQuJyk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBnY1V0aWxzLmFzU3RyaW5nID0gYXNTdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBBc3NlcnRzIHRoYXQgYSB2YWx1ZSBpcyBhIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSBzdXBwb3NlZCB0byBiZSBudW1lcmljLlxuICAgICAqIEBwYXJhbSBudWxsT0sgV2hldGhlciBudWxsIHZhbHVlcyBhcmUgYWNjZXB0YWJsZS5cbiAgICAgKiBAcGFyYW0gcG9zaXRpdmUgV2hldGhlciB0byBhY2NlcHQgb25seSBwb3NpdGl2ZSBudW1lcmljIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJuIFRoZSBudW1iZXIgcGFzc2VkIGluLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzTnVtYmVyKHZhbHVlLCBudWxsT0ssIHBvc2l0aXZlKSB7XG4gICAgICAgIGlmIChjaGVja1R5cGUobnVsbE9LLCBVTkRFRklORUQpKSB7XG4gICAgICAgICAgICBudWxsT0sgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hlY2tUeXBlKHBvc2l0aXZlLCBVTkRFRklORUQpKSB7XG4gICAgICAgICAgICBwb3NpdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydCgobnVsbE9LICYmIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSkgfHwgaXNOdW1iZXIodmFsdWUpLCAnTnVtYmVyIGV4cGVjdGVkLicpO1xuICAgICAgICBpZiAocG9zaXRpdmUgJiYgdmFsdWUgJiYgdmFsdWUgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyAnUG9zaXRpdmUgbnVtYmVyIGV4cGVjdGVkLic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGdjVXRpbHMuYXNOdW1iZXIgPSBhc051bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEFzc2VydHMgdGhhdCBhIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgVmFsdWUgc3VwcG9zZWQgdG8gYmUgYW4gaW50ZWdlci5cbiAgICAgKiBAcGFyYW0gbnVsbE9LIFdoZXRoZXIgbnVsbCB2YWx1ZXMgYXJlIGFjY2VwdGFibGUuXG4gICAgICogQHBhcmFtIHBvc2l0aXZlIFdoZXRoZXIgdG8gYWNjZXB0IG9ubHkgcG9zaXRpdmUgaW50ZWdlcnMuXG4gICAgICogQHJldHVybiBUaGUgbnVtYmVyIHBhc3NlZCBpbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc0ludCh2YWx1ZSwgbnVsbE9LLCBwb3NpdGl2ZSkge1xuICAgICAgICBpZiAoY2hlY2tUeXBlKG51bGxPSywgVU5ERUZJTkVEKSkge1xuICAgICAgICAgICAgbnVsbE9LID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoZWNrVHlwZShwb3NpdGl2ZSwgVU5ERUZJTkVEKSkge1xuICAgICAgICAgICAgcG9zaXRpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoKG51bGxPSyAmJiBpc1VuZGVmaW5lZE9yTnVsbCh2YWx1ZSkpIHx8IGlzSW50KHZhbHVlKSwgJ0ludGVnZXIgZXhwZWN0ZWQuJyk7XG4gICAgICAgIGlmIChwb3NpdGl2ZSAmJiB2YWx1ZSAmJiB2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93ICdQb3NpdGl2ZSBpbnRlZ2VyIGV4cGVjdGVkLic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGdjVXRpbHMuYXNJbnQgPSBhc0ludDtcblxuICAgIC8qKlxuICAgICAqIEFzc2VydHMgdGhhdCBhIHZhbHVlIGlzIGEgQm9vbGVhbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSBzdXBwb3NlZCB0byBiZSBCb29sZWFuLlxuICAgICAqIEBwYXJhbSBudWxsT0sgV2hldGhlciBudWxsIHZhbHVlcyBhcmUgYWNjZXB0YWJsZS5cbiAgICAgKiBAcmV0dXJuIFRoZSBCb29sZWFuIHBhc3NlZCBpbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc0Jvb2xlYW4odmFsdWUsIG51bGxPSykge1xuICAgICAgICBpZiAoY2hlY2tUeXBlKG51bGxPSywgVU5ERUZJTkVEKSkge1xuICAgICAgICAgICAgbnVsbE9LID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KChudWxsT0sgJiYgaXNVbmRlZmluZWRPck51bGwodmFsdWUpKSB8fCBpc0Jvb2xlYW4odmFsdWUpLCAnQm9vbGVhbiBleHBlY3RlZC4nKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGdjVXRpbHMuYXNCb29sZWFuID0gYXNCb29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQXNzZXJ0cyB0aGF0IGEgdmFsdWUgaXMgYSBEYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIFZhbHVlIHN1cHBvc2VkIHRvIGJlIGEgRGF0ZS5cbiAgICAgKiBAcGFyYW0gbnVsbE9LIFdoZXRoZXIgbnVsbCB2YWx1ZXMgYXJlIGFjY2VwdGFibGUuXG4gICAgICogQHJldHVybiBUaGUgRGF0ZSBwYXNzZWQgaW4uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNEYXRlKHZhbHVlLCBudWxsT0spIHtcbiAgICAgICAgaWYgKGNoZWNrVHlwZShudWxsT0ssIFVOREVGSU5FRCkpIHtcbiAgICAgICAgICAgIG51bGxPSyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydCgobnVsbE9LICYmIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSkgfHwgaXNEYXRlKHZhbHVlKSwgJ0RhdGUgZXhwZWN0ZWQuJyk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBnY1V0aWxzLmFzRGF0ZSA9IGFzRGF0ZTtcblxuICAgIC8qKlxuICAgICAqIEFzc2VydHMgdGhhdCBhIHZhbHVlIGlzIGEgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgVmFsdWUgc3VwcG9zZWQgdG8gYmUgYSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gbnVsbE9LIFdoZXRoZXIgbnVsbCB2YWx1ZXMgYXJlIGFjY2VwdGFibGUuXG4gICAgICogQHJldHVybiBUaGUgZnVuY3Rpb24gcGFzc2VkIGluLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzRnVuY3Rpb24odmFsdWUsIG51bGxPSykge1xuICAgICAgICBpZiAoY2hlY2tUeXBlKG51bGxPSywgVU5ERUZJTkVEKSkge1xuICAgICAgICAgICAgbnVsbE9LID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KChudWxsT0sgJiYgaXNVbmRlZmluZWRPck51bGwodmFsdWUpKSB8fCBpc0Z1bmN0aW9uKHZhbHVlKSwgJ0Z1bmN0aW9uIGV4cGVjdGVkLicpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2NVdGlscy5hc0Z1bmN0aW9uID0gYXNGdW5jdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEFzc2VydHMgdGhhdCBhIHZhbHVlIGlzIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIFZhbHVlIHN1cHBvc2VkIHRvIGJlIGFuIGFycmF5LlxuICAgICAqIEBwYXJhbSBudWxsT0sgV2hldGhlciBudWxsIHZhbHVlcyBhcmUgYWNjZXB0YWJsZS5cbiAgICAgKiBAcmV0dXJuIFRoZSBhcnJheSBwYXNzZWQgaW4uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNBcnJheSh2YWx1ZSwgbnVsbE9LKSB7XG4gICAgICAgIGlmIChjaGVja1R5cGUobnVsbE9LLCBVTkRFRklORUQpKSB7XG4gICAgICAgICAgICBudWxsT0sgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoKG51bGxPSyAmJiBpc1VuZGVmaW5lZE9yTnVsbCh2YWx1ZSkpIHx8IGlzQXJyYXkodmFsdWUpLCAnQXJyYXkgZXhwZWN0ZWQuJyk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBnY1V0aWxzLmFzQXJyYXkgPSBhc0FycmF5O1xuXG4gICAgLyoqXG4gICAgICogQXNzZXJ0cyB0aGF0IGEgdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgYSBnaXZlbiB0eXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gICAgICogQHBhcmFtIHR5cGUgVHlwZSBvZiB2YWx1ZSBleHBlY3RlZC5cbiAgICAgKiBAcGFyYW0gbnVsbE9LIFdoZXRoZXIgbnVsbCB2YWx1ZXMgYXJlIGFjY2VwdGFibGUuXG4gICAgICogQHJldHVybiBUaGUgdmFsdWUgcGFzc2VkIGluLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzVHlwZSh2YWx1ZSwgdHlwZSwgbnVsbE9LKSB7XG4gICAgICAgIGlmIChjaGVja1R5cGUobnVsbE9LLCBVTkRFRklORUQpKSB7XG4gICAgICAgICAgICBudWxsT0sgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoKG51bGxPSyAmJiBpc1VuZGVmaW5lZE9yTnVsbCh2YWx1ZSkpIHx8IHZhbHVlIGluc3RhbmNlb2YgdHlwZSwgdHlwZSArICcgZXhwZWN0ZWQuJyk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBnY1V0aWxzLmFzVHlwZSA9IGFzVHlwZTtcblxuICAgIC8qKlxuICAgICAqIEFzc2VydHMgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgc2V0dGluZyBmb3IgYW4gZW51bWVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgVmFsdWUgc3VwcG9zZWQgdG8gYmUgYSBtZW1iZXIgb2YgdGhlIGVudW1lcmF0aW9uLlxuICAgICAqIEBwYXJhbSBlbnVtVHlwZSBFbnVtZXJhdGlvbiB0byB0ZXN0IGZvci5cbiAgICAgKiBAcGFyYW0gbnVsbE9LIFdoZXRoZXIgbnVsbCB2YWx1ZXMgYXJlIGFjY2VwdGFibGUuXG4gICAgICogQHJldHVybiBUaGUgdmFsdWUgcGFzc2VkIGluLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzRW51bSh2YWx1ZSwgZW51bVR5cGUsIG51bGxPSykge1xuICAgICAgICBpZiAoY2hlY2tUeXBlKG51bGxPSywgVU5ERUZJTkVEKSkge1xuICAgICAgICAgICAgbnVsbE9LID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSAmJiBudWxsT0spIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlID0gZW51bVR5cGVbdmFsdWVdO1xuICAgICAgICBhc3NlcnQoIWlzVW5kZWZpbmVkT3JOdWxsKGUpLCAnSW52YWxpZCBlbnVtIHZhbHVlLicpO1xuICAgICAgICByZXR1cm4gaXNOdW1iZXIoZSkgPyBlIDogdmFsdWU7XG4gICAgfVxuXG4gICAgZ2NVdGlscy5hc0VudW0gPSBhc0VudW07XG5cbiAgICAvKipcbiAgICAgKiBFbnVtZXJhdGlvbiB3aXRoIGtleSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIGVudW1lcmF0aW9uIGlzIHVzZWZ1bCB3aGVuIGhhbmRsaW5nIDxiPmtleURvd248L2I+IGV2ZW50cy5cbiAgICAgKi9cbiAgICB2YXIgS2V5ID0ge1xuICAgICAgICAvKiogVGhlIGJhY2tzcGFjZSBrZXkuICovXG4gICAgICAgIEJhY2s6IDgsXG4gICAgICAgIC8qKiBUaGUgdGFiIGtleS4gKi9cbiAgICAgICAgVGFiOiA5LFxuICAgICAgICAvKiogVGhlIGVudGVyIGtleS4gKi9cbiAgICAgICAgRW50ZXI6IDEzLFxuICAgICAgICAvKiogVGhlIGVzY2FwZSBrZXkuICovXG4gICAgICAgIEVzY2FwZTogMjcsXG4gICAgICAgIC8qKiBUaGUgc3BhY2Uga2V5LiAqL1xuICAgICAgICBTcGFjZTogMzIsXG4gICAgICAgIC8qKiBUaGUgcGFnZSB1cCBrZXkuICovXG4gICAgICAgIFBhZ2VVcDogMzMsXG4gICAgICAgIC8qKiBUaGUgcGFnZSBkb3duIGtleS4gKi9cbiAgICAgICAgUGFnZURvd246IDM0LFxuICAgICAgICAvKiogVGhlIGVuZCBrZXkuICovXG4gICAgICAgIEVuZDogMzUsXG4gICAgICAgIC8qKiBUaGUgaG9tZSBrZXkuICovXG4gICAgICAgIEhvbWU6IDM2LFxuICAgICAgICAvKiogVGhlIGxlZnQgYXJyb3cga2V5LiAqL1xuICAgICAgICBMZWZ0OiAzNyxcbiAgICAgICAgLyoqIFRoZSB1cCBhcnJvdyBrZXkuICovXG4gICAgICAgIFVwOiAzOCxcbiAgICAgICAgLyoqIFRoZSByaWdodCBhcnJvdyBrZXkuICovXG4gICAgICAgIFJpZ2h0OiAzOSxcbiAgICAgICAgLyoqIFRoZSBkb3duIGFycm93IGtleS4gKi9cbiAgICAgICAgRG93bjogNDAsXG4gICAgICAgIC8qKiBUaGUgZGVsZXRlIGtleS4gKi9cbiAgICAgICAgRGVsZXRlOiA0NixcbiAgICAgICAgLyoqIFRoZSBGMSBrZXkuICovXG4gICAgICAgIEYxOiAxMTIsXG4gICAgICAgIC8qKiBUaGUgRjIga2V5LiAqL1xuICAgICAgICBGMjogMTEzLFxuICAgICAgICAvKiogVGhlIEYzIGtleS4gKi9cbiAgICAgICAgRjM6IDExNCxcbiAgICAgICAgLyoqIFRoZSBGNCBrZXkuICovXG4gICAgICAgIEY0OiAxMTUsXG4gICAgICAgIC8qKiBUaGUgRjUga2V5LiAqL1xuICAgICAgICBGNTogMTE2LFxuICAgICAgICAvKiogVGhlIEY2IGtleS4gKi9cbiAgICAgICAgRjY6IDExNyxcbiAgICAgICAgLyoqIFRoZSBGNyBrZXkuICovXG4gICAgICAgIEY3OiAxMTgsXG4gICAgICAgIC8qKiBUaGUgRjgga2V5LiAqL1xuICAgICAgICBGODogMTE5LFxuICAgICAgICAvKiogVGhlIEY5IGtleS4gKi9cbiAgICAgICAgRjk6IDEyMCxcbiAgICAgICAgLyoqIFRoZSBGMTAga2V5LiAqL1xuICAgICAgICBGMTA6IDEyMSxcbiAgICAgICAgLyoqIFRoZSBGMTEga2V5LiAqL1xuICAgICAgICBGMTE6IDEyMixcbiAgICAgICAgLyoqIFRoZSBGMTIga2V5LiAqL1xuICAgICAgICBGMTI6IDEyM1xuICAgIH07XG4gICAgZ2NVdGlscy5LZXkgPSBLZXk7XG5cbiAgICB2YXIgRWRpdG9yVHlwZSA9IHtcbiAgICAgICAgJ1RleHQnOiAndGV4dCcsXG4gICAgICAgICdDaGVja0JveCc6ICdjaGVja2JveCcsXG4gICAgICAgICdEYXRlJzogJ2RhdGUnLFxuICAgICAgICAnQ29sb3InOiAnY29sb3InLFxuICAgICAgICAnTnVtYmVyJzogJ251bWJlcidcbiAgICB9O1xuICAgIGdjVXRpbHMuRWRpdG9yVHlwZSA9IEVkaXRvclR5cGU7XG5cbiAgICB2YXIgRGF0YVR5cGUgPSB7XG4gICAgICAgICdPYmplY3QnOiAnT2JqZWN0JyxcbiAgICAgICAgJ1N0cmluZyc6ICdTdHJpbmcnLFxuICAgICAgICAnTnVtYmVyJzogJ051bWJlcicsXG4gICAgICAgICdCb29sZWFuJzogJ0Jvb2xlYW4nLFxuICAgICAgICAnRGF0ZSc6ICdEYXRlJyxcbiAgICAgICAgJ0FycmF5JzogJ0FycmF5J1xuICAgIH07XG4gICAgZ2NVdGlscy5EYXRhVHlwZSA9IERhdGFUeXBlO1xuXG4gICAgdmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gICAgICAgIGNvbHVtbkNvdW50OiB0cnVlLFxuICAgICAgICBmbGV4OiB0cnVlLFxuICAgICAgICBmbGV4R3JvdzogdHJ1ZSxcbiAgICAgICAgZmxleFNocmluazogdHJ1ZSxcbiAgICAgICAgZm9udFdlaWdodDogdHJ1ZSxcbiAgICAgICAgbGluZUNsYW1wOiB0cnVlLFxuICAgICAgICBsaW5lSGVpZ2h0OiB0cnVlLFxuICAgICAgICBvcGFjaXR5OiB0cnVlLFxuICAgICAgICBvcmRlcjogdHJ1ZSxcbiAgICAgICAgb3JwaGFuczogdHJ1ZSxcbiAgICAgICAgd2lkb3dzOiB0cnVlLFxuICAgICAgICB6SW5kZXg6IHRydWUsXG4gICAgICAgIHpvb206IHRydWUsXG5cbiAgICAgICAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICAgICAgICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgICAgICAgc3Ryb2tlT3BhY2l0eTogdHJ1ZVxuICAgIH07XG4gICAgdmFyIF91cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcbiAgICB2YXIgbXNQYXR0ZXJuID0gL14tbXMtLztcblxuICAgIGZ1bmN0aW9uIGRhbmdlcm91c1N0eWxlVmFsdWUobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGlzRW1wdHkgPSBpc1VuZGVmaW5lZE9yTnVsbCh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuICAgICAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlzTm9uTnVtZXJpYyA9IGlzTmFOKHZhbHVlKTtcbiAgICAgICAgaWYgKGlzTm9uTnVtZXJpYyB8fCB2YWx1ZSA9PT0gMCB8fFxuICAgICAgICAgICAgaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gJycgKyB2YWx1ZTsgLy8gY2FzdCB0byBzdHJpbmdcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUgKyAncHgnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lbW9pemVTdHJpbmdPbmx5KGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IHt9O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkoc3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZVtzdHJpbmddO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWNoZVtzdHJpbmddID0gY2FsbGJhY2suY2FsbCh0aGlzLCBzdHJpbmcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZVtzdHJpbmddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBwcm9jZXNzU3R5bGVOYW1lID0gbWVtb2l6ZVN0cmluZ09ubHkoZnVuY3Rpb24oc3R5bGVOYW1lKSB7XG4gICAgICAgIHJldHVybiBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGh5cGhlbmF0ZShzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF91cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBoeXBoZW5hdGUoc3RyaW5nKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVNYXJrdXBGb3JTdHlsZXMoc3R5bGVzKSB7XG4gICAgICAgIHZhciBzZXJpYWxpemVkID0gJyc7XG4gICAgICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdHlsZVZhbHVlID0gc3R5bGVzW3N0eWxlTmFtZV07XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkT3JOdWxsKHN0eWxlVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZCArPSBwcm9jZXNzU3R5bGVOYW1lKHN0eWxlTmFtZSkgKyAnOic7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSkgKyAnOyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQgfHwgbnVsbDtcbiAgICB9XG5cbiAgICBnY1V0aWxzLmNyZWF0ZU1hcmt1cEZvclN0eWxlcyA9IGNyZWF0ZU1hcmt1cEZvclN0eWxlcztcblxuICAgIC8qKlxuICAgICAqIENhbmNlbHMgdGhlIHJvdXRlIGZvciBET00gZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FuY2VsRGVmYXVsdChlKSB7XG4gICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9JRSA4XG4gICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBnY1V0aWxzLmNhbmNlbERlZmF1bHQgPSBjYW5jZWxEZWZhdWx0O1xuXG4gICAgZnVuY3Rpb24gc2VyaWFsaXplT2JqZWN0KG9iaikge1xuICAgICAgICB2YXIgY2xvbmVPYmogPSBfLmNsb25lKG9iaik7XG4gICAgICAgIHZhciBjYWNoZV8gPSBbXTtcbiAgICAgICAgaWYgKGNsb25lT2JqKSB7XG4gICAgICAgICAgICBjYWNoZV8ucHVzaChjbG9uZU9iaik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlc3Q7XG4gICAgICAgIHdoaWxlIChjYWNoZV8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZGVzdCA9IGNhY2hlXy5wb3AoKTtcbiAgICAgICAgICAgIGlmICghaXNPYmplY3QoZGVzdCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGl0ZW0gaW4gZGVzdCkge1xuICAgICAgICAgICAgICAgIGNhY2hlXy5wdXNoKGRlc3RbaXRlbV0pO1xuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGRlc3RbaXRlbV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RbaXRlbV0gPSBzZXJpYWxpemVGdW5jdGlvbihkZXN0W2l0ZW1dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lT2JqO1xuICAgIH1cblxuICAgIGdjVXRpbHMuc2VyaWFsaXplT2JqZWN0ID0gc2VyaWFsaXplT2JqZWN0O1xuXG4gICAgZnVuY3Rpb24gZGVzZXJpYWxpemVPYmplY3Qob2JqKSB7XG4gICAgICAgIHZhciBjbG9uZU9iaiA9IF8uY2xvbmUob2JqKTtcbiAgICAgICAgdmFyIGNhY2hlXyA9IFtdO1xuICAgICAgICBpZiAoY2xvbmVPYmopIHtcbiAgICAgICAgICAgIGNhY2hlXy5wdXNoKGNsb25lT2JqKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVzdDtcbiAgICAgICAgdmFyIGZ1bmM7XG4gICAgICAgIHdoaWxlIChjYWNoZV8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZGVzdCA9IGNhY2hlXy5wb3AoKTtcbiAgICAgICAgICAgIGlmICghaXNPYmplY3QoZGVzdCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGl0ZW0gaW4gZGVzdCkge1xuICAgICAgICAgICAgICAgIGNhY2hlXy5wdXNoKGRlc3RbaXRlbV0pO1xuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhkZXN0W2l0ZW1dKSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jID0gZGVzZXJpYWxpemVGdW5jdGlvbihkZXN0W2l0ZW1dKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RbaXRlbV0gPSBmdW5jO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9uZU9iajtcbiAgICB9XG5cbiAgICBnY1V0aWxzLmRlc2VyaWFsaXplT2JqZWN0ID0gZGVzZXJpYWxpemVPYmplY3Q7XG5cbiAgICBmdW5jdGlvbiBzZXJpYWxpemVGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBnY1V0aWxzLnNlcmlhbGl6ZUZ1bmN0aW9uID0gc2VyaWFsaXplRnVuY3Rpb247XG5cbiAgICBmdW5jdGlvbiBkZXNlcmlhbGl6ZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciB0ZW1wU3RyID0gdmFsdWUuc3Vic3RyKDgsIHZhbHVlLmluZGV4T2YoJygnKSAtIDgpOyAvLzggaXMgJ2Z1bmN0aW9uJyBsZW5ndGhcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdWJzdHIoMCwgOCkgPT09ICdmdW5jdGlvbicgJiYgdGVtcFN0ci5yZXBsYWNlKC9cXHMrLywgJycpID09PSAnJykge1xuICAgICAgICAgICAgICAgIHZhciBhcmdTdGFydCA9IHZhbHVlLmluZGV4T2YoJygnKSArIDE7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ0VuZCA9IHZhbHVlLmluZGV4T2YoJyknKTtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IHZhbHVlLnN1YnN0cihhcmdTdGFydCwgYXJnRW5kIC0gYXJnU3RhcnQpLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnLnJlcGxhY2UoL1xccysvLCAnJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHlTdGFydCA9IHZhbHVlLmluZGV4T2YoJ3snKSArIDE7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHlFbmQgPSB2YWx1ZS5sYXN0SW5kZXhPZignfScpO1xuICAgICAgICAgICAgICAgIC8qanNsaW50IGV2aWw6IHRydWUgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGFyZ3MsIHZhbHVlLnN1YnN0cihib2R5U3RhcnQsIGJvZHlFbmQgLSBib2R5U3RhcnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBnY1V0aWxzLmRlc2VyaWFsaXplRnVuY3Rpb24gPSBkZXNlcmlhbGl6ZUZ1bmN0aW9uO1xuICAgIC8qKlxuICAgICAqIEFzc2VydHMgdGhhdCBhIHZhbHVlIGlzIGFuIEBzZWU6SUNvbGxlY3Rpb25WaWV3IG9yIGFuIEFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIEFycmF5IG9yIEBzZWU6SUNvbGxlY3Rpb25WaWV3LlxuICAgICAqIEBwYXJhbSBudWxsT0sgV2hldGhlciBudWxsIHZhbHVlcyBhcmUgYWNjZXB0YWJsZS5cbiAgICAgKiBAcmV0dXJuIFRoZSBAc2VlOklDb2xsZWN0aW9uVmlldyB0aGF0IHdhcyBwYXNzZWQgaW4gb3IgYSBAc2VlOkNvbGxlY3Rpb25WaWV3XG4gICAgICogY3JlYXRlZCBmcm9tIHRoZSBhcnJheSB0aGF0IHdhcyBwYXNzZWQgaW4uXG4gICAgICovXG4gICAgLypcbiAgICAgZnVuY3Rpb24gYXNDb2xsZWN0aW9uVmlldyh2YWx1ZSwgbnVsbE9LKSB7XG4gICAgIGlmICh0eXBlb2YgbnVsbE9LID09PSBcInVuZGVmaW5lZFwiKSB7IG51bGxPSyA9IHRydWU7IH1cbiAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgbnVsbE9LKSB7XG4gICAgIHJldHVybiBudWxsO1xuICAgICB9XG4gICAgIHZhciBjdiA9IHRyeUNhc3QodmFsdWUsICdJQ29sbGVjdGlvblZpZXcnKTtcbiAgICAgaWYgKGN2ICE9IG51bGwpIHtcbiAgICAgcmV0dXJuIGN2O1xuICAgICB9XG4gICAgIGlmICghaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgYXNzZXJ0KGZhbHNlLCAnQXJyYXkgb3IgSUNvbGxlY3Rpb25WaWV3IGV4cGVjdGVkLicpO1xuICAgICB9XG4gICAgIHJldHVybiBuZXcgd2lqbW8uY29sbGVjdGlvbnMuQ29sbGVjdGlvblZpZXcodmFsdWUpO1xuICAgICB9XG4gICAgIGdjVXRpbHMuYXNDb2xsZWN0aW9uVmlldyA9IGFzQ29sbGVjdGlvblZpZXc7Ki9cblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIHBsdWdpbiBtb2R1bGUuXG4gICAgICogQHBhcmFtIG5hbWUgb2YgbW9kdWxlXG4gICAgICogQHJldHVybnMgcGx1Z2luIG1vZHVsZSBvYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kUGx1Z2luKG5hbWUpIHtcbiAgICAgICAgdmFyIHBsdWdpbjtcbiAgICAgICAgLy8gZmluZCBmcm9tIGdsb2JhbFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGx1Z2luID0gR2NTcHJlYWQuVmlld3MuR2NHcmlkLlBsdWdpbnNbbmFtZV07Ly8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgKCFwbHVnaW4gJiYgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7Ly8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgIC8vICAgIHBsdWdpbiA9IHJlcXVpcmVqcyAmJiByZXF1aXJlanMobmFtZSkgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgIC8vfVxuICAgICAgICAvL1xuICAgICAgICAvLy8vIGNvbW1vbmpzIG5vdCBzdXBwb3J0ZWQgbm93XG4gICAgICAgIC8vaWYgKCFwbHVnaW4gJiYgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7Ly8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgIC8vfVxuICAgICAgICByZXR1cm4gcGx1Z2luO1xuICAgIH1cblxuICAgIGdjVXRpbHMuZmluZFBsdWdpbiA9IGZpbmRQbHVnaW47XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdjVXRpbHM7XG59KCkpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2FwcC9zY3JpcHRzL2dyaWQvZ2NVdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbih3aW5kb3cpIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIHZhciBzdXBwb3J0RXZlbnRzID0gWyd0b3VjaHN0YXJ0JywgJ3RvdWNobW92ZScsICd0b3VjaGVuZCddO1xuXG4gICAgICAgIHZhciBsYXN0SHdUaW1lc3RhbXAgPSAwO1xuXG4gICAgICAgIHZhciBldmVudE1hcHBpbmdzID0ge1xuICAgICAgICAgICAgdG91Y2hzdGFydDogWydwb2ludGVyZG93bicsICdNU1BvaW50ZXJEb3duJywgJ3RvdWNoc3RhcnQnXSxcbiAgICAgICAgICAgIHRvdWNobW92ZTogWydwb2ludGVybW92ZScsICdNU1BvaW50ZXJNb3ZlJywgJ3RvdWNobW92ZSddLFxuICAgICAgICAgICAgdG91Y2hlbmQ6IFsncG9pbnRlcnVwJywgJ01TUG9pbnRlclVwJywgJ3RvdWNoZW5kJ11cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbWFwcGluZ0luZGV4ID0gd2luZG93LlBvaW50ZXJFdmVudCA/IDAgOiAod2luZG93Lk1TUG9pbnRlckV2ZW50ID8gMSA6IDIpO1xuXG4gICAgICAgIHZhciB0b3VjaGVzV3JhcHBlcjtcbiAgICAgICAgdmFyIGNoYW5nZWRUb3VjaGVzV3JhcHBlcjtcbiAgICAgICAgdmFyIHRhcmdldFRvdWNoZXNXcmFwcGVyO1xuXG4gICAgICAgIGZ1bmN0aW9uIFRvdWNoV3JhcHBlcihlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hbmFnZXIoZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBNYW5hZ2VyKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBNYW5hZ2VyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgICAgIG9uOiBmdW5jdGlvbih0YXJnZXRFdmVudCwgaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRFdmVudHMuaW5kZXhPZih0YXJnZXRFdmVudCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0YXJnZXRFdmVudCwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydFRhcmdldEV2ZW50KGVsZW1lbnQsIHRhcmdldEV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodGFyZ2V0RXZlbnQsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hdGl2ZUV2ZW50ID0gZXZlbnROYW1lR2VuZXJhdGUodGFyZ2V0RXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydFRhcmdldEV2ZW50KGVsZW1lbnQsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hdGl2ZUhhbmRsZXIgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZVRvdWNoQ2xvbmVkRXZlbnQoZXZ0LCBoYW5kbGVyLCB0YXJnZXRFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdWlkID0gZ3VpZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci51aWQgPSB1aWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRvclJlbW92ZVdyYXBFdmVudExpc3RlbmVyKGVsZW1lbnQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVIYW5kbGVyLCB1aWQsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlSUVTY3JvbGwoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvZmY6IGZ1bmN0aW9uKHRhcmdldEV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydEV2ZW50cy5pbmRleE9mKHRhcmdldEV2ZW50KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHRhcmdldEV2ZW50LCBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0VGFyZ2V0RXZlbnQoZWxlbWVudCwgdGFyZ2V0RXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlbGVtZW50LCB0YXJnZXRFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZGRvclJlbW92ZVdyYXBFdmVudExpc3RlbmVyKGVsZW1lbnQsIHRhcmdldEV2ZW50LCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZUlFU2Nyb2xsKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNob3VsZFJhaXNlVGFwRXZlbnQ6ZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEod2luZG93LlBvaW50ZXJFdmVudCB8fCB3aW5kb3cuTVNQb2ludGVyRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIFRvdWNoTGlzdFdyYXBwZXIoKSB7XG4gICAgICAgICAgICB2YXIgdG91Y2hMaXN0ID0gW107XG4gICAgICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgICAgICAgICAvL3JlZmVyOiBodHRwOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvXG4gICAgICAgICAgICBmdW5jdGlvbiBUb3VjaChpZGVudGlmaWVyLCB0YXJnZXQsIHNjcmVlblgsIHNjcmVlblksIGNsaWVudFgsIGNsaWVudFksIHBhZ2VYLCBwYWdlWSkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBzZWxmLmlkZW50aWZpZXIgPSBpZGVudGlmaWVyO1xuICAgICAgICAgICAgICAgIHNlbGYudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIHNlbGYuc2NyZWVuWCA9IHNjcmVlblg7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JlZW5ZID0gc2NyZWVuWTtcbiAgICAgICAgICAgICAgICBzZWxmLmNsaWVudFggPSBjbGllbnRYO1xuICAgICAgICAgICAgICAgIHNlbGYuY2xpZW50WSA9IGNsaWVudFk7XG4gICAgICAgICAgICAgICAgc2VsZi5wYWdlWCA9IHBhZ2VYO1xuICAgICAgICAgICAgICAgIHNlbGYucGFnZVkgPSBwYWdlWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0VG91Y2goaWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgIHZhciBsO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0b3VjaExpc3QubGVuZ3RoOyBpIDwgbDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3VjaExpc3RbaV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvdWNoTGlzdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkVXBkYXRlVG91Y2godG91Y2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICB2YXIgbDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdG91Y2hMaXN0Lmxlbmd0aDsgaSA8IGw7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG91Y2hMaXN0W2ldLmlkZW50aWZpZXIgPT09IHRvdWNoLmlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdWNoTGlzdFtpXSA9IHRvdWNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdG91Y2hMaXN0LnB1c2godG91Y2gpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiByZW1vdmVUb3VjaChpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgdmFyIGw7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHRvdWNoTGlzdC5sZW5ndGg7IGkgPCB0b3VjaExpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvdWNoTGlzdFtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3VjaExpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjbGVhclRvdWNoZXMoKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRvdWNoTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoTGlzdC5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbnRhaW5zVG91Y2hBdChzY3JlZW5YLCBzY3JlZW5ZKSB7XG4gICAgICAgICAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG91Y2hMaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3VjaExpc3RbaV0uc2NyZWVuWCA9PT0gc2NyZWVuWCAmJiB0b3VjaExpc3RbaV0uc2NyZWVuWSA9PT0gc2NyZWVuWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjb3BlLnRvdWNoTGlzdCA9IHRvdWNoTGlzdDtcblxuICAgICAgICAgICAgc2NvcGUuVG91Y2ggPSBUb3VjaDtcbiAgICAgICAgICAgIHNjb3BlLmdldFRvdWNoID0gZ2V0VG91Y2g7XG4gICAgICAgICAgICBzY29wZS5hZGRVcGRhdGVUb3VjaCA9IGFkZFVwZGF0ZVRvdWNoO1xuICAgICAgICAgICAgc2NvcGUucmVtb3ZlVG91Y2ggPSByZW1vdmVUb3VjaDtcbiAgICAgICAgICAgIHNjb3BlLmNsZWFyVG91Y2hlcyA9IGNsZWFyVG91Y2hlcztcbiAgICAgICAgICAgIHNjb3BlLmNvbnRhaW5zVG91Y2hBdCA9IGNvbnRhaW5zVG91Y2hBdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZG9yUmVtb3ZlV3JhcEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIHVpZCwgZW5hYmxlKSB7XG4gICAgICAgICAgICBpZiAoZW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKCF3aW5kb3cuY2FjaGVkRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jYWNoZWRFdmVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3aW5kb3cuY2FjaGVkRXZlbnRzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiB1aWRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghd2luZG93LmNhY2hlZEV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB3aW5kb3cuY2FjaGVkRXZlbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2FjaGVkRXZlbnQgPSB3aW5kb3cuY2FjaGVkRXZlbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVkRXZlbnQudWlkID09PSBoYW5kbGVyLnVpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkRXZlbnQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGNhY2hlZEV2ZW50LmV2ZW50LCBjYWNoZWRFdmVudC5oYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2luZG93LmNhY2hlZEV2ZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5jYWNoZWRFdmVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3cuY2FjaGVkRXZlbnRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdlbmVyYXRlVG91Y2hDbG9uZWRFdmVudChldmVudEFyZ3MsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHZhciBldk9iajtcbiAgICAgICAgICAgIHZhciBvbGRUb3VjaDtcbiAgICAgICAgICAgIHZhciBvbGRUYXJnZXQ7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRhcmdldFRvdWNoZXModGhpc1RvdWNoVGFyZ2V0LCB0b3VjaGVzVG91Y2hMaXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgdmFyIHRvdWNoO1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0VG91Y2hlc1dyYXBwZXIuY2xlYXJUb3VjaGVzKCk7XG5cbiAgICAgICAgICAgICAgICAvL3RhcmdldFRvdWNoZXM6YSBsaXN0IG9mIFRvdWNoZXMgZm9yIGV2ZXJ5IHBvaW50IG9mIGNvbnRhY3QgdGhhdCBpcyB0b3VjaGluZyB0aGUgc3VyZmFjZSBhbmQgc3RhcnRlZCBvbiB0aGUgZWxlbWVudCB0aGF0IGlzIHRoZSB0YXJnZXQgb2YgdGhlIGN1cnJlbnQgZXZlbnQuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvdWNoZXNUb3VjaExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2ggPSB0b3VjaGVzVG91Y2hMaXN0W2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG91Y2gudGFyZ2V0LmlzU2FtZU5vZGUodGhpc1RvdWNoVGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VG91Y2hlc1dyYXBwZXIuYWRkVXBkYXRlVG91Y2godG91Y2gpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiB0b3VjaEhhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRUeXBlO1xuICAgICAgICAgICAgICAgIHZhciB0b3VjaDtcbiAgICAgICAgICAgICAgICB2YXIgdG91Y2hFdmVudDtcblxuICAgICAgICAgICAgICAgIGlmIChpc1BvaW50ZXJEb3duRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VHlwZSA9ICd0b3VjaHN0YXJ0JztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBldmVudFR5cGUgPSAndG91Y2htb3ZlJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0b3VjaCA9IG5ldyB0b3VjaGVzV3JhcHBlci5Ub3VjaChldmVudC5wb2ludGVySWQsIChpc1BvaW50ZXJEb3duRXZlbnQoZXZlbnQpID8gZXZlbnQudGFyZ2V0IDogb2xkVGFyZ2V0KSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc2NyZWVuWCwgZXZlbnQuc2NyZWVuWSwgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSwgZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZKTtcblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSwgZnJvbSBjaGFuZ2VkVG91Y2hlcywgYW55IFRvdWNoIHRoYXQgaXMgbm8gbG9uZ2VyIGJlaW5nIHRvdWNoZWQsIG9yIGlzIGJlaW5nIHRvdWNoZWRcbiAgICAgICAgICAgICAgICAvLyBpbiBleGFjdGx5IHRoZSBzYW1lIHBsYWNlLlxuICAgICAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHNpbXVsdGFuZW91cyB0b3VjaGVzIGRvbid0IGtpY2sgZWFjaCBvdGhlciBvZmYgb2YgdGhlIGNoYW5nZWRUb3VjaGVzIGFycmF5XG4gICAgICAgICAgICAgICAgLy8gKGJlY2F1c2UgdGhleSBhcmUgcHJvY2Vzc2VkIGFzIGRpZmZlcmVudCBwb2ludGVyIGV2ZW50cyksIHNraXAgdGhpcyBpZiB0aGUgbGFzdEh3VGltZXN0YW1wIGhhc24ndCBpbmNyZWFzZWQuXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50Lmh3VGltZXN0YW1wID4gbGFzdEh3VGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZWRUb3VjaExpc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlZFRvdWNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoaW5nVG91Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWRlbnRpZmllcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWRUb3VjaExpc3QgPSBjaGFuZ2VkVG91Y2hlc1dyYXBwZXIudG91Y2hMaXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNoYW5nZWRUb3VjaExpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkVG91Y2ggPSBjaGFuZ2VkVG91Y2hMaXN0W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSBjaGFuZ2VkVG91Y2guaWRlbnRpZmllcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZ1RvdWNoID0gdG91Y2hlc1dyYXBwZXIuZ2V0VG91Y2goaWRlbnRpZmllcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoaW5nVG91Y2ggfHwgdG91Y2hlc0FyZUF0U2FtZVNwb3QobWF0Y2hpbmdUb3VjaCwgY2hhbmdlZFRvdWNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkVG91Y2hlc1dyYXBwZXIucmVtb3ZlVG91Y2goaWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwb2ludGVySWQgPSBldmVudC5wb2ludGVySWQ7XG4gICAgICAgICAgICAgICAgaWYgKGlzUG9pbnRlckRvd25FdmVudChldmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdNU1BvaW50ZXJEb3duJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG91Y2gudGFyZ2V0Lm1zU2V0UG9pbnRlckNhcHR1cmUocG9pbnRlcklkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdWNoLnRhcmdldC5zZXRQb2ludGVyQ2FwdHVyZShwb2ludGVySWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy/pl67popjvvJrmnInkupvml7blgJnvvIzlvZPmiYvmjIfnprvlvIDlvZPliY3pobXpnaLml7bvvIxlbGVtZW50IOaXoOazleaUtuWIsHBvaW50ZXIgdXAvY2FuY2xlIOS6i+S7tu+8jFxuICAgICAgICAgICAgICAgICAgICAvL+WwseayoeacieaXtuacuuWOu3JlbW92ZSDnprvlvIDnmoR0b3VjaCBwb2ludGVyXG4gICAgICAgICAgICAgICAgICAgIC8v5pa55qGI77ya55uu5YmN5Y+q5pyJ5ZyocG9pbnRlcmRvd27ml7bmuIXnqbrnvJPlrZjnmoRwb2ludGVyIOS/oeaBr+OAglxuICAgICAgICAgICAgICAgICAgICAvL+W9seWTje+8muaMieeFp+S7peWJjeiuvuiuoeWPr+S7peaUr+aMgeWkmuS4quaJi+aMh++8jOeOsOWcqOWPquiDveaUr+aMgeWNleS4quaJi+aMh++8jOWboOS4uklF5LiL55qEem9vbeihjOS4uuW3sue7j+iiq+a1j+iniOWZqOWunueOsO+8jOaJgOS7pVxuICAgICAgICAgICAgICAgICAgICAvL+aUueWKqOS4jeS8muWvvOiHtOe8uuWkseOAguWQjumdouacieaXtumXtOeahOivnei/meS4queCuemcgOimgeWGjeiAg+iZkeiAg+iZkSAtVGltIDQvMjgvMjAxNS5cbiAgICAgICAgICAgICAgICAgICAgdG91Y2hlc1dyYXBwZXIuY2xlYXJUb3VjaGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGxvZygncG9pbnRlckRvd24gJyArICd0aW1zdGFwOicgKyBldmVudC5od1RpbWVzdGFtcCArICcgcG9pbnRlcklkOiAnICsgZXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2coJ3BvaW50ZXJNb3ZlJyArICcgdGltc3RhcDonICsgZXZlbnQuaHdUaW1lc3RhbXAgKyAnIHBvaW50ZXJJZDogJyArIGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIHRvdWNoZXNXcmFwcGVyLmFkZFVwZGF0ZVRvdWNoKHRvdWNoKTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkVG91Y2hlc1dyYXBwZXIuYWRkVXBkYXRlVG91Y2godG91Y2gpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVRhcmdldFRvdWNoZXModG91Y2gudGFyZ2V0LCB0b3VjaGVzV3JhcHBlci50b3VjaExpc3QpO1xuXG4gICAgICAgICAgICAgICAgdG91Y2hFdmVudCA9IG5ldyBDdXN0b21FdmVudChldmVudFR5cGUsIHtidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgdG91Y2hFdmVudC50b3VjaGVzID0gdG91Y2hlc1dyYXBwZXIudG91Y2hMaXN0O1xuICAgICAgICAgICAgICAgIHRvdWNoRXZlbnQuY2hhbmdlZFRvdWNoZXMgPSBjaGFuZ2VkVG91Y2hlc1dyYXBwZXIudG91Y2hMaXN0O1xuICAgICAgICAgICAgICAgIHRvdWNoRXZlbnQudGFyZ2V0VG91Y2hlcyA9IHRhcmdldFRvdWNoZXNXcmFwcGVyLnRvdWNoTGlzdDtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0b3VjaEV2ZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiB0b3VjaENoYW5nZWRIYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50VHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgdG91Y2g7XG4gICAgICAgICAgICAgICAgdmFyIHRvdWNoRXZlbnQ7XG5cbiAgICAgICAgICAgICAgICBldmVudC5jaGFuZ2VkVG91Y2hlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA9IDE7XG4gICAgICAgICAgICAgICAgZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gPSBldmVudDtcbiAgICAgICAgICAgICAgICBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5pZGVudGlmaWVyID0gZXZlbnQucG9pbnRlcklkO1xuXG4gICAgICAgICAgICAgICAgdG91Y2ggPSBuZXcgdG91Y2hlc1dyYXBwZXIuVG91Y2goZXZlbnQucG9pbnRlcklkLCBvbGRUYXJnZXQsIGV2ZW50LnNjcmVlblgsIGV2ZW50LnNjcmVlblksIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFksIGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNQb2ludGVyVXBFdmVudChldmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRUeXBlID0gJ3RvdWNoZW5kJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdNU1BvaW50ZXJVcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdWNoLnRhcmdldC5tc1JlbGVhc2VQb2ludGVyQ2FwdHVyZShldmVudC5wb2ludGVySWQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG91Y2gudGFyZ2V0LnJlbGVhc2VQb2ludGVyQ2FwdHVyZShldmVudC5wb2ludGVySWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG5ldyB0b3VjaCBldmVudCBpZiBpdCBoYXBwZW5lZCBhdCBhIGdyZWF0ZXIgdGltZSB0aGFuIHRoZSBsYXN0IHRvdWNoIGV2ZW50LlxuICAgICAgICAgICAgICAgIC8vIElmIGl0IGlzIGEgbmV3IHRvdWNoIGV2ZW50LCBjbGVhciBvdXQgdGhlIGNoYW5nZWRUb3VjaGVzIFRvdWNoTGlzdC5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuaHdUaW1lc3RhbXAgPiBsYXN0SHdUaW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZFRvdWNoZXNXcmFwcGVyLmNsZWFyVG91Y2hlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB0b3VjaGVzV3JhcHBlci5yZW1vdmVUb3VjaCh0b3VjaC5pZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkVG91Y2hlc1dyYXBwZXIuYWRkVXBkYXRlVG91Y2godG91Y2gpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVRhcmdldFRvdWNoZXModG91Y2gudGFyZ2V0LCB0b3VjaGVzV3JhcHBlci50b3VjaExpc3QpO1xuXG4gICAgICAgICAgICAgICAgdG91Y2hFdmVudCA9IG5ldyBDdXN0b21FdmVudChldmVudFR5cGUsIHtidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgdG91Y2hFdmVudC50b3VjaGVzID0gdG91Y2hlc1dyYXBwZXIudG91Y2hMaXN0O1xuICAgICAgICAgICAgICAgIHRvdWNoRXZlbnQuY2hhbmdlZFRvdWNoZXMgPSBjaGFuZ2VkVG91Y2hlc1dyYXBwZXIudG91Y2hMaXN0O1xuICAgICAgICAgICAgICAgIHRvdWNoRXZlbnQudGFyZ2V0VG91Y2hlcyA9IHRhcmdldFRvdWNoZXNXcmFwcGVyLnRvdWNoTGlzdDtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0b3VjaEV2ZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGxvZyh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2codmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gaXNQb2ludGVyRG93bkV2ZW50KGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnR5cGUgPT09ICdNU1BvaW50ZXJEb3duJyB8fCBldmVudC50eXBlID09PSAncG9pbnRlcmRvd24nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBpc1BvaW50ZXJNb3ZlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQudHlwZSA9PT0gJ01TUG9pbnRlck1vdmUnIHx8IGV2ZW50LnR5cGUgPT09ICdwb2ludGVybW92ZSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzUG9pbnRlclVwRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQudHlwZSA9PT0gJ01TUG9pbnRlclVwJyB8fCBldmVudC50eXBlID09PSAncG9pbnRlcnVwJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlnbm9yZVBvaW50ZXJFdmVudChldmVudEFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBbiBpbXBvcnRhbnQgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBNUyBwb2ludGVyIGV2ZW50cyBhbmQgdGhlIFczQyB0b3VjaCBldmVudHNcbiAgICAgICAgICAgIC8vIGlzIHRoYXQgZm9yIHBvaW50ZXIgZXZlbnRzIGV4Y2VwdCBmb3IgcG9pbnRlcmRvd24sIGFsbCB0YXJnZXQgdGhlIGVsZW1lbnQgdGhhdCB0aGUgdG91Y2hcbiAgICAgICAgICAgIC8vIGlzIG92ZXIgd2hlbiB0aGUgZXZlbnQgaXMgZmlyZWQuXG4gICAgICAgICAgICAvLyBUaGUgVzNDIHRvdWNoIGV2ZW50cyB0YXJnZXQgdGhlIGVsZW1lbnQgd2hlcmUgdGhlIHRvdWNoIG9yaWdpbmFsbHkgc3RhcnRlZC5cbiAgICAgICAgICAgIC8vIFRoZXJlZm9yZSwgd2hlbiB0aGVzZSBldmVudHMgYXJlIGZpcmVkLCB3ZSBtdXN0IG1ha2UgdGhpcyBjaGFuZ2UgbWFudWFsbHkuXG4gICAgICAgICAgICBpZiAoIWlzUG9pbnRlckRvd25FdmVudChldmVudEFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgb2xkVG91Y2ggPSB0b3VjaGVzV3JhcHBlci5nZXRUb3VjaChldmVudEFyZ3MucG9pbnRlcklkKTtcbiAgICAgICAgICAgICAgICBvbGRUYXJnZXQgPSBvbGRUb3VjaCA/IG9sZFRvdWNoLnRhcmdldCA6IGV2ZW50QXJncy50YXJnZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc1BvaW50ZXJEb3duRXZlbnQoZXZlbnRBcmdzKSB8fCBpc1BvaW50ZXJNb3ZlRXZlbnQoZXZlbnRBcmdzKSkge1xuICAgICAgICAgICAgICAgIGV2T2JqID0gdG91Y2hIYW5kbGVyKGV2ZW50QXJncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV2T2JqID0gdG91Y2hDaGFuZ2VkSGFuZGxlcihldmVudEFyZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBldk9iai5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudEFyZ3MucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRBcmdzLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaGFuZGxlci5jYWxsKGV2ZW50QXJncy50YXJnZXQsIGV2T2JqKTtcblxuICAgICAgICAgICAgbGFzdEh3VGltZXN0YW1wID0gZXZlbnRBcmdzLmh3VGltZXN0YW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZXZlbnROYW1lR2VuZXJhdGUoZXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudE1hcHBpbmdzW2V2ZW50XVttYXBwaW5nSW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc3VwcG9ydFRhcmdldEV2ZW50KGVsZW1lbnQsIGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRQcm8gPSAnb24nICsgZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJldHVybiAoZXZlbnRQcm8gaW4gZWxlbWVudCkgfHwgKGVsZW1lbnQuaGFzT3duUHJvcGVydHkoZXZlbnRQcm8pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlnbm9yZVBvaW50ZXJFdmVudChldmVudCkge1xuXG4gICAgICAgICAgICBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZXZlbnQucG9pbnRlclR5cGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdwb2ludGVyZG93bicgJiYgZXZlbnQueCA9PT0gMCAmJiBldmVudC55ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gJ3BlbicgJiYgZXZlbnQucHJlc3N1cmUgPT09IDAgJiYgZXZlbnQudHlwZSA9PT0gJ3BvaW50ZXJtb3ZlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdG91Y2hlc0FyZUF0U2FtZVNwb3QodG91Y2gwLCB0b3VjaDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0b3VjaDAuc2NyZWVuWCA9PT0gdG91Y2gxLnNjcmVlblggJiYgdG91Y2gwLnNjcmVlblkgPT09IHRvdWNoMS5zY3JlZW5ZO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZGlzYWJsZUlFU2Nyb2xsKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuc3R5bGUpIHtcbiAgICAgICAgICAgICAgICBpZiAod2luZG93Lk1TUG9pbnRlckV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0QXR0cmlidXRlKCctbXMtdG91Y2gtYWN0aW9uJywgJ25vbmU7Jyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS50b3VjaEFjdGlvbiA9ICdub25lJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBlbmFibGVJRVNjcm9sbChlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LnN0eWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5NU1BvaW50ZXJFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnLW1zLXRvdWNoLWFjdGlvbicpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUudG91Y2hBY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGd1aWQoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBzNCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoMSArIE1hdGgucmFuZG9tKCkpICogMHgxMDAwMClcbiAgICAgICAgICAgICAgICAgICAgLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgICAgICAgICAuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gczQoKSArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICsgczQoKSArICctJyArXG4gICAgICAgICAgICAgICAgczQoKSArICctJyArIHM0KCkgKyBzNCgpICsgczQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvdWNoZXNXcmFwcGVyID0gbmV3IFRvdWNoTGlzdFdyYXBwZXIoKTtcbiAgICAgICAgY2hhbmdlZFRvdWNoZXNXcmFwcGVyID0gbmV3IFRvdWNoTGlzdFdyYXBwZXIoKTtcbiAgICAgICAgdGFyZ2V0VG91Y2hlc1dyYXBwZXIgPSBuZXcgVG91Y2hMaXN0V3JhcHBlcigpO1xuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gVG91Y2hXcmFwcGVyO1xuICAgIH0od2luZG93KSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXBwL3NjcmlwdHMvZ3JpZC9Ub3VjaC5qc1xuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgZG9tVXRpbCA9IHJlcXVpcmUoJy4vZG9tVXRpbCcpO1xuICAgIHZhciBnY1V0aWxzID0gcmVxdWlyZSgnLi9nY1V0aWxzJyk7XG4gICAgdmFyIGRvVCA9IHJlcXVpcmUoJy4vZG9ULmpzJyk7XG4gICAgdmFyIEVkaXRvclR5cGUgPSBnY1V0aWxzLkVkaXRvclR5cGU7XG4gICAgdmFyIEVkaXRvciA9IHt9O1xuICAgIHZhciBFZGl0TW9kZSA9IHtcbiAgICAgICAgSW5saW5lOiAnaW5saW5lJyxcbiAgICAgICAgUG9wVXA6ICdwb3B1cCcsXG4gICAgICAgIEVkaXRGb3JtOiAnZWRpdEZvcm0nXG4gICAgfTtcblxuICAgIC8vPGVkaXRvci1mb2xkIGRlc2M9XCJIZWxwZXJcIj5cbiAgICBmdW5jdGlvbiBzZXRDb250YWluZXJaSW5kZXhfKEdlbmVyYWxFZGl0b3IpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnIycgKyBHZW5lcmFsRWRpdG9yLm9wdGlvbnMuZ3JpZE1vZGVsLnVpZCArICctZWRpdGluZy1hcmVhIC50b3AnKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZG9tVXRpbC5yZW1vdmVDbGFzcyhlbGVtZW50c1tpXSwgJ3RvcCcpO1xuICAgICAgICB9XG4gICAgICAgIGRvbVV0aWwuYWRkQ2xhc3ModGhpcywgJ3RvcCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkanVzdFN0eWxlXyhHZW5lcmFsRWRpdG9yKSB7XG4gICAgICAgIHZhciBzZWxmID0gR2VuZXJhbEVkaXRvcjtcbiAgICAgICAgdmFyIGlucHV0SGVpZ2h0ID0gc2VsZi5vcHRpb25zLnBvc2l0aW9uLmhlaWdodDtcbiAgICAgICAgaWYgKHNlbGYudHlwZV8gPT09IEVkaXRvclR5cGUuRGF0ZSkge1xuICAgICAgICAgICAgdmFyIGRhdGVQaWNrZXJIZWlnaHQgPSAxMDtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGRvbVV0aWwuZ2V0U3R5bGUoc2VsZi4kaW5wdXQpO1xuICAgICAgICAgICAgdmFyIGJvcmRlclRvcFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdib3JkZXItdG9wLXdpZHRoJykpO1xuICAgICAgICAgICAgdmFyIGJvcmRlckJvdHRvbVdpZHRoID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdib3JkZXItYm90dG9tLXdpZHRoJykpO1xuICAgICAgICAgICAgaWYgKCFpc05hTihib3JkZXJUb3BXaWR0aCkgJiYgIWlzTmFOKGJvcmRlckJvdHRvbVdpZHRoKSkge1xuICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nID0gKGlucHV0SGVpZ2h0IC0gYm9yZGVyVG9wV2lkdGggLSBib3JkZXJCb3R0b21XaWR0aCkgLyAyIC0gZGF0ZVBpY2tlckhlaWdodDtcbiAgICAgICAgICAgICAgICBzZWxmLiRpbnB1dC5zdHlsZS5wYWRkaW5nID0gcGFkZGluZyArICdweCAwcHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZml4RGF0ZV8odmFsdWUpIHtcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgIHZhciB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBtb250aCA9IChkYXRlLmdldE1vbnRoKCkgKyAxKS50b1N0cmluZygpO1xuICAgICAgICB2YXIgZGF5ID0gKGRhdGUuZ2V0RGF0ZSgpKS50b1N0cmluZygpO1xuICAgICAgICBpZiAobW9udGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBtb250aCA9ICcwJyArIG1vbnRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBkYXkgPSAnMCcgKyBkYXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHllYXIgKyAnLScgKyBtb250aCArICctJyArIGRheTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRWaWV3cG9ydFRyYW5zZm9ybV8ocmVtb3ZlKSB7XG4gICAgICAgIC8vRml4IGJ1Zy4gdHJhbnNmb3JtIHdpbGwgbWFrZSAnei1pbmRleCcgdGFrZSBubyBlZmZlY3QuXG4gICAgICAgIHZhciBncmlkID0gdGhpcy5ncmlkTW9kZWw7XG4gICAgICAgIHZhciBwcm9OYW1lID0gKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignTVNJRScpICE9PSAtMSB8fCBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKCdUcmlkZW50LycpID4gMCB8fCBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9GaXJlZm94L2kpKSA/ICd0cmFuc2Zvcm0nIDogJy13ZWJraXQtdHJhbnNmb3JtJztcbiAgICAgICAgdmFyIHZpZXdwb3J0SW5uZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChncmlkLnVpZCArICctdmlld3BvcnQtaW5uZXInKTtcbiAgICAgICAgdmFyIHNjcm9sbE9mZnNldCA9IGdyaWQuc2Nyb2xsT2Zmc2V0O1xuICAgICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgICAgICB2aWV3cG9ydElubmVyLnN0eWxlLnJlbW92ZVByb3BlcnR5KHByb05hbWUpO1xuICAgICAgICAgICAgdmlld3BvcnRJbm5lci5zdHlsZS5sZWZ0ID0gLXNjcm9sbE9mZnNldC5sZWZ0ICsgJ3B4JztcbiAgICAgICAgICAgIHZpZXdwb3J0SW5uZXIuc3R5bGUudG9wID0gLXNjcm9sbE9mZnNldC50b3AgKyAncHgnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRyYW5zbGF0ZTNkID0gJ3RyYW5zbGF0ZTNkKCcgKyAoLXNjcm9sbE9mZnNldC5sZWZ0KSArICdweCwnICsgKC1zY3JvbGxPZmZzZXQudG9wKSArICdweCwgMHB4KSc7XG4gICAgICAgICAgICB2aWV3cG9ydElubmVyLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdsZWZ0Jyk7XG4gICAgICAgICAgICB2aWV3cG9ydElubmVyLnN0eWxlLnJlbW92ZVByb3BlcnR5KCd0b3AnKTtcbiAgICAgICAgICAgIHZpZXdwb3J0SW5uZXIuc3R5bGUuc2V0UHJvcGVydHkocHJvTmFtZSwgdHJhbnNsYXRlM2QpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWx1ZUNoYW5nZWRfKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobmV3VmFsdWUpICE9PSBKU09OLnN0cmluZ2lmeShvbGRWYWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VyaWFsaXplVmFsdWVfKGluZGV4KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGVkaXRNb2RlID0gc2VsZi5ncmlkTW9kZWwub3B0aW9ucy5lZGl0TW9kZTtcbiAgICAgICAgdmFyIGVkaXRvciA9IHNlbGYuZWRpdG9yc19baW5kZXhdO1xuICAgICAgICB2YXIgY29sdW1uRGVmID0gc2VsZi5ncmlkTW9kZWwuY29sdW1uc1tpbmRleF07XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKGVkaXRNb2RlID09PSBFZGl0TW9kZS5JbmxpbmUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZWRpdG9yLnNlcmlhbGl6ZVZhbHVlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFnTmFtZSA9IGVkaXRvci50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ2lucHV0JyAmJiBlZGl0b3IudHlwZSA9PT0gRWRpdG9yVHlwZS5DaGVja0JveCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZWRpdG9yLmNoZWNrZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZWRpdG9yLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhVHlwZSA9IGNvbHVtbkRlZi5kYXRhVHlwZTtcbiAgICAgICAgaWYgKCFkYXRhVHlwZSkge1xuICAgICAgICAgICAgZGF0YVR5cGUgPSBnY1V0aWxzLmdldFR5cGUoc2VsZi5mb3JtYXR0ZWRJdGVtW2NvbHVtbkRlZi5kYXRhRmllbGRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YVR5cGUgPyBnY1V0aWxzLmNoYW5nZVR5cGUodmFsdWUsIGRhdGFUeXBlKSA6IHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbW1pdENoYW5nZXNfKG5ld0l0ZW0pIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZ3JpZCA9IHNlbGYuZ3JpZE1vZGVsO1xuICAgICAgICB2YXIgZWRpdG9ycyA9IHNlbGYuZWRpdG9yc187XG4gICAgICAgIHZhciBsZW5ndGggPSBncmlkLmNvbHVtbnMubGVuZ3RoO1xuICAgICAgICB2YXIgcm93ID0gc2VsZi5lZGl0aW5nSW5mb18ucm93SW5kZXg7XG4gICAgICAgIHZhciBncm91cEluZm8gPSBzZWxmLmVkaXRpbmdJbmZvXy5ncm91cEluZm87XG4gICAgICAgIHZhciBpdGVtID0gZ3JvdXBJbmZvID8gZ3JvdXBJbmZvLmRhdGEuZ2V0SXRlbShyb3cpIDogZ3JpZC5nZXREYXRhSXRlbShyb3cpO1xuICAgICAgICB2YXIgZWRpdG9yO1xuICAgICAgICB2YXIgY29sdW1uRGVmO1xuICAgICAgICB2YXIgdmFsO1xuICAgICAgICB2YXIgY29sRGF0YUZpZWxkO1xuICAgICAgICB2YXIgY29sSUQ7XG4gICAgICAgIHZhciBjYWxjU291cmNlID0gZ3JpZC5kYXRhLmNhbGNTb3VyY2U7XG4gICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IGxlbmd0aDsgY29sKyspIHtcbiAgICAgICAgICAgIGVkaXRvciA9IGVkaXRvcnNbY29sXTtcbiAgICAgICAgICAgIGlmIChlZGl0b3IpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5EZWYgPSBncmlkLmNvbHVtbnNbY29sXTtcbiAgICAgICAgICAgICAgICBjb2xEYXRhRmllbGQgPSBjb2x1bW5EZWYuZGF0YUZpZWxkO1xuICAgICAgICAgICAgICAgIGNvbElEID0gY29sdW1uRGVmLmlkO1xuICAgICAgICAgICAgICAgIGlmIChjb2x1bW5EZWYuaXNDYWxjQ29sdW1uXykge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSBuZXdJdGVtW2NvbElEXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbERhdGFGaWVsZCAhPT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5EZWYuZGF0YUZpZWxkID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGNTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxjU291cmNlLmRpcnR5Q29sdW1uKGNvbElELCAtMSwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLndob2xlQ29sdW1uQ2hhbmdlZF8gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gbmV3SXRlbVtjb2xEYXRhRmllbGRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbVtjb2xEYXRhRmllbGRdICE9PSB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1bY29sRGF0YUZpZWxkXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxjU291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi53aG9sZUNvbHVtbkNoYW5nZWRfID0gY2FsY1NvdXJjZS5kaXJ0eUNvbHVtbihjb2xJRCwgcm93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlZGl0b3IgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChncmlkLmRhdGEuZ3JvdXBzKSB7XG4gICAgICAgICAgICBncmlkLmRhdGEucmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FjaGVUZW1wbGF0ZUVkaXRvcnNfKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgdGVtcEVkaXRvcnMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWNvbHVtbl0nKTtcbiAgICAgICAgdmFyIGdyaWRNb2RlbCA9IHNlbGYuZ3JpZE1vZGVsO1xuICAgICAgICB2YXIgY29sdW1ucyA9IGdyaWRNb2RlbC5jb2x1bW5zO1xuICAgICAgICBzZWxmLmVkaXRvcnNfID0gW107XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgIHZhciBsZW5ndGg7XG4gICAgICAgIHZhciBjb2w7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHRlbXBFZGl0b3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb2wgPSBncmlkTW9kZWwuZ2V0Q29sQnlJZF8odGVtcEVkaXRvcnNbaV0uZ2V0QXR0cmlidXRlKCdkYXRhLWNvbHVtbicpKTtcbiAgICAgICAgICAgIGluZGV4ID0gY29sdW1ucy5pbmRleE9mKGNvbCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHNlbGYuZWRpdG9yc19baW5kZXhdID0gdGVtcEVkaXRvcnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhbGxvd0VkaXRpbmdfKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBncmlkTW9kZWwgPSBzZWxmLmdyaWRNb2RlbDtcbiAgICAgICAgdmFyIGNvbHVtbnMgPSBncmlkTW9kZWwuY29sdW1ucztcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW5ndGg7XG4gICAgICAgIGlmICghZ3JpZE1vZGVsLm9wdGlvbnMuYWxsb3dFZGl0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gY29sdW1ucy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvbHVtbnNbaV0uYWxsb3dFZGl0aW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vPC9lZGl0b3ItZm9sZD5cblxuICAgIC8vPGVkaXRvci1mb2xkIGRlc2M9XCJHZW5lcmFsRWRpdG9yXCI+XG4gICAgdmFyIEdlbmVyYWxFZGl0b3IgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIEdlbmVyYWxFZGl0b3Iob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgc2VsZi5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIEdlbmVyYWxFZGl0b3IucHJvdG90eXBlID0ge1xuICAgICAgICAgICAgaW5zdGFsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gc2VsZi5vcHRpb25zO1xuICAgICAgICAgICAgICAgIHNlbGYudHlwZV8gPSBFZGl0b3IuZ2V0RWRpdG9yVHlwZShvcHRpb25zLmNvbC5kYXRhVHlwZSk7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBzZWxmLnR5cGVfO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5jb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lcjtcblxuICAgICAgICAgICAgICAgIHZhciBpbnB1dEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IEVkaXRvclR5cGUuQ2hlY2tCb3gpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRFbGVtZW50ID0gJzxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjbGFzcz1cImdjLWlubGluZS1lZGl0b3IgY2hlY2tib3hcIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyBzdHlsZT1cIm1hcmdpbjowIGF1dG87dmVydGljYWwtYWxpZ246bWlkZGxlXCIgLz4nO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbnRhaW5lci5zdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dEVsZW1lbnQgPSAnPGlucHV0IHR5cGU9XCInICsgdHlwZSArICdcIiBjbGFzcz1cImdjLWlubGluZS1lZGl0b3IgJyArICh0eXBlID09PSBFZGl0b3JUeXBlLkRhdGUgPyAnZGF0ZScgOiAnJykgKyAnXCIgLz4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLiRpbnB1dCA9IGRvbVV0aWwuY3JlYXRlRWxlbWVudChpbnB1dEVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJhd1ZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gRWRpdG9yVHlwZS5DaGVja0JveCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRlZmF1bHRWYWx1ZSA9ICEhcmF3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuJGlucHV0LmNoZWNrZWQgPSBzZWxmLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEVkaXRvclR5cGUuRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRlZmF1bHRWYWx1ZSA9IGZpeERhdGVfKHJhd1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi4kaW5wdXQudmFsdWUgPSBzZWxmLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi4kaW5wdXQuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kZWZhdWx0VmFsdWUgPSByYXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi4kaW5wdXQudmFsdWUgPSBzZWxmLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi4kaW5wdXQuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZi5jb250YWluZXIuYXBwZW5kQ2hpbGQoc2VsZi4kaW5wdXQpO1xuICAgICAgICAgICAgICAgIGFkanVzdFN0eWxlXyhzZWxmKTtcbiAgICAgICAgICAgICAgICBzZWxmLiRpbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0WkluZGV4XyA9IHNldENvbnRhaW5lclpJbmRleF8uYmluZChzZWxmLmNvbnRhaW5lciwgc2VsZik7XG4gICAgICAgICAgICAgICAgc2VsZi5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzZWxmLnNldFpJbmRleF8pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuc2V0WkluZGV4Xyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBmb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNlcmlhbGl6ZVZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYudHlwZV8gPT09IEVkaXRvclR5cGUuQ2hlY2tCb3gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuJGlucHV0LmNoZWNrZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuJGlucHV0LnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEdlbmVyYWxFZGl0b3I7XG4gICAgfSkoKTtcbiAgICAvLzwvZWRpdG9yLWZvbGQ+XG5cbiAgICAvLzxlZGl0b3ItZm9sZCBkZXNjPVwiRWRpdG9yIFRlbXBsYXRlXCI+XG4gICAgZnVuY3Rpb24gZ2V0RWRpdG9yVGVtcGxhdGVfKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBsYXlvdXRFbmdpbmUgPSBzZWxmLmdyaWRNb2RlbC5sYXlvdXRFbmdpbmU7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IGdldFVzZXJEZWZpbmVkRWRpdG9yVGVtcGxhdGVfLmNhbGwoc2VsZikgfHwgbGF5b3V0RW5naW5lLmdldERlZmF1bHRFZGl0b3JUZW1wbGF0ZV8oKTtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBkb21VdGlsLmNyZWF0ZVRlbXBsYXRlRWxlbWVudCh0ZW1wbGF0ZSk7XG4gICAgICAgIHZhciB0ZW1wbGF0ZVN0ciA9IGRvbVV0aWwuZ2V0RWxlbWVudElubmVyVGV4dChlbGVtZW50KTtcbiAgICAgICAgdmFyIGNvbnRyb2xzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1jb2x1bW5dJyk7XG4gICAgICAgIHZhciBpZDtcbiAgICAgICAgdmFyIGNvbjtcbiAgICAgICAgdmFyIHRhZ05hbWU7XG4gICAgICAgIHZhciBvbGRUbXA7XG4gICAgICAgIHZhciBuZXdUbXA7XG4gICAgICAgIHZhciBzZWxPcHQ7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgajtcbiAgICAgICAgdmFyIGxlbjtcbiAgICAgICAgdmFyIGxlbmd0aDtcbiAgICAgICAgdmFyIG9sZE9wdFN0cjtcbiAgICAgICAgdmFyIG5ld09wdFN0cjtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gY29udHJvbHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbiA9IGNvbnRyb2xzW2ldO1xuICAgICAgICAgICAgb2xkVG1wID0gZG9tVXRpbC5nZXRFbGVtZW50T3V0ZXJUZXh0KGNvbik7XG4gICAgICAgICAgICB0YWdOYW1lID0gY29uLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlkID0gY29uLmdldEF0dHJpYnV0ZSgnZGF0YS1jb2x1bW4nKTtcbiAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAndGV4dGFyZWEnKSB7XG4gICAgICAgICAgICAgICAgY29uLmlubmVySFRNTCA9ICd7ez1pdC4nICsgaWQgKyAnfX0nO1xuICAgICAgICAgICAgICAgIG5ld1RtcCA9IGRvbVV0aWwuZ2V0RWxlbWVudE91dGVyVGV4dChjb24pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YWdOYW1lID09PSAnaW5wdXQnICYmIGNvbi50eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICAgICAgICAgICAgbmV3VG1wID0gJzxpbnB1dCAnICsgJ3t7PyBpdC4nICsgaWQgKyAnfX1jaGVja2Vke3s/fX0nICsgb2xkVG1wLnN1YnN0cihvbGRUbXAuaW5kZXhPZignPGlucHV0JykgKyA2KTsgLy8gNiBpcyAnPGlucHV0JyBsZW5ndGhcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFnTmFtZSA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgICAgICAgICBzZWxPcHQgPSBjb24ub3B0aW9ucztcbiAgICAgICAgICAgICAgICBuZXdUbXAgPSBvbGRUbXA7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gc2VsT3B0Lmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZE9wdFN0ciA9IGRvbVV0aWwuZ2V0RWxlbWVudE91dGVyVGV4dChzZWxPcHRbal0pO1xuICAgICAgICAgICAgICAgICAgICBuZXdPcHRTdHIgPSAnPG9wdGlvbiAnICsgJ3t7PyBpdC4nICsgaWQgKyAnID09PSBcIicgKyBzZWxPcHRbal0udGV4dCArICdcIn19c2VsZWN0ZWR7ez99fScgKyBvbGRPcHRTdHIuc3Vic3RyKG9sZE9wdFN0ci5pbmRleE9mKCc8b3B0aW9uJykgKyA3KTsgLy83IGlzICc8b3B0aW9uJyBsZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgbmV3VG1wID0gbmV3VG1wLnJlcGxhY2Uob2xkT3B0U3RyLCBuZXdPcHRTdHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uLnNldEF0dHJpYnV0ZSgndmFsdWUnLCAne3s9aXQuJyArIGlkICsgJ319Jyk7XG4gICAgICAgICAgICAgICAgbmV3VG1wID0gZG9tVXRpbC5nZXRFbGVtZW50T3V0ZXJUZXh0KGNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3VG1wKSB7XG4gICAgICAgICAgICAgICAgLy8ganNjczpkaXNhYmxlIHZhbGlkYXRlUXVvdGVNYXJrc1xuICAgICAgICAgICAgICAgIC8qanNoaW50IHF1b3RtYXJrOiBkb3VibGUgKi9cbiAgICAgICAgICAgICAgICBuZXdUbXAgPSBuZXdUbXAucmVwbGFjZSgvXCIvZywgXCInXCIpO1xuICAgICAgICAgICAgICAgIC8vIGpzY3M6ZW5hYmxlIHZhbGlkYXRlUXVvdGVNYXJrc1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlU3RyID0gdGVtcGxhdGVTdHIucmVwbGFjZShvbGRUbXAsIG5ld1RtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvVC50ZW1wbGF0ZSh0ZW1wbGF0ZVN0ciwgbnVsbCwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VXNlckRlZmluZWRFZGl0b3JUZW1wbGF0ZV8oKSB7XG4gICAgICAgIHZhciBncmlkTW9kZWwgPSB0aGlzLmdyaWRNb2RlbDtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBncmlkTW9kZWwub3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5lZGl0Um93VGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHZhciBlZGl0VG1wID0gZ3JpZE1vZGVsLm9wdGlvbnMuZWRpdFJvd1RlbXBsYXRlO1xuICAgICAgICAgICAgaWYgKGdjVXRpbHMuaXNTdHJpbmcoZWRpdFRtcCkgJiYgZWRpdFRtcC5sZW5ndGggPiAxICYmIGVkaXRUbXBbMF0gPT09ICcjJykge1xuICAgICAgICAgICAgICAgIHZhciB0bXBsRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVkaXRUbXAuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0bXBsRWxlbWVudC5pbm5lckhUTUw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBlZGl0VG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEZvcm1hdHRlZEl0ZW1fKGl0ZW0pIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY29sdW1ucyA9IHNlbGYuZ3JpZE1vZGVsLmNvbHVtbnM7XG4gICAgICAgIHZhciBjb2w7XG4gICAgICAgIHZhciBkYXRhRmllbGQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBjb2x1bW5zLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb2wgPSBjb2x1bW5zW2ldO1xuICAgICAgICAgICAgZGF0YUZpZWxkID0gY29sLmRhdGFGaWVsZDtcbiAgICAgICAgICAgIGlmIChjb2wuaXNDYWxjQ29sdW1uXykge1xuICAgICAgICAgICAgICAgIGl0ZW1bY29sLmlkXSA9IGRhdGFGaWVsZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbC5kYXRhVHlwZSAmJiBjb2wuZGF0YVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2RhdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bZGF0YUZpZWxkXSA9IGZpeERhdGVfKGl0ZW1bZGF0YUZpZWxkXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIC8vPC9lZGl0b3ItZm9sZD5cblxuICAgIC8vPGVkaXRvci1mb2xkIGRlc2M9XCJTdGFydCBFZGl0aW5nXCI+XG4gICAgZnVuY3Rpb24gc3RhcnRUZW1wbGF0ZUVkaXRpbmdfKGdyb3VwSW5mbywgdWlSb3dJbmRleCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBncmlkTW9kZWwgPSBzZWxmLmdyaWRNb2RlbDtcbiAgICAgICAgdmFyIGVkaXRvclRlbXBsYXRlXyA9IGdldEVkaXRvclRlbXBsYXRlXy5jYWxsKHRoaXMpO1xuICAgICAgICB2YXIgcm93SW5kZXggPSBzZWxmLmVkaXRpbmdJbmZvXy5yb3dJbmRleDtcbiAgICAgICAgdmFyIGRhdGFJdGVtID0gZ3JvdXBJbmZvID8gZ3JvdXBJbmZvLmRhdGEuZ2V0SXRlbShyb3dJbmRleCkgOiBncmlkTW9kZWwuZ2V0RGF0YUl0ZW0ocm93SW5kZXgpO1xuICAgICAgICBzZWxmLmZvcm1hdHRlZEl0ZW0gPSBnZXRGb3JtYXR0ZWRJdGVtXy5jYWxsKHNlbGYsIF8uY2xvbmUoZGF0YUl0ZW0pKTtcbiAgICAgICAgc2VsZi5vbGRJdGVtID0gXy5jbG9uZShzZWxmLmZvcm1hdHRlZEl0ZW0pO1xuICAgICAgICB2YXIgYXJncyA9IHtcbiAgICAgICAgICAgIHN0YXR1czogJ2JlZm9yZVN0YXJ0RWRpdGluZycsXG4gICAgICAgICAgICBncmlkTW9kZWw6IGdyaWRNb2RlbCxcbiAgICAgICAgICAgIGdyb3VwSW5mbzogZ3JvdXBJbmZvLFxuICAgICAgICAgICAgcm93OiByb3dJbmRleCxcbiAgICAgICAgICAgIGl0ZW06IHNlbGYuZm9ybWF0dGVkSXRlbSxcbiAgICAgICAgICAgIGNhbmNlbDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgZ3JpZE1vZGVsLmVkaXRpbmcucmFpc2UoZ3JpZE1vZGVsLCBhcmdzKTtcbiAgICAgICAgaWYgKGFyZ3MgJiYgYXJncy5jYW5jZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWRpdG9ySFRNTCA9IGVkaXRvclRlbXBsYXRlXyhzZWxmLmZvcm1hdHRlZEl0ZW0pO1xuICAgICAgICBncmlkTW9kZWwubGF5b3V0RW5naW5lLnN0YXJ0RWRpdGluZ18oZ3JvdXBJbmZvLCB1aVJvd0luZGV4LCBlZGl0b3JIVE1MKTtcbiAgICAgICAgdmFyIGVsZW1lbnQ7XG4gICAgICAgIHZhciB1aWQgPSBncmlkTW9kZWwudWlkO1xuICAgICAgICB2YXIgZWRpdE1vZGUgPSBncmlkTW9kZWwub3B0aW9ucy5lZGl0TW9kZTtcbiAgICAgICAgaWYgKGVkaXRNb2RlID09PSBFZGl0TW9kZS5Qb3BVcCkge1xuICAgICAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHVpZCArICctcG9wdXAtZWRpdGluZy1hcmVhJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWRpdE1vZGUgPT09IEVkaXRNb2RlLkVkaXRGb3JtKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodWlkICsgJy1mb3JtLWVkaXRpbmctYXJlYScpO1xuICAgICAgICB9XG4gICAgICAgIGNhY2hlVGVtcGxhdGVFZGl0b3JzXy5jYWxsKHNlbGYsIGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0SW5saW5lRWRpdGluZ18oZ3JvdXBJbmZvLCB1aVJvd0luZGV4KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGdyaWQgPSBzZWxmLmdyaWRNb2RlbDtcbiAgICAgICAgdmFyIGNvbHVtbnMgPSBncmlkLmNvbHVtbnM7XG4gICAgICAgIHZhciBlZGl0b3JzID0gc2VsZi5lZGl0b3JzXyA9IFtdO1xuICAgICAgICAvL1RPRE86IHJlLWNvbnNpZGVyIHRoaXMsIG1heWJlIHdlIGRvbid0IG5lZWQgcmVtb3ZlIHNlbGVjdCBlZmZlY3RzXG4gICAgICAgIC8vdmFyIG9sZEVsZW1lbnQgPSBkb21VdGlsLmdldEVsZW1lbnQoJy5nYy1zZWxlY3RlZCcpO1xuICAgICAgICAvL2lmIChvbGRFbGVtZW50KSB7XG4gICAgICAgIC8vICAgIGRvbVV0aWwucmVtb3ZlQ2xhc3Mob2xkRWxlbWVudCwgJ2djLXNlbGVjdGVkJyk7XG4gICAgICAgIC8vfVxuICAgICAgICB2YXIgc2VsZWN0b3IgPSBncmlkLnVpZCArIChncm91cEluZm8gPyAoJy1ncicgKyBncm91cEluZm8ucGF0aC5qb2luKCdfJykpIDogJycpICsgJy1yJyArIHVpUm93SW5kZXg7XG4gICAgICAgIHZhciBwaW5uZWRTZWxlY3RvciA9IGdyaWQudWlkICsgKGdyb3VwSW5mbyA/ICgnLXBncicgKyBncm91cEluZm8ucGF0aC5qb2luKCdfJykpIDogJycpICsgJy1wcicgKyB1aVJvd0luZGV4O1xuICAgICAgICB2YXIgcGlubmVkUmlnaHRTZWxlY3RvciA9IGdyaWQudWlkICsgKGdyb3VwSW5mbyA/ICgnLXByZ3InICsgZ3JvdXBJbmZvLnBhdGguam9pbignXycpKSA6ICcnKSArICctcHJyJyArIHVpUm93SW5kZXg7XG5cbiAgICAgICAgdmFyIHJvdyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbGVjdG9yKTtcbiAgICAgICAgdmFyIHJvd1JlY3QgPSBkb21VdGlsLmdldEVsZW1lbnRSZWN0KHJvdyk7XG4gICAgICAgIHZhciBwaW5uZWRSb3cgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwaW5uZWRTZWxlY3Rvcik7XG4gICAgICAgIHZhciBwaW5uZWRSb3dSZWN0O1xuICAgICAgICBpZiAocGlubmVkUm93KSB7XG4gICAgICAgICAgICBwaW5uZWRSb3dSZWN0ID0gZG9tVXRpbC5nZXRFbGVtZW50UmVjdChwaW5uZWRSb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy92YXIgcGlubmVkUmlnaHRSb3cgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwaW5uZWRSaWdodFNlbGVjdG9yKTtcbiAgICAgICAgLy92YXIgcGlubmVkUmlnaHRSb3dSZWN0O1xuICAgICAgICAvL2lmIChwaW5uZWRSaWdodFJvdykge1xuICAgICAgICAvLyAgICBwaW5uZWRSaWdodFJvd1JlY3QgPSBkb21VdGlsLmdldEVsZW1lbnRSZWN0KHBpbm5lZFJpZ2h0Um93KTtcbiAgICAgICAgLy99XG4gICAgICAgIHNlbGYuaW5saW5lQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9tVXRpbC5jcmVhdGVFbGVtZW50KCc8ZGl2IGNsYXNzPVwiZ2MtaW5saW5lLWVkaXRvci1jb250YWluZXJcIiA+PC9kaXY+Jyk7XG4gICAgICAgIHZhciByb3dJbmRleCA9IHNlbGYuZWRpdGluZ0luZm9fLnJvd0luZGV4O1xuICAgICAgICB2YXIgZGF0YUl0ZW0gPSBncm91cEluZm8gPyBncm91cEluZm8uZGF0YS5nZXRJdGVtKHJvd0luZGV4KSA6IGdyaWQuZ2V0RGF0YUl0ZW0ocm93SW5kZXgpO1xuICAgICAgICBzZWxmLmZvcm1hdHRlZEl0ZW0gPSBnZXRGb3JtYXR0ZWRJdGVtXy5jYWxsKHNlbGYsIF8uY2xvbmUoZGF0YUl0ZW0pKTtcbiAgICAgICAgc2VsZi5vbGRJdGVtID0gXy5jbG9uZShzZWxmLmZvcm1hdHRlZEl0ZW0pO1xuICAgICAgICB2YXIgYXJncyA9IHtcbiAgICAgICAgICAgIHN0YXR1czogJ2JlZm9yZVN0YXJ0RWRpdGluZycsXG4gICAgICAgICAgICBncmlkTW9kZWw6IGdyaWQsXG4gICAgICAgICAgICBncm91cEluZm86IGdyb3VwSW5mbyxcbiAgICAgICAgICAgIHJvdzogcm93SW5kZXgsXG4gICAgICAgICAgICBpdGVtOiBzZWxmLmZvcm1hdHRlZEl0ZW0sXG4gICAgICAgICAgICBjYW5jZWw6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGdyaWQuZWRpdGluZy5yYWlzZShncmlkLCBhcmdzKTtcbiAgICAgICAgaWYgKGFyZ3MgJiYgYXJncy5jYW5jZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xvbmVDb250YWluZXI7XG4gICAgICAgIHZhciBlZGl0b3I7XG4gICAgICAgIHZhciBjb2x1bW5EZWY7XG4gICAgICAgIHZhciBlZGl0aW5nVmFsdWU7XG4gICAgICAgIHZhciBlZGl0Tm9kZTtcbiAgICAgICAgdmFyIGFjdGlvbk5vZGU7XG4gICAgICAgIHZhciBjZWxsUG9zaXRpb247XG4gICAgICAgIHZhciBvcDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW47XG4gICAgICAgIHZhciBzO1xuICAgICAgICB2YXIgbmVlZFNldFZpZXdwb3J0VHJhbnNmb3JtID0gZmFsc2U7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNvbHVtbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbHVtbkRlZiA9IGNvbHVtbnNbaV07XG4gICAgICAgICAgICBpZiAoY29sdW1uRGVmLnBpbm5lZCA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAgICAgcyA9IHBpbm5lZFNlbGVjdG9yO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2x1bW5EZWYucGlubmVkID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgcyA9IHBpbm5lZFJpZ2h0U2VsZWN0b3I7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHMgPSBzZWxlY3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmlzQ29sdW1uRWRpdGFibGUoZ3JpZCwgY29sdW1uRGVmKSkge1xuICAgICAgICAgICAgICAgIGVkaXRpbmdWYWx1ZSA9IGNvbHVtbkRlZi5pc0NhbGNDb2x1bW5fID8gc2VsZi5mb3JtYXR0ZWRJdGVtW2NvbHVtbkRlZi5pZF0gOiBzZWxmLmZvcm1hdHRlZEl0ZW1bY29sdW1uRGVmLmRhdGFGaWVsZF07XG4gICAgICAgICAgICAgICAgZWRpdE5vZGUgPSBkb21VdGlsLmdldEVsZW1lbnQoJyMnICsgcyArICcgW2RhdGEtY29sdW1uPVwiJyArIGNvbHVtbkRlZi5pZCArICdcIl0nKTtcbiAgICAgICAgICAgICAgICBpZiAoZWRpdE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbFBvc2l0aW9uID0gZG9tVXRpbC5nZXRFbGVtZW50UmVjdChlZGl0Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lQ29udGFpbmVyID0gY29udGFpbmVyLmNsb25lTm9kZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGRvbVV0aWwuc2V0Q3NzKGNsb25lQ29udGFpbmVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAndG9wJzogY2VsbFBvc2l0aW9uLnRvcCAtIHJvd1JlY3QudG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xlZnQnOiBjZWxsUG9zaXRpb24ubGVmdCAtIChwaW5uZWRSb3dSZWN0ID8gcGlubmVkUm93UmVjdC5sZWZ0IDogcm93UmVjdC5sZWZ0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aWR0aCc6IGNlbGxQb3NpdGlvbi53aWR0aCAtIDEsICAvL1RPRE86IC0xIGlzIG5vdCBhIGdvb2Qgd2F5XG4gICAgICAgICAgICAgICAgICAgICAgICAnekluZGV4JzogY29sdW1uRGVmLnBpbm5lZCA9PT0gJ25vbmUnID8gMSA6IDJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5saW5lQ29udGFpbmVyLmFwcGVuZENoaWxkKGNsb25lQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgb3AgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IGNsb25lQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZE1vZGVsOiBncmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sOiBjb2x1bW5EZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogY2VsbFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGVkaXRpbmdWYWx1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uRGVmLmVkaXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yID0gbmV3IGNvbHVtbkRlZi5lZGl0b3Iob3ApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yID0gbmV3IEdlbmVyYWxFZGl0b3Iob3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9maXggYnVnLiBzZXQgaGVpZ2h0IGFzIHRoZSBkZWZhdWx0IHJvdyBoZWlnaHQgZm9yIHRoZSBkZWZhdWx0IGVkaXRvcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZUNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBjZWxsUG9zaXRpb24uaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5pbnN0YWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvcnNbaV0gPSBlZGl0b3I7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uRGVmLmFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25Ob2RlID0gZG9tVXRpbC5nZXRFbGVtZW50KCcjJyArIHMgKyAnIC5jJyArIGkgKyAnIC5nYy1hY3Rpb24tYXJlYScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uTm9kZS5jbGFzc05hbWUgKz0gJyB0b3AnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5lZWRTZXRWaWV3cG9ydFRyYW5zZm9ybSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkU2V0Vmlld3BvcnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHNldFZpZXdwb3J0VHJhbnNmb3JtXy5jYWxsKHNlbGYsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGdyaWQubGF5b3V0RW5naW5lLnN0YXJ0RWRpdGluZ18oZ3JvdXBJbmZvLCB1aVJvd0luZGV4KTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZWRpdG9ycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGVkaXRvcnNbaV0gJiYgZWRpdG9yc1tpXS5mb2N1cykge1xuICAgICAgICAgICAgICAgIGVkaXRvcnNbaV0uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vPC9lZGl0b3ItZm9sZD5cblxuICAgIC8vPGVkaXRvci1mb2xkIGRlc2M9XCJFdmVudFwiPlxuICAgIGZ1bmN0aW9uIHJlZ2lzdEV2ZW50c18oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGdyaWQgPSBzZWxmLmdyaWRNb2RlbDtcbiAgICAgICAgc2VsZi5kb3VibGVDbGlja0hhbmRsZXJfID0gZG91YmxlQ2xpY2tIYW5kbGVyXy5iaW5kKHNlbGYpO1xuICAgICAgICBzZWxmLm1vdXNlQ2xpY2tIYW5kbGVyXyA9IG1vdXNlQ2xpY2tIYW5kbGVyXy5iaW5kKHNlbGYpO1xuICAgICAgICBzZWxmLnRhcEhhbmRsZXJfID0gdGFwSGFuZGxlcl8uYmluZChzZWxmKTtcbiAgICAgICAgZ3JpZC5vbk1vdXNlRGJDbGljay5hZGRIYW5kbGVyKHNlbGYuZG91YmxlQ2xpY2tIYW5kbGVyXyk7XG4gICAgICAgIGdyaWQub25Nb3VzZUNsaWNrLmFkZEhhbmRsZXIoc2VsZi5tb3VzZUNsaWNrSGFuZGxlcl8pO1xuICAgICAgICBncmlkLm9uVGFwXy5hZGRIYW5kbGVyKHNlbGYudGFwSGFuZGxlcl8pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuUmVnaXN0RXZlbnRzXygpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZ3JpZCA9IHNlbGYuZ3JpZE1vZGVsO1xuICAgICAgICBncmlkLm9uTW91c2VEYkNsaWNrLnJlbW92ZUhhbmRsZXIoc2VsZi5kb3VibGVDbGlja0hhbmRsZXJfKTtcbiAgICAgICAgZ3JpZC5vbk1vdXNlQ2xpY2sucmVtb3ZlSGFuZGxlcihzZWxmLm1vdXNlQ2xpY2tIYW5kbGVyXyk7XG4gICAgICAgIGdyaWQub25UYXBfLnJlbW92ZUhhbmRsZXIoc2VsZi50YXBIYW5kbGVyXyk7XG4gICAgICAgIHNlbGYuZG91YmxlQ2xpY2tIYW5kbGVyXyA9IG51bGw7XG4gICAgICAgIHNlbGYubW91c2VDbGlja0hhbmRsZXJfID0gbnVsbDtcbiAgICAgICAgc2VsZi50YXBIYW5kbGVyXyA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGFwSGFuZGxlcl8oc2VuZGVyLCBlKSB7XG4gICAgICAgIG1vdXNlQ2xpY2tIYW5kbGVyXy5jYWxsKHRoaXMsIHNlbmRlciwgZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG91YmxlQ2xpY2tIYW5kbGVyXyhzZW5kZXIsIGUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZ3JpZE1vZGVsID0gc2VuZGVyO1xuICAgICAgICB2YXIgbGF5b3V0RW5naW5lID0gZ3JpZE1vZGVsLmxheW91dEVuZ2luZTtcbiAgICAgICAgdmFyIGhpdEluZm8gPSBsYXlvdXRFbmdpbmUgJiYgbGF5b3V0RW5naW5lLmhpdFRlc3QoZSk7XG5cbiAgICAgICAgaWYgKCFoaXRJbmZvIHx8IChzZWxmLmlzRWRpdGluZ18gJiYgaXNFZGl0aW5nU2FtZVJvd18oaGl0SW5mbywgc2VsZi5lZGl0aW5nSW5mb18pKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaGl0SW5mby5hcmVhID09PSAndmlld3BvcnQnIHx8IGhpdEluZm8uYXJlYSA9PT0gJ3Bpbm5lZFZpZXdwb3J0JykgJiYgIWdyaWRNb2RlbC5oYXNFZGl0QWN0aW9uXykge1xuICAgICAgICAgICAgdmFyIHVpUm93SW5kZXg7XG4gICAgICAgICAgICB2YXIgZ3JvdXBJbmZvID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBoaXRHcm91cEluZm8gPSBoaXRJbmZvLmdyb3VwSW5mbztcbiAgICAgICAgICAgIGlmIChoaXRHcm91cEluZm8pIHtcbiAgICAgICAgICAgICAgICB1aVJvd0luZGV4ID0gaGl0R3JvdXBJbmZvLnJvdztcbiAgICAgICAgICAgICAgICBncm91cEluZm8gPSBncmlkTW9kZWwuZ2V0R3JvdXBJbmZvXyhoaXRHcm91cEluZm8ucGF0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVpUm93SW5kZXggPSBoaXRJbmZvLnJvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuc3RhcnRFZGl0aW5nKGdyaWRNb2RlbCwgZ3JvdXBJbmZvLCB1aVJvd0luZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRWRpdGluZ1NhbWVSb3dfKGhpdEluZm8sIGVkaXRpbmdJbmZvKSB7XG4gICAgICAgIHJldHVybiBoaXRJbmZvLmdyb3VwSW5mbyA/XG4gICAgICAgICAgICAoaGl0SW5mby5ncm91cEluZm8uZ3JvdXAgPT09IGVkaXRpbmdJbmZvLmdyb3VwSW5mby5wYXRoICYmIGhpdEluZm8uZ3JvdXBJbmZvLnJvdyA9PT0gZWRpdGluZ0luZm8ucm93SW5kZXgpIDpcbiAgICAgICAgaGl0SW5mby5yb3cgPT09IGVkaXRpbmdJbmZvLnJvd0luZGV4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdXNlQ2xpY2tIYW5kbGVyXyhzZW5kZXIsIGUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZ3JpZE1vZGVsID0gc2VuZGVyO1xuICAgICAgICB2YXIgbGF5b3V0RW5naW5lID0gZ3JpZE1vZGVsLmxheW91dEVuZ2luZTtcbiAgICAgICAgdmFyIGhpdEluZm8gPSBsYXlvdXRFbmdpbmUuaGl0VGVzdChlKTtcbiAgICAgICAgaWYgKCFoaXRJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi5pc0VkaXRpbmdfICYmICFpc0VkaXRpbmdTYW1lUm93XyhoaXRJbmZvLCBzZWxmLmVkaXRpbmdJbmZvXykgJiYgIWdyaWRNb2RlbC5oYXNFZGl0QWN0aW9uXykge1xuICAgICAgICAgICAgc2VsZi5zdG9wRWRpdGluZyhncmlkTW9kZWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9jdW1lbnRNb3VzZU1vdmVIYW5kbGVyXyhlKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGluZm8gPSBzZWxmLnN0YXJ0TW92ZUluZm9fO1xuICAgICAgICB2YXIgZ3JpZE1vZGVsID0gc2VsZi5ncmlkTW9kZWw7XG4gICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZ3JpZE1vZGVsLnVpZCArICctcG9wdXAtZWRpdGluZy1hcmVhJyk7XG4gICAgICAgICAgICB2YXIgbW91c2VPZmZzZXQgPSBpbmZvLm1vdXNlT2Zmc2V0O1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lck9mZnNldCA9IGluZm8uY29udGFpbmVyT2Zmc2V0O1xuICAgICAgICAgICAgZG9tVXRpbC5zZXRDc3MoY29udGFpbmVyLCB7XG4gICAgICAgICAgICAgICAgJ2xlZnQnOiBjb250YWluZXJPZmZzZXQubGVmdCArIChlLnBhZ2VYIC0gbW91c2VPZmZzZXQubGVmdCksXG4gICAgICAgICAgICAgICAgJ3RvcCc6IGNvbnRhaW5lck9mZnNldC50b3AgKyAoZS5wYWdlWSAtIG1vdXNlT2Zmc2V0LnRvcClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9jdW1lbnRNb3VzZVVwSGFuZGxlcl8oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgc2VsZi5zdGFydE1vdmVJbmZvXyA9IG51bGw7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHNlbGYuZG9jdW1lbnRNb3VzZU1vdmVIYW5kbGVyXyk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBzZWxmLmRvY3VtZW50TW91c2VVcEhhbmRsZXJfKTtcbiAgICAgICAgc2VsZi5kb2N1bWVudE1vdXNlTW92ZUhhbmRsZXJfID0gbnVsbDtcbiAgICAgICAgc2VsZi5kb2N1bWVudE1vdXNlVXBIYW5kbGVyXyA9IG51bGw7XG4gICAgfVxuXG4gICAgLy88L2VkaXRvci1mb2xkPlxuXG4gICAgLy88ZWRpdG9yLWZvbGQgZGVzYz1cIlB1YmxpYyBNZXRob2RcIj5cbiAgICBmdW5jdGlvbiBpbml0KGdyaWRNb2RlbCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHNlbGYuZ3JpZE1vZGVsID0gZ3JpZE1vZGVsO1xuICAgICAgICByZWdpc3RFdmVudHNfLmNhbGwoc2VsZik7XG4gICAgfVxuXG4gICAgRWRpdG9yLmluaXQgPSBpbml0O1xuXG4gICAgZnVuY3Rpb24gc3RhcnRFZGl0aW5nKGdyaWRNb2RlbCwgZ3JvdXBJbmZvLCByb3dJbmRleCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghYWxsb3dFZGl0aW5nXy5jYWxsKHNlbGYpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuaXNFZGl0aW5nXykge1xuICAgICAgICAgICAgaWYgKHNlbGYuZ3JpZE1vZGVsICYmIHNlbGYuZ3JpZE1vZGVsLnVpZCAhPT0gZ3JpZE1vZGVsLnVpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi51bk1vdW50RWRpdG9ycyhncmlkTW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNlbGYuZ3JpZE1vZGVsID0gZ3JpZE1vZGVsO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGdyaWRNb2RlbC5vcHRpb25zO1xuICAgICAgICAvL3ZhciBkYXRhUm93SW5kZXggPSBncm91cEluZm8gPyBncm91cEluZm8uZGF0YS50b0dsb2JhbEluZGV4KHJvd0luZGV4KSA6IHJvd0luZGV4O1xuICAgICAgICBzZWxmLmVkaXRpbmdJbmZvXyA9IHtcbiAgICAgICAgICAgIC8vZ3JvdXA6IGdyb3VwSW5mbyA/IGdyb3VwSW5mby5wYXRoIDogbnVsbCxcbiAgICAgICAgICAgIGdyb3VwSW5mbzogZ3JvdXBJbmZvLFxuICAgICAgICAgICAgcm93SW5kZXg6IHJvd0luZGV4XG4gICAgICAgIH07XG4gICAgICAgIHZhciBlZGl0TW9kZSA9IG9wdGlvbnMuZWRpdE1vZGUgfHwgRWRpdE1vZGUuSW5saW5lO1xuICAgICAgICBpZiAoZWRpdE1vZGUgPT09IEVkaXRNb2RlLlBvcFVwIHx8IGVkaXRNb2RlID09PSBFZGl0TW9kZS5FZGl0Rm9ybSkge1xuICAgICAgICAgICAgc3RhcnRUZW1wbGF0ZUVkaXRpbmdfLmNhbGwoc2VsZiwgZ3JvdXBJbmZvLCByb3dJbmRleCk7XG4gICAgICAgIH0gZWxzZSB7IC8vSW5saW5lIG1vZGVcbiAgICAgICAgICAgIHN0YXJ0SW5saW5lRWRpdGluZ18uY2FsbChzZWxmLCBncm91cEluZm8sIHJvd0luZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJncyA9IHtcbiAgICAgICAgICAgIHN0YXR1czogJ3N0YXJ0RWRpdGluZycsXG4gICAgICAgICAgICBncmlkTW9kZWw6IGdyaWRNb2RlbCxcbiAgICAgICAgICAgIGdyb3VwSW5mbzogZ3JvdXBJbmZvLFxuICAgICAgICAgICAgcm93OiByb3dJbmRleCxcbiAgICAgICAgICAgIGl0ZW06IHNlbGYuZm9ybWF0dGVkSXRlbVxuICAgICAgICB9O1xuICAgICAgICBncmlkTW9kZWwuZWRpdGluZy5yYWlzZShncmlkTW9kZWwsIGFyZ3MpO1xuICAgICAgICBzZWxmLmlzRWRpdGluZ18gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBFZGl0b3Iuc3RhcnRFZGl0aW5nID0gc3RhcnRFZGl0aW5nO1xuXG4gICAgZnVuY3Rpb24gc3RvcEVkaXRpbmcoZ3JpZE1vZGVsKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCFzZWxmLmlzRWRpdGluZ18pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlbGYuZ3JpZE1vZGVsIHx8IHNlbGYuZ3JpZE1vZGVsLnVpZCAhPT0gZ3JpZE1vZGVsLnVpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciByb3cgPSBzZWxmLmVkaXRpbmdJbmZvXy5yb3dJbmRleDtcbiAgICAgICAgdmFyIG5ld0l0ZW0gPSBfLmNsb25lKHNlbGYuZm9ybWF0dGVkSXRlbSk7XG4gICAgICAgIHZhciBjb2x1bW5zID0gZ3JpZE1vZGVsLmNvbHVtbnM7XG4gICAgICAgIHZhciBlZGl0b3JzID0gc2VsZi5lZGl0b3JzXztcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW5ndGg7XG4gICAgICAgIHZhciBjb2x1bW5EZWY7XG4gICAgICAgIHZhciBuZXdWYWx1ZTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gY29sdW1ucy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29sdW1uRGVmID0gY29sdW1uc1tpXTtcbiAgICAgICAgICAgIGlmIChlZGl0b3JzW2ldKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBzZXJpYWxpemVWYWx1ZV8uY2FsbChzZWxmLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uRGVmLmlzQ2FsY0NvbHVtbl8pIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3SXRlbVtjb2x1bW5EZWYuaWRdID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIC8vc2VsZi5jYWxjQ29sdW1uQ2hhbmdlZF8gPSBzZWxmLmNhbGNDb2x1bW5DaGFuZ2VkXyB8fCBjb2x1bW5EZWYuZGF0YUZpZWxkICE9PSBuZXdWYWx1ZTsvL2NhbGMgY29sdW1uIGNoYW5nZWQgd2lsbCBpbnZhbGlkYXRlIGFmdGVyIGNvbW1pdCBjaGFuZ2VcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdJdGVtW2NvbHVtbkRlZi5kYXRhRmllbGRdID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBhcmdzID0ge1xuICAgICAgICAgICAgc3RhdHVzOiAnYmVmb3JlRW5kRWRpdGluZycsXG4gICAgICAgICAgICBncmlkTW9kZWw6IGdyaWRNb2RlbCxcbiAgICAgICAgICAgIGdyb3VwSW5mbzogc2VsZi5lZGl0aW5nSW5mb18uZ3JvdXBJbmZvLFxuICAgICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgICBvbGRJdGVtOiBzZWxmLm9sZEl0ZW0sXG4gICAgICAgICAgICBuZXdJdGVtOiBuZXdJdGVtLFxuICAgICAgICAgICAgY2FuY2VsOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBncmlkTW9kZWwuZWRpdGluZy5yYWlzZShncmlkTW9kZWwsIGFyZ3MpO1xuICAgICAgICBpZiAoYXJncyAmJiBhcmdzLmNhbmNlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGlzVmFsdWVDaGFuZ2VkXyhuZXdJdGVtLCBzZWxmLm9sZEl0ZW0pKSB7XG4gICAgICAgICAgICBjb21taXRDaGFuZ2VzXy5jYWxsKHNlbGYsIG5ld0l0ZW0pO1xuICAgICAgICAgICAgdmFsdWVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLnVuTW91bnRFZGl0b3JzKGdyaWRNb2RlbCwgdmFsdWVDaGFuZ2VkKTtcbiAgICAgICAgZ3JpZE1vZGVsLmVkaXRpbmcucmFpc2UoZ3JpZE1vZGVsLCB7XG4gICAgICAgICAgICBzdGF0dXM6ICdlbmRFZGl0aW5nJyxcbiAgICAgICAgICAgIGdyaWRNb2RlbDogZ3JpZE1vZGVsLFxuICAgICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgICBpdGVtOiBuZXdJdGVtXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBFZGl0b3Iuc3RvcEVkaXRpbmcgPSBzdG9wRWRpdGluZztcblxuICAgIGZ1bmN0aW9uIHVuTW91bnRFZGl0b3JzKGdyaWRNb2RlbCwgdmFsdWVDaGFuZ2VkKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCFzZWxmLmdyaWRNb2RlbCB8fCBzZWxmLmdyaWRNb2RlbC51aWQgIT09IGdyaWRNb2RlbC51aWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGF5b3V0RW5naW5lID0gZ3JpZE1vZGVsLmxheW91dEVuZ2luZTtcbiAgICAgICAgbGF5b3V0RW5naW5lLnN0b3BFZGl0aW5nXyh2YWx1ZUNoYW5nZWQpO1xuICAgICAgICB2YXIgZWRpdE1vZGUgPSBsYXlvdXRFbmdpbmUub3B0aW9ucy5lZGl0TW9kZTtcbiAgICAgICAgaWYgKGVkaXRNb2RlID09PSBFZGl0TW9kZS5JbmxpbmUpIHtcbiAgICAgICAgICAgIHZhciB1aWQgPSBncmlkTW9kZWwudWlkO1xuICAgICAgICAgICAgdmFyIGFjdGlvbkNvbHVtbnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjJyArIHVpZCArICcgLmdjLWFjdGlvbi1hcmVhLnRvcCcpO1xuICAgICAgICAgICAgaWYgKGFjdGlvbkNvbHVtbnMgJiYgYWN0aW9uQ29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYWN0aW9uQ29sdW1ucy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBkb21VdGlsLnJlbW92ZUNsYXNzKGFjdGlvbkNvbHVtbnNbaV0sICd0b3AnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0Vmlld3BvcnRUcmFuc2Zvcm1fLmNhbGwoc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5pc0VkaXRpbmdfID0gZmFsc2U7XG4gICAgICAgIC8vc2VsZi5jYWxjQ29sdW1uQ2hhbmdlZF8gPSBmYWxzZTtcbiAgICAgICAgc2VsZi53aG9sZUNvbHVtbkNoYW5nZWRfID0gZmFsc2U7XG4gICAgICAgIHNlbGYuZWRpdGluZ0luZm9fID0gbnVsbDtcbiAgICAgICAgc2VsZi5mb3JtYXR0ZWRJdGVtID0gbnVsbDtcbiAgICAgICAgc2VsZi5vbGRJdGVtID0gbnVsbDtcbiAgICAgICAgc2VsZi5lZGl0b3JzXy5sZW5ndGggPSAwO1xuICAgICAgICBzZWxmLmlubGluZUNvbnRhaW5lciA9IG51bGw7XG4gICAgfVxuXG4gICAgRWRpdG9yLnVuTW91bnRFZGl0b3JzID0gdW5Nb3VudEVkaXRvcnM7XG5cbiAgICBmdW5jdGlvbiBpc0NvbHVtbkVkaXRhYmxlKGdyaWRNb2RlbCwgY29sKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHNlbGYuZ3JpZE1vZGVsICYmIHNlbGYuZ3JpZE1vZGVsLnVpZCAhPT0gZ3JpZE1vZGVsLnVpZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuZ3JpZE1vZGVsID0gZ3JpZE1vZGVsO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ3JpZE1vZGVsLm9wdGlvbnM7XG4gICAgICAgIGlmIChjb2wudmlzaWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sLmFjdGlvbikgeyAvL2FjdGlvbiBjb2x1bW4gY2FuJ3QgZW50ZXIgZWRpdGluZyBzdGF0dXNcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YUZpZWxkID0gY29sLmRhdGFGaWVsZDsgLy9tdWx0aS1maWVsZCBjYW4ndCBlbnRlciBlZGl0aW5nIHN0YXR1c1xuICAgICAgICBpZiAoIV8uc3RhcnRzV2l0aChfLnRyaW0oZGF0YUZpZWxkKSwgJz0nKSAmJiBkYXRhRmllbGQgJiYgZGF0YUZpZWxkLnNwbGl0KCcsJykubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dFZGl0aW5nICYmIGNvbC5oYXNPd25Qcm9wZXJ0eSgnYWxsb3dFZGl0aW5nJykpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2wuYWxsb3dFZGl0aW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIEVkaXRvci5pc0NvbHVtbkVkaXRhYmxlID0gaXNDb2x1bW5FZGl0YWJsZTtcblxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koZ3JpZE1vZGVsKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCFzZWxmLmdyaWRNb2RlbCB8fCBzZWxmLmdyaWRNb2RlbC51aWQgIT09IGdyaWRNb2RlbC51aWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB1blJlZ2lzdEV2ZW50c18uY2FsbChzZWxmKTtcbiAgICAgICAgaWYgKHNlbGYuaXNFZGl0aW5nXykge1xuICAgICAgICAgICAgc2VsZi51bk1vdW50RWRpdG9ycyhncmlkTW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuZ3JpZE1vZGVsID0gbnVsbDtcbiAgICB9XG5cbiAgICBFZGl0b3IuZGVzdHJveSA9IGRlc3Ryb3k7XG5cbiAgICBmdW5jdGlvbiBnZXRFZGl0b3JUeXBlKGRhdGFUeXBlKSB7XG4gICAgICAgIHZhciBlZGl0b3JUeXBlID0gZ2NVdGlscy5FZGl0b3JUeXBlO1xuICAgICAgICBpZiAoIWRhdGFUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZWRpdG9yVHlwZS5UZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgc3dpdGNoIChkYXRhVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWRpdG9yVHlwZS5DaGVja0JveDtcbiAgICAgICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVkaXRvclR5cGUuRGF0ZTtcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWRpdG9yVHlwZS5OdW1iZXI7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVkaXRvclR5cGUuVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIEVkaXRvci5nZXRFZGl0b3JUeXBlID0gZ2V0RWRpdG9yVHlwZTtcblxuICAgIGZ1bmN0aW9uIGNvbnRhaW5lck1vdXNlRG93bkhhbmRsZXIoZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBncmlkTW9kZWwgPSBzZWxmLmdyaWRNb2RlbDtcbiAgICAgICAgdmFyIGN1clRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gY3VyVGFyZ2V0LmNsYXNzTmFtZTtcbiAgICAgICAgdmFyIHRhZ05hbWUgPSBjdXJUYXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgYXJyID0gY2xhc3NOYW1lID8gY2xhc3NOYW1lLnNwbGl0KCcgJykgOiBbXTtcbiAgICAgICAgd2hpbGUgKHRhZ05hbWUgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgaWYgKGFyci5pbmRleE9mKCdnYy1lZGl0aW5nLWNsb3NlJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZ3JpZE1vZGVsLmNhbmNlbEVkaXRpbmcoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJyLmluZGV4T2YoJ2djLWVkaXRpbmctdXBkYXRlJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZ3JpZE1vZGVsLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyci5pbmRleE9mKCdnYy1lZGl0aW5nLWNhbmNlbCcpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGdyaWRNb2RlbC5jYW5jZWxFZGl0aW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyci5pbmRleE9mKCdnYy1lZGl0aW5nLWhlYWRlcicpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChncmlkTW9kZWwudWlkICsgJy1wb3B1cC1lZGl0aW5nLWFyZWEnKTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZG9jdW1lbnRNb3VzZU1vdmVIYW5kbGVyXyA9IGRvY3VtZW50TW91c2VNb3ZlSGFuZGxlcl8uYmluZChzZWxmKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kb2N1bWVudE1vdXNlVXBIYW5kbGVyXyA9IGRvY3VtZW50TW91c2VVcEhhbmRsZXJfLmJpbmQoc2VsZik7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHNlbGYuZG9jdW1lbnRNb3VzZU1vdmVIYW5kbGVyXyk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBzZWxmLmRvY3VtZW50TW91c2VVcEhhbmRsZXJfKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lck9mZnNldCA9IGRvbVV0aWwub2Zmc2V0KGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJTdHlsZSA9IGRvbVV0aWwuZ2V0U3R5bGUoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lck1hcmdpblRvcCA9IHBhcnNlRmxvYXQoY29udGFpbmVyU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLXRvcCcpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lck1hcmdpbkxlZnQgPSBwYXJzZUZsb2F0KGNvbnRhaW5lclN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ21hcmdpbi1sZWZ0JykpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnN0YXJ0TW92ZUluZm9fID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VPZmZzZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBlLnBhZ2VYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogZS5wYWdlWVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lck9mZnNldDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGNvbnRhaW5lck9mZnNldC5sZWZ0IC0gY29udGFpbmVyTWFyZ2luTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGNvbnRhaW5lck9mZnNldC50b3AgLSBjb250YWluZXJNYXJnaW5Ub3BcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJUYXJnZXQgPSBjdXJUYXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHRhZ05hbWUgPSBjdXJUYXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gY3VyVGFyZ2V0LmNsYXNzTmFtZTtcbiAgICAgICAgICAgIGFyciA9IGNsYXNzTmFtZSA/IGNsYXNzTmFtZS5zcGxpdCgnICcpIDogW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBFZGl0b3IuY29udGFpbmVyTW91c2VEb3duSGFuZGxlciA9IGNvbnRhaW5lck1vdXNlRG93bkhhbmRsZXI7XG5cbiAgICBmdW5jdGlvbiBjb250YWluZXJLZXlEb3duSGFuZGxlcihlKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGdyaWRNb2RlbCA9IHNlbGYuZ3JpZE1vZGVsO1xuICAgICAgICB2YXIgS2V5ID0gZ2NVdGlscy5LZXk7XG4gICAgICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIEtleS5FbnRlcjpcbiAgICAgICAgICAgICAgICBpZiAoIWdyaWRNb2RlbC5oYXNFZGl0QWN0aW9uXykge1xuICAgICAgICAgICAgICAgICAgICBncmlkTW9kZWwuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtleS5Fc2NhcGU6XG4gICAgICAgICAgICAgICAgaWYgKCFncmlkTW9kZWwuaGFzQ2FuY2VsQWN0aW9uXykge1xuICAgICAgICAgICAgICAgICAgICBncmlkTW9kZWwuY2FuY2VsRWRpdGluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBFZGl0b3IuY29udGFpbmVyS2V5RG93bkhhbmRsZXIgPSBjb250YWluZXJLZXlEb3duSGFuZGxlcjtcblxuICAgIGZ1bmN0aW9uIGdldElubGluZUZyYWdtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmxpbmVDb250YWluZXI7XG4gICAgfVxuXG4gICAgRWRpdG9yLmdldElubGluZUZyYWdtZW50ID0gZ2V0SW5saW5lRnJhZ21lbnQ7XG5cbiAgICAvLzwvZWRpdG9yLWZvbGQ+XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEVkaXRvcjtcbn0pKCk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXBwL3NjcmlwdHMvZ3JpZC9lZGl0aW5nSGFuZGxlci5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuICAgICAgICB2YXIgZ2NVdGlscyA9IHJlcXVpcmUoJy4uL2djVXRpbHMnKTtcbiAgICAgICAgdmFyIGRvVCA9IHJlcXVpcmUoJy4uL2RvVC5qcycpO1xuICAgICAgICB2YXIgZG9tVXRpbCA9IHJlcXVpcmUoJy4uL2RvbVV0aWwnKTtcbiAgICAgICAgdmFyIFBPU19BQlMgPSAnYWJzb2x1dGUnO1xuICAgICAgICB2YXIgUE9TX1JFTCA9ICdyZWxhdGl2ZSc7XG4gICAgICAgIHZhciBPVkVSRkxPV19ISURERU4gPSAnaGlkZGVuJztcbiAgICAgICAgdmFyIE9WRVJGTE9XX0FVVE8gPSAnYXV0byc7XG4gICAgICAgIHZhciBWSUVXUE9SVCA9ICd2aWV3cG9ydCc7XG4gICAgICAgIHZhciBUT09MUEFORUwgPSAndG9vbFBhbmVsJztcbiAgICAgICAgdmFyIFBJTk5FRF9WSUVXUE9SVCA9ICdwaW5uZWRMZWZ0Vmlld3BvcnQnO1xuICAgICAgICB2YXIgUElOTkVEX0NPTFVNTl9IRUFERVIgPSAncGlubmVkTGVmdENvbHVtbkhlYWRlcic7XG4gICAgICAgIHZhciBQSU5ORURfUklHSFRfVklFV1BPUlQgPSAncGlubmVkUmlnaHRWaWV3cG9ydCc7XG4gICAgICAgIHZhciBQSU5ORURfUklHSFRfQ09MVU1OX0hFQURFUiA9ICdwaW5uZWRSaWdodENvbHVtbkhlYWRlcic7XG4gICAgICAgIHZhciBDT0xVTU5fSEVBREVSID0gJ2NvbHVtbkhlYWRlcic7XG4gICAgICAgIHZhciBST1dfSEVBREVSID0gJ3Jvd0hlYWRlcic7XG4gICAgICAgIHZhciBDT1JORVJfSEVBREVSID0gJ2Nvcm5lckhlYWRlcic7XG4gICAgICAgIHZhciBHUk9VUF9EUkFHX1BBTkVMID0gJ2dyb3VwaW5nUGFuZWwnO1xuICAgICAgICB2YXIgR1JPVVBfRFJBR19URVhUID0gJ0RyYWcgYSBjb2x1bW4gaGVhZGVyIGhlcmUgYW5kIGRyb3AgaXQgdG8gZ3JvdXAgYnkgdGhhdCBjb2x1bW4nO1xuICAgICAgICB2YXIgUkVTSVpFX0dBUF9TSVpFID0gNDtcbiAgICAgICAgdmFyIFBBRERJTkdfTEVGVCA9ICdwYWRkaW5nLWxlZnQnO1xuICAgICAgICB2YXIgUEFERElOR19SSUdIVCA9ICdwYWRkaW5nLXJpZ2h0JztcblxuICAgICAgICB2YXIgR1JPVVBfSEVBREVSID0gJ2dyb3VwSGVhZGVyJztcbiAgICAgICAgdmFyIEdST1VQX0ZPT1RFUiA9ICdncm91cEZvb3Rlcic7XG4gICAgICAgIHZhciBHUk9VUF9DT05URU5UID0gJ2dyb3VwQ29udGVudCc7XG4gICAgICAgIHZhciBNSU5fQ09MX1dJRFRIID0gNjtcbiAgICAgICAgdmFyIFNlbGVjdE1vZGUgPSB7XG4gICAgICAgICAgICBOT05FOiAnbm9uZScsXG4gICAgICAgICAgICBTSU5HTEU6ICdzaW5nbGUnLFxuICAgICAgICAgICAgTVVMVElQTEU6ICdtdWx0aXBsZSdcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHN3aXBlU3RhdHVzID0ge307XG4gICAgICAgIHZhciBGTElDS19USFJFU0hPTERfViA9IDAuODtcblxuICAgICAgICB2YXIgR3JpZExheW91dEVuZ2luZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25EZWZhdWx0cyA9IHtcbiAgICAgICAgICAgICAgICByb3dIZWFkZXJXaWR0aDogNDAsXG4gICAgICAgICAgICAgICAgY29sSGVhZGVySGVpZ2h0OiAyNCxcbiAgICAgICAgICAgICAgICByb3dIZWlnaHQ6IDI0LFxuICAgICAgICAgICAgICAgIGNvbFdpZHRoOiAnKicsXG4gICAgICAgICAgICAgICAgc2hvd1Jvd0hlYWRlcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzaG93Q29sSGVhZGVyOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNob3dHcm91cEhlYWRlcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzaG93R3JvdXBGb290ZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgYWxsb3dFZGl0aW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhbGxvd0dyb3VwaW5nOiBmYWxzZSwgIC8vaWYgc2V0IHRvIHRydWUsIGl0IHdpbGwgc2hvdyBhIGdyb3VwIGRyYWcgcGFuZWwgdG8gaGVscCB1c2VyIGdyb3VwaW5nIHRoZSBkYXRhIGF0IHJ1bnRpbWVcbiAgICAgICAgICAgICAgICBhbGxvd1NvcnRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbk1vZGU6IFNlbGVjdE1vZGUuU0lOR0xFLFxuICAgICAgICAgICAgICAgIGFsbG93SGVhZGVyU2VsZWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhbGxvd0NvbHVtblJlb3JkZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgYWxsb3dDb2x1bW5SZXNpemU6IHRydWUsXG4gICAgICAgICAgICAgICAgZWRpdE1vZGU6ICdpbmxpbmUnLFxuICAgICAgICAgICAgICAgIHNob3dUb29sUGFuZWw6IGZhbHNlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZWxmLmxheW91dEluZm9fID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYubmFtZSA9ICdHcmlkTGF5b3V0RW5naW5lJzsgLy9uYW1lIG11c3QgZW5kIHdpdGggTGF5b3V0RW5naW5lXG4gICAgICAgICAgICBzZWxmLm9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMgfHwge30sIG9wdGlvbkRlZmF1bHRzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBHcmlkTGF5b3V0RW5naW5lLnByb3RvdHlwZSA9IHtcbiAgICAgICAgICAgIGdldENvbHVtbkRlZmF1bHRzXzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gc2VsZi5vcHRpb25zO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBvcHRpb25zLmNvbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd1NvcnRpbmc6IG9wdGlvbnMuYWxsb3dTb3J0aW5nLFxuICAgICAgICAgICAgICAgICAgICBwaW5uZWQ6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dFZGl0aW5nOiBvcHRpb25zLmFsbG93RWRpdGluZ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB1cGRhdGVTdGFydFNpemVfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBncmlkID0gc2NvcGUuZ3JpZDtcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1ucyA9IGdyaWQuY29sdW1ucztcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHNjb3BlLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lclJlY3QgPSBncmlkLmdldENvbnRhaW5lckluZm9fKCkuY29udGVudFJlY3Q7XG4gICAgICAgICAgICAgICAgdmFyIHN6QXZhaWxhYmxlID0gY29udGFpbmVyUmVjdC53aWR0aCAtIG9wdGlvbnMucm93SGVhZGVyV2lkdGggLSBnZXRUb29sUGFuZWxXaWR0aF8uY2FsbChzY29wZSk7XG4gICAgICAgICAgICAgICAgaWYgKChncmlkLmRhdGEuaXRlbUNvdW50ICogb3B0aW9ucy5yb3dIZWlnaHQpID4gKGNvbnRhaW5lclJlY3QuaGVpZ2h0IC0gb3B0aW9ucy5jb2xIZWFkZXJIZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN6QXZhaWxhYmxlIC09IGRvbVV0aWwuZ2V0U2Nyb2xsYmFyU2l6ZSgpLndpZHRoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBzdGFydENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFN0YXJ0Q29sO1xuICAgICAgICAgICAgICAgIHZhciBsYXN0V2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIHN6Q29scyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBoYXNTdGFyID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBfLmVhY2goY29sdW1ucywgZnVuY3Rpb24oY29sLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JpZC5pc0NvbFZpc2libGVfKGNvbCwgY29sLnBpbm5lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeiA9IHBhcnNlU3RhcnRTaXplXyhjb2wud2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3pDb2xzW2luZGV4XSA9IHN6O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN6KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzU3RhciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRDb3VudCArPSBzejtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0U3RhcnRDb2wgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3pBdmFpbGFibGUgLT0gY29sLnZpc2libGVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGhhc1N0YXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFdpZHRoID0gc3pBdmFpbGFibGU7XG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaChjb2x1bW5zLCBmdW5jdGlvbihjb2wsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3pDb2xzW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IGxhc3RTdGFydENvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sLnZpc2libGVXaWR0aCA9IGxhc3RXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbC52aXNpYmxlV2lkdGggPSBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKHN6Q29sc1tpbmRleF0gLyBzdGFydENvdW50ICogc3pBdmFpbGFibGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RXaWR0aCAtPSBjb2wudmlzaWJsZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHNlbGYuZ3JpZCA9IGdyaWQ7XG4gICAgICAgICAgICAgICAgZ3JpZC5jb2x1bW5zID0gXy5tYXAoZ3JpZC5jb2x1bW5zLCBmdW5jdGlvbihjb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uZGVmYXVsdHMoY29sLCBfLmRlZmF1bHRzKHNlbGYuZ2V0Q29sdW1uRGVmYXVsdHNfKCksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjb2wuZGF0YUZpZWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FwdGlvbjogY29sLmRhdGFGaWVsZFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgXy5lYWNoKGdyaWQuY29sdW1ucywgZnVuY3Rpb24oY29sKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbC52aXNpYmxlV2lkdGggPSBjb2wud2lkdGg7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB1cGRhdGVQaW5uZWRDb2x1bW5zXy5jYWxsKHNlbGYpO1xuXG4gICAgICAgICAgICAgICAgaWYgKF8uc29tZShncmlkLmNvbHVtbnMsICdwaW5uZWQnLCAnbGVmdCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaGFzTGVmdFBpbm5lZENvbHVtbl8gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfLnNvbWUoZ3JpZC5jb2x1bW5zLCAncGlubmVkJywgJ3JpZ2h0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5oYXNSaWdodFBpbm5lZENvbHVtbl8gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlU3RhcnRTaXplXygpO1xuXG4gICAgICAgICAgICAgICAgLy9JZiB0aGVyZSBpcyByb3cgdGVtcGxhdGUsIHVzZSB0aGUgYWN0dWFsIGNvbHVtbiB3aWR0aCBpbiByb3cgdGVtcGxhdGUuXG4gICAgICAgICAgICAgICAgY29uc29saWRhdGVDb2x1bW5XaWR0aF8uY2FsbChzZWxmLCAnbm9uZScpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmhhc0xlZnRQaW5uZWRDb2x1bW5fKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGlkYXRlQ29sdW1uV2lkdGhfLmNhbGwoc2VsZiwgJ2xlZnQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaGFzUmlnaHRQaW5uZWRDb2x1bW5fKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGlkYXRlQ29sdW1uV2lkdGhfLmNhbGwoc2VsZiwgJ3JpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzaG93VG9vbFBhbmVsXyA9IHNlbGYub3B0aW9ucy5zaG93VG9vbFBhbmVsO1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLm9wdGlvbnMsICdzaG93VG9vbFBhbmVsJywge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNob3dUb29sUGFuZWxfO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvd1Rvb2xQYW5lbF8gIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pdCdzIHVzdWFsbHkgY2hhbmdlIHRoZSB0ZW1wbGF0ZSBkdXJpbmcgbGF5b3V0L2dyb3VwIHN0cmF0ZWd5IGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2FzIHRoZSByZXN1bHQsIHRoZSBzaXplIG9mIHRoZSB0ZW1wbGF0ZSBtYXliZSBkaWZmZXJlbnQgYW5kIGNvbHVtbiBzaXplIG1heSBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1Rvb2xQYW5lbF8gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmdyaWQuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldExheW91dEluZm86IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHNlbGYub3B0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5ncm91cFN0cmF0ZWd5Xykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5ncm91cFN0cmF0ZWd5Xy5nZXRMYXlvdXRJbmZvKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmxheW91dEluZm9fKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmxheW91dEluZm9fO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbGF5b3V0SW5mbyA9IHNlbGYubGF5b3V0SW5mb18gPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zaG93VG9vbFBhbmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheW91dEluZm9bVE9PTFBBTkVMXSA9IGdldFRvb2xQYW5lbExheW91dEluZm9fLmNhbGwoc2VsZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBhbGxDb2x1bW5IaWRkbGVuID0gXy5hbGwoc2VsZi5ncmlkLmNvbHVtbnMsIGZ1bmN0aW9uKGNvbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWNvbC52aXNpYmxlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghYWxsQ29sdW1uSGlkZGxlbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5oYXNMZWZ0UGlubmVkQ29sdW1uXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0SW5mb1tQSU5ORURfVklFV1BPUlRdID0gZ2V0UGlubmVkVmlld3BvcnRMYXlvdXRJbmZvXy5jYWxsKHNlbGYsICdsZWZ0Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuaGFzUmlnaHRQaW5uZWRDb2x1bW5fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRJbmZvW1BJTk5FRF9SSUdIVF9WSUVXUE9SVF0gPSBnZXRQaW5uZWRWaWV3cG9ydExheW91dEluZm9fLmNhbGwoc2VsZiwgJ3JpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0SW5mb1tWSUVXUE9SVF0gPSBnZXRWaWV3cG9ydExheW91dEluZm9fLmNhbGwoc2VsZik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0NvbEhlYWRlciAmJiBvcHRpb25zLnNob3dSb3dIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dEluZm9bQ09STkVSX0hFQURFUl0gPSBnZXRDb3JuZXJIZWFkZXJMYXlvdXRJbmZvXy5jYWxsKHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dSb3dIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dEluZm9bUk9XX0hFQURFUl0gPSBnZXRSb3dIZWFkZXJMYXlvdXRJbmZvXy5jYWxsKHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dDb2xIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dEluZm9bQ09MVU1OX0hFQURFUl0gPSBnZXRDb2x1bW5IZWFkZXJMYXlvdXRJbmZvXy5jYWxsKHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuaGFzTGVmdFBpbm5lZENvbHVtbl8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRJbmZvW1BJTk5FRF9DT0xVTU5fSEVBREVSXSA9IGdldFBpbm5lZENvbHVtbkhlYWRlclZpZXdwb3J0TGF5b3V0SW5mb18uY2FsbChzZWxmLCAnbGVmdCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuaGFzUmlnaHRQaW5uZWRDb2x1bW5fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0SW5mb1tQSU5ORURfUklHSFRfQ09MVU1OX0hFQURFUl0gPSBnZXRQaW5uZWRDb2x1bW5IZWFkZXJWaWV3cG9ydExheW91dEluZm9fLmNhbGwoc2VsZiwgJ3JpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5hbGxvd0dyb3VwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRJbmZvW0dST1VQX0RSQUdfUEFORUxdID0gZ2V0R3JvdXBEcmFnUGFuZWxMYXlvdXRJbmZvXy5jYWxsKHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsYXlvdXRJbmZvO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0UmVuZGVyUm93SW5mb186IGZ1bmN0aW9uKHJvdywgYXJlYSkge1xuICAgICAgICAgICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlLmdyb3VwU3RyYXRlZ3lfKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS5ncm91cFN0cmF0ZWd5Xy5nZXRSZW5kZXJSb3dJbmZvXyhyb3csIGFyZWEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB1aWQgPSBzY29wZS5ncmlkLnVpZDtcbiAgICAgICAgICAgICAgICB2YXIgaGFzR3JvdXAgPSBoYXNHcm91cF8oc2NvcGUuZ3JpZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJlYSA9PT0gVklFV1BPUlQgfHwgYXJlYSA9PT0gUElOTkVEX1ZJRVdQT1JUIHx8IGFyZWEgPT09IFBJTk5FRF9SSUdIVF9WSUVXUE9SVCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gcm93LmFyZWE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyckluZm8gPSByb3cuaW5mbztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cEluZm8gPSBzY29wZS5ncmlkLmdldEdyb3VwSW5mb18oY3VyckluZm8ucGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydCA9PT0gR1JPVVBfSEVBREVSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEdyb3VwSGVhZGVyUm93Xy5jYWxsKHNjb3BlLCByb3cua2V5LCBjdXJySW5mbywgZ3JvdXBJbmZvLCByb3cud2lkdGgsIHJvdy50b3AsIGFyZWEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSBHUk9VUF9DT05URU5UKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEdyb3VwQ29udGVudFJvd18uY2FsbChzY29wZSwgcm93LmtleSwgY3VyckluZm8uaXRlbUluZGV4LCBncm91cEluZm8sIHJvdy5oZWlnaHQsIHJvdy50b3AsIGFyZWEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0R3JvdXBGb290ZXJSb3dfLmNhbGwoc2NvcGUsIHJvdy5rZXksIGN1cnJJbmZvLCBncm91cEluZm8sIHJvdy50b3AsIGFyZWEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVJvd1JlbmRlckluZm8uY2FsbChzY29wZSwgcm93LmluZGV4LCByb3cuaGVpZ2h0LCBhcmVhLCB1aWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmVhID09PSBST1dfSEVBREVSKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSByb3cua2V5O1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9wID0gaGFzR3JvdXAgPyByb3cudG9wIDogcm93LmluZGV4ICogcm93LmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzUm93Um9sZSA9IGhhc0dyb3VwID8gZmFsc2UgOiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcm93LmhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVpbGRIZWFkZXJDZWxsLmNhbGwoc2NvcGUsIGtleSwgcm93LmluZm8sIGlzUm93Um9sZSwgdG9wLCBoZWlnaHQsIHJvdy5pbmRleCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmVhID09PSBDT0xVTU5fSEVBREVSIHx8IGFyZWEgPT09IFBJTk5FRF9DT0xVTU5fSEVBREVSIHx8IGFyZWEgPT09IFBJTk5FRF9SSUdIVF9DT0xVTU5fSEVBREVSKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRSZW5kZXJlZENvbHVtbkhlYWRlckluZm9fLmNhbGwoc2NvcGUsIGFyZWEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFJlbmRlclJhbmdlXzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlLmdyb3VwU3RyYXRlZ3lfKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS5ncm91cFN0cmF0ZWd5Xy5nZXRSZW5kZXJSYW5nZV8ob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGFyZWEgPSAob3B0aW9ucyAmJiBvcHRpb25zLmFyZWEpIHx8ICcnO1xuICAgICAgICAgICAgICAgIGlmICghYXJlYSB8fCBhcmVhID09PSBDT1JORVJfSEVBREVSIHx8IGFyZWEgPT09IFRPT0xQQU5FTCB8fCBhcmVhID09PSBHUk9VUF9EUkFHX1BBTkVMKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRSb3dzUmVuZGVySW5mby5jYWxsKHNjb3BlLCBhcmVhLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFJlbmRlckluZm86IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGlmIChzY29wZS5ncm91cFN0cmF0ZWd5Xykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZ3JvdXBTdHJhdGVneV8uZ2V0UmVuZGVySW5mbyhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGluY2x1ZGVSb3dzID0gb3B0aW9ucy5pbmNsdWRlUm93cyB8fCB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBhcmVhID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5hcmVhKSB8fCAnJztcbiAgICAgICAgICAgICAgICBpZiAoIWFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHVpZCA9IHNjb3BlLmdyaWQudWlkO1xuICAgICAgICAgICAgICAgIHZhciBsYXlvdXRJbmZvID0gdGhpcy5nZXRMYXlvdXRJbmZvKCk7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJMYXlvdXRJbmZvID0gbGF5b3V0SW5mb1thcmVhXTtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBjdXJyTGF5b3V0SW5mby53aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gY3VyckxheW91dEluZm8uaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciByO1xuICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgIHZhciByb3dIZWlnaHQgPSBzY29wZS5vcHRpb25zLnJvd0hlaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQ7XG4gICAgICAgICAgICAgICAgdmFyIGVuZDtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0VG9wO1xuICAgICAgICAgICAgICAgIHZhciBncmlkID0gc2NvcGUuZ3JpZDtcblxuICAgICAgICAgICAgICAgIHZhciByZW5kZXJSYW5nZSA9IGdldFJlbmRlclJhbmdlLmNhbGwoc2NvcGUsIGFyZWEsIGN1cnJMYXlvdXRJbmZvLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHJlbmRlclJhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgICAgIGVuZCA9IHJlbmRlclJhbmdlLmVuZDtcbiAgICAgICAgICAgICAgICBvZmZzZXRUb3AgPSByZW5kZXJSYW5nZS5vZmZzZXRUb3A7XG4gICAgICAgICAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2djLXZpZXdwb3J0JztcbiAgICAgICAgICAgICAgICBpZiAoYXJlYSA9PT0gUElOTkVEX1ZJRVdQT1JUKSB7XG4gICAgICAgICAgICAgICAgICAgIGNzc0NsYXNzID0gJ2djLXBpbm5lZC1sZWZ0JztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZWEgPT09IFBJTk5FRF9SSUdIVF9WSUVXUE9SVCkge1xuICAgICAgICAgICAgICAgICAgICBjc3NDbGFzcyA9ICdnYy1waW5uZWQtcmlnaHQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXJlYSA9PT0gVklFV1BPUlQgfHwgYXJlYSA9PT0gUElOTkVEX1ZJRVdQT1JUIHx8IGFyZWEgPT09IFBJTk5FRF9SSUdIVF9WSUVXUE9SVCkge1xuICAgICAgICAgICAgICAgICAgICByID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJEaXZDc3NDbGFzczogY3NzQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRlckRpdlN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFBPU19BQlMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBjdXJyTGF5b3V0SW5mby50b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogY3VyckxheW91dEluZm8ubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6IE9WRVJGTE9XX0hJRERFTlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyRGl2U3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogUE9TX1JFTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogY3VyckxheW91dEluZm8uY29udGVudFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0IC0gKG9mZnNldFRvcCA8IDAgPyBvZmZzZXRUb3AgOiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyRGl2VHJhbnNsYXRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogYXJlYSA9PT0gVklFV1BPUlQgPyAoLW9wdGlvbnMub2Zmc2V0TGVmdCB8fCAwKSA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAtb3B0aW9ucy5vZmZzZXRUb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlZFJvd3M6IFtdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlUm93cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0dyb3VwXyhncmlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIucmVuZGVyZWRSb3dzID0gci5yZW5kZXJlZFJvd3MuY29uY2F0KGdldEdyb3VwUmVuZGVySW5mb18uY2FsbChzY29wZSwgc3RhcnQsIGVuZCwgb2Zmc2V0VG9wLCBmYWxzZSwgZmFsc2UsIGFyZWEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnJlbmRlcmVkUm93cy5wdXNoKGNyZWF0ZVJvd1JlbmRlckluZm8uY2FsbChzY29wZSwgaSwgcm93SGVpZ2h0LCBhcmVhLCB1aWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJlYSA9PT0gQ09STkVSX0hFQURFUikge1xuICAgICAgICAgICAgICAgICAgICByID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJEaXZDc3NDbGFzczogJ2djLWNvcm5lckhlYWRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRlckRpdlN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFBPU19BQlMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBjdXJyTGF5b3V0SW5mby50b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiBPVkVSRkxPV19ISURERU4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgekluZGV4OiAxMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyRGl2U3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogUE9TX1JFTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlZFJvd3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB1aWQgKyAnLWNvcm5lcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNSb3dSb2xlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJJbmZvOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzc0NsYXNzOiAnZ2MtY29ybmVyLWhlYWRlci1jZWxsIGNoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogJzEwMCUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkSFRNTDogc2NvcGUub3B0aW9ucy5hbGxvd0hlYWRlclNlbGVjdCA/ICc8ZGl2IGlkPVwiJyArIHVpZCArICctY29ybmVyLXNlbGVjdFwiIGNsYXNzPVwiZ2MtaWNvbiBnYy1oZWFkZXItc2VsZWN0LWljb24nICsgKChncmlkLmRhdGEuaXRlbUNvdW50ID09PSAoc2NvcGUuc2VsZWN0ZWRSb3dzXyAmJiBzY29wZS5zZWxlY3RlZFJvd3NfLmxlbmd0aCkpID8gJyBzZWxlY3RlZCcgOiAnJykgKyAnXCI+PC9kaXY+JyA6ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZWEgPT09IENPTFVNTl9IRUFERVIgfHwgYXJlYSA9PT0gUElOTkVEX0NPTFVNTl9IRUFERVIgfHwgYXJlYSA9PT0gUElOTkVEX1JJR0hUX0NPTFVNTl9IRUFERVIpIHtcbiAgICAgICAgICAgICAgICAgICAgY3NzQ2xhc3MgPSAnZ2MtY29sdW1uSGVhZGVyJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZWEgPT09IFBJTk5FRF9DT0xVTU5fSEVBREVSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NDbGFzcyArPSAnIGdjLXBpbm5lZC1sZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmVhID09PSBQSU5ORURfUklHSFRfQ09MVU1OX0hFQURFUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3NzQ2xhc3MgKz0gJyBnYy1waW5uZWQtcmlnaHQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRlckRpdkNzc0NsYXNzOiBjc3NDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyRGl2U3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogUE9TX0FCUyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGN1cnJMYXlvdXRJbmZvLnRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBjdXJyTGF5b3V0SW5mby5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogT1ZFUkZMT1dfSElEREVOXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJEaXZTdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBQT1NfUkVMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjdXJyTGF5b3V0SW5mby5jb250ZW50V2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbm5lckRpdlRyYW5zbGF0ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGFyZWEgPT09IENPTFVNTl9IRUFERVIgPyAoLW9wdGlvbnMub2Zmc2V0TGVmdCB8fCAwKSA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRSb3dzOiBbZ2V0UmVuZGVyZWRDb2x1bW5IZWFkZXJJbmZvXy5jYWxsKHNjb3BlLCBhcmVhKV1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZWEgPT09IFJPV19IRUFERVIpIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyRGl2Q3NzQ2xhc3M6ICdnYy1yb3dIZWFkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJEaXZTdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBQT1NfQUJTLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogY3VyckxheW91dEluZm8udG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGN1cnJMYXlvdXRJbmZvLmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiBPVkVSRkxPV19ISURERU5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbm5lckRpdlN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFBPU19SRUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgLSAob2Zmc2V0VG9wIDwgMCA/IG9mZnNldFRvcCA6IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjdXJyTGF5b3V0SW5mby5jb250ZW50V2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbm5lckRpdlRyYW5zbGF0ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAtb3B0aW9ucy5vZmZzZXRUb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlZFJvd3M6IFtdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlUm93cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0dyb3VwXyhncmlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIucmVuZGVyZWRSb3dzID0gci5yZW5kZXJlZFJvd3MuY29uY2F0KGdldEdyb3VwUmVuZGVySW5mb18uY2FsbChzY29wZSwgc3RhcnQsIGVuZCwgb2Zmc2V0VG9wLCB0cnVlLCBmYWxzZSwgYXJlYSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIucmVuZGVyZWRSb3dzLnB1c2goZ2V0Um93SGVhZGVyQ2VsbFJlbmRlckluZm9fLmNhbGwoc2NvcGUsIG51bGwsIGksIHJvd0hlaWdodCwgb2Zmc2V0VG9wKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFRvcCArPSByb3dIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZWEgPT09IEdST1VQX0RSQUdfUEFORUwpIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyRGl2Q3NzQ2xhc3M6ICdnYy1ncm91cGluZy1jb250YWluZXIgbm8tc2VsZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyRGl2U3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogUE9TX0FCUyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGN1cnJMYXlvdXRJbmZvLnRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBjdXJyTGF5b3V0SW5mby5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogT1ZFUkZMT1dfSElEREVOXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJEaXZTdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBQT1NfUkVMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogY3VyckxheW91dEluZm8udG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGN1cnJMYXlvdXRJbmZvLmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRSb3dzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUm93Um9sZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVySW5mbzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlZEhUTUw6IGdldFJlbmRlcmVkR3JvdXBEcmFnUGFuZWxJbmZvXy5jYWxsKHNjb3BlLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmVhID09PSBUT09MUEFORUwpIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyRGl2Q3NzQ2xhc3M6ICdnYy10b29sLXBhbmVsLWNvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRlckRpdlN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFBPU19BQlMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBjdXJyTGF5b3V0SW5mby50b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogY3VyckxheW91dEluZm8ubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6IE9WRVJGTE9XX0hJRERFTixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6SW5kZXg6IDk5OVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyRGl2U3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogUE9TX1JFTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3dpZHRoOiB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkUm93czogW2dldFRvb2xQYW5lbFJlbmRlckluZm9fLmNhbGwoc2NvcGUpXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEluaXRpYWxTY3JvbGxPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogMFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRSb3dUZW1wbGF0ZTogZnVuY3Rpb24oYXJlYSkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICAvLy8vVE9ETzogcmUtY29uc2lkZXIgd2hldGhlciB3ZSBzaG91bGQgdXNlIGdyb3VwIHN0cmF0ZWd5IHJvdyB0ZW1wbGF0ZSBoZXJlXG4gICAgICAgICAgICAgICAgLy9pZiAoc2VsZi5ncm91cFN0cmF0ZWd5Xykge1xuICAgICAgICAgICAgICAgIC8vICAgIHJldHVybiBzZWxmLmdyb3VwU3RyYXRlZ3lfLmdldFJvd1RlbXBsYXRlKCk7XG4gICAgICAgICAgICAgICAgLy99XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFRlbXBsYXRlXy5jYWxsKHNlbGYsIGZhbHNlLCBhcmVhKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNob3dTY3JvbGxQYW5lbDogZnVuY3Rpb24oYXJlYSkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5ncm91cFN0cmF0ZWd5Xykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5ncm91cFN0cmF0ZWd5Xy5zaG93U2Nyb2xsUGFuZWwoYXJlYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsYXlvdXRJbmZvO1xuICAgICAgICAgICAgICAgIGlmIChhcmVhID09PSBWSUVXUE9SVCkge1xuICAgICAgICAgICAgICAgICAgICBsYXlvdXRJbmZvID0gc2VsZi5nZXRMYXlvdXRJbmZvKClbVklFV1BPUlRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYuaGFzUmlnaHRQaW5uZWRDb2x1bW5fICYmIChsYXlvdXRJbmZvLmhlaWdodCA8IGxheW91dEluZm8uY29udGVudEhlaWdodCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0SW5mby53aWR0aCA8IGxheW91dEluZm8uY29udGVudFdpZHRoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5oYXNSaWdodFBpbm5lZENvbHVtbl8gJiYgbGF5b3V0SW5mby53aWR0aCA8IGxheW91dEluZm8uY29udGVudFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXJlYSA9PT0gUElOTkVEX1JJR0hUX1ZJRVdQT1JUKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheW91dEluZm8gPSBzZWxmLmdldExheW91dEluZm8oKVtWSUVXUE9SVF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXlvdXRJbmZvLmhlaWdodCA8IGxheW91dEluZm8uY29udGVudEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaXNTY3JvbGxhYmxlQXJlYV86IGZ1bmN0aW9uKGFyZWEpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZ3JvdXBTdHJhdGVneV8gJiYgc2VsZi5ncm91cFN0cmF0ZWd5Xy5pc1Njcm9sbGFibGVBcmVhXykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5ncm91cFN0cmF0ZWd5Xy5pc1Njcm9sbGFibGVBcmVhXyhhcmVhKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYXJlYSA9PT0gVklFV1BPUlQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRTY3JvbGxQYW5lbFJlbmRlckluZm86IGZ1bmN0aW9uKGFyZWEpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZ3JvdXBTdHJhdGVneV8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ3JvdXBTdHJhdGVneV8uZ2V0U2Nyb2xsUGFuZWxSZW5kZXJJbmZvKGFyZWEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXJlYSA9PT0gVklFV1BPUlQgfHwgYXJlYSA9PT0gUElOTkVEX1JJR0hUX1ZJRVdQT1JUKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXlvdXQgPSBzZWxmLmdldExheW91dEluZm8oKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVtcHR5TGF5b3V0ID0ge3dpZHRoOiAwLCBoZWlnaHQ6IDAsIGNvbnRlbnRXaWR0aDogMCwgY29udGVudEhlaWdodDogMH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW5IZWFkZXJMYXlvdXRJbmZvID0gbGF5b3V0W0NPTFVNTl9IRUFERVJdIHx8IGVtcHR5TGF5b3V0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93SGVhZGVyTGF5b3V0SW5mbyA9IGxheW91dFtST1dfSEVBREVSXSB8fCBlbXB0eUxheW91dDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXdwb3J0TGF5b3V0ID0gbGF5b3V0W1ZJRVdQT1JUXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBpbm5lZFZpZXdwb3J0bGF5b3V0ID0gbGF5b3V0W1BJTk5FRF9WSUVXUE9SVF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaG93SFNjcm9sbGJhciA9IGFyZWEgPT09IFZJRVdQT1JUID8gKHZpZXdwb3J0TGF5b3V0LmNvbnRlbnRXaWR0aCA+IHZpZXdwb3J0TGF5b3V0LndpZHRoKSA6IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2hvd1ZTY3JvbGxiYXIgPSBhcmVhID09PSBWSUVXUE9SVCA/ICghc2VsZi5oYXNSaWdodFBpbm5lZENvbHVtbl8gJiYgdmlld3BvcnRMYXlvdXQuY29udGVudEhlaWdodCA+IHZpZXdwb3J0TGF5b3V0LmhlaWdodCkgOiB2aWV3cG9ydExheW91dC5jb250ZW50SGVpZ2h0ID4gdmlld3BvcnRMYXlvdXQuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3V0ZXJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlubmVyV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRlckhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlubmVySGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjc3NDbGFzcyA9ICdnYy1ncmlkLScgKyBWSUVXUE9SVCArICctc2Nyb2xsLXBhbmVsJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZWEgPT09IFZJRVdQT1JUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NDbGFzcyArPSAnIHNjcm9sbC1sZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi5oYXNSaWdodFBpbm5lZENvbHVtbl8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3NDbGFzcyArPSAnIHNjcm9sbC10b3AnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJXaWR0aCA9IHZpZXdwb3J0TGF5b3V0LndpZHRoICsgKHNlbGYuaGFzTGVmdFBpbm5lZENvbHVtbl8gPyAwIDogcm93SGVhZGVyTGF5b3V0SW5mby53aWR0aCkgKyAoc2hvd1ZTY3JvbGxiYXIgPyBkb21VdGlsLmdldFNjcm9sbGJhclNpemUoKS53aWR0aCA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJXaWR0aCA9IHZpZXdwb3J0TGF5b3V0LmNvbnRlbnRXaWR0aCArIChzZWxmLmhhc0xlZnRQaW5uZWRDb2x1bW5fID8gMCA6IHJvd0hlYWRlckxheW91dEluZm8ud2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJIZWlnaHQgPSB2aWV3cG9ydExheW91dC5oZWlnaHQgKyBjb2x1bW5IZWFkZXJMYXlvdXRJbmZvLmhlaWdodCArIChzaG93SFNjcm9sbGJhciA/IGRvbVV0aWwuZ2V0U2Nyb2xsYmFyU2l6ZSgpLmhlaWdodCA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJIZWlnaHQgPSAoc2VsZi5oYXNSaWdodFBpbm5lZENvbHVtbl8gPyB2aWV3cG9ydExheW91dC5oZWlnaHQgOiB2aWV3cG9ydExheW91dC5jb250ZW50SGVpZ2h0KSArIGNvbHVtbkhlYWRlckxheW91dEluZm8uaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHNlbGYuaGFzTGVmdFBpbm5lZENvbHVtbl8gPyAocm93SGVhZGVyTGF5b3V0SW5mby53aWR0aCArIHBpbm5lZFZpZXdwb3J0bGF5b3V0LndpZHRoKSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NDbGFzcyArPSAnIHNjcm9sbC10b3AnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBpbm5lZFJpZ2h0TGF5b3V0ID0gbGF5b3V0W2FyZWFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJXaWR0aCA9IHBpbm5lZFJpZ2h0TGF5b3V0LndpZHRoICsgKHNob3dWU2Nyb2xsYmFyID8gZG9tVXRpbC5nZXRTY3JvbGxiYXJTaXplKCkud2lkdGggOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyV2lkdGggPSBwaW5uZWRSaWdodExheW91dC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGVySGVpZ2h0ID0gcGlubmVkUmlnaHRMYXlvdXQuaGVpZ2h0ICsgY29sdW1uSGVhZGVyTGF5b3V0SW5mby5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbm5lckhlaWdodCA9IHZpZXdwb3J0TGF5b3V0LmNvbnRlbnRIZWlnaHQgKyBjb2x1bW5IZWFkZXJMYXlvdXRJbmZvLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSByb3dIZWFkZXJMYXlvdXRJbmZvLndpZHRoICsgKHNlbGYuaGFzTGVmdFBpbm5lZENvbHVtbl8gPyBwaW5uZWRWaWV3cG9ydGxheW91dC53aWR0aCA6IDApICsgdmlld3BvcnRMYXlvdXQud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJEaXZDc3NDbGFzczogY3NzQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRlckRpdlN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFBPU19BQlMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiB0aGlzLm9wdGlvbnMuYWxsb3dHcm91cGluZyA/IGxheW91dFtHUk9VUF9EUkFHX1BBTkVMXS5oZWlnaHQgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBvdXRlckhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogb3V0ZXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogT1ZFUkZMT1dfQVVUT1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyRGl2U3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogUE9TX1JFTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGlubmVySGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBpbm5lcldpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY2xlYXJSZW5kZXJDYWNoZV86IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5ncm91cFN0cmF0ZWd5Xykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmdyb3VwU3RyYXRlZ3lfLmNsZWFyUmVuZGVyQ2FjaGVfKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2xlYXJUZW1wbGF0ZUNhY2hlXy5jYWxsKHNlbGYpO1xuICAgICAgICAgICAgICAgIHNlbGYudG9vbFBhbmVsSW5mb18gPSBudWxsO1xuICAgICAgICAgICAgICAgIHNlbGYuZ3JvdURyYWdQYW5lbExheW91dEluZm9fID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzZWxmLmNhY2hlZFZpZXdwb3J0TGF5b3V0SW5mb18gPSBudWxsO1xuICAgICAgICAgICAgICAgIHNlbGYubGF5b3V0SW5mb18gPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaGFzTGVmdFBpbm5lZENvbHVtbl8pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wdkluZm9fID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaGFzUmlnaHRQaW5uZWRDb2x1bW5fKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucHJ2SW5mb18gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGhhbmRsZVRlbXBsYXRlQ2hhbmdlXzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGlmICghc2VsZi5zdXNwZW5kVG1wbFVwZGF0ZV8pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi51cGRhdGVTdGFydFNpemVfKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGlkYXRlQ29sdW1uV2lkdGhfLmNhbGwoc2VsZiwgJ25vbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb2xzUmVzaXplSW5mb18gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbExheW91dHNfID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuaGFzTGVmdFBpbm5lZENvbHVtbl8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGlkYXRlQ29sdW1uV2lkdGhfLmNhbGwoc2VsZiwgJ2xlZnQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5oYXNSaWdodFBpbm5lZENvbHVtbl8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGlkYXRlQ29sdW1uV2lkdGhfLmNhbGwoc2VsZiwgJ3JpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRHcm91cEluZm9EZWZhdWx0c186IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdyb3VwU3RyYXRlZ3lfKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdyb3VwU3RyYXRlZ3lfLmdldEdyb3VwSW5mb0RlZmF1bHRzXygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBmb290ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsYXBzZVdpdGhHcm91cDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpbml0R3JvdXBJbmZvc0hlaWdodF86IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5ncm91cFN0cmF0ZWd5XyAmJiBzZWxmLmdyb3VwU3RyYXRlZ3lfLmluaXRHcm91cEluZm9zSGVpZ2h0Xykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5ncm91cFN0cmF0ZWd5Xy5pbml0R3JvdXBJbmZvc0hlaWdodF8oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwSW5mb3MgPSBzZWxmLmdyaWQuZ3JvdXBJbmZvc187XG4gICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgdmFyIGxlbjtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGdyb3VwSW5mb3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBJbmZvc1tpXS5oZWlnaHQgPSBzZWxmLmdldEdyb3VwSGVpZ2h0Xyhncm91cEluZm9zW2ldKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEdyb3VwSGVpZ2h0XzogZnVuY3Rpb24oZ3JvdXBJbmZvKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGlmICghZ3JvdXBJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWdjVXRpbHMuaXNVbmRlZmluZWQoZ3JvdXBJbmZvLmhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdyb3VwSW5mby5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBJbmZvLmRhdGE7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlciA9IGdyb3VwLmdyb3VwRGVzY3JpcHRvci5oZWFkZXI7XG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlciAmJiBoZWFkZXIudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgKz0gc2VsZi5nZXRHcm91cEhlYWRlckhlaWdodF8oZ3JvdXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuO1xuICAgICAgICAgICAgICAgIHZhciBmb290ZXI7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkR3JvdXA7XG4gICAgICAgICAgICAgICAgaWYgKCFncm91cC5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gZ3JvdXAuaXNCb3R0b21MZXZlbCA/IGdyb3VwLml0ZW1Db3VudCA6IGdyb3VwSW5mby5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwLmlzQm90dG9tTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgKz0gc2VsZi5nZXRSb3dIZWlnaHRfKGdyb3VwLmdldEl0ZW0oaSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZEdyb3VwID0gZ3JvdXBJbmZvLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkR3JvdXAuaGVpZ2h0ID0gc2VsZi5nZXRHcm91cEhlaWdodF8oY2hpbGRHcm91cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ICs9IGNoaWxkR3JvdXAuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCArPSBzZWxmLmdldEdyb3VwRm9vdGVySGVpZ2h0Xyhncm91cCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9vdGVyID0gZ3JvdXAuZ3JvdXBEZXNjcmlwdG9yLmZvb3RlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvb3RlciAmJiBmb290ZXIudmlzaWJsZSAmJiAhZm9vdGVyLmNvbGxhcHNlV2l0aEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgKz0gc2VsZi5nZXRHcm91cEZvb3RlckhlaWdodF8oZ3JvdXApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBoYW5kbGVTY3JvbGw6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZ3JvdXBTdHJhdGVneV8pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5ncm91cFN0cmF0ZWd5Xy5oYW5kbGVTY3JvbGwoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JpZCA9IHNlbGYuZ3JpZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxmLmlzUmVzaXppbmdDb2xfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmlkLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmlkLnNjcm9sbFJlbmRlclBhcnRfKFZJRVdQT1JUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyaWQuc2Nyb2xsUmVuZGVyUGFydF8oQ09MVU1OX0hFQURFUik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5oYXNMZWZ0UGlubmVkQ29sdW1uXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWQuc2Nyb2xsUmVuZGVyUGFydF8oUElOTkVEX1ZJRVdQT1JUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkLnNjcm9sbFJlbmRlclBhcnRfKFBJTk5FRF9DT0xVTU5fSEVBREVSKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmhhc1JpZ2h0UGlubmVkQ29sdW1uXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWQuc2Nyb2xsUmVuZGVyUGFydF8oUElOTkVEX1JJR0hUX1ZJRVdQT1JUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkLnNjcm9sbFJlbmRlclBhcnRfKFBJTk5FRF9SSUdIVF9DT0xVTU5fSEVBREVSKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdyaWQuc2Nyb2xsUmVuZGVyUGFydF8oUk9XX0hFQURFUik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5ncmlkLm9uU2Nyb2xsT3Zlcl8ucmFpc2Uoc2VsZi5ncmlkLCB7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbERpcmVjdGlvbjogZS5zY3JvbGxEaXJlY3Rpb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGhpdFRlc3Q6IGZ1bmN0aW9uKGV2ZW50QXJncykge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5ncm91cFN0cmF0ZWd5Xykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5ncm91cFN0cmF0ZWd5Xy5oaXRUZXN0KGV2ZW50QXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gc2VsZi5vcHRpb25zO1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gZXZlbnRBcmdzLnBhZ2VYO1xuICAgICAgICAgICAgICAgIHZhciB0b3AgPSBldmVudEFyZ3MucGFnZVk7XG4gICAgICAgICAgICAgICAgdmFyIGdyaWQgPSBzZWxmLmdyaWQ7XG4gICAgICAgICAgICAgICAgdmFyIGxheW91dEluZm8gPSBzZWxmLmdldExheW91dEluZm8oKTtcbiAgICAgICAgICAgICAgICB2YXIgZW1wdHlMYXlvdXQgPSB7d2lkdGg6IDAsIGhlaWdodDogMCwgY29udGVudFdpZHRoOiAwLCBjb250ZW50SGVpZ2h0OiAwfTtcbiAgICAgICAgICAgICAgICB2YXIgdmlld3BvcnRMYXlvdXQgPSBsYXlvdXRJbmZvW1ZJRVdQT1JUXSB8fCBlbXB0eUxheW91dDtcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uSGVhZGVyTGF5b3V0ID0gbGF5b3V0SW5mb1tDT0xVTU5fSEVBREVSXSB8fCBlbXB0eUxheW91dDtcbiAgICAgICAgICAgICAgICB2YXIgcm93SGVhZGVyTGF5b3V0ID0gbGF5b3V0SW5mb1tST1dfSEVBREVSXSB8fCBlbXB0eUxheW91dDtcbiAgICAgICAgICAgICAgICB2YXIgY29ybmVySGVhZGVyTGF5b3V0ID0gbGF5b3V0SW5mb1tDT1JORVJfSEVBREVSXSB8fCBlbXB0eUxheW91dDtcbiAgICAgICAgICAgICAgICB2YXIgcGlubmVkVmlld3BvcnRMYXlvdXQgPSBsYXlvdXRJbmZvW1BJTk5FRF9WSUVXUE9SVF0gfHwgZW1wdHlMYXlvdXQ7XG4gICAgICAgICAgICAgICAgdmFyIHBpbm5lZENvbHVtbkhlYWRlckxheW91dCA9IGxheW91dEluZm9bUElOTkVEX0NPTFVNTl9IRUFERVJdIHx8IGVtcHR5TGF5b3V0O1xuICAgICAgICAgICAgICAgIHZhciBwaW5uZWRSaWdodFZpZXdwb3J0TGF5b3V0ID0gbGF5b3V0SW5mb1tQSU5ORURfUklHSFRfVklFV1BPUlRdIHx8IGVtcHR5TGF5b3V0O1xuICAgICAgICAgICAgICAgIHZhciBwaW5uZWRSaWdodENvbHVtbkhlYWRlckxheW91dCA9IGxheW91dEluZm9bUElOTkVEX1JJR0hUX0NPTFVNTl9IRUFERVJdIHx8IGVtcHR5TGF5b3V0O1xuICAgICAgICAgICAgICAgIHZhciB0b29sUGFuZWxMYXlvdXQgPSBsYXlvdXRJbmZvW1RPT0xQQU5FTF0gfHwgZW1wdHlMYXlvdXQ7XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwRHJhZ1BhbmVsTGF5b3V0ID0gb3B0aW9ucy5hbGxvd0dyb3VwaW5nID8gbGF5b3V0SW5mb1tHUk9VUF9EUkFHX1BBTkVMXSA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVySW5mbyA9IGdyaWQuZ2V0Q29udGFpbmVySW5mb18oKS5jb250ZW50UmVjdDtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0TGVmdCA9IGxlZnQgLSBjb250YWluZXJJbmZvLmxlZnQ7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldFRvcCA9IHRvcCAtIGNvbnRhaW5lckluZm8udG9wO1xuXG4gICAgICAgICAgICAgICAgdmFyIHBhbmVsT2Zmc2V0O1xuICAgICAgICAgICAgICAgIHZhciBjZWxsRWxlbWVudDtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbE9mZnNldDtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbExlZnQ7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGxUb3A7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHMgPSBncmlkLmNvbHVtbnM7XG4gICAgICAgICAgICAgICAgdmFyIGNvbExlbiA9IGNvbHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW4gPSAtMTtcbiAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuO1xuICAgICAgICAgICAgICAgIHZhciBhY3RJbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgYWN0TGVuO1xuICAgICAgICAgICAgICAgIHZhciBhY3Rpb247XG4gICAgICAgICAgICAgICAgdmFyIGhpdFRlc3RJbmZvID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IG9mZnNldExlZnQsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogb2Zmc2V0VG9wXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRSb3dQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0VG9wTGVmdDtcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBJbmZvO1xuICAgICAgICAgICAgICAgIHZhciByb3dJbmZvO1xuICAgICAgICAgICAgICAgIHZhciByZWxhdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGluVmlld3BvcnQgPSBjb250YWluc18odmlld3BvcnRMYXlvdXQsIHBvaW50KTtcbiAgICAgICAgICAgICAgICB2YXIgaW5QaW5uZWRWaWV3cG9ydCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBpblBpbm5lZENvbHVtbkhlYWRlckFyZWEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgaW5SaWdodFBpbm5lZFZpZXdwb3J0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIGluUmlnaHRQaW5uZWRDb2x1bW5IZWFkZXJBcmVhID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIGluVG9vbFBhbmVsID0gY29udGFpbnNfKHRvb2xQYW5lbExheW91dCwgcG9pbnQpO1xuICAgICAgICAgICAgICAgIHZhciBpblRyZWVOb2RlID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5Db2x1bW5IZWFkZXJBcmVhID0gY29udGFpbnNfKGNvbHVtbkhlYWRlckxheW91dCwgcG9pbnQpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmhhc0xlZnRQaW5uZWRDb2x1bW5fKSB7XG4gICAgICAgICAgICAgICAgICAgIGluUGlubmVkVmlld3BvcnQgPSBjb250YWluc18ocGlubmVkVmlld3BvcnRMYXlvdXQsIHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgaW5QaW5uZWRDb2x1bW5IZWFkZXJBcmVhID0gY29udGFpbnNfKHBpbm5lZENvbHVtbkhlYWRlckxheW91dCwgcG9pbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5oYXNSaWdodFBpbm5lZENvbHVtbl8pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5SaWdodFBpbm5lZFZpZXdwb3J0ID0gY29udGFpbnNfKHBpbm5lZFJpZ2h0Vmlld3BvcnRMYXlvdXQsIHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgaW5SaWdodFBpbm5lZENvbHVtbkhlYWRlckFyZWEgPSBjb250YWluc18ocGlubmVkUmlnaHRDb2x1bW5IZWFkZXJMYXlvdXQsIHBvaW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd1Rvb2xQYW5lbCAmJiBpblRvb2xQYW5lbCkge1xuICAgICAgICAgICAgICAgICAgICBoaXRUZXN0SW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZWE6IFRPT0xQQU5FTCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IC0xXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldExlZnQgLT0gdG9vbFBhbmVsTGF5b3V0LmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFRvcCAtPSB0b29sUGFuZWxMYXlvdXQudG9wO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0SXRlbXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0SXRlbTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoZWNrSWNvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW92ZUljb247XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b29sUGFuZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjJyArIGdyaWQudWlkICsgJy0nICsgVE9PTFBBTkVMKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbkxpc3QgPSB0b29sUGFuZWwucXVlcnlTZWxlY3RvcignLmNvbHVtbi1saXN0Jyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cExpc3QgPSB0b29sUGFuZWwucXVlcnlTZWxlY3RvcignLmdyb3VwLWxpc3QnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50SW5fLmNhbGwoc2VsZiwgb2Zmc2V0TGVmdCwgb2Zmc2V0VG9wLCBjb2x1bW5MaXN0LCB0b29sUGFuZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXRUZXN0SW5mby5jb2x1bW5MaXN0SW5mbyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdEl0ZW1zID0gdG9vbFBhbmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jb2x1bW4tbGlzdC1pdGVtJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBsaXN0SXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0SXRlbSA9IGxpc3RJdGVtc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnRJbl8ob2Zmc2V0TGVmdCwgb2Zmc2V0VG9wLCBsaXN0SXRlbSwgdG9vbFBhbmVsKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdFRlc3RJbmZvLmNvbHVtbkxpc3RJbmZvLmNvbHVtbiA9IGxpc3RJdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1jb2wtaWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tJY29uID0gbGlzdEl0ZW0ucXVlcnlTZWxlY3RvcignLmNoZWNrJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2ludEluXy5jYWxsKHNlbGYsIG9mZnNldExlZnQsIG9mZnNldFRvcCwgY2hlY2tJY29uLCB0b29sUGFuZWwsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRUZXN0SW5mby5jb2x1bW5MaXN0SW5mby5hY3Rpb24gPSAndmlzaWJsZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBvaW50SW5fLmNhbGwoc2VsZiwgb2Zmc2V0TGVmdCwgb2Zmc2V0VG9wLCBncm91cExpc3QsIHRvb2xQYW5lbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdFRlc3RJbmZvLmdyb3VwTGlzdEluZm8gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RJdGVtcyA9IHRvb2xQYW5lbC5xdWVyeVNlbGVjdG9yQWxsKCcuZ3JvdXAtbGlzdC1pdGVtJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBsaXN0SXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0SXRlbSA9IGxpc3RJdGVtc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnRJbl8uY2FsbChzZWxmLCBvZmZzZXRMZWZ0LCBvZmZzZXRUb3AsIGxpc3RJdGVtLCB0b29sUGFuZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdFRlc3RJbmZvLmdyb3VwTGlzdEluZm8uZ3JvdXAgPSBsaXN0SXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtZ3JvdXAtaWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlSWNvbiA9IGxpc3RJdGVtLnF1ZXJ5U2VsZWN0b3IoJy5yZW1vdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50SW5fLmNhbGwoc2VsZiwgb2Zmc2V0TGVmdCwgb2Zmc2V0VG9wLCByZW1vdmVJY29uLCB0b29sUGFuZWwsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRUZXN0SW5mby5ncm91cExpc3RJbmZvLmFjdGlvbiA9ICdyZW1vdmVHcm91cCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc2VydENvbHVtbkljb24gPSB0b29sUGFuZWwucXVlcnlTZWxlY3RvcignLmluc2VydC1jb2x1bW4taWNvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc2VydENvbHVtbkljb24gJiYgcG9pbnRJbl8uY2FsbChzZWxmLCBvZmZzZXRMZWZ0LCBvZmZzZXRUb3AsIGluc2VydENvbHVtbkljb24sIHRvb2xQYW5lbCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRUZXN0SW5mby5jb2x1bW5MaXN0SW5mbyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdFRlc3RJbmZvLmNvbHVtbkxpc3RJbmZvLmFjdGlvbiA9ICdzaG93QWRkQ29sdW1uV2luZG93JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5WaWV3cG9ydCB8fCBpblBpbm5lZFZpZXdwb3J0IHx8IGluUmlnaHRQaW5uZWRWaWV3cG9ydCkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0IC09IHJvd0hlYWRlckxheW91dC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VG9wIC09IChjb2x1bW5IZWFkZXJMYXlvdXQuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dHcm91cGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VG9wIC09IGdyb3VwRHJhZ1BhbmVsTGF5b3V0LmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5WaWV3cG9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuaGFzTGVmdFBpbm5lZENvbHVtbl8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0IC09IHBpbm5lZFZpZXdwb3J0TGF5b3V0LndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0TGVmdCArPSBncmlkLnNjcm9sbE9mZnNldC5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpblJpZ2h0UGlubmVkVmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmhhc0xlZnRQaW5uZWRDb2x1bW5fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0TGVmdCAtPSBwaW5uZWRWaWV3cG9ydExheW91dC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldExlZnQgLT0gdmlld3BvcnRMYXlvdXQud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VG9wICs9IGdyaWQuc2Nyb2xsT2Zmc2V0LnRvcDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzR3JvdXBfKGdyaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFJvd1Bvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFRvcExlZnQgPSBvZmZzZXRUb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBncmlkLmRhdGEuZ3JvdXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBJbmZvID0gZ3JpZC5ncm91cEluZm9zX1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRUZXN0SW5mbyA9IGhpdFRlc3RHcm91cF8uY2FsbChzZWxmLCBncm91cEluZm8sIG9mZnNldFRvcExlZnQsIHN0YXJ0Um93UG9zaXRpb24sIG9mZnNldExlZnQsIG9mZnNldFRvcCwgVklFV1BPUlQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoaXRUZXN0SW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRUZXN0SW5mby5hcmVhID0gKGluVmlld3BvcnQgPyBWSUVXUE9SVCA6IChpblBpbm5lZFZpZXdwb3J0ID8gUElOTkVEX1ZJRVdQT1JUIDogUElOTkVEX1JJR0hUX1ZJRVdQT1JUKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRUb3BMZWZ0IC09IGdyb3VwSW5mby5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRSb3dQb3NpdGlvbiArPSBncm91cEluZm8uaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93SW5mbyA9IGdldFJvd0luZm9BdC5jYWxsKHRoaXMsIHt0b3A6IG9mZnNldFRvcH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd0luZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gcm93SW5mby5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydFJvd1Bvc2l0aW9uID0gcm93SW5mby5zdGFydFBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXRUb3BGcm9tQ3VycmVudFJvdyA9IG9mZnNldFRvcCAtIHN0YXJ0Um93UG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvd1NlbGVjdG9yID0gZ3JpZC51aWQgKyAoaW5WaWV3cG9ydCA/ICctcicgOiAoaW5QaW5uZWRWaWV3cG9ydCA/ICctcHInIDogJy1wcnInKSkgKyByb3c7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvd0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChyb3dTZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFjdGlvbkVsZW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldExlZnQgLT0gKHJvd0VsZW1lbnQuc3R5bGUubGVmdCA/IHBhcnNlRmxvYXQocm93RWxlbWVudC5zdHlsZS5sZWZ0KSA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2xMZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRWxlbWVudCA9IHJvd0VsZW1lbnQucXVlcnlTZWxlY3RvcignLmMnICsgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsRWxlbWVudCAmJiBwb2ludEluXyhvZmZzZXRMZWZ0LCBvZmZzZXRUb3BGcm9tQ3VycmVudFJvdywgY2VsbEVsZW1lbnQsIHJvd0VsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVFbGVtZW50ID0gY2VsbEVsZW1lbnQucXVlcnlTZWxlY3RvcignLmdjLXRyZWUtbm9kZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVFbGVtZW50ICYmIHBvaW50SW5fLmNhbGwoc2VsZiwgb2Zmc2V0TGVmdCwgb2Zmc2V0VG9wRnJvbUN1cnJlbnRSb3csIG5vZGVFbGVtZW50LCByb3dFbGVtZW50LCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluVHJlZU5vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2xzW2ldLmFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkVsZW1lbnRzID0gY2VsbEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtYWN0aW9uXScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoYWN0SW5kZXggPSAwLCBhY3RMZW4gPSBhY3Rpb25FbGVtZW50cy5sZW5ndGg7IGFjdEluZGV4IDwgYWN0TGVuOyBhY3RJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2ludEluXyhvZmZzZXRMZWZ0LCBvZmZzZXRUb3BGcm9tQ3VycmVudFJvdywgYWN0aW9uRWxlbWVudHNbYWN0SW5kZXhdLCByb3dFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gZ3JpZC5nZXRBY3Rpb25IYW5kbGVyXyhjb2xzW2ldLmlkLCBhY3Rpb25FbGVtZW50c1thY3RJbmRleF0uZ2V0QXR0cmlidXRlKCdkYXRhLWFjdGlvbicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gaGl0VGVzdFRvdWNoUGFuZWxfKGdyaWQsIGNvbHMsIG9mZnNldExlZnQsIG9mZnNldFRvcEZyb21DdXJyZW50Um93LCByb3dFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRUZXN0SW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlYTogKGluVmlld3BvcnQgPyBWSUVXUE9SVCA6IChpblBpbm5lZFZpZXdwb3J0ID8gUElOTkVEX1ZJRVdQT1JUIDogUElOTkVEX1JJR0hUX1ZJRVdQT1JUKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogcm93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5UcmVlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRUZXN0SW5mby5pblRyZWVOb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdFRlc3RJbmZvLmFjdGlvbiA9IGFjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdFRlc3RJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmVhOiAnbm9uZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbkNvbHVtbkhlYWRlckFyZWEgfHwgaW5QaW5uZWRDb2x1bW5IZWFkZXJBcmVhIHx8IGluUmlnaHRQaW5uZWRDb2x1bW5IZWFkZXJBcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldExlZnQgLT0gcm93SGVhZGVyTGF5b3V0LndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5Db2x1bW5IZWFkZXJBcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5oYXNMZWZ0UGlubmVkQ29sdW1uXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldExlZnQgLT0gcGlubmVkQ29sdW1uSGVhZGVyTGF5b3V0LndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpblJpZ2h0UGlubmVkQ29sdW1uSGVhZGVyQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuaGFzTGVmdFBpbm5lZENvbHVtbl8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0IC09IHBpbm5lZENvbHVtbkhlYWRlckxheW91dC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldExlZnQgLT0gdmlld3BvcnRMYXlvdXQud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VG9wIC09IChvcHRpb25zLmFsbG93R3JvdXBpbmcgPyBncm91cERyYWdQYW5lbExheW91dC5oZWlnaHQgOiAwKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5Db2x1bW5IZWFkZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdFBhcnQgPSBpbkNvbHVtbkhlYWRlckFyZWEgPyBDT0xVTU5fSEVBREVSIDogKGluUGlubmVkQ29sdW1uSGVhZGVyQXJlYSA/IFBJTk5FRF9DT0xVTU5fSEVBREVSIDogUElOTkVEX1JJR0hUX0NPTFVNTl9IRUFERVIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1uSGVhZGVyUGFuZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChncmlkLnVpZCArICctJyArIHNlbGVjdFBhcnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGlubmVkID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5QaW5uZWRDb2x1bW5IZWFkZXJBcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaW5uZWQgPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5SaWdodFBpbm5lZENvbHVtbkhlYWRlckFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpbm5lZCA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFuZWxPZmZzZXQgPSBkb21VdGlsLm9mZnNldChjb2x1bW5IZWFkZXJQYW5lbCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2xMZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyaWQuaXNDb2xWaXNpYmxlXyhjb2xzW2ldLCBwaW5uZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjJyArIGdyaWQudWlkICsgJy0nICsgc2VsZWN0UGFydCArICcgLmdjLWNvbHVtbi1oZWFkZXItY2VsbC5jJyArIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsT2Zmc2V0ID0gZG9tVXRpbC5vZmZzZXQoY2VsbEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsTGVmdCA9IGNlbGxPZmZzZXQubGVmdCAtIHBhbmVsT2Zmc2V0LmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxUb3AgPSBjZWxsT2Zmc2V0LnRvcCAtIHBhbmVsT2Zmc2V0LnRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGxFbGVtZW50U3R5bGUgPSBkb21VdGlsLmdldFN0eWxlKGNlbGxFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhZGRpbmdMZWZ0ID0gcGFyc2VTdHlsZVByb3BlcnR5VmFsdWVfKGNlbGxFbGVtZW50U3R5bGUsIFBBRERJTkdfTEVGVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nUmlnaHQgPSBwYXJzZVN0eWxlUHJvcGVydHlWYWx1ZV8oY2VsbEVsZW1lbnRTdHlsZSwgUEFERElOR19SSUdIVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2ludEluXyhvZmZzZXRMZWZ0LCBvZmZzZXRUb3AsIGNlbGxFbGVtZW50LCBjb2x1bW5IZWFkZXJQYW5lbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluQ29sdW1uSGVhZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdFRlc3RJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZWE6IHNlbGVjdFBhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93OiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVySW5mbzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpblJlc2l6ZU1vZGU6IChjZWxsTGVmdCArIGNlbGxFbGVtZW50Lm9mZnNldFdpZHRoIC0gb2Zmc2V0TGVmdCkgPD0gUkVTSVpFX0dBUF9TSVpFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNpemVGcm9tWmVybzogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKGNlbGxFbGVtZW50LmNsaWVudFdpZHRoIC0gcGFkZGluZ0xlZnQgLSBwYWRkaW5nUmlnaHQpID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsTGVmdCA8IG9mZnNldExlZnQgJiYgY2VsbFRvcCA+PSBvZmZzZXRUb3AgJiYgb2Zmc2V0VG9wIDw9IChjZWxsVG9wICsgY2VsbEVsZW1lbnQuY2xpZW50SGVpZ2h0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNlbGxMZWZ0ICsgUkVTSVpFX0dBUF9TSVpFKSA+IG9mZnNldExlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluQ29sdW1uSGVhZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdFRlc3RJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZWE6IHNlbGVjdFBhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93OiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVySW5mbzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpblJlc2l6ZU1vZGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6ZUZyb21aZXJvOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cENvbHVtbkhlYWRlcnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjJyArIGdyaWQudWlkICsgJy0nICsgc2VsZWN0UGFydCArICcgW2RhdGEtY29sdW1uLWdyb3VwLWhlYWRlcl0nKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGdyb3VwQ29sdW1uSGVhZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbkhlYWRlciA9IGdyb3VwQ29sdW1uSGVhZGVyc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW5DYXB0aW9uID0gY29sdW1uSGVhZGVyLmdldEF0dHJpYnV0ZSgnZGF0YS1jb2x1bW4tZ3JvdXAtaGVhZGVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uQ2FwdGlvbiAmJiBwb2ludEluXyhvZmZzZXRMZWZ0LCBvZmZzZXRUb3AsIGNvbHVtbkhlYWRlciwgY29sdW1uSGVhZGVyUGFuZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbE9mZnNldCA9IGRvbVV0aWwub2Zmc2V0KGNvbHVtbkhlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5Db2x1bW5IZWFkZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdFRlc3RJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmVhOiBzZWxlY3RQYXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3c6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5Hcm91cEluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcHRpb246IGNvbHVtbkNhcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVySW5mbzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5SZXNpemVNb2RlOiAoY2VsbE9mZnNldC5sZWZ0IC0gcGFuZWxPZmZzZXQubGVmdCArIGNvbHVtbkhlYWRlci5vZmZzZXRXaWR0aCAtIG9mZnNldExlZnQpIDw9IFJFU0laRV9HQVBfU0laRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6ZUZyb21aZXJvOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpY29uRWxlbWVudCA9IGNvbHVtbkhlYWRlci5xdWVyeVNlbGVjdG9yKCcuZ2MtaGVhZGVyLXRvZ2dsZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpY29uRWxlbWVudCAmJiBwb2ludEluXy5jYWxsKHNlbGYsIG9mZnNldExlZnQsIG9mZnNldFRvcCwgaWNvbkVsZW1lbnQsIGNvbHVtbkhlYWRlclBhbmVsLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRUZXN0SW5mby5jb2x1bW5Hcm91cEluZm8ub25FeHBhbmRUb2dnbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5Db2x1bW5IZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdFRlc3RJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZWE6ICdub25lJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb250YWluc18ocm93SGVhZGVyTGF5b3V0LCBwb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VG9wIC09IChjb2x1bW5IZWFkZXJMYXlvdXQuaGVpZ2h0ICsgKG9wdGlvbnMuYWxsb3dHcm91cGluZyA/IGdyb3VwRHJhZ1BhbmVsTGF5b3V0LmhlaWdodCA6IDApKTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VG9wICs9IGdyaWQuc2Nyb2xsT2Zmc2V0LnRvcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0dyb3VwXyhncmlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRSb3dQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRUb3BMZWZ0ID0gb2Zmc2V0VG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZ3JpZC5kYXRhLmdyb3Vwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwSW5mbyA9IGdyaWQuZ3JvdXBJbmZvc19baV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRUZXN0SW5mbyA9IGhpdFRlc3RHcm91cF8uY2FsbCh0aGlzLCBncm91cEluZm8sIG9mZnNldFRvcExlZnQsIHN0YXJ0Um93UG9zaXRpb24sIG9mZnNldExlZnQsIG9mZnNldFRvcCwgUk9XX0hFQURFUik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhpdFRlc3RJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRUb3BMZWZ0IC09IGdyb3VwSW5mby5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRSb3dQb3NpdGlvbiArPSBncm91cEluZm8uaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93SW5mbyA9IGdldFJvd0luZm9BdC5jYWxsKHRoaXMsIHt0b3A6IG9mZnNldFRvcH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd0luZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRUZXN0SW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlYTogUk9XX0hFQURFUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93OiByb3dJbmZvLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hbGxvd0hlYWRlclNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChncmlkLnVpZCArICctcmgnICsgcm93SW5mby5pbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSByZWxhdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLmdjLWhlYWRlci1zZWxlY3QtaWNvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBwb2ludEluXy5jYWxsKHNlbGYsIG9mZnNldExlZnQsIG9mZnNldFRvcCAtIHJvd0luZm8uc3RhcnRQb3NpdGlvbiwgZWxlbWVudCwgcmVsYXRpdmVFbGVtZW50LCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGl0VGVzdEluZm8uY2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdFRlc3RJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmVhOiAnbm9uZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb250YWluc18oY29ybmVySGVhZGVyTGF5b3V0LCBwb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGl0VGVzdEluZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmVhOiBDT1JORVJfSEVBREVSLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93OiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogLTFcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dIZWFkZXJTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGdyaWQudWlkICsgJy1jb3JuZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSByZWxhdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLmdjLWhlYWRlci1zZWxlY3QtaWNvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VG9wID0gb2Zmc2V0VG9wIC0gKG9wdGlvbnMuYWxsb3dHcm91cGluZyA/IGdyb3VwRHJhZ1BhbmVsTGF5b3V0LmhlaWdodCA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgcG9pbnRJbl8uY2FsbChzZWxmLCBvZmZzZXRMZWZ0LCBvZmZzZXRUb3AsIGVsZW1lbnQsIHJlbGF0aXZlRWxlbWVudCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRUZXN0SW5mby5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5hbGxvd0dyb3VwaW5nICYmIGNvbnRhaW5zXyhncm91cERyYWdQYW5lbExheW91dCwgcG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhpdFRlc3RJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJlYTogR1JPVVBfRFJBR19QQU5FTCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IC0xXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cERlc2NyaXB0b3JzID0gZ3JpZC5kYXRhLmdyb3VwRGVzY3JpcHRvcnM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYW5lbEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChncmlkLnVpZCArICctJyArIEdST1VQX0RSQUdfUEFORUwpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBncm91cERlc2NyaXB0b3JzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGdyaWQudWlkICsgJy1ncm91cGluZy1pbmRpY2F0b3ItJyArIGdyb3VwRGVzY3JpcHRvcnNbaV0uZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxFbGVtZW50ICYmIHBvaW50SW5fKG9mZnNldExlZnQsIG9mZnNldFRvcCwgY2VsbEVsZW1lbnQsIHBhbmVsRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRUZXN0SW5mby5ncm91cGluZ1BhbmVsSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGdyb3VwRGVzY3JpcHRvcnNbaV0uZmllbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2ludEluXyhvZmZzZXRMZWZ0LCBvZmZzZXRUb3AsIGNlbGxFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5nYy1ncm91cGluZy10aXRsZScpLCBwYW5lbEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdFRlc3RJbmZvLmdyb3VwaW5nUGFuZWxJbmZvLmFjdGlvbiA9ICdyZW9yZGVyJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50SW5fKG9mZnNldExlZnQsIG9mZnNldFRvcCwgY2VsbEVsZW1lbnQucXVlcnlTZWxlY3RvcignLmdjLWljb24tZ3JvdXBpbmctZGVsZXRlJyksIHBhbmVsRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGl0VGVzdEluZm8uZ3JvdXBpbmdQYW5lbEluZm8uYWN0aW9uID0gJ2RlbGV0ZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhpdFRlc3RJbmZvO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmdyb3VwU3RyYXRlZ3lfKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZ3JvdXBTdHJhdGVneV8uZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2VsZi5ncm91cFN0cmF0ZWd5XztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnVuUmVnaXN0ZUV2ZW50c18oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHNlbGYub3B0aW9ucztcbiAgICAgICAgICAgICAgICB2YXIganNvbk9iaiA9IHt9O1xuICAgICAgICAgICAgICAgIGpzb25PYmoubmFtZSA9IHNlbGYubmFtZTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JpZE9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5yb3dIZWFkZXJXaWR0aCAhPT0gNDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZE9wdGlvbnMucm93SGVhZGVyV2lkdGggPSBvcHRpb25zLnJvd0hlYWRlcldpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jb2xIZWFkZXJIZWlnaHQgIT09IDI0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdyaWRPcHRpb25zLmNvbEhlYWRlckhlaWdodCA9IG9wdGlvbnMuY29sSGVhZGVySGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5yb3dIZWlnaHQgIT09IDI0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdyaWRPcHRpb25zLnJvd0hlaWdodCA9IG9wdGlvbnMucm93SGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jb2xXaWR0aCAhPT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyaWRPcHRpb25zLmNvbFdpZHRoID0gb3B0aW9ucy5jb2xXaWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd1Jvd0hlYWRlciAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBncmlkT3B0aW9ucy5zaG93Um93SGVhZGVyID0gb3B0aW9ucy5zaG93Um93SGVhZGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zaG93Q29sSGVhZGVyICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyaWRPcHRpb25zLnNob3dDb2xIZWFkZXIgPSBvcHRpb25zLnNob3dDb2xIZWFkZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dHcm91cEhlYWRlciAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBncmlkT3B0aW9ucy5zaG93R3JvdXBIZWFkZXIgPSBvcHRpb25zLnNob3dHcm91cEhlYWRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0dyb3VwRm9vdGVyICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyaWRPcHRpb25zLnNob3dHcm91cEZvb3RlciA9IG9wdGlvbnMuc2hvd0dyb3VwRm9vdGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hbGxvd0VkaXRpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyaWRPcHRpb25zLmFsbG93RWRpdGluZyA9IG9wdGlvbnMuYWxsb3dFZGl0aW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hbGxvd0dyb3VwaW5nICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBncmlkT3B0aW9ucy5hbGxvd0dyb3VwaW5nID0gb3B0aW9ucy5hbGxvd0dyb3VwaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5yb3dUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBncmlkT3B0aW9ucy5yb3dUZW1wbGF0ZSA9IGdldFJhd1Jvd1RlbXBsYXRlXy5jYWxsKHNlbGYsIGZhbHNlLCBWSUVXUE9SVCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmdyb3VwU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZE9wdGlvbnMuZ3JvdXBTdHJhdGVneSA9IG9wdGlvbnMuZ3JvdXBTdHJhdGVneS50b0pTT04oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZWRpdE1vZGUgIT09ICdpbmxpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyaWRPcHRpb25zLmVkaXRNb2RlID0gb3B0aW9ucy5lZGl0TW9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFfLmlzRW1wdHkoZ3JpZE9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGpzb25PYmoub3B0aW9ucyA9IGdyaWRPcHRpb25zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ganNvbk9iajtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFNlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgc2VscyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZFJvd3MgPSBzZWxmLnNlbGVjdGVkUm93c187XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxlY3RlZFJvd3MgfHwgIXNlbGVjdGVkUm93cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uID0gc2VsZi5ncmlkLmRhdGEuc291cmNlQ29sbGVjdGlvbjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZWN0ZWRSb3dzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbHMucHVzaChjb2xsZWN0aW9uW3NlbGVjdGVkUm93c1tpXV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2VscztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldElubmVyR3JvdXBIZWlnaHQ6IGZ1bmN0aW9uKGdyb3VwSW5mbywgY29udGFpbmVyU2l6ZSkge1xuICAgICAgICAgICAgICAgIGlmICghZ3JvdXBJbmZvLmlzQm90dG9tTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJvd0hlaWdodF8oKSAqIGdyb3VwSW5mby5kYXRhLml0ZW1Db3VudDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldElubmVyR3JvdXBSZW5kZXJJbmZvOiBmdW5jdGlvbihncm91cEluZm8sIGNvbnRhaW5lclNpemUsIGxheW91dENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFncm91cEluZm8uaXNCb3R0b21MZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cEluZm8uZGF0YTtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0VG9wID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuO1xuICAgICAgICAgICAgICAgIHZhciByb3dIZWlnaHQgPSBzZWxmLmdldFJvd0hlaWdodF8oKTtcbiAgICAgICAgICAgICAgICB2YXIgcm93cyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBsYXlvdXQ7XG4gICAgICAgICAgICAgICAgdmFyIGFkZGl0aW9uYWxTdHlsZTtcbiAgICAgICAgICAgICAgICB2YXIgYWRkaXRpb25hbENTU0NsYXNzO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGdyb3VwLml0ZW1Db3VudDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXlvdXRDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0ID0gbGF5b3V0Q2FsbGJhY2soZ3JvdXBJbmZvLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxDU1NDbGFzcyA9IGxheW91dC5jc3NDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxTdHlsZSA9IGxheW91dC5zdHlsZSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxTdHlsZS53aWR0aCA9IGNvbnRhaW5lclNpemUud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dIZWlnaHQgPSBsYXlvdXQucm93SGVpZ2h0IHx8IHJvd0hlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXlvdXQubG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dzLnB1c2goZ2V0UmVuZGVyZWRHcm91cENvbnRlbnRJdGVtSW5mb18uY2FsbChzZWxmLCBpLCBncm91cEluZm8sIHJvd0hlaWdodCwgbGF5b3V0LmxvY2F0aW9uLnRvcCwgZmFsc2UsIGFkZGl0aW9uYWxDU1NDbGFzcywgYWRkaXRpb25hbFN0eWxlLCBWSUVXUE9SVCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dzLnB1c2goZ2V0UmVuZGVyZWRHcm91cENvbnRlbnRJdGVtSW5mb18uY2FsbChzZWxmLCBpLCBncm91cEluZm8sIHJvd0hlaWdodCwgb2Zmc2V0VG9wLCBmYWxzZSwgYWRkaXRpb25hbENTU0NsYXNzLCBhZGRpdGlvbmFsU3R5bGUsIFZJRVdQT1JUKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VG9wICs9IHJvd0hlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxTdHlsZSA9IHt3aWR0aDogY29udGFpbmVyU2l6ZS53aWR0aH07XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dzLnB1c2goZ2V0UmVuZGVyZWRHcm91cENvbnRlbnRJdGVtSW5mb18uY2FsbChzZWxmLCBpLCBncm91cEluZm8sIHJvd0hlaWdodCwgb2Zmc2V0VG9wLCBmYWxzZSwgbnVsbCwgYWRkaXRpb25hbFN0eWxlLCBWSUVXUE9SVCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VG9wICs9IHJvd0hlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcm93cztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldE1heFZpc2libGVJdGVtQ291bnQ6IGZ1bmN0aW9uKGNvbnRhaW5lclNpemUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoY29udGFpbmVyU2l6ZS5oZWlnaHQgLyBzZWxmLmdldFJvd0hlaWdodF8oKSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBoaXRUZXN0R3JvdXBDb250ZW50XzogZnVuY3Rpb24oZ3JvdXBJbmZvLCBhcmVhLCBvZmZzZXRMZWZ0LCBvZmZzZXRUb3AsIGNvbnRhaW5lclNpemUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWdyb3VwSW5mby5pc0JvdHRvbUxldmVsIHx8IG9mZnNldExlZnQgPCAwIHx8IG9mZnNldFRvcCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgdWlkID0gc2VsZi5ncmlkLnVpZDtcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cEluZm8uZGF0YTtcbiAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuO1xuICAgICAgICAgICAgICAgIHZhciByb3dIZWlnaHQgPSBnZXRHcm91cEl0ZW1Sb3dIZWlnaHRfLmNhbGwoc2VsZik7XG4gICAgICAgICAgICAgICAgdmFyIGhpdEdyb3VwSW5mbztcbiAgICAgICAgICAgICAgICB2YXIgcmVsYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50O1xuICAgICAgICAgICAgICAgIHZhciBncm91cFBhdGggPSBncm91cEluZm8ucGF0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBncm91cC5pdGVtQ291bnQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0VG9wIDw9IHJvd0hlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZWEgPT09IFJPV19IRUFERVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRHcm91cEluZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZWE6IFJPV19IRUFERVIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwSW5mbzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlYTogR1JPVVBfQ09OVEVOVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGdyb3VwUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogLTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5hbGxvd0hlYWRlclNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxmLmdyaWQudWlkICsgJy1ncmgnICsgZ3JvdXBQYXRoLmpvaW4oJy0nKSArICctcicgKyBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IHJlbGF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZ2MtaGVhZGVyLXNlbGVjdC1pY29uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIHBvaW50SW5fLmNhbGwoc2VsZiwgb2Zmc2V0TGVmdCwgb2Zmc2V0VG9wLCBlbGVtZW50LCByZWxhdGl2ZUVsZW1lbnQsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRHcm91cEluZm8uZ3JvdXBJbmZvLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoaXRHcm91cEluZm87XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHVpZCArICctZ3InICsgZ3JvdXBQYXRoLmpvaW4oJ18nKSArICctcicgKyBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlbGF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlYTogVklFV1BPUlQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3c6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwSW5mbzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZWE6IEdST1VQX0NPTlRFTlQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogZ3JvdXBQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdEdyb3VwSW5mbyA9IGhpdFRlc3RHcm91cFJvd0NvbHVtbnNfLmNhbGwoc2VsZiwgZ3JvdXBQYXRoLCBpLCByZWxhdGl2ZUVsZW1lbnQsIG9mZnNldExlZnQsIG9mZnNldFRvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhpdEdyb3VwSW5mbztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRUb3AgLT0gcm93SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAvL2FjY0hlaWdodCArPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9UT0RPOiBhZGQgcm93IGluZGV4IGFuZCByZXR1cm4gZGlmZmVyZW50IHZhbHVlcyBiYXNlZCBvbiByb3cgaW5kZXhcbiAgICAgICAgICAgIGdldFJvd0hlaWdodF86IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMucm93SGVpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0R3JvdXBIZWFkZXJIZWlnaHRfOiBmdW5jdGlvbihncm91cCkge1xuICAgICAgICAgICAgICAgIHZhciBoZWFkZXIgPSBncm91cC5ncm91cERlc2NyaXB0b3IuaGVhZGVyO1xuICAgICAgICAgICAgICAgIHJldHVybiAoaGVhZGVyICYmIGhlYWRlci52aXNpYmxlKSA/IChoZWFkZXIuaGVpZ2h0IHx8IHRoaXMub3B0aW9ucy5yb3dIZWlnaHQpIDogMDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEdyb3VwRm9vdGVySGVpZ2h0XzogZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgZm9vdGVyID0gZ3JvdXAuZ3JvdXBEZXNjcmlwdG9yLmZvb3RlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGZvb3RlciAmJiBmb290ZXIudmlzaWJsZSkgPyAoZm9vdGVyLmhlaWdodCB8fCB0aGlzLm9wdGlvbnMucm93SGVpZ2h0KSA6IDA7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICByZWdpc3RlRXZlbnRzXzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBncmlkID0gc2VsZi5ncmlkO1xuICAgICAgICAgICAgICAgIHNlbGYuaGFuZGxlTW91c2VNb3ZlRm5fID0gaGFuZGxlTW91c2VNb3ZlXy5iaW5kKGdyaWQpO1xuICAgICAgICAgICAgICAgIHNlbGYuaGFuZGxlVG91Y2hNb3ZlRm5fID0gaGFuZGxlVG91Y2hNb3ZlXy5iaW5kKGdyaWQpO1xuICAgICAgICAgICAgICAgIHNlbGYuaGFuZGxlVG91Y2hFbmRGbl8gPSBoYW5kbGVUb3VjaEVuZF8uYmluZChncmlkKTtcbiAgICAgICAgICAgICAgICBzZWxmLmhhbmRsZVN3aXBlRm5fID0gaGFuZGxlU3dpcGVfLmJpbmQoZ3JpZCk7XG4gICAgICAgICAgICAgICAgc2VsZi5oYW5kbGVTY3JvbGxUb3VjaEZuXyA9IGhhbmRsZVRvdWNoU2Nyb2xsLmJpbmQoZ3JpZCk7XG4gICAgICAgICAgICAgICAgZ3JpZC5vbk1vdXNlQ2xpY2suYWRkSGFuZGxlcihoYW5kbGVNb3VzZUNsaWNrXyk7XG4gICAgICAgICAgICAgICAgLy9ncmlkLm9uTW91c2VEYkNsaWNrLmFkZEhhbmRsZXIoaGFuZGxlTW91c2VEb3VibGVDbGljayk7XG4gICAgICAgICAgICAgICAgZ3JpZC5vbk1vdXNlTW92ZS5hZGRIYW5kbGVyKHNlbGYuaGFuZGxlTW91c2VNb3ZlRm5fKTtcbiAgICAgICAgICAgICAgICBncmlkLm9uTW91c2VXaGVlbC5hZGRIYW5kbGVyKGhhbmRsZU1vdXNlV2hlZWwpO1xuICAgICAgICAgICAgICAgIGdyaWQub25Nb3VzZURvd24uYWRkSGFuZGxlcihoYW5kbGVNb3VzZURvd24pO1xuICAgICAgICAgICAgICAgIGdyaWQub25Ub3VjaFN0YXJ0Xy5hZGRIYW5kbGVyKGhhbmRsZVRvdWNoU3RhcnQpO1xuICAgICAgICAgICAgICAgIGdyaWQub25Ub3VjaE1vdmVfLmFkZEhhbmRsZXIoc2VsZi5oYW5kbGVUb3VjaE1vdmVGbl8pO1xuICAgICAgICAgICAgICAgIGdyaWQub25Ub3VjaEVuZF8uYWRkSGFuZGxlcihzZWxmLmhhbmRsZVRvdWNoRW5kRm5fKTtcbiAgICAgICAgICAgICAgICBncmlkLm9uVGFwXy5hZGRIYW5kbGVyKGhhbmRsZVRvdWNoVGFwKTtcbiAgICAgICAgICAgICAgICBncmlkLm9uU3dpcGVfLmFkZEhhbmRsZXIoc2VsZi5oYW5kbGVTd2lwZUZuXyk7XG4gICAgICAgICAgICAgICAgZ3JpZC5vblRvdWNoU2Nyb2xsXy5hZGRIYW5kbGVyKHNlbGYuaGFuZGxlU2Nyb2xsVG91Y2hGbl8pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdW5SZWdpc3RlRXZlbnRzXzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBncmlkID0gc2VsZi5ncmlkO1xuICAgICAgICAgICAgICAgIC8vZ3JpZC5vbk1vdXNlRGJDbGljay5yZW1vdmVIYW5kbGVyKGhhbmRsZU1vdXNlRG91YmxlQ2xpY2spO1xuICAgICAgICAgICAgICAgIGdyaWQub25Nb3VzZUNsaWNrLnJlbW92ZUhhbmRsZXIoaGFuZGxlTW91c2VDbGlja18pO1xuICAgICAgICAgICAgICAgIGdyaWQub25Nb3VzZU1vdmUucmVtb3ZlSGFuZGxlcihzZWxmLmhhbmRsZU1vdXNlTW92ZUZuXyk7XG4gICAgICAgICAgICAgICAgZ3JpZC5vbk1vdXNlV2hlZWwucmVtb3ZlSGFuZGxlcihoYW5kbGVNb3VzZVdoZWVsKTtcbiAgICAgICAgICAgICAgICBncmlkLm9uTW91c2VEb3duLnJlbW92ZUhhbmRsZXIoaGFuZGxlTW91c2VEb3duKTtcbiAgICAgICAgICAgICAgICBncmlkLm9uVG91Y2hTdGFydF8ucmVtb3ZlSGFuZGxlcihoYW5kbGVUb3VjaFN0YXJ0KTtcbiAgICAgICAgICAgICAgICBncmlkLm9uVG91Y2hNb3ZlXy5yZW1vdmVIYW5kbGVyKHNlbGYuaGFuZGxlVG91Y2hNb3ZlRm5fKTtcbiAgICAgICAgICAgICAgICBncmlkLm9uVG91Y2hFbmRfLnJlbW92ZUhhbmRsZXIoc2VsZi5oYW5kbGVUb3VjaEVuZEZuXyk7XG4gICAgICAgICAgICAgICAgZ3JpZC5vblRhcF8ucmVtb3ZlSGFuZGxlcihoYW5kbGVUb3VjaFRhcCk7XG4gICAgICAgICAgICAgICAgZ3JpZC5vblN3aXBlXy5yZW1vdmVIYW5kbGVyKHNlbGYuaGFuZGxlU3dpcGVGbl8pO1xuICAgICAgICAgICAgICAgIGdyaWQub25Ub3VjaFNjcm9sbF8ucmVtb3ZlSGFuZGxlcihzZWxmLmhhbmRsZVNjcm9sbFRvdWNoRm5fKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHN0YXJ0RWRpdGluZ186IGZ1bmN0aW9uKGdyb3VwSW5mbywgdWlSb3dJbmRleCwgdGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGVkaXRNb2RlID0gc2VsZi5vcHRpb25zLmVkaXRNb2RlO1xuICAgICAgICAgICAgICAgIHZhciBncmlkID0gc2VsZi5ncmlkO1xuICAgICAgICAgICAgICAgIHZhciBlZGl0Q29udGFpbmVyO1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IGdyaWQudWlkICsgKGdyb3VwSW5mbyA/ICgnLWdyJyArIGdyb3VwSW5mby5wYXRoLmpvaW4oJ18nKSkgOiAnJykgKyAnLXInICsgdWlSb3dJbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIHZhciByb3dSZWN0ID0gZG9tVXRpbC5nZXRFbGVtZW50UmVjdChyb3cpO1xuICAgICAgICAgICAgICAgIHZhciB2aWV3cG9ydFJlY3QgPSBkb21VdGlsLmdldEVsZW1lbnRSZWN0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGdyaWQudWlkICsgJy12aWV3cG9ydCcpKTtcbiAgICAgICAgICAgICAgICB2YXIgcGlubmVkVmlld3BvcnRSZWN0O1xuICAgICAgICAgICAgICAgIHZhciBwaW5uZWRSb3dSZWN0O1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmhhc0xlZnRQaW5uZWRDb2x1bW5fKSB7XG4gICAgICAgICAgICAgICAgICAgIHBpbm5lZFJvd1JlY3QgPSBkb21VdGlsLmdldEVsZW1lbnRSZWN0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGdyaWQudWlkICsgKGdyb3VwSW5mbyA/ICgnLXBncicgKyBncm91cEluZm8ucGF0aC5qb2luKCdfJykpIDogJycpICsgJy1wcicgKyB1aVJvd0luZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgIHBpbm5lZFZpZXdwb3J0UmVjdCA9IGRvbVV0aWwuZ2V0RWxlbWVudFJlY3QoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZ3JpZC51aWQgKyAnLXBpbm5lZExlZnRWaWV3cG9ydCcpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcGlubmVkUmlnaHRWaWV3cG9ydFJlY3Q7XG4gICAgICAgICAgICAgICAgdmFyIHBpbm5lZFJpZ2h0Um93UmVjdDtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5oYXNSaWdodFBpbm5lZENvbHVtbl8pIHtcbiAgICAgICAgICAgICAgICAgICAgcGlubmVkUmlnaHRSb3dSZWN0ID0gZG9tVXRpbC5nZXRFbGVtZW50UmVjdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChncmlkLnVpZCArIChncm91cEluZm8gPyAoJy1wcmdyJyArIGdyb3VwSW5mby5wYXRoLmpvaW4oJ18nKSkgOiAnJykgKyAnLXBycicgKyB1aVJvd0luZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgIHBpbm5lZFJpZ2h0Vmlld3BvcnRSZWN0ID0gZG9tVXRpbC5nZXRFbGVtZW50UmVjdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChncmlkLnVpZCArICctcGlubmVkUmlnaHRWaWV3cG9ydCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGVkaXRpbmdIYW5kbGVyID0gZ3JpZC5lZGl0aW5nSGFuZGxlcjtcbiAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5jb250YWluZXJLZXlEb3duSGFuZGxlcl8gPSBlZGl0aW5nSGFuZGxlci5jb250YWluZXJLZXlEb3duSGFuZGxlci5iaW5kKGVkaXRpbmdIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbnRhaW5lck1vdXNlRG93bkhhbmRsZXJfID0gZWRpdGluZ0hhbmRsZXIuY29udGFpbmVyTW91c2VEb3duSGFuZGxlci5iaW5kKGVkaXRpbmdIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoZWRpdE1vZGUgPT09ICdpbmxpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmxpbmVGcmFnbWVudCA9IGVkaXRpbmdIYW5kbGVyLmdldElubGluZUZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRDb250YWluZXIgPSBkb21VdGlsLmNyZWF0ZUVsZW1lbnQoJzxkaXYgaWQ9XCInICsgZ3JpZC51aWQgKyAnLWlubGluZS1lZGl0aW5nLWFyZWFcIiBjbGFzcz1cImdjLWlubGluZS1lZGl0aW5nLWFyZWEgZ2MtZWRpdGluZy1hcmVhXCIgc3R5bGU9XCJ0b3A6JyArIHJvd1JlY3QudG9wICsgJ3B4O2xlZnQ6JyArIChwaW5uZWRWaWV3cG9ydFJlY3QgPyBwaW5uZWRWaWV3cG9ydFJlY3QubGVmdCA6IHZpZXdwb3J0UmVjdC5sZWZ0KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAncHg7IHdpZHRoOicgKyAoKHBpbm5lZFZpZXdwb3J0UmVjdCA/IHBpbm5lZFZpZXdwb3J0UmVjdC53aWR0aCA6IDApICsgdmlld3BvcnRSZWN0LndpZHRoICsgKHBpbm5lZFJpZ2h0Vmlld3BvcnRSZWN0ID8gcGlubmVkUmlnaHRWaWV3cG9ydFJlY3Qud2lkdGggOiAwKSkgKyAncHg7XCI+PC9kaXY+Jyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbm5lckNvbnRhaW5lciA9IGRvbVV0aWwuY3JlYXRlRWxlbWVudCgnPGRpdiBpZD1cIicgKyBncmlkLnVpZCArICctaW5saW5lLWVkaXRpbmctYXJlYS1pbm5lclwiIHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7bGVmdDonICsgKChwaW5uZWRSb3dSZWN0ID8gcGlubmVkUm93UmVjdC5sZWZ0IDogcm93UmVjdC5sZWZ0KSAtIChwaW5uZWRWaWV3cG9ydFJlY3QgPyBwaW5uZWRWaWV3cG9ydFJlY3QubGVmdCA6IHZpZXdwb3J0UmVjdC5sZWZ0KSkgKyAncHg7XCI+PC9kaXY+Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlubmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKGlubGluZUZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZWRpdENvbnRhaW5lci5hcHBlbmRDaGlsZChpbm5lckNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHNlbGYuY29udGFpbmVyS2V5RG93bkhhbmRsZXJfKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlZGl0Q29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlubGluZUVkaXRvcnMgPSBlZGl0Q29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5nYy1pbmxpbmUtZWRpdG9yLWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3Q7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGlubGluZUVkaXRvcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3QgPSBkb21VdGlsLmdldEVsZW1lbnRSZWN0KGlubGluZUVkaXRvcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCByZWN0LnRvcCAtIHJvd1JlY3QudG9wICsgcmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVkaXRDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVkaXRNb2RlID09PSAncG9wdXAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlZGl0UG9wdXBPdmVybGF5ID0gZG9tVXRpbC5jcmVhdGVFbGVtZW50KCc8ZGl2IGNsYXNzPVwiZ2MtZWRpdGluZy1vdmVybGF5XCI+PC9kaXY+Jyk7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRDb250YWluZXIgPSBkb21VdGlsLmNyZWF0ZUVsZW1lbnQoJzxkaXYgaWQ9XCInICsgZ3JpZC51aWQgKyAnLXBvcHVwLWVkaXRpbmctYXJlYVwiIGNsYXNzPVwiZ2MtcG9wdXAtZWRpdGluZy1hcmVhIGdjLWVkaXRpbmctYXJlYVwiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJnYy1lZGl0aW5nLWhlYWRlclwiPjxzcGFuIGNsYXNzPVwiaGVhZGVyLXRleHRcIj5FZGl0IEZvcm08L3NwYW4+PGRpdiBjbGFzcz1cImdjLWVkaXRpbmctY2xvc2VcIj48c3BhbiBjbGFzcz1cImdjLWljb24gY2xvc2UtaWNvblwiPjwvc3Bhbj48L2Rpdj48L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZ2MtZWRpdGluZy1jb250ZW50XCI+JyArIHRlbXBsYXRlICsgJzwvZGl2PicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJnYy1lZGl0aW5nLWZvb3RlclwiPjxkaXYgY2xhc3M9XCJnYy1lZGl0aW5nLWNhbmNlbCBnYy1lZGl0aW5nLWJ1dHRvblwiPjxzcGFuIGNsYXNzPVwiY2FuY2VsLXRleHRcIj5DYW5jZWw8L3NwYW4+PC9kaXY+PGRpdiBjbGFzcz1cImdjLWVkaXRpbmctdXBkYXRlIGdjLWVkaXRpbmctYnV0dG9uXCI+PHNwYW4gY2xhc3M9XCJ1cGRhdGUtdGV4dFwiPlVwZGF0ZTwvc3Bhbj48L2Rpdj48L2Rpdj48L2Rpdj4nKTtcblxuICAgICAgICAgICAgICAgICAgICBlZGl0Q29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBzZWxmLmNvbnRhaW5lcktleURvd25IYW5kbGVyXyk7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgc2VsZi5jb250YWluZXJNb3VzZURvd25IYW5kbGVyXyk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWRpdENvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWRpdFBvcHVwT3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJSZWN0ID0gZG9tVXRpbC5nZXRFbGVtZW50UmVjdChlZGl0Q29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBwYXJzZUludCgod2luZG93LmlubmVyV2lkdGggLSBjb250YWluZXJSZWN0LndpZHRoKSAvIDIgKyB3aW5kb3cucGFnZVhPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9wID0gcGFyc2VJbnQoKHdpbmRvdy5pbm5lckhlaWdodCAtIGNvbnRhaW5lclJlY3QuaGVpZ2h0KSAvIDIgKyB3aW5kb3cucGFnZVlPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBkb21VdGlsLnNldENzcyhlZGl0Q29udGFpbmVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiB0b3BcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlZGl0TW9kZSA9PT0gJ2VkaXRGb3JtJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93SGVhZGVyV2lkdGggPSBncmlkLm9wdGlvbnMucm93SGVhZGVyV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2aWV3cG9ydElubmVyUmVjdCA9IGRvbVV0aWwuZ2V0RWxlbWVudFJlY3QoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZ3JpZC51aWQgKyAnLScgKyBWSUVXUE9SVCArICctaW5uZXInKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwaW5uZWRWaWV3cG9ydElubmVyUmVjdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmhhc0xlZnRQaW5uZWRDb2x1bW5fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaW5uZWRWaWV3cG9ydElubmVyUmVjdCA9IGRvbVV0aWwuZ2V0RWxlbWVudFJlY3QoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZ3JpZC51aWQgKyAnLScgKyBQSU5ORURfVklFV1BPUlQgKyAnLWlubmVyJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJXaWR0aCA9IGdyaWQuZ2V0Q29udGFpbmVySW5mb18oKS5jb250ZW50UmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgZWRpdENvbnRhaW5lciA9IGRvbVV0aWwuY3JlYXRlRWxlbWVudCgnPGRpdiBzdHlsZT1cIm92ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OicgKyAoKHBpbm5lZFZpZXdwb3J0SW5uZXJSZWN0ID8gcGlubmVkVmlld3BvcnRJbm5lclJlY3QubGVmdCA6IHZpZXdwb3J0SW5uZXJSZWN0LmxlZnQpIC0gcm93SGVhZGVyV2lkdGgpICsgJ3B4OycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpZHRoOicgKyBjb250YWluZXJXaWR0aCArXG4gICAgICAgICAgICAgICAgICAgICAgICAncHg7bWF4LXdpZHRoOicgKyBjb250YWluZXJXaWR0aCArICdweDtcIiBpZD1cIicgKyBncmlkLnVpZCArICctZm9ybS1lZGl0aW5nLWFyZWFcIiBjbGFzcz1cImdjLWZvcm0tZWRpdGluZy1hcmVhIGdjLWVkaXRpbmctYXJlYVwiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJnYy1lZGl0aW5nLWNvbnRlbnRcIj4nICsgdGVtcGxhdGUgKyAnPC9kaXY+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImdjLWVkaXRpbmctZm9vdGVyXCI+PGRpdiBjbGFzcz1cImdjLWVkaXRpbmctY2FuY2VsIGdjLWVkaXRpbmctYnV0dG9uXCI+PHNwYW4gY2xhc3M9XCJjYW5jZWwtdGV4dFwiPkNhbmNlbDwvc3Bhbj48L2Rpdj48ZGl2IGNsYXNzPVwiZ2MtZWRpdGluZy11cGRhdGUgZ2MtZWRpdGluZy1idXR0b25cIj48c3BhbiBjbGFzcz1cInVwZGF0ZS10ZXh0XCI+VXBkYXRlPC9zcGFuPjwvZGl2PjwvZGl2PjwvZGl2PicpO1xuXG4gICAgICAgICAgICAgICAgICAgIGVkaXRDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHNlbGYuY29udGFpbmVyS2V5RG93bkhhbmRsZXJfKTtcbiAgICAgICAgICAgICAgICAgICAgZWRpdENvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBzZWxmLmNvbnRhaW5lck1vdXNlRG93bkhhbmRsZXJfKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlZGl0Q29udGFpbmVyKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVuZGVyZWRSb3dzID0gZ3JpZC5sYXN0UmVuZGVyZWRSb3dzXy52aWV3cG9ydDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbmRlcmVkSGVhZGVycyA9IGdyaWQubGFzdFJlbmRlcmVkUm93c18ucm93SGVhZGVyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGlubmVkUmVuZGVyZWRSb3dzID0gZ3JpZC5sYXN0UmVuZGVyZWRSb3dzXy5waW5uZWRWaWV3cG9ydDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSByZW5kZXJlZFJvd3MuaW5kZXhPZihzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3JtSGVpZ2h0ID0gZG9tVXRpbC5nZXRFbGVtZW50UmVjdChlZGl0Q29udGFpbmVyKS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wUm93O1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcEhlYWRlcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBQaW5uZWRSb3c7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdmFpbGFibGVIZWlnaHRfID0gdmlld3BvcnRSZWN0LmhlaWdodCAtIHJvd1JlY3QuaGVpZ2h0IC0gKHJvd1JlY3QudG9wIC0gdmlld3BvcnRSZWN0LnRvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9wRGlzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdmFpbGFibGVIZWlnaHRfIDwgZm9ybUhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vSWYgdGhlcmUgaXMgbm8gZW5vdWdoIHNwYWNlIHRvIGRpc3BsYXksIHNvbWUgcm93cyBtb3ZlIHVwd2FyZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IGZvcm1IZWlnaHQgLSBhdmFpbGFibGVIZWlnaHRfO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPD0gc3RhcnRJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBSb3cgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChyZW5kZXJlZFJvd3NbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wSGVhZGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocmVuZGVyZWRIZWFkZXJzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wRGlzdCA9IE1hdGguY2VpbChwYXJzZUludCh0ZW1wUm93LnN0eWxlLnRvcCkgLSBkaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBSb3cuc3R5bGUudG9wID0gdG9wRGlzdCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBIZWFkZXIuc3R5bGUudG9wID0gdG9wRGlzdCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwaW5uZWRSZW5kZXJlZFJvd3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBQaW5uZWRSb3cgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwaW5uZWRSZW5kZXJlZFJvd3NbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFBpbm5lZFJvdy5zdHlsZS50b3AgPSB0b3BEaXN0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0Q29udGFpbmVyLnN0eWxlLnRvcCA9IE1hdGguY2VpbChyb3dSZWN0LnRvcCArIHJvd1JlY3QuaGVpZ2h0IC0gZGlzdGFuY2UpICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiB0aGVyZSBpcyBlbm91Z2ggc3BhY2UsIHNvbWUgcm93cyBtb3ZlIGRvd25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBzdGFydEluZGV4ICsgMSwgbGVuZ3RoID0gcmVuZGVyZWRSb3dzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBSb3cgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChyZW5kZXJlZFJvd3NbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wSGVhZGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocmVuZGVyZWRIZWFkZXJzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFJvdy5zdHlsZS50b3AgPSAocGFyc2VJbnQodGVtcFJvdy5zdHlsZS50b3ApICsgZm9ybUhlaWdodCkgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wSGVhZGVyLnN0eWxlLnRvcCA9IChwYXJzZUludCh0ZW1wSGVhZGVyLnN0eWxlLnRvcCkgKyBmb3JtSGVpZ2h0KSArICdweCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwaW5uZWRSZW5kZXJlZFJvd3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBQaW5uZWRSb3cgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwaW5uZWRSZW5kZXJlZFJvd3NbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFBpbm5lZFJvdy5zdHlsZS50b3AgPSAocGFyc2VJbnQodGVtcFBpbm5lZFJvdy5zdHlsZS50b3ApICsgZm9ybUhlaWdodCkgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRDb250YWluZXIuc3R5bGUudG9wID0gTWF0aC5jZWlsKHJvd1JlY3QudG9wICsgcm93UmVjdC5oZWlnaHQpICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWVkaXRDb250YWluZXIudGFiSW5kZXggfHwgZWRpdENvbnRhaW5lci50YWJJbmRleCA8IDApIHsgLy9Pbmx5IGZvY3VzYWJsZSBlbGVtZW50IGNhbiBiZSBib3VuZCBrZXlkb3duIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICBlZGl0Q29udGFpbmVyLnRhYkluZGV4ID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzdG9wRWRpdGluZ186IGZ1bmN0aW9uKHZhbHVlQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgZ3JpZCA9IHNlbGYuZ3JpZDtcbiAgICAgICAgICAgICAgICB2YXIgZWRpdE1vZGUgPSBzZWxmLm9wdGlvbnMuZWRpdE1vZGU7XG4gICAgICAgICAgICAgICAgdmFyIHVpZCA9IGdyaWQudWlkO1xuICAgICAgICAgICAgICAgIHZhciBlZGl0aW5nSGFuZGxlciA9IGdyaWQuZWRpdGluZ0hhbmRsZXI7XG4gICAgICAgICAgICAgICAgdmFyIGVkaXRDb250YWluZXI7XG4gICAgICAgICAgICAgICAgaWYgKGVkaXRNb2RlID09PSAnaW5saW5lJykge1xuICAgICAgICAgICAgICAgICAgICBlZGl0Q29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodWlkICsgJy1pbmxpbmUtZWRpdGluZy1hcmVhJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlZGl0TW9kZSA9PT0gJ3BvcHVwJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3ZlcmxheSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5nYy1lZGl0aW5nLW92ZXJsYXknKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQob3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWRpdENvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHVpZCArICctcG9wdXAtZWRpdGluZy1hcmVhJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlZGl0TW9kZSA9PT0gJ2VkaXRGb3JtJykge1xuICAgICAgICAgICAgICAgICAgICBlZGl0Q29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodWlkICsgJy1mb3JtLWVkaXRpbmctYXJlYScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZWRpdENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBlZGl0Q29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHNlbGYuY29udGFpbmVyTW91c2VEb3duSGFuZGxlcl8pO1xuICAgICAgICAgICAgICAgICAgICBlZGl0Q29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBzZWxmLmNvbnRhaW5lcktleURvd25IYW5kbGVyXyk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWRpdENvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYuY29udGFpbmVyS2V5RG93bkhhbmRsZXJfID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbnRhaW5lck1vdXNlRG93bkhhbmRsZXJfID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmIChlZGl0TW9kZSA9PT0gJ2VkaXRGb3JtJykge1xuICAgICAgICAgICAgICAgICAgICBncmlkLmludmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JpZC5kYXRhLmdyb3Vwcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWQudXBkYXRlR3JvdXBJbmZvc18oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkLmludmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVkaXRpbmdIYW5kbGVyLndob2xlQ29sdW1uQ2hhbmdlZF8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZC5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwSW5mbyA9IGVkaXRpbmdIYW5kbGVyLmVkaXRpbmdJbmZvXy5ncm91cEluZm87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWQucmVmcmVzaFJvd18oJ3ZpZXdwb3J0JywgZ3JvdXBJbmZvID8gZ3JvdXBJbmZvLnBhdGggOiBudWxsLCBlZGl0aW5nSGFuZGxlci5lZGl0aW5nSW5mb18ucm93SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldERlZmF1bHRFZGl0b3JUZW1wbGF0ZV86IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBncmlkID0gdGhpcy5ncmlkO1xuICAgICAgICAgICAgICAgIHZhciBlZGl0aW5nSGFuZGxlciA9IGdyaWQuZWRpdGluZ0hhbmRsZXI7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHMgPSBncmlkLmNvbHVtbnM7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSAnPGRpdj4nO1xuICAgICAgICAgICAgICAgIF8uZWFjaChjb2xzLCBmdW5jdGlvbihjb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVkaXRpbmdIYW5kbGVyLmlzQ29sdW1uRWRpdGFibGUoZ3JpZCwgY29sKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgciArPSAnPGRpdj48ZGl2IGNsYXNzPVwiZ2MtZWRpdGluZy10ZW1wbGF0ZS1sYWJlbFwiPjxsYWJlbCBjbGFzcz1cImNvbnRlbnQtdGV4dFwiPicgKyAoY29sLmNhcHRpb24gfHwgY29sLmlkKSArICc8L2xhYmVsPjwvZGl2PjxkaXYgY2xhc3M9XCJnYy1lZGl0aW5nLXRlbXBsYXRlLWZpZWxkXCI+PGlucHV0IHR5cGU9XCInICsgZWRpdGluZ0hhbmRsZXIuZ2V0RWRpdG9yVHlwZShjb2wuZGF0YVR5cGUpICsgJ1wiIGRhdGEtY29sdW1uPVwiJyArIGNvbC5pZCArICdcIj48L2Rpdj48L2Rpdj4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgciArPSAnPC9kaXY+JztcbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW5Eb1N3aXBlXzogZnVuY3Rpb24obW92ZURpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBncmlkID0gdGhpcy5ncmlkO1xuICAgICAgICAgICAgICAgIGlmIChtb3ZlRGlyZWN0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0VG91Y2hBY3Rpb25Db2x1bW47XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGdyaWQuY29sdW1ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sID0gZ3JpZC5jb2x1bW5zW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNUb3VjaEFjdGlvbkNvbHVtbl8oY29sKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RUb3VjaEFjdGlvbkNvbHVtbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3RUb3VjaEFjdGlvbkNvbHVtbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW5TdGFydFN3aXBlXzogZnVuY3Rpb24oZGVsdGFYLCBkZWx0YVkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoZGVsdGFYKSA+PSAxMCAmJiBNYXRoLmFicyhkZWx0YVkpIDw9IDU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gY2xlYXJUZW1wbGF0ZUNhY2hlXygpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHNlbGYuY2FjaGVkVG1wbEZuXyA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLmNhY2hlZEdyb3VwRm9vdGVyRm5fID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYuY2FjaGVkR3JvdXBIZWFkZXJGbl8gPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5jaF8gPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5oYXNMZWZ0UGlubmVkQ29sdW1uXykge1xuICAgICAgICAgICAgICAgIHNlbGYuY2FjaGVkUGluZWRUbXBsRm5fID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzZWxmLnBjaF8gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuaGFzUmlnaHRQaW5uZWRDb2x1bW5fKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWNoZWRSaWdodFBpbmVkVG1wbEZuXyA9IG51bGw7XG4gICAgICAgICAgICAgICAgc2VsZi5wcmNoXyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBoaXRUZXN0R3JvdXBSb3dDb2x1bW5zXyhncm91cFBhdGgsIHJvdywgcm93RWxlbWVudCwgb2Zmc2V0TGVmdCwgb2Zmc2V0VG9wKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYztcbiAgICAgICAgICAgIHZhciBjb2xzID0gc2VsZi5ncmlkLmNvbHVtbnM7XG4gICAgICAgICAgICB2YXIgY29sTGVuID0gY29scy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgY29sRWxlbWVudDtcbiAgICAgICAgICAgIHZhciBhY3Rpb25FbGVtZW50cztcbiAgICAgICAgICAgIHZhciBhY3RJbmRleDtcbiAgICAgICAgICAgIHZhciBhY3RMZW47XG4gICAgICAgICAgICB2YXIgYWN0aW9uO1xuICAgICAgICAgICAgdmFyIGhpdEdyb3VwSW5mbztcbiAgICAgICAgICAgIHZhciBpblRyZWVOb2RlID0gZmFsc2U7XG4gICAgICAgICAgICBvZmZzZXRMZWZ0IC09IChyb3dFbGVtZW50LnN0eWxlLmxlZnQgPyBwYXJzZUZsb2F0KHJvd0VsZW1lbnQuc3R5bGUubGVmdCkgOiAwKTtcbiAgICAgICAgICAgIGZvciAoYyA9IDA7IGMgPCBjb2xMZW47IGMrKykge1xuICAgICAgICAgICAgICAgIGNvbEVsZW1lbnQgPSByb3dFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jJyArIGMpO1xuICAgICAgICAgICAgICAgIGlmIChjb2xFbGVtZW50ICYmIHBvaW50SW5fKG9mZnNldExlZnQsIG9mZnNldFRvcCwgY29sRWxlbWVudCwgcm93RWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVFbGVtZW50ID0gY29sRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZ2MtdHJlZS1ub2RlJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlRWxlbWVudCAmJiBwb2ludEluXy5jYWxsKHNlbGYsIG9mZnNldExlZnQsIG9mZnNldFRvcCwgbm9kZUVsZW1lbnQsIHJvd0VsZW1lbnQsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpblRyZWVOb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbHNbY10uYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25FbGVtZW50cyA9IGNvbEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtYWN0aW9uXScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChhY3RJbmRleCA9IDAsIGFjdExlbiA9IGFjdGlvbkVsZW1lbnRzLmxlbmd0aDsgYWN0SW5kZXggPCBhY3RMZW47IGFjdEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnRJbl8ob2Zmc2V0TGVmdCwgb2Zmc2V0VG9wLCBhY3Rpb25FbGVtZW50c1thY3RJbmRleF0sIHJvd0VsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9IHNlbGYuZ3JpZC5nZXRBY3Rpb25IYW5kbGVyXyhjb2xzW2NdLmlkLCBhY3Rpb25FbGVtZW50c1thY3RJbmRleF0uZ2V0QXR0cmlidXRlKCdkYXRhLWFjdGlvbicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSBoaXRUZXN0VG91Y2hQYW5lbF8oc2VsZi5ncmlkLCBjb2xzLCBvZmZzZXRMZWZ0LCBvZmZzZXRUb3AsIHJvd0VsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGl0R3JvdXBJbmZvID0ge1xuICAgICAgICAgICAgICAgIGFyZWE6IFZJRVdQT1JULFxuICAgICAgICAgICAgICAgIHJvdzogLTEsXG4gICAgICAgICAgICAgICAgY29sdW1uOiAtMSxcbiAgICAgICAgICAgICAgICBncm91cEluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgYXJlYTogR1JPVVBfQ09OVEVOVCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogZ3JvdXBQYXRoLFxuICAgICAgICAgICAgICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjID09PSBjb2xMZW4gPyAtMSA6IGNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGluVHJlZU5vZGUpIHtcbiAgICAgICAgICAgICAgICBoaXRHcm91cEluZm8uZ3JvdXBJbmZvLmluVHJlZU5vZGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFjdGlvbikge1xuICAgICAgICAgICAgICAgIGhpdEdyb3VwSW5mby5ncm91cEluZm8uYWN0aW9uID0gYWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhpdEdyb3VwSW5mbztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFJvd3NSZW5kZXJJbmZvKGFyZWEsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZ3JpZCA9IHNjb3BlLmdyaWQ7XG4gICAgICAgICAgICB2YXIgdWlkID0gZ3JpZC51aWQ7XG4gICAgICAgICAgICB2YXIgY3VyckxheW91dEluZm8gPSBzY29wZS5nZXRMYXlvdXRJbmZvKClbYXJlYV07XG4gICAgICAgICAgICB2YXIgciA9IHt9O1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgcm93SGVpZ2h0ID0gc2NvcGUub3B0aW9ucy5yb3dIZWlnaHQ7XG5cbiAgICAgICAgICAgIHZhciByZW5kZXJSYW5nZSA9IGdldFJlbmRlclJhbmdlLmNhbGwoc2NvcGUsIGFyZWEsIGN1cnJMYXlvdXRJbmZvLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChhcmVhID09PSBWSUVXUE9SVCB8fCBhcmVhID09PSBQSU5ORURfVklFV1BPUlQgfHwgYXJlYSA9PT0gUElOTkVEX1JJR0hUX1ZJRVdQT1JUKSB7XG5cbiAgICAgICAgICAgICAgICByLmxlZnQgPSBhcmVhID09PSBWSUVXUE9SVCA/ICgtb3B0aW9ucy5vZmZzZXRMZWZ0IHx8IDApIDogMDtcbiAgICAgICAgICAgICAgICByLnRvcCA9IC1vcHRpb25zLm9mZnNldFRvcDtcbiAgICAgICAgICAgICAgICByLnJlbmRlcmVkUm93cyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGhhc0dyb3VwXyhncmlkKSkge1xuICAgICAgICAgICAgICAgICAgICByLnJlbmRlcmVkUm93cyA9IHIucmVuZGVyZWRSb3dzLmNvbmNhdChnZXRHcm91cFJlbmRlckluZm9fLmNhbGwoc2NvcGUsIHJlbmRlclJhbmdlLnN0YXJ0LCByZW5kZXJSYW5nZS5lbmQsIHJlbmRlclJhbmdlLm9mZnNldFRvcCwgZmFsc2UsIHRydWUsIGFyZWEpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSByZW5kZXJSYW5nZS5zdGFydDsgaSA8IHJlbmRlclJhbmdlLmVuZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByLnJlbmRlcmVkUm93cy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB1aWQgKyAoYXJlYSA9PT0gUElOTkVEX1ZJRVdQT1JUID8gJy1wcicgOiAoYXJlYSA9PT0gUElOTkVEX1JJR0hUX1ZJRVdQT1JUID8gJy1wcnInIDogJy1yJykpICsgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogcm93SGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZWEgPT09IFJPV19IRUFERVIpIHtcbiAgICAgICAgICAgICAgICByLmxlZnQgPSAwO1xuICAgICAgICAgICAgICAgIHIudG9wID0gLW9wdGlvbnMub2Zmc2V0VG9wO1xuICAgICAgICAgICAgICAgIHIucmVuZGVyZWRSb3dzID0gW107XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzR3JvdXBfKGdyaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHIucmVuZGVyZWRSb3dzID0gci5yZW5kZXJlZFJvd3MuY29uY2F0KGdldEdyb3VwUmVuZGVySW5mb18uY2FsbChzY29wZSwgcmVuZGVyUmFuZ2Uuc3RhcnQsIHJlbmRlclJhbmdlLmVuZCwgcmVuZGVyUmFuZ2Uub2Zmc2V0VG9wLCB0cnVlLCB0cnVlLCBhcmVhKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gcmVuZGVyUmFuZ2Uuc3RhcnQ7IGkgPCByZW5kZXJSYW5nZS5lbmQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgci5yZW5kZXJlZFJvd3MucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogdWlkICsgJy1yaCcgKyBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiByb3dIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJlYSA9PT0gQ09MVU1OX0hFQURFUiB8fCBhcmVhID09PSBQSU5ORURfQ09MVU1OX0hFQURFUiB8fCBhcmVhID09PSBQSU5ORURfUklHSFRfQ09MVU1OX0hFQURFUikge1xuICAgICAgICAgICAgICAgIHIubGVmdCA9IGFyZWEgPT09IENPTFVNTl9IRUFERVIgPyAoLW9wdGlvbnMub2Zmc2V0TGVmdCB8fCAwKSA6IDA7XG4gICAgICAgICAgICAgICAgci50b3AgPSAwO1xuICAgICAgICAgICAgICAgIHIucmVuZGVyZWRSb3dzID0gW107XG5cbiAgICAgICAgICAgICAgICByLnJlbmRlcmVkUm93cy5wdXNoKHtrZXk6IHVpZCArIChhcmVhID09PSBQSU5ORURfQ09MVU1OX0hFQURFUiA/ICctcGNoJyA6IChhcmVhID09PSBQSU5ORURfUklHSFRfQ09MVU1OX0hFQURFUiA/ICctcHJjaCcgOiAnLWNoJykpfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0UmVuZGVyUmFuZ2UoYXJlYSwgY3VyckxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZ3JpZCA9IHNjb3BlLmdyaWQ7XG4gICAgICAgICAgICB2YXIgcmVuZGVyUmFuZ2UgPSB7fTtcbiAgICAgICAgICAgIHZhciBvZmZzZXRUb3AgPSBvcHRpb25zLm9mZnNldFRvcDtcbiAgICAgICAgICAgIHZhciBvZmZzZXRMZWZ0ID0gb3B0aW9ucy5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgdmFyIGlzUm93QXJlYSA9IChhcmVhID09PSBWSUVXUE9SVCB8fCBhcmVhID09PSBQSU5ORURfVklFV1BPUlQgfHwgYXJlYSA9PT0gUElOTkVEX1JJR0hUX1ZJRVdQT1JUIHx8IGFyZWEgPT09IFJPV19IRUFERVIpO1xuXG4gICAgICAgICAgICBpZiAoaXNSb3dBcmVhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0dyb3VwXyhzY29wZS5ncmlkKSkge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJSYW5nZS5zdGFydCA9IGdldEdyb3VwSW5mb0F0Xy5jYWxsKHNjb3BlLCBvZmZzZXRUb3ApO1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJSYW5nZS5lbmQgPSBnZXRHcm91cEluZm9BdF8uY2FsbChzY29wZSwgb2Zmc2V0VG9wICsgY3VyckxheW91dEluZm8uaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyUmFuZ2Uub2Zmc2V0VG9wID0gcmVuZGVyUmFuZ2Uuc3RhcnQuc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRJbmZvID0gZ2V0Um93SW5mb0F0LmNhbGwoc2NvcGUsIHt0b3A6IG9mZnNldFRvcCwgbGVmdDogb2Zmc2V0TGVmdH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kSW5mbyA9IGdldFJvd0luZm9BdC5jYWxsKHNjb3BlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IG9mZnNldFRvcCArIGN1cnJMYXlvdXRJbmZvLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IG9mZnNldExlZnQgKyBjdXJyTGF5b3V0SW5mby53aWR0aFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJSYW5nZS5zdGFydCA9IHN0YXJ0SW5mby5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclJhbmdlLmVuZCA9IGVuZEluZm8gPyAoZW5kSW5mby5pbmRleCArIDEpIDogZ3JpZC5kYXRhLml0ZW1Db3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclJhbmdlLm9mZnNldFRvcCA9IHN0YXJ0SW5mby5zdGFydFBvc2l0aW9uIC0gb2Zmc2V0VG9wO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyUmFuZ2Uuc3RhcnQgPSByZW5kZXJSYW5nZS5lbmQgPSByZW5kZXJSYW5nZS5vZmZzZXRUb3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyUmFuZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVSb3dSZW5kZXJJbmZvKGksIHJvd0hlaWdodCwgYXJlYSwgdWlkKSB7XG4gICAgICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGZvcm1hdHRlZFJvd0l0ZW0gPSBzY29wZS5ncmlkLmdldEZvcm1hdHRlZERhdGFJdGVtKGkpO1xuICAgICAgICAgICAgdmFyIHNvdXJjZUl0ZW1JbmRleCA9IHNjb3BlLmdyaWQuZGF0YS50b1NvdXJjZVJvdyhpKTtcbiAgICAgICAgICAgIC8vdmFyIHNvdXJjZUl0ZW1JbmRleCA9IGk7XG4gICAgICAgICAgICB2YXIga2V5UHJlZml4ID0gKGFyZWEgPT09IFZJRVdQT1JUKSA/ICctcicgOiAoYXJlYSA9PT0gUElOTkVEX1ZJRVdQT1JUID8gJy1wcicgOiAnLXBycicpO1xuICAgICAgICAgICAgdmFyIGZuID0gYXJlYSA9PT0gUElOTkVEX1ZJRVdQT1JUID8gc2NvcGUuY2FjaGVkUGluZWRUbXBsRm5fIDogKGFyZWEgPT09IFBJTk5FRF9SSUdIVF9WSUVXUE9SVCA/IHNjb3BlLmNhY2hlZFJpZ2h0UGluZWRUbXBsRm5fIDogc2NvcGUuY2FjaGVkVG1wbEZuXyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGtleTogdWlkICsga2V5UHJlZml4ICsgaSxcbiAgICAgICAgICAgICAgICBpc1Jvd1JvbGU6IHRydWUsXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IHNjb3BlLnNlbGVjdGVkUm93c18gJiYgc2NvcGUuc2VsZWN0ZWRSb3dzXy5pbmRleE9mKHNvdXJjZUl0ZW1JbmRleCkgIT09IC0xLFxuICAgICAgICAgICAgICAgIHJlbmRlckluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPOiByZW1vdmUgaW5kZXgsZXZhbHVhdGUgdGhlIGNzc0NsYXNzcywgd2h5IGFsd2F5cyBldmVuP1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgICAgICAgICAgICAgY3NzQ2xhc3M6ICdnYy1yb3cgcicgKyBpICsgJyBldmVuJyxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogaSAqIHJvd0hlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogcm93SGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkSFRNTDogKGZuIHx8IHNjb3BlLmdldFJvd1RlbXBsYXRlKGFyZWEpKShmb3JtYXR0ZWRSb3dJdGVtKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRUb29sUGFuZWxXaWR0aF8oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIXNlbGYub3B0aW9ucy5zaG93VG9vbFBhbmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnRvb2xQYW5lbEluZm9fID0gc2VsZi50b29sUGFuZWxJbmZvXyB8fCBnZXRUb29sUGFuZWxJbmZvXygpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYudG9vbFBhbmVsSW5mb18ud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRUb29sUGFuZWxQYWRkaW5nXygpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGlmICghc2VsZi5vcHRpb25zLnNob3dUb29sUGFuZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYudG9vbFBhbmVsSW5mb18gPSBzZWxmLnRvb2xQYW5lbEluZm9fIHx8IGdldFRvb2xQYW5lbEluZm9fKCk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi50b29sUGFuZWxJbmZvXy5wYWRkaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0VG9vbFBhbmVsSW5mb18oKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICB2YXIgZGl2ID0gJzxkaXYgc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTt0b3A6LTEwMDAwcHg7bGVmdDotMTAwMDBweDt3aWR0aDo1MDAwcHg7aGVpZ2h0OjUwMDBweDtcIj4nO1xuICAgICAgICAgICAgZGl2ICs9ICc8ZGl2IGNsYXNzPVwiZ2MtdG9vbC1wYW5lbC1jb250YWluZXJcIj48L2Rpdj48L2Rpdj4nO1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkb21VdGlsLmNyZWF0ZUVsZW1lbnQoZGl2KTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZWxlbWVudC5maXJzdENoaWxkO1xuICAgICAgICAgICAgcmVzdWx0LndpZHRoID0gcGFyc2VJbnQoZG9tVXRpbC5nZXRTdHlsZVZhbHVlKGNvbnRhaW5lciwgJ3dpZHRoJykpIHx8IDIwMDtcbiAgICAgICAgICAgIHJlc3VsdC5wYWRkaW5nID0gKHBhcnNlSW50KGRvbVV0aWwuZ2V0U3R5bGVWYWx1ZShjb250YWluZXIsICdwYWRkaW5nLXRvcCcpKSB8fCAwKSArIChwYXJzZUludChkb21VdGlsLmdldFN0eWxlVmFsdWUoY29udGFpbmVyLCAncGFkZGluZy1ib3R0b20nKSkgfHwgMCk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbnNvbGlkYXRlQ29sdW1uV2lkdGhfKHBpbm5lZCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHRtcGwgPSBnZXRVc2VyRGVmaW5lZFRlbXBsYXRlXy5jYWxsKHNlbGYsIHBpbm5lZCk7XG4gICAgICAgICAgICBpZiAodG1wbCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXYgPSAnPGRpdiBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlO3RvcDotMTAwMDBweDtsZWZ0Oi0xMDAwMHB4O3dpZHRoOjUwMDBweDtoZWlnaHQ6NTAwMHB4O1wiPic7XG4gICAgICAgICAgICAgICAgZGl2ICs9IHRtcGwgKyAnPC9kaXY+JztcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGRvbVV0aWwuY3JlYXRlRWxlbWVudChkaXYpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgY29sRWxlbTtcbiAgICAgICAgICAgICAgICBfLmVhY2goc2VsZi5ncmlkLmNvbHVtbnMsIGZ1bmN0aW9uKGNvbCkge1xuICAgICAgICAgICAgICAgICAgICBjb2xFbGVtID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jb2x1bW49XCInICsgY29sLmlkICsgJ1wiXScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sRWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sLnZpc2libGVXaWR0aCA9IGRvbVV0aWwuZ2V0RWxlbWVudFJlY3QoY29sRWxlbSkud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRVc2VyRGVmaW5lZFRlbXBsYXRlXyhwaW5uZWQpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93VG1wbDtcbiAgICAgICAgICAgICAgICBpZiAocGlubmVkID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93VG1wbCA9IG9wdGlvbnMucGlubmVkTGVmdFJvd1RlbXBsYXRlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGlubmVkID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1RtcGwgPSBvcHRpb25zLnBpbm5lZFJpZ2h0Um93VGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm93VG1wbCA9IG9wdGlvbnMucm93VGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb3dUbXBsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnY1V0aWxzLmlzU3RyaW5nKHJvd1RtcGwpICYmIHJvd1RtcGwubGVuZ3RoID4gMSAmJiByb3dUbXBsWzBdID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXBsRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHJvd1RtcGwuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRtcGxFbGVtZW50LmlubmVySFRNTDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByb3dUbXBsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRSYXdSb3dUZW1wbGF0ZV8oaXNDb2x1bW5IZWFkZXIsIGFyZWEpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBwaW5uZWQgPSAnbm9uZSc7XG4gICAgICAgICAgICBpZiAoYXJlYSA9PT0gUElOTkVEX1ZJRVdQT1JUIHx8IGFyZWEgPT09IFBJTk5FRF9DT0xVTU5fSEVBREVSKSB7XG4gICAgICAgICAgICAgICAgcGlubmVkID0gJ2xlZnQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmVhID09PSBQSU5ORURfUklHSFRfVklFV1BPUlQgfHwgYXJlYSA9PT0gUElOTkVEX1JJR0hUX0NPTFVNTl9IRUFERVIpIHtcbiAgICAgICAgICAgICAgICBwaW5uZWQgPSAncmlnaHQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdldFVzZXJEZWZpbmVkVGVtcGxhdGVfLmNhbGwoc2VsZiwgcGlubmVkKSB8fCAoaXNDb2x1bW5IZWFkZXIgPyBnZXREZWZhdWx0UmF3Q29sdW1uSGVhZGVyVGVtcGxhdGVfLmNhbGwoc2VsZiwgcGlubmVkKSA6IGdldERlZmF1bHRSYXdSb3dUZW1wbGF0ZV8uY2FsbChzZWxmLCBwaW5uZWQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZpbHRlckFjdGlvbkNvbHVtbih0ZW1wbGF0ZVN0ciwgYXJlYSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGdyaWQgPSBzZWxmLmdyaWQ7XG4gICAgICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gdGVtcGxhdGVTdHI7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGRpdi5jaGlsZHJlblswXTtcbiAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uQ29scyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtY29sdW1uXScpO1xuICAgICAgICAgICAgdmFyIGNvbElkO1xuICAgICAgICAgICAgdmFyIGNvbDtcbiAgICAgICAgICAgIHZhciBwaW5uZWQgPSAnbm9uZSc7XG4gICAgICAgICAgICBpZiAoYXJlYSA9PT0gUElOTkVEX1ZJRVdQT1JUIHx8IGFyZWEgPT09IFBJTk5FRF9DT0xVTU5fSEVBREVSKSB7XG4gICAgICAgICAgICAgICAgcGlubmVkID0gJ2xlZnQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmVhID09PSBQSU5ORURfUklHSFRfVklFV1BPUlQgfHwgYXJlYSA9PT0gUElOTkVEX1JJR0hUX0NPTFVNTl9IRUFERVIpIHtcbiAgICAgICAgICAgICAgICBwaW5uZWQgPSAncmlnaHQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXy5lYWNoKGFubm90YXRpb25Db2xzLCBmdW5jdGlvbihhbm5vdGF0aW9uQ29sKSB7XG4gICAgICAgICAgICAgICAgY29sSWQgPSBhbm5vdGF0aW9uQ29sLmdldEF0dHJpYnV0ZSgnZGF0YS1jb2x1bW4nKTtcbiAgICAgICAgICAgICAgICBjb2wgPSBncmlkLmdldENvbEJ5SWRfKGNvbElkKTtcbiAgICAgICAgICAgICAgICAvL2ZpbHRlciB0b3VjaCBhY3Rpb24gY29sdW1uXG4gICAgICAgICAgICAgICAgaWYgKGlzVG91Y2hBY3Rpb25Db2x1bW5fKGNvbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbkNvbC5zdHlsZS5zZXRQcm9wZXJ0eSgnZGlzcGxheScsICdub25lJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vZmlsdGVyIGdyb3VwIGNvbHVtbnNcbiAgICAgICAgICAgICAgICBpZiAoIWdyaWQuaXNDb2xWaXNpYmxlXyhjb2wsIHBpbm5lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbkNvbC5zdHlsZS5zZXRQcm9wZXJ0eSgnZGlzcGxheScsICdub25lJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGRvbVV0aWwuZ2V0RWxlbWVudElubmVyVGV4dChkaXYpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0RGVmYXVsdFJhd1Jvd1RlbXBsYXRlXyhwaW5uZWQpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBncmlkID0gc2VsZi5ncmlkO1xuICAgICAgICAgICAgdmFyIGNvbHMgPSBncmlkLmNvbHVtbnM7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IDA7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2VsZi5vcHRpb25zLnJvd0hlaWdodDtcbiAgICAgICAgICAgIHZhciByID0gJzxkaXYgc3R5bGU9XCJoZWlnaHQ6JyArIGhlaWdodCArICdweDtcIj4nO1xuICAgICAgICAgICAgXy5lYWNoKGNvbHMsIGZ1bmN0aW9uKGNvbCkge1xuICAgICAgICAgICAgICAgIGlmIChncmlkLmlzQ29sVmlzaWJsZV8oY29sLCBwaW5uZWQpICYmICgocGlubmVkID09PSAnbm9uZScgJiYgY29sLnBpbm5lZCA9PT0gJ25vbmUnKSB8fCAoKHBpbm5lZCA9PT0gJ2xlZnQnIHx8IHBpbm5lZCA9PT0gJ3JpZ2h0JykgJiYgY29sLnBpbm5lZCA9PT0gcGlubmVkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgciArPSAnPGRpdiBjbGFzcz1cImdjLWNvbHVtblwiIHN0eWxlPVwiaGVpZ2h0OicgKyBoZWlnaHQgKyAncHg7d2lkdGg6JyArIGNvbC52aXNpYmxlV2lkdGggKyAncHg7bGVmdDonICsgbGVmdCArICdweDsnICsgKGNvbC52aXNpYmxlID8gJycgOiAnZGlzcGxheTpub25lJykgKyAnXCIgZGF0YS1jb2x1bW49XCInICsgY29sLmlkICsgJ1wiPjwvZGl2Pic7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgKz0gY29sLnZpc2libGVXaWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHIgKz0gJzwvZGl2Pic7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldERlZmF1bHRSYXdDb2x1bW5IZWFkZXJUZW1wbGF0ZV8ocGlubmVkKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY29scyA9IHNlbGYuZ3JpZC5jb2x1bW5zQ29uZmlnXztcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gMDtcbiAgICAgICAgICAgIHZhciBiYXNlSGVpZ2h0ID0gc2VsZi5vcHRpb25zLmNvbEhlYWRlckhlaWdodDtcbiAgICAgICAgICAgIHZhciBtYXhMZXZlbCA9IGdldENvbHVtbkhlYWRlckxldmVsXyhjb2xzKTtcbiAgICAgICAgICAgIHZhciByID0gJzxkaXYgc3R5bGU9XCJoZWlnaHQ6JyArIGJhc2VIZWlnaHQgKiBtYXhMZXZlbCArICdweDtcIj4nO1xuICAgICAgICAgICAgdmFyIGluZm87XG5cbiAgICAgICAgICAgIF8uZWFjaChjb2xzLCBmdW5jdGlvbihjb2wpIHtcbiAgICAgICAgICAgICAgICBpbmZvID0gZ2V0R3JvdXBDb2x1bW5IZWFkZXJSZW5kZXJJbmZvXy5jYWxsKHNlbGYsIGNvbCwgbWF4TGV2ZWwsIGJhc2VIZWlnaHQsIGxlZnQsIHBpbm5lZCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgciArPSBpbmZvLmh0bWw7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgKz0gaW5mby53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHIgKz0gJzwvZGl2Pic7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEdyb3VwQ29sdW1uSGVhZGVyUmVuZGVySW5mb18oY29sLCBwYXJlbnRHcm91cExldmVsLCBiYXNlSGVpZ2h0LCBsZWZ0LCBwaW5uZWQpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBncmlkID0gc2VsZi5ncmlkO1xuICAgICAgICAgICAgdmFyIGxldmVsID0gZ2V0Q29sdW1uSGVhZGVyTGV2ZWxfKFtjb2xdKTtcbiAgICAgICAgICAgIHZhciBjb2xUcmVlID0gZ3JpZC5jb2xUcmVlXztcbiAgICAgICAgICAgIHZhciB3aWR0aDtcbiAgICAgICAgICAgIHZhciByO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgbGVuO1xuICAgICAgICAgICAgdmFyIGluZm87XG4gICAgICAgICAgICB2YXIgY29sdW1ucztcbiAgICAgICAgICAgIHZhciBpbm5lckxlZnQ7XG4gICAgICAgICAgICB2YXIgY29sRGVmO1xuICAgICAgICAgICAgaWYgKGxldmVsID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyaWQuaXNDb2xWaXNpYmxlXyhjb2wsIHBpbm5lZCkgJiYgKChwaW5uZWQgPT09ICdub25lJyAmJiBjb2wucGlubmVkID09PSAnbm9uZScpIHx8ICgocGlubmVkID09PSAnbGVmdCcgfHwgcGlubmVkID09PSAncmlnaHQnKSAmJiBjb2wucGlubmVkID09PSBwaW5uZWQpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDogJzxkaXYgY2xhc3M9XCJnYy1jb2x1bW5cIiBzdHlsZT1cImhlaWdodDonICsgKHBhcmVudEdyb3VwTGV2ZWwgLSBsZXZlbCArIDEpICogYmFzZUhlaWdodCArICdweDt3aWR0aDonICsgY29sLnZpc2libGVXaWR0aCArICdweDttYXgtd2lkdGg6JyArIGNvbC52aXNpYmxlV2lkdGggKyAncHg7bGVmdDonICsgbGVmdCArICdweDsnICsgKGNvbC52aXNpYmxlID8gJycgOiAnZGlzcGxheTpub25lJykgKyAnXCIgZGF0YS1jb2x1bW49XCInICsgY29sLmlkICsgJ1wiPjwvZGl2PicsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogY29sLnZpc2libGVXaWR0aFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sdW1ucyA9IGNvbC5jb2x1bW5zO1xuICAgICAgICAgICAgICAgIGlmICgocGlubmVkICE9PSAnbm9uZScgJiYgaGFzUGlubmVkQ29sdW1uXyhjb2x1bW5zKSkgfHwgcGlubmVkID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBnZXRHcm91cENvbHVtbkhlYWRlcldpZHRoXy5jYWxsKHNlbGYsIGNvbHVtbnMsIHBpbm5lZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aWR0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbERlZiA9IGNvbFRyZWVbY29sLmNhcHRpb25dO1xuICAgICAgICAgICAgICAgICAgICAgICAgciA9ICc8ZGl2IHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7IGhlaWdodDonICsgbGV2ZWwgKiBiYXNlSGVpZ2h0ICsgJ3B4O3dpZHRoOicgKyB3aWR0aCArICdweDtsZWZ0OicgKyBsZWZ0ICsgJ3B4O1wiIGRhdGEtY29sdW1uLWdyb3VwPjxkaXYgY2xhc3M9XCJnYy1jb2x1bW4taGVhZGVyLWNlbGxcIiBzdHlsZT1cImhlaWdodDonICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocGFyZW50R3JvdXBMZXZlbCAtIGxldmVsICsgMSkgKiBiYXNlSGVpZ2h0ICsgJ3B4O3dpZHRoOicgKyB3aWR0aCArICdweDttYXgtd2lkdGg6JyArIHdpZHRoICsgJ3B4O1wiIGRhdGEtY29sdW1uLWdyb3VwLWhlYWRlcj1cIicgKyBjb2wuY2FwdGlvbiArICdcIj48c3Bhbj4nICsgY29sLmNhcHRpb24gKyAnPC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgocGlubmVkICE9PSAnbm9uZScgPyAocGlubmVkID09PSAnbGVmdCcgPyBjb2xEZWYucGlubmVkU3RhdHVzLnNob3dJY29uIDogY29sRGVmLnBpbm5lZFJpZ2h0U3RhdHVzLnNob3dJY29uKSA6IGNvbERlZi5zdGF0dXMuc2hvd0ljb24pID8gJyA8c3BhbiBjbGFzcz1cImdjLWljb24gZ2MtaGVhZGVyLXRvZ2dsZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKChwaW5uZWQgIT09ICdub25lJyA/IChwaW5uZWQgPT09ICdsZWZ0JyA/IGNvbERlZi5waW5uZWRTdGF0dXMuaXNDb2xsYXBzZWQgOiBjb2xEZWYucGlubmVkUmlnaHRTdGF0dXMuaXNDb2xsYXBzZWQpIDogY29sRGVmLnN0YXR1cy5pc0NvbGxhcHNlZCkpID8gJ2NvbGxhcHNlZCcgOiAnZXhwYW5kJykgKyAnXCI+PC9zcGFuPicgOiAnJykgKyAnPC9kaXY+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyTGVmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb2wuY29sdW1ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8gPSBnZXRHcm91cENvbHVtbkhlYWRlclJlbmRlckluZm9fLmNhbGwoc2VsZiwgY29sdW1uc1tpXSwgbGV2ZWwgLSAxLCBiYXNlSGVpZ2h0LCBpbm5lckxlZnQsIHBpbm5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciArPSBpbmZvLmh0bWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyTGVmdCArPSBpbmZvLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHIgKz0gJzwvZGl2Pic7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaGFzUGlubmVkQ29sdW1uXyhjb2xzKSB7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIHZhciBsZW47XG4gICAgICAgICAgICB2YXIgY29sO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY29scy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbCA9IGNvbHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNvbC5jb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGhhc1Bpbm5lZENvbHVtbl8oY29sLmNvbHVtbnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IChjb2wucGlubmVkID09PSAnbGVmdCcgfHwgY29sLnBpbm5lZCA9PT0gJ3JpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEdyb3VwQ29sdW1uSGVhZGVyV2lkdGhfKGNvbHMsIHBpbm5lZCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgbGVuO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgICAgICAgIHZhciBjb2w7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb2xzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29sID0gY29sc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoY29sLmNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggKz0gZ2V0R3JvdXBDb2x1bW5IZWFkZXJXaWR0aF8uY2FsbChzZWxmLCBjb2wuY29sdW1ucywgcGlubmVkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYuZ3JpZC5pc0NvbFZpc2libGVfKGNvbCwgcGlubmVkKSAmJiBjb2wucGlubmVkID09PSBwaW5uZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggKz0gY29sLnZpc2libGVXaWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRDb2x1bW5IZWFkZXJMZXZlbF8oY29scykge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgbGVuO1xuICAgICAgICAgICAgdmFyIG1heCA9IDA7XG4gICAgICAgICAgICB2YXIgY29sO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY29scy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbCA9IGNvbHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFjb2wuaGFzT3duUHJvcGVydHkoJ2NvbHVtbnMnKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgMSArIGdldENvbHVtbkhlYWRlckxldmVsXyhjb2wuY29sdW1ucykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXg7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc1RvdWNoQWN0aW9uQ29sdW1uXyhjb2wpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2wuYWN0aW9uICYmIGNvbC5zd2lwZURpcmVjdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFRvb2xQYW5lbFJlbmRlckluZm9fKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGdyaWQgPSBzZWxmLmdyaWQ7XG4gICAgICAgICAgICB2YXIgY29sdW1ucyA9IGdyaWQuY29sdW1ucztcbiAgICAgICAgICAgIHZhciBwYWRkaW5nID0gZ2V0VG9vbFBhbmVsUGFkZGluZ18uY2FsbChzZWxmKTtcblxuICAgICAgICAgICAgdmFyIHRvdGFsSGVpZ2h0ID0gc2VsZi5nZXRMYXlvdXRJbmZvKClbVE9PTFBBTkVMXS5oZWlnaHQgLSBwYWRkaW5nO1xuXG4gICAgICAgICAgICB2YXIgY29sU3RyID0gJzxkaXYgY2xhc3M9XCJjb2x1bW4tbGlzdFwiIHN0eWxlPVwiaGVpZ2h0OicgKyAodG90YWxIZWlnaHQgKiAwLjYgLSAyMCkgKyAncHg7XCI+PGRpdj4nOyAvLzIwIHRpdGxlIGhlaWdodFxuICAgICAgICAgICAgXy5lYWNoKGNvbHVtbnMsIGZ1bmN0aW9uKGNvbCkge1xuICAgICAgICAgICAgICAgIC8vY29sU3RyICs9ICc8ZGl2IGNsYXNzPVwiY29sdW1uLWxpc3QtaXRlbVwiPjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cIicgKyBjb2wuaWQgKyAnXCInICsgKGNvbC52aXNpYmxlID8gJyBjaGVja2VkJyA6ICcnKSArICcvPjxsYWJlbD4nICsgJyAnICsgY29sLmNhcHRpb24gKyAnPC9kaXY+JztcbiAgICAgICAgICAgICAgICBjb2xTdHIgKz0gJzxkaXYgZGF0YS1jb2wtaWQ9XCInICsgY29sLmlkICsgJ1wiIGNsYXNzPVwiY29sdW1uLWxpc3QtaXRlbScgKyAoY29sLnZpc2libGUgPyAnJyA6ICcgbm90LXZpc2libGUnKSArICdcIj48ZGl2IGNsYXNzPVwiY2hlY2tcIj48c3BhbiBjbGFzcz1cImdjLWljb24gc2VsZWN0LWljb24nICsgKGNvbC52aXNpYmxlID8gJycgOiAnIG5vdC12aXNpYmxlJykgKyAnXCI+PC9zcGFuPjwvZGl2PjxzcGFuIGNsYXNzPVwiY29udGVudFwiPicgK1xuICAgICAgICAgICAgICAgICAgICBjb2wuY2FwdGlvbiArICc8L3NwYW4+PC9kaXY+JztcblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb2xTdHIgKz0gJzwvZGl2PjwvZGl2Pic7XG4gICAgICAgICAgICB2YXIgaHRtbCA9ICc8ZGl2IHN0eWxlPVwidGV4dC1hbGlnbjpjZW50ZXI7IGhlaWdodDoyMHB4O1wiPkNvbHVtbnMnO1xuICAgICAgICAgICAgaWYgKCFzZWxmLm9wdGlvbnMucm93VGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8c3BhbiBjbGFzcz1cImdjLWljb24gaW5zZXJ0LWNvbHVtbi1pY29uXCI+PHNwYW4+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGh0bWwgKz0gJzwvZGl2PicgKyBjb2xTdHI7XG5cbiAgICAgICAgICAgIGh0bWwgKz0gJzxkaXYgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlcjsgaGVpZ2h0OjIwcHg7XCI+R3JvdXAgQ29sdW1ucyc7XG4gICAgICAgICAgICBjb2xTdHIgPSAnPGRpdiBjbGFzcz1cImdyb3VwLWxpc3RcIiBzdHlsZT1cImhlaWdodDonICsgKHRvdGFsSGVpZ2h0ICogMC40IC0gMjApICsgJ3B4O1wiPjxkaXY+JzsgLy8yMCB0aXRsZSBoZWlnaHRcbiAgICAgICAgICAgIHZhciBncm91cERlc2NyaXB0b3JzID0gZ3JpZC5kYXRhLmdyb3VwRGVzY3JpcHRvcnM7XG4gICAgICAgICAgICB2YXIgbGVuID0gZ3JvdXBEZXNjcmlwdG9ycy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgY29sO1xuICAgICAgICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICAgICAgICBfLmVhY2goZ3JvdXBEZXNjcmlwdG9ycywgZnVuY3Rpb24oZGVzcCkge1xuICAgICAgICAgICAgICAgICAgICBjb2wgPSBncmlkLmdldENvbEJ5SWRfKGRlc3AuZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICBjb2xTdHIgKz0gJzxkaXYgZGF0YS1ncm91cC1pZD1cIicgKyBjb2wuaWQgKyAnXCIgY2xhc3M9XCJncm91cC1saXN0LWl0ZW1cIj48c3BhbiBjbGFzcz1cImNvbnRlbnRcIj4nICsgY29sLmNhcHRpb24gKyAnPC9zcGFuPjxkaXYgY2xhc3M9XCJyZW1vdmVcIj48c3BhbiBjbGFzcz1cImdjLWljb24gcmVtb3ZlLWljb25cIj48L3NwYW4+PC9kaXY+PC9kaXY+JztcblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2xTdHIgKz0gJzxkaXY+PHNwYW4gY2xhc3M9XCJncm91cC1jbHVlXCI+RHJhZyBjb2x1bW5zIGZyb20gYWJvdmUgdG8gY3JlYXRlIGdyb3Vwczwvc3Bhbj48L2Rpdj4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29sU3RyICs9ICc8L2Rpdj48L2Rpdj4nO1xuICAgICAgICAgICAgaHRtbCArPSAnPC9kaXY+JyArIGNvbFN0cjtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAvL2tleTogc2VsZi5ncmlkLnVpZCArICctdG9vbC1wYW5lbCcsXG4gICAgICAgICAgICAgICAgaXNSb3dSb2xlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZW5kZXJJbmZvOiB7XG4gICAgICAgICAgICAgICAgICAgIGNzc0NsYXNzOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogJzEwMCUnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkSFRNTDogaHRtbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRSZW5kZXJlZENvbHVtbkhlYWRlckluZm9fKGFyZWEpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoYXJlYSA9PT0gQ09MVU1OX0hFQURFUikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNlbGYuY2hfO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmVhID09PSBQSU5ORURfQ09MVU1OX0hFQURFUikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNlbGYucGNoXztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc2VsZi5wcmNoXztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZ2V0VGVtcGxhdGVfLmNhbGwodGhpcywgdHJ1ZSwgYXJlYSk7XG4gICAgICAgICAgICAgICAgaWYgKGFyZWEgPT09IFBJTk5FRF9DT0xVTU5fSEVBREVSKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGNoXyA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZWEgPT09IFBJTk5FRF9SSUdIVF9DT0xVTU5fSEVBREVSKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucHJjaF8gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jaF8gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBrZXk6IHNlbGYuZ3JpZC51aWQgKyAoYXJlYSA9PT0gUElOTkVEX0NPTFVNTl9IRUFERVIgPyAnLXBjaCcgOiAoYXJlYSA9PT0gUElOTkVEX1JJR0hUX0NPTFVNTl9IRUFERVIgPyAnLXByY2gnIDogJy1jaCcpKSxcbiAgICAgICAgICAgICAgICBpc1Jvd1JvbGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlbmRlckluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgY3NzQ2xhc3M6ICdnYy1jb2x1bW4taGVhZGVyIGNoJyxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRIVE1MOiByZXN1bHRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0UmVuZGVyZWRHcm91cERyYWdQYW5lbEluZm9fKGdlbmVyYXRlSWQpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBncmlkID0gc2VsZi5ncmlkO1xuICAgICAgICAgICAgdmFyIGdyb3VwRGVzY3JpcHRvcnMgPSBncmlkLmRhdGEuZ3JvdXBEZXNjcmlwdG9ycztcbiAgICAgICAgICAgIHZhciBpZFByZWZpeCA9IHNlbGYuZ3JpZC51aWQgKyAnLWdyb3VwaW5nLWluZGljYXRvci0nO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgY29sSWQ7XG4gICAgICAgICAgICB2YXIgY29sO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGdyb3VwRGVzY3JpcHRvcnMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHN0ciA9ICcnO1xuICAgICAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0ciArPSAnPGRpdiBjbGFzcz1cImdjLWdyb3VwaW5nLWhlbHAtY29udGVudFwiPicgKyBHUk9VUF9EUkFHX1RFWFQgKyAnPC9kaXY+JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbElkID0gZ3JvdXBEZXNjcmlwdG9yc1tpXS5maWVsZDtcbiAgICAgICAgICAgICAgICAgICAgY29sID0gZ3JpZC5nZXRDb2xCeUlkXyhjb2xJZCk7XG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSAoJzxkaXYnICsgKGdlbmVyYXRlSWQgPyAoJyBpZD1cIicgKyBpZFByZWZpeCArIGNvbElkICsgJ1wiJykgOiAnJykgKyAnIGNsYXNzPVwiZ2MtZ3JvdXBpbmctaW5kaWNhdG9yXCI+PHNwYW4gY2xhc3M9XCJnYy1ncm91cGluZy10aXRsZVwiPicgKyAoY29sID8gY29sLmNhcHRpb24gOiAnJykgKyAnPC9zcGFuPjxzcGFuIGNsYXNzPVwiZ2MtaWNvbiBnYy1pY29uLWdyb3VwaW5nLWRlbGV0ZVwiPjwvc3Bhbj48L2Rpdj4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0R3JvdXBEcmFnUGFuZWxIZWlnaHRfKCkge1xuICAgICAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgICAgICAgICAgLy9UT0RPOiBhcHBlbmRDaGlsZC9yZW1vdmVDaGlsZCB0d2ljZSBpcyB0b28gZXhwZW5zaXZlLCBpbXByb3ZlIGl0IGxhdGVyLlxuICAgICAgICAgICAgdmFyIG1heFdpZHRoID0gc2NvcGUuZ3JpZC5nZXRDb250YWluZXJJbmZvXygpLmNvbnRlbnRSZWN0LndpZHRoO1xuICAgICAgICAgICAgdmFyIGdyb3VwRHJhZ1BhbmVsRWxlbWVudCA9IGRvbVV0aWwuY3JlYXRlRWxlbWVudCgnPGRpdiBjbGFzcz1cImdjLWdyb3VwaW5nLWNvbnRhaW5lclwiPjxkaXY+Jyk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGdyb3VwRHJhZ1BhbmVsRWxlbWVudCk7XG4gICAgICAgICAgICB2YXIgZ3JvdXBEcmFnUGFuZWxFbGVtZW50U3R5bGUgPSBkb21VdGlsLmdldFN0eWxlKGdyb3VwRHJhZ1BhbmVsRWxlbWVudCk7XG4gICAgICAgICAgICB2YXIgcGFkZGluZ0xlZnQgPSBwYXJzZVN0eWxlUHJvcGVydHlWYWx1ZV8oZ3JvdXBEcmFnUGFuZWxFbGVtZW50U3R5bGUsIFBBRERJTkdfTEVGVCk7XG4gICAgICAgICAgICB2YXIgcGFkZGluZ1JpZ2h0ID0gcGFyc2VTdHlsZVByb3BlcnR5VmFsdWVfKGdyb3VwRHJhZ1BhbmVsRWxlbWVudFN0eWxlLCBQQURESU5HX1JJR0hUKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZ3JvdXBEcmFnUGFuZWxFbGVtZW50KTtcblxuICAgICAgICAgICAgbWF4V2lkdGggPSBtYXhXaWR0aCAtIHBhZGRpbmdMZWZ0IC0gcGFkZGluZ1JpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgZGl2ID0gJzxkaXYgY2xhc3M9XCJnYy1ncm91cGluZy1jb250YWluZXJcIj48ZGl2IHN0eWxlPVwid2lkdGg6JyArIG1heFdpZHRoICsgJ3B4O1wiPicgKyBnZXRSZW5kZXJlZEdyb3VwRHJhZ1BhbmVsSW5mb18uY2FsbChzY29wZSwgZmFsc2UpICsgJzwvZGl2PjwvZGl2Pic7XG5cbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9tVXRpbC5jcmVhdGVFbGVtZW50KGRpdik7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRHcm91cERyYWdQYW5lbExheW91dEluZm9fKCkge1xuICAgICAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICAgICAgICAgIGlmIChzY29wZS5ncm91RHJhZ1BhbmVsTGF5b3V0SW5mb18pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZ3JvdURyYWdQYW5lbExheW91dEluZm9fO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGdyaWQgPSBzY29wZS5ncmlkO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gZ3JpZC5nZXRDb250YWluZXJJbmZvXygpLmNvbnRlbnRSZWN0LndpZHRoO1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBzY29wZS5vcHRpb25zO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dHcm91cGluZykge1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBnZXRHcm91cERyYWdQYW5lbEhlaWdodF8uY2FsbChzY29wZSk7XG4gICAgICAgICAgICAgICAgc2NvcGUuZ3JvdURyYWdQYW5lbExheW91dEluZm9fID0ge1xuICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRXaWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRIZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjb3BlLmdyb3VEcmFnUGFuZWxMYXlvdXRJbmZvXyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50V2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRIZWlnaHQ6IDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc2NvcGUuZ3JvdURyYWdQYW5lbExheW91dEluZm9fO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0UGlubmVkQ29sdW1uSGVhZGVyVmlld3BvcnRMYXlvdXRJbmZvXyhwaW5uZWQpIHtcbiAgICAgICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHNjb3BlLm9wdGlvbnM7XG4gICAgICAgICAgICB2YXIgZ3JvdXBEcmFnUGFuZWxMYXlvdXRJbmZvID0gZ2V0R3JvdXBEcmFnUGFuZWxMYXlvdXRJbmZvXy5jYWxsKHNjb3BlKTtcbiAgICAgICAgICAgIHZhciB2aWV3cG9ydExheW91dEluZm8gPSBnZXRQaW5uZWRWaWV3cG9ydExheW91dEluZm9fLmNhbGwoc2NvcGUsIHBpbm5lZCk7XG4gICAgICAgICAgICB2YXIgY29sSGVhZGVySGVpZ2h0ID0gKG9wdGlvbnMuc2hvd0NvbEhlYWRlciA/IG9wdGlvbnMuY29sSGVhZGVySGVpZ2h0ICogZ2V0Q29sdW1uSGVhZGVyTGV2ZWxfKHNjb3BlLmdyaWQuY29sdW1uc0NvbmZpZ18pIDogMCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9wOiBncm91cERyYWdQYW5lbExheW91dEluZm8uaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGxlZnQ6IHZpZXdwb3J0TGF5b3V0SW5mby5sZWZ0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB2aWV3cG9ydExheW91dEluZm8ud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBjb2xIZWFkZXJIZWlnaHQsXG4gICAgICAgICAgICAgICAgY29udGVudFdpZHRoOiB2aWV3cG9ydExheW91dEluZm8uY29udGVudFdpZHRoLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRIZWlnaHQ6IGNvbEhlYWRlckhlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFRvb2xQYW5lbExheW91dEluZm9fKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lclJlY3QgPSBzZWxmLmdyaWQuZ2V0Q29udGFpbmVySW5mb18oKS5jb250ZW50UmVjdDtcbiAgICAgICAgICAgIHZhciBncm91cERyYWdQYW5lbExheW91dEluZm8gPSBnZXRHcm91cERyYWdQYW5lbExheW91dEluZm9fLmNhbGwoc2VsZik7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBnZXRUb29sUGFuZWxXaWR0aF8uY2FsbChzZWxmKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9wOiBncm91cERyYWdQYW5lbExheW91dEluZm8uaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGxlZnQ6IE1hdGgubWF4KDAsIGNvbnRhaW5lclJlY3Qud2lkdGggLSB3aWR0aCksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogY29udGFpbmVyUmVjdC5oZWlnaHQgLSBncm91cERyYWdQYW5lbExheW91dEluZm8uaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGNvbnRlbnRXaWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgY29udGVudEhlaWdodDogY29udGFpbmVyUmVjdC5oZWlnaHQgLSBncm91cERyYWdQYW5lbExheW91dEluZm8uaGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0UGlubmVkVmlld3BvcnRMYXlvdXRJbmZvXyhwaW5uZWQpIHtcbiAgICAgICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAocGlubmVkID09PSAnbGVmdCcgJiYgc2NvcGUucHZJbmZvXykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS5wdkluZm9fO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwaW5uZWQgPT09ICdyaWdodCcgJiYgc2NvcGUucHJ2SW5mb18pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUucHJ2SW5mb187XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZ3JpZCA9IHNjb3BlLmdyaWQ7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHNjb3BlLm9wdGlvbnM7XG4gICAgICAgICAgICB2YXIgZ3JvdXBEcmFnUGFuZWxMYXlvdXRJbmZvID0gZ2V0R3JvdXBEcmFnUGFuZWxMYXlvdXRJbmZvXy5jYWxsKHNjb3BlKTtcbiAgICAgICAgICAgIHZhciByb3dIZWFkZXJXaWR0aCA9IChvcHRpb25zLnNob3dSb3dIZWFkZXIgPyBvcHRpb25zLnJvd0hlYWRlcldpZHRoIDogMCk7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyUmVjdCA9IGdyaWQuZ2V0Q29udGFpbmVySW5mb18oKS5jb250ZW50UmVjdDtcbiAgICAgICAgICAgIHZhciBjb2xIZWFkZXJIZWlnaHQgPSAob3B0aW9ucy5zaG93Q29sSGVhZGVyID8gb3B0aW9ucy5jb2xIZWFkZXJIZWlnaHQgKiBnZXRDb2x1bW5IZWFkZXJMZXZlbF8oZ3JpZC5jb2x1bW5zQ29uZmlnXykgOiAwKTtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBjb250YWluZXJSZWN0LmhlaWdodCAtIGNvbEhlYWRlckhlaWdodCAtIGdyb3VwRHJhZ1BhbmVsTGF5b3V0SW5mby5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgd2lkdGg7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSBnZXRVc2VyRGVmaW5lZFRlbXBsYXRlXy5jYWxsKHNjb3BlLCBwaW5uZWQpO1xuICAgICAgICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpdlN0ciA9ICc8ZGl2IHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7dG9wOi0xMDAwMHB4Oy0xMDAwMHB4O3dpZHRoOjUwMDBweDtoZWlnaHQ6NTAwMHB4O1wiPic7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkb21VdGlsLmNyZWF0ZVRlbXBsYXRlRWxlbWVudCh0ZW1wbGF0ZSk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jaGlsZHJlblswXS5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgICAgICAgICAgICAgZGl2U3RyICs9IGVsZW1lbnQuaW5uZXJIVE1MICsgJzwvZGl2Pic7XG4gICAgICAgICAgICAgICAgdmFyIGRpdiA9IGRvbVV0aWwuY3JlYXRlRWxlbWVudChkaXZTdHIpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IGRpdi5jaGlsZHJlblswXS5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG4gICAgICAgICAgICAgICAgZGl2ID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBfLnJlZHVjZShncmlkLmNvbHVtbnMsIGZ1bmN0aW9uKHN1bSwgY29sKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdW0gKyAoKGlzVG91Y2hBY3Rpb25Db2x1bW5fKGNvbCkgfHwgY29sLnBpbm5lZCAhPT0gcGlubmVkIHx8ICFncmlkLmlzQ29sVmlzaWJsZV8oY29sLCBwaW5uZWQpKSA/IDAgOiBjb2wudmlzaWJsZVdpZHRoKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBpbm5lZCA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAgICAgc2NvcGUucHZJbmZvXyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBjb2xIZWFkZXJIZWlnaHQgKyBncm91cERyYWdQYW5lbExheW91dEluZm8uaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiByb3dIZWFkZXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudEhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUucHZJbmZvXztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRIZWlnaHQgPSBnZXRDb250ZW50SGVpZ2h0XyhncmlkKTtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdFBpbm5lZExheW91dCA9IGdldFBpbm5lZFZpZXdwb3J0TGF5b3V0SW5mb18uY2FsbChzY29wZSwgJ2xlZnQnKTtcbiAgICAgICAgICAgICAgICBzY29wZS5wcnZJbmZvXyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBjb2xIZWFkZXJIZWlnaHQgKyBncm91cERyYWdQYW5lbExheW91dEluZm8uaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBNYXRoLm1heChsZWZ0UGlubmVkTGF5b3V0LmxlZnQgKyBsZWZ0UGlubmVkTGF5b3V0LndpZHRoLCBjb250YWluZXJSZWN0LndpZHRoIC0gZ2V0VG9vbFBhbmVsV2lkdGhfLmNhbGwoc2NvcGUpIC0gd2lkdGggLSAoaGVpZ2h0IDwgY29udGVudEhlaWdodCA/IGRvbVV0aWwuZ2V0U2Nyb2xsYmFyU2l6ZSgpLndpZHRoIDogMCkpLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50V2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50SGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS5wcnZJbmZvXztcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Vmlld3BvcnRMYXlvdXRJbmZvXygpIHtcbiAgICAgICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoc2NvcGUuY2FjaGVkVmlld3BvcnRMYXlvdXRJbmZvXykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS5jYWNoZWRWaWV3cG9ydExheW91dEluZm9fO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGdyaWQgPSBzY29wZS5ncmlkO1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lclJlY3QgPSBncmlkLmdldENvbnRhaW5lckluZm9fKCkuY29udGVudFJlY3Q7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gc2NvcGUub3B0aW9ucztcbiAgICAgICAgICAgIHZhciBncm91cERyYWdQYW5lbExheW91dEluZm8gPSBnZXRHcm91cERyYWdQYW5lbExheW91dEluZm9fLmNhbGwoc2NvcGUpO1xuXG4gICAgICAgICAgICB2YXIgcm93SGVhZGVyV2lkdGggPSAob3B0aW9uLnNob3dSb3dIZWFkZXIgPyBvcHRpb24ucm93SGVhZGVyV2lkdGggOiAwKTtcbiAgICAgICAgICAgIHZhciBjb2xIZWFkZXJIZWlnaHQgPSAob3B0aW9uLnNob3dDb2xIZWFkZXIgPyBvcHRpb24uY29sSGVhZGVySGVpZ2h0ICogZ2V0Q29sdW1uSGVhZGVyTGV2ZWxfKGdyaWQuY29sdW1uc0NvbmZpZ18pIDogMCk7XG5cbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGNvbnRhaW5lclJlY3Qud2lkdGggLSBnZXRUb29sUGFuZWxXaWR0aF8uY2FsbChzY29wZSkgLSByb3dIZWFkZXJXaWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBjb250YWluZXJSZWN0LmhlaWdodCAtIGNvbEhlYWRlckhlaWdodCAtIGdyb3VwRHJhZ1BhbmVsTGF5b3V0SW5mby5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgY29udGVudEhlaWdodCA9IGdldENvbnRlbnRIZWlnaHRfKGdyaWQpO1xuICAgICAgICAgICAgd2lkdGggPSAoaGVpZ2h0ID49IGNvbnRlbnRIZWlnaHQpID8gd2lkdGggOiAod2lkdGggLSBkb21VdGlsLmdldFNjcm9sbGJhclNpemUoKS53aWR0aCk7XG4gICAgICAgICAgICB2YXIgY29udGVudFdpZHRoO1xuICAgICAgICAgICAgLy9pZiB0aGVyZSBpcyByb3dUZW1wbGF0ZSwgbWVhc3VyZSB0aGUgdGVtcGxhdGUgd2lkdGggYXMgdGhlIGNvbnRlbnQgd2lkdGhcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IGdldFVzZXJEZWZpbmVkVGVtcGxhdGVfLmNhbGwoc2NvcGUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBkaXZTdHIgPSAnPGRpdiBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlO3RvcDotMTAwMDBweDstMTAwMDBweDt3aWR0aDo1MDAwcHg7aGVpZ2h0OjUwMDBweDtcIj4nO1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9tVXRpbC5jcmVhdGVUZW1wbGF0ZUVsZW1lbnQodGVtcGxhdGUpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmNoaWxkcmVuWzBdLnN0eWxlLmRpc3BsYXkgIT09ICd0YWJsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jaGlsZHJlblswXS5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpdlN0ciArPSBlbGVtZW50LmlubmVySFRNTCArICc8L2Rpdj4nO1xuICAgICAgICAgICAgICAgIHZhciBkaXYgPSBkb21VdGlsLmNyZWF0ZUVsZW1lbnQoZGl2U3RyKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAgICAgICAgICAgY29udGVudFdpZHRoID0gZGl2LmNoaWxkcmVuWzBdLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICAgICAgICAgICAgICBkaXYgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZW50V2lkdGggPSBfLnJlZHVjZShncmlkLmNvbHVtbnMsIGZ1bmN0aW9uKHN1bSwgY29sKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdW0gKyAoKGlzVG91Y2hBY3Rpb25Db2x1bW5fKGNvbCkgfHwgKGNvbC5waW5uZWQgIT09ICdub25lJykgfHwgIWdyaWQuaXNDb2xWaXNpYmxlXyhjb2wsICdub25lJykpID8gMCA6IGNvbC52aXNpYmxlV2lkdGgpO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBpbm5lZFdpZHRoID0gMDtcbiAgICAgICAgICAgIHZhciBwaW5uZWRWaWV3cG9ydExheW91dEluZm87XG4gICAgICAgICAgICB2YXIgcGlubmVkUmlnaHRWaWV3cG9ydExheW91dEluZm87XG4gICAgICAgICAgICBpZiAoc2NvcGUuaGFzTGVmdFBpbm5lZENvbHVtbl8pIHtcbiAgICAgICAgICAgICAgICBwaW5uZWRWaWV3cG9ydExheW91dEluZm8gPSBnZXRQaW5uZWRWaWV3cG9ydExheW91dEluZm9fLmNhbGwoc2NvcGUsICdsZWZ0Jyk7XG4gICAgICAgICAgICAgICAgcGlubmVkV2lkdGggPSBwaW5uZWRWaWV3cG9ydExheW91dEluZm8ud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aWR0aCAtPSBwaW5uZWRXaWR0aDtcbiAgICAgICAgICAgIGlmIChzY29wZS5oYXNSaWdodFBpbm5lZENvbHVtbl8pIHtcbiAgICAgICAgICAgICAgICBwaW5uZWRSaWdodFZpZXdwb3J0TGF5b3V0SW5mbyA9IGdldFBpbm5lZFZpZXdwb3J0TGF5b3V0SW5mb18uY2FsbChzY29wZSwgJ3JpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgd2lkdGggLT0gcGlubmVkUmlnaHRWaWV3cG9ydExheW91dEluZm8ud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2Nyb2xsYmFySGVpZ2h0ID0gZG9tVXRpbC5nZXRTY3JvbGxiYXJTaXplKCkuaGVpZ2h0O1xuICAgICAgICAgICAgaGVpZ2h0ID0gKHdpZHRoID49IGNvbnRlbnRXaWR0aCkgPyBoZWlnaHQgOiAoaGVpZ2h0IC0gc2Nyb2xsYmFySGVpZ2h0KTtcbiAgICAgICAgICAgIGlmICh3aWR0aCA8IGNvbnRlbnRXaWR0aCkge1xuICAgICAgICAgICAgICAgIGlmIChwaW5uZWRSaWdodFZpZXdwb3J0TGF5b3V0SW5mbykge1xuICAgICAgICAgICAgICAgICAgICBwaW5uZWRSaWdodFZpZXdwb3J0TGF5b3V0SW5mby5oZWlnaHQgLT0gc2Nyb2xsYmFySGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjb3BlLmNhY2hlZFZpZXdwb3J0TGF5b3V0SW5mb18gPSB7XG4gICAgICAgICAgICAgICAgdG9wOiBjb2xIZWFkZXJIZWlnaHQgKyBncm91cERyYWdQYW5lbExheW91dEluZm8uaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGxlZnQ6IChyb3dIZWFkZXJXaWR0aCArIHBpbm5lZFdpZHRoKSxcbiAgICAgICAgICAgICAgICB3aWR0aDogTWF0aC5tYXgoMCwgd2lkdGgpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGNvbnRlbnRXaWR0aDogY29udGVudFdpZHRoLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRIZWlnaHQ6IGNvbnRlbnRIZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gc2NvcGUuY2FjaGVkVmlld3BvcnRMYXlvdXRJbmZvXztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldENvbnRlbnRIZWlnaHRfKGdyaWQpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZ3JpZC5kYXRhO1xuICAgICAgICAgICAgaWYgKGhhc0dyb3VwXyhncmlkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfLnJlZHVjZShncmlkLmdyb3VwSW5mb3NfLCBmdW5jdGlvbihzdW0sIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1bSArIGl0ZW0uaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5pdGVtQ291bnQgKiBncmlkLm9wdGlvbnMucm93SGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Um93SGVhZGVyTGF5b3V0SW5mb18oKSB7XG4gICAgICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBzY29wZS5vcHRpb25zO1xuICAgICAgICAgICAgdmFyIHZpZXdwb3J0TGF5b3V0SW5mbyA9IGdldFZpZXdwb3J0TGF5b3V0SW5mb18uY2FsbChzY29wZSk7XG4gICAgICAgICAgICB2YXIgcm93SGVhZGVyV2lkdGggPSAob3B0aW9ucy5zaG93Um93SGVhZGVyID8gb3B0aW9ucy5yb3dIZWFkZXJXaWR0aCA6IDApO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHZpZXdwb3J0TGF5b3V0SW5mby5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAoc2NvcGUuaGFzTGVmdFBpbm5lZENvbHVtbl8pIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBnZXRQaW5uZWRWaWV3cG9ydExheW91dEluZm9fLmNhbGwoc2NvcGUsICdsZWZ0JykuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3A6IHZpZXdwb3J0TGF5b3V0SW5mby50b3AsXG4gICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICB3aWR0aDogcm93SGVhZGVyV2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICAgICAgY29udGVudFdpZHRoOiByb3dIZWFkZXJXaWR0aCxcbiAgICAgICAgICAgICAgICBjb250ZW50SGVpZ2h0OiB2aWV3cG9ydExheW91dEluZm8uY29udGVudEhlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlU3R5bGVQcm9wZXJ0eVZhbHVlXyhzdHlsZSwgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldENvbHVtbkhlYWRlckxheW91dEluZm9fKCkge1xuICAgICAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICAgICAgICAgIHZhciBncmlkID0gc2NvcGUuZ3JpZDtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gc2NvcGUub3B0aW9ucztcbiAgICAgICAgICAgIHZhciBncm91cERyYWdQYW5lbExheW91dEluZm8gPSBnZXRHcm91cERyYWdQYW5lbExheW91dEluZm9fLmNhbGwoc2NvcGUpO1xuICAgICAgICAgICAgdmFyIHZpZXdwb3J0TGF5b3V0SW5mbyA9IGdldFZpZXdwb3J0TGF5b3V0SW5mb18uY2FsbChzY29wZSk7XG4gICAgICAgICAgICB2YXIgY29sSGVhZGVySGVpZ2h0ID0gKG9wdGlvbnMuc2hvd0NvbEhlYWRlciA/IG9wdGlvbnMuY29sSGVhZGVySGVpZ2h0ICogZ2V0Q29sdW1uSGVhZGVyTGV2ZWxfKGdyaWQuY29sdW1uc0NvbmZpZ18pIDogMCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9wOiBncm91cERyYWdQYW5lbExheW91dEluZm8uaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGxlZnQ6IHZpZXdwb3J0TGF5b3V0SW5mby5sZWZ0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB2aWV3cG9ydExheW91dEluZm8ud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBjb2xIZWFkZXJIZWlnaHQsXG4gICAgICAgICAgICAgICAgY29udGVudFdpZHRoOiB2aWV3cG9ydExheW91dEluZm8uY29udGVudFdpZHRoLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRIZWlnaHQ6IGNvbEhlYWRlckhlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldENvcm5lckhlYWRlckxheW91dEluZm9fKCkge1xuICAgICAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gc2NvcGUub3B0aW9ucztcblxuICAgICAgICAgICAgdmFyIGdyb3VwRHJhZ1BhbmVsTGF5b3V0SW5mbyA9IGdldEdyb3VwRHJhZ1BhbmVsTGF5b3V0SW5mb18uY2FsbChzY29wZSk7XG4gICAgICAgICAgICB2YXIgcm93SGVhZGVyV2lkdGggPSAob3B0aW9ucy5zaG93Um93SGVhZGVyID8gb3B0aW9ucy5yb3dIZWFkZXJXaWR0aCA6IDApO1xuICAgICAgICAgICAgdmFyIGNvbEhlYWRlckhlaWdodCA9IChvcHRpb25zLnNob3dDb2xIZWFkZXIgPyBvcHRpb25zLmNvbEhlYWRlckhlaWdodCAqIGdldENvbHVtbkhlYWRlckxldmVsXyhzY29wZS5ncmlkLmNvbHVtbnNDb25maWdfKSA6IDApO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3A6IGdyb3VwRHJhZ1BhbmVsTGF5b3V0SW5mby5oZWlnaHQsXG4gICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICB3aWR0aDogcm93SGVhZGVyV2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBjb2xIZWFkZXJIZWlnaHQsXG4gICAgICAgICAgICAgICAgY29udGVudFdpZHRoOiByb3dIZWFkZXJXaWR0aCxcbiAgICAgICAgICAgICAgICBjb250ZW50SGVpZ2h0OiBjb2xIZWFkZXJIZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZVN0YXJ0U2l6ZV8odmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChnY1V0aWxzLmlzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwICYmIHZhbHVlLnNsaWNlKC0xKSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN6ID0gdmFsdWUubGVuZ3RoID09PSAxID8gMSA6IHZhbHVlLnNsaWNlKDAsIC0xKSAqIDE7XG4gICAgICAgICAgICAgICAgaWYgKHN6ID4gMCAmJiAhaXNOYU4oc3opKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzejtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVBpbm5lZENvbHVtbnNfKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGdyaWQgPSBzZWxmLmdyaWQ7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHNlbGYub3B0aW9ucztcbiAgICAgICAgICAgIHZhciBsZWZ0VG1wbCA9IG9wdGlvbnMucGlubmVkTGVmdFJvd1RlbXBsYXRlO1xuICAgICAgICAgICAgdmFyIHJpZ2h0VG1wbCA9IG9wdGlvbnMucGlubmVkUmlnaHRSb3dUZW1wbGF0ZTtcbiAgICAgICAgICAgIGlmIChsZWZ0VG1wbCB8fCByaWdodFRtcGwpIHtcbiAgICAgICAgICAgICAgICBfLmVhY2goZ3JpZC5jb2x1bW5zLCBmdW5jdGlvbihjb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sLnBpbm5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlUGlubmVkQ29sdW1uc0luUm93VGVtcGxhdGVfKGdyaWQsIGxlZnRUbXBsLCAnbGVmdCcpO1xuICAgICAgICAgICAgdXBkYXRlUGlubmVkQ29sdW1uc0luUm93VGVtcGxhdGVfKGdyaWQsIHJpZ2h0VG1wbCwgJ3JpZ2h0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVQaW5uZWRDb2x1bW5zSW5Sb3dUZW1wbGF0ZV8oZ3JpZCwgcm93VGVtcGxhdGUsIHBpbm5lZCkge1xuICAgICAgICAgICAgaWYgKHJvd1RlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkb21VdGlsLmNyZWF0ZVRlbXBsYXRlRWxlbWVudChyb3dUZW1wbGF0ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGFubm90YXRpb25Db2xzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1jb2x1bW5dJyk7XG4gICAgICAgICAgICAgICAgXy5lYWNoKGFubm90YXRpb25Db2xzLCBmdW5jdGlvbihhbm5vdGF0aW9uQ29sKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyaWQuZ2V0Q29sQnlJZF8oYW5ub3RhdGlvbkNvbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY29sdW1uJykpLnBpbm5lZCA9IHBpbm5lZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEdyb3VwRGVzY3JpcHRvckluZGV4Xyhncm91cERlcywgaWQpIHtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgdmFyIGxlbjtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGdyb3VwRGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwRGVzW2ldLmZpZWxkID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRDb2xJbmRleF8oaWQpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjb2xzID0gc2VsZi5ncmlkLmNvbHVtbnM7XG4gICAgICAgICAgICB2YXIgY29sO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb2wgPSBjb2xzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjb2wuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFRlbXBsYXRlXyhpc0NvbHVtbkhlYWRlciwgYXJlYSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCFpc0NvbHVtbkhlYWRlcikge1xuICAgICAgICAgICAgICAgIGlmIChhcmVhID09PSBWSUVXUE9SVCAmJiBzZWxmLmNhY2hlZFRtcGxGbl8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FjaGVkVG1wbEZuXztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZWEgPT09IFBJTk5FRF9WSUVXUE9SVCAmJiBzZWxmLmNhY2hlZFBpbmVkVG1wbEZuXykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jYWNoZWRQaW5lZFRtcGxGbl87XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmVhID09PSBQSU5ORURfUklHSFRfVklFV1BPUlQgJiYgc2VsZi5jYWNoZWRSaWdodFBpbmVkVG1wbEZuXykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jYWNoZWRSaWdodFBpbmVkVG1wbEZuXztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVN0ciA9IGdldFJhd1Jvd1RlbXBsYXRlXy5jYWxsKHRoaXMsIGlzQ29sdW1uSGVhZGVyLCBhcmVhKTtcbiAgICAgICAgICAgIHZhciBvbGRDb2xUbXBsO1xuICAgICAgICAgICAgdmFyIG5ld0NvbFRtcGw7XG4gICAgICAgICAgICB2YXIgY3NzTmFtZTtcbiAgICAgICAgICAgIHZhciB0YWdOYW1lO1xuICAgICAgICAgICAgdmFyIGNvbElkO1xuICAgICAgICAgICAgdmFyIGNvbFRtcGw7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGdyaWQgPSBzZWxmLmdyaWQ7XG4gICAgICAgICAgICB2YXIgY29sSW5kZXg7XG4gICAgICAgICAgICB0ZW1wbGF0ZVN0ciA9IGZpbHRlckFjdGlvbkNvbHVtbi5jYWxsKHRoaXMsIHRlbXBsYXRlU3RyLCBhcmVhKTtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9tVXRpbC5jcmVhdGVUZW1wbGF0ZUVsZW1lbnQodGVtcGxhdGVTdHIpO1xuICAgICAgICAgICAgLy9EaWZmZXJlbnQgYnJvd3NlcnMgbWF5IHJldHVybiBkaWZmZXJlbnQgaW5uZXJIVE1McyBjb21wYXJlZCB3aXRoIHRoZSBvcmlnaW5hbCBIVE1MLFxuICAgICAgICAgICAgLy90aGV5IG1heSByZW9yZGVyIHRoZSBhdHRyaWJ1dGUgb2YgYSB0YWcsZXNjYXBlcyB0YWdzIHdpdGggaW5zaWRlIGEgbm9zY3JpcHQgdGFnIGV0Yy5cbiAgICAgICAgICAgIHRlbXBsYXRlU3RyID0gZG9tVXRpbC5nZXRFbGVtZW50SW5uZXJUZXh0KGVsZW1lbnQpO1xuXG4gICAgICAgICAgICB2YXIgdHJlZUNvbElkID0gZ2V0VHJlZUNvbHVtbl8oZ3JpZCk7XG4gICAgICAgICAgICB2YXIgYW5ub3RhdGlvbkNvbHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWNvbHVtbl0nKTtcbiAgICAgICAgICAgIF8uZWFjaChhbm5vdGF0aW9uQ29scywgZnVuY3Rpb24oYW5ub3RhdGlvbkNvbCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IGFubm90YXRpb25Db2wuc3R5bGUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIC8vd2lkdGggPSBhbm5vdGF0aW9uQ29sLnN0eWxlLndpZHRoO1xuICAgICAgICAgICAgICAgIGNvbElkID0gYW5ub3RhdGlvbkNvbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY29sdW1uJyk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbCA9IGdyaWQuZ2V0Q29sQnlJZF8oY29sSWQpO1xuICAgICAgICAgICAgICAgIHZhciBjb2xBbm5vdGF0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChjb2wuaXNDYWxjQ29sdW1uXykge1xuICAgICAgICAgICAgICAgICAgICBjb2xBbm5vdGF0aW9uID0gJ3t7PWl0LicgKyBjb2wuaWQgKyAnfX0nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhRmllbGRzID0gY29sLmRhdGFGaWVsZCA/IGNvbC5kYXRhRmllbGQuc3BsaXQoJywnKSA6IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YUZpZWxkcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbEFubm90YXRpb24gPSAne3s9aXQuJyArIGNvbC5kYXRhRmllbGQgKyAnfX0nO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uZWFjaChkYXRhRmllbGRzLCBmdW5jdGlvbihkYXRhRmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wLnB1c2goZ3JpZC5nZXRDb2xCeUlkXyhkYXRhRmllbGQpLnByZXNlbnRlciB8fCAne3s9aXQuJyArIGRhdGFGaWVsZCArICd9fScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xBbm5vdGF0aW9uID0gdGVtcC5qb2luKCcgJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29sVG1wbCA9IGFubm90YXRpb25Db2w7XG4gICAgICAgICAgICAgICAgdGFnTmFtZSA9IGNvbFRtcGwudGFnTmFtZTtcbiAgICAgICAgICAgICAgICBvbGRDb2xUbXBsID0gZG9tVXRpbC5nZXRFbGVtZW50T3V0ZXJUZXh0KGNvbFRtcGwpO1xuICAgICAgICAgICAgICAgIGNvbEluZGV4ID0gZ2V0Q29sSW5kZXhfLmNhbGwoc2VsZiwgY29sSWQpO1xuICAgICAgICAgICAgICAgIGNzc05hbWUgPSAoaXNDb2x1bW5IZWFkZXIgPyAnZ2MtY29sdW1uLWhlYWRlci1jZWxsJyA6ICdnYy1jZWxsJykgKyAnIGMnICsgY29sSW5kZXggKyAoY29sLmNzc0NsYXNzID8gKCcgJyArIGNvbC5jc3NDbGFzcykgOiAnJyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5uZXJQcmVzZW50ZXI7XG4gICAgICAgICAgICAgICAgaWYgKGNvbC5hY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJQcmVzZW50ZXIgPSBpc0NvbHVtbkhlYWRlciA/IChjb2wuY2FwdGlvbiB8fCAnJykgOiBjcmVhdGVBY3Rpb25Db2x1bW5fLmNhbGwoc2VsZiwgY29sKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbm5lclByZXNlbnRlciA9IGlzQ29sdW1uSGVhZGVyID8gY29sLmNhcHRpb24gOiAoY29sLnByZXNlbnRlciA/IGNvbC5wcmVzZW50ZXIgOiBjb2xBbm5vdGF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlzQ29sdW1uSGVhZGVyICYmIGdyaWQuZGF0YS5pc0hpZXJhcmNoaWNhbCAmJiBjb2xJZCA9PT0gdHJlZUNvbElkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmVlQ29sUHJlc2VudGVyID0gJzxkaXYgc3R5bGU9XCJtYXJnaW4tbGVmdDp7ez1pdC5ub2RlLm9mZnNldH19cHg7XCI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJnYy1pY29uIGdjLXRyZWUtbm9kZSB7ez8gaXQubm9kZS5jb2xsYXBzZWR9fWNvbGxhcHNlZHt7Pz99fWV4cGFuZGVke3s/fX1cIiBzdHlsZT1cInZpc2liaWxpdHk6e3s/IGl0Lm5vZGUuY2hpbGRyZW4ubGVuZ3RoICE9MH19dmlzaWJsZXt7Pz99fWhpZGRlbnt7P319O1wiPjwvc3Bhbj48L2Rpdj4nO1xuICAgICAgICAgICAgICAgICAgICBpbm5lclByZXNlbnRlciA9IHRyZWVDb2xQcmVzZW50ZXIgKyBpbm5lclByZXNlbnRlcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuZXdDb2xUbXBsID0gb2xkQ29sVG1wbC5zbGljZSgwLCBvbGRDb2xUbXBsLmxlbmd0aCAtICh0YWdOYW1lLmxlbmd0aCArIDMpKSArXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiJyArIGNzc05hbWUgKyAnXCInICsgKGlzQ29sdW1uSGVhZGVyID8gJycgOiAnIHJvbGU9XCJncmlkY2VsbFwiJykgKyAnPicgKyBpbm5lclByZXNlbnRlciArXG4gICAgICAgICAgICAgICAgICAgIChpc0NvbHVtbkhlYWRlciA/IGdldFNvcnRJbmRpY2F0b3JIdG1sXyhzZWxmLCBjb2wsIGNvbEluZGV4KSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICc8L2Rpdj48LycgKyB0YWdOYW1lICsgJz4nO1xuXG4gICAgICAgICAgICAgICAgLy9vdXRlckhUTUwgcmV0dXJucyBkb3VibGUgcXVvdGVzIGluIGF0dHJpYnV0ZSBzb21ldGltZXNcbiAgICAgICAgICAgICAgICBpZiAodGVtcGxhdGVTdHIuaW5kZXhPZihvbGRDb2xUbXBsKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8ganNjczpkaXNhYmxlIHZhbGlkYXRlUXVvdGVNYXJrc1xuICAgICAgICAgICAgICAgICAgICAvKmpzaGludCBxdW90bWFyazogZG91YmxlICovXG4gICAgICAgICAgICAgICAgICAgIG9sZENvbFRtcGwgPSBvbGRDb2xUbXBsLnJlcGxhY2UoL1wiL2csIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8ganNjczplbmFibGUgdmFsaWRhdGVRdW90ZU1hcmtzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRlbXBsYXRlU3RyID0gdGVtcGxhdGVTdHIucmVwbGFjZShvbGRDb2xUbXBsLCBuZXdDb2xUbXBsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIGlmICghaXNDb2x1bW5IZWFkZXIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBkb1QudGVtcGxhdGUodGVtcGxhdGVTdHIsIG51bGwsIG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmIChhcmVhID09PSBQSU5ORURfVklFV1BPUlQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWNoZWRQaW5lZFRtcGxGbl8gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmVhID09PSBQSU5ORURfUklHSFRfVklFV1BPUlQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWNoZWRSaWdodFBpbmVkVG1wbEZuXyA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNhY2hlZFRtcGxGbl8gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlU3RyO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0VHJlZUNvbHVtbl8oZ3JpZCkge1xuICAgICAgICAgICAgdmFyIGhpZXJhcmNoeSA9IGdyaWQub3B0aW9ucy5oaWVyYXJjaHk7XG4gICAgICAgICAgICB2YXIgY29scyA9IGdyaWQuY29sdW1ucztcbiAgICAgICAgICAgIGlmIChoaWVyYXJjaHkgJiYgaGllcmFyY2h5LmNvbHVtbikge1xuICAgICAgICAgICAgICAgIHZhciBjb2wgPSBfLmZpbmQoY29scywgXy5tYXRjaGVzUHJvcGVydHkoJ2lkJywgaGllcmFyY2h5LmNvbHVtbikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2wgPyBjb2wuaWQgOiBjb2xzWzBdLmlkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sc1swXS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUFjdGlvbkNvbHVtbl8oY29sKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgaW5uZXJQcmVzZW50ZXIgPSAnJztcbiAgICAgICAgICAgIGlmICghc2VsZi5ncmlkLmNvbHVtbkFjdGlvbnNfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyUHJlc2VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFjdGlvbkluZm9zID0gc2VsZi5ncmlkLmNvbHVtbkFjdGlvbnNfW2NvbC5pZF07XG4gICAgICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhY3Rpb25JbmZvcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBhY3Rpb25JbmZvc1tpXTtcbiAgICAgICAgICAgICAgICBpbm5lclByZXNlbnRlciArPSAoaXRlbS5wcmVzZW50ZXIgPyBpdGVtLnByZXNlbnRlciA6ICgnPGJ1dHRvbiBjbGFzcz1cImdjLWFjdGlvblwiIGRhdGEtYWN0aW9uPVwiJyArIGl0ZW0ubmFtZSArICdcIj4nICsgaXRlbS5uYW1lICsgJzwvYnV0dG9uPicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbm5lclByZXNlbnRlciAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICBpbm5lclByZXNlbnRlciA9ICc8ZGl2IGNsYXNzPVwiZ2MtYWN0aW9uLWFyZWFcIj4nICsgaW5uZXJQcmVzZW50ZXIgKyAnPC9kaXY+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbm5lclByZXNlbnRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUFjdGlvbkNvbHVtbnMoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY29sdW1ucyA9IFtdO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgICAgIHZhciBhY3Rpb25UeXBlID0gc3dpcGVTdGF0dXMuYWN0aW9uVHlwZTtcbiAgICAgICAgICAgIF8uZWFjaChzZWxmLmdyaWQuY29sdW1ucywgZnVuY3Rpb24oY29sKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVG91Y2hBY3Rpb25Db2x1bW5fKGNvbCkgJiYgY29sLnN3aXBlRGlyZWN0aW9uID09PSBhY3Rpb25UeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbm5lclByZXNlbnRlciA9IGNyZWF0ZUFjdGlvbkNvbHVtbl8uY2FsbChzZWxmLCBjb2wpO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVyc2VudGVyOiBpbm5lclByZXNlbnRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcmZlcnJlZFNpemU6IGNvbC52aXNpYmxlV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGNvbHVtbnM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVDb2x1bW5Ub3VjaFBhbmVsKHBhbmVsV2lkdGgpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciByb3cgPSBzd2lwZVN0YXR1cy5yb3c7XG4gICAgICAgICAgICB2YXIgYWN0aW9uVHlwZSA9IHN3aXBlU3RhdHVzLmFjdGlvblR5cGU7XG4gICAgICAgICAgICB2YXIgY29sdW1ucyA9IHN3aXBlU3RhdHVzLmNvbHVtbnM7XG4gICAgICAgICAgICB2YXIgaWQgPSByb3cuaWQgKyAnLScgKyBhY3Rpb25UeXBlICsgJy1hY3Rpb25QYW5lbCc7XG4gICAgICAgICAgICB2YXIgbGF5b3V0SW5mbyA9IHNlbGYuZ2V0TGF5b3V0SW5mbygpW1ZJRVdQT1JUXTtcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSByb3cuY2xhc3NOYW1lICsgJyBhY3Rpb25QYW5lbCc7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBwYW5lbFdpZHRoO1xuICAgICAgICAgICAgdmFyIGxlZnQgPSBhY3Rpb25UeXBlID09PSAnbGVmdCcgPyAobGF5b3V0SW5mby5jb250ZW50V2lkdGggLSB3aWR0aCkgOiAwO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gJ3RvcDonICsgcm93LnN0eWxlLnRvcCArICc7IGhlaWdodDonICsgcm93LnN0eWxlLmhlaWdodCArICc7IGxlZnQ6JyArIGxlZnQgKyAncHg7IHdpZHRoOicgKyB3aWR0aCArICdweDtwb3NpdGlvbjphYnNvbHV0ZSc7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVySHRtbCA9ICc8ZGl2IGlkPVwiJyArIGlkICsgJ1wiIHN0eWxlPVwiJyArIHN0eWxlICsgJ1wiIGNsYXNzPVwiJyArIGNsYXNzTmFtZSArICdcIj4nO1xuICAgICAgICAgICAgdmFyIGNvbGxlZnQgPSBhY3Rpb25UeXBlID09PSAnbGVmdCcgPyAwIDogd2lkdGg7XG5cbiAgICAgICAgICAgIF8uZWFjaChjb2x1bW5zLCBmdW5jdGlvbihjb2wpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sV2lkdGggPSAoY29sLnBlcmZlcnJlZFNpemUgLyBzd2lwZVN0YXR1cy5jb2x1bW5zVG90YWxXaWR0aCkgKiB3aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgY29sVG1sO1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb25UeXBlID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlZnQgLT0gY29sV2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29sVG1sID0gJzxkaXYgc3R5bGUgPSBcIicgKyAnaGVpZ2h0OjEwMCU7bGVmdDonICsgY29sbGVmdCArICdweDt3aWR0aDonICsgY29sV2lkdGggKyAncHg7cG9zaXRpb246YWJzb2x1dGU7b3ZlcmZsb3c6aGlkZGVuO1wiPic7XG4gICAgICAgICAgICAgICAgY29sVG1sICs9ICc8ZGl2IHN0eWxlPVwiaGVpZ2h0OjEwMCU7ZmxvYXQ6JyArIGFjdGlvblR5cGUgKyAnXCIgY2xhc3M9XCJnYy1hY3Rpb25jb2x1bW4nICsgY29sLmluZGV4ICsgJ1wiPicgKyBjb2wucGVyc2VudGVyICsgJzwvZGl2Pic7XG4gICAgICAgICAgICAgICAgY29sVG1sICs9ICc8L2Rpdj4nO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvblR5cGUgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICAgICAgICBjb2xsZWZ0ICs9IGNvbFdpZHRoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckh0bWwgKz0gY29sVG1sO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnRhaW5lckh0bWwgKz0gJzwvZGl2Pic7XG4gICAgICAgICAgICByZXR1cm4gZG9tVXRpbC5jcmVhdGVFbGVtZW50KGNvbnRhaW5lckh0bWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ3JvdXBJbmZvQXJlU2FtZV8obGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgIGlmIChsZWZ0Lml0ZW1JbmRleCAhPT0gcmlnaHQuaXRlbUluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZnQuYXJlYSAhPT0gcmlnaHQuYXJlYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxlZnRQYXRoID0gbGVmdC5wYXRoO1xuICAgICAgICAgICAgdmFyIHJpZ2h0UGF0aCA9IHJpZ2h0LnBhdGg7XG4gICAgICAgICAgICBpZiAobGVmdFBhdGgubGVuZ3RoICE9PSByaWdodFBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGVmdFBhdGgubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGVmdFBhdGhbaV0gIT09IHJpZ2h0UGF0aFtpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb250YWluc18obGF5b3V0SW5mbywgcG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwb2ludC5sZWZ0ID49IGxheW91dEluZm8ubGVmdCAmJiBwb2ludC50b3AgPj0gbGF5b3V0SW5mby50b3AgJiYgcG9pbnQubGVmdCA8PSAobGF5b3V0SW5mby5sZWZ0ICsgbGF5b3V0SW5mby53aWR0aCkgJiYgcG9pbnQudG9wIDw9IChsYXlvdXRJbmZvLnRvcCArIGxheW91dEluZm8uaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEdyb3VwSW5mb0F0XyhvZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBzdGFydFBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgIHZhciBwYXRoO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgbGVuID0gc2VsZi5ncmlkLmRhdGEuZ3JvdXBzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHBhdGggPSBbaV07XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwSW5mbyA9IHNlbGYuZ3JpZC5nZXRHcm91cEluZm9fKHBhdGgpO1xuICAgICAgICAgICAgICAgIHZhciBncm91cEhlaWdodCA9IGdyb3VwSW5mby5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGdldEdyb3VwSW5mb0F0SW50ZXJuYWxfLmNhbGwoc2VsZiwgcGF0aCwgb2Zmc2V0LCBzdGFydFBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IChsZW4gLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9vdGVyID0gZ3JvdXBJbmZvLmRhdGEuZ3JvdXBEZXNjcmlwdG9yLmZvb3RlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvb3RlciAmJiBmb290ZXIudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUluZGV4OiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmVhOiAnZ3JvdXBGb290ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zaXRpb246IHN0YXJ0UG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZ2V0TGFzdEdyb3VwSXRlbVBhdGhfLmNhbGwodGhpcywgcGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCAtPSBncm91cEhlaWdodDtcbiAgICAgICAgICAgICAgICBzdGFydFBvc2l0aW9uICs9IGdyb3VwSGVpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldExhc3RHcm91cEl0ZW1QYXRoXyhwYXRoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZ3JvdXBJbmZvID0gc2VsZi5ncmlkLmdldEdyb3VwSW5mb18ocGF0aCk7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cEluZm8uZGF0YTtcbiAgICAgICAgICAgIHZhciBnZCA9IGdyb3VwLmdyb3VwRGVzY3JpcHRvcjtcbiAgICAgICAgICAgIHZhciBsYXN0SW5kZXggPSAoZ3JvdXAuaXNCb3R0b21MZXZlbCA/IGdyb3VwLml0ZW1Db3VudCA6IGdyb3VwSW5mby5jaGlsZHJlbi5sZW5ndGgpIC0gMTtcbiAgICAgICAgICAgIGlmICghZ3JvdXAuaXNCb3R0b21MZXZlbCAmJiAhZ3JvdXAuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldExhc3RHcm91cEl0ZW1QYXRoXy5jYWxsKHNlbGYsIHBhdGguc2xpY2UoKS5jb25jYXQoW2xhc3RJbmRleF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmb290ZXIgPSBnZC5mb290ZXI7XG4gICAgICAgICAgICBpZiAoZ3JvdXAuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgaXRlbUluZGV4OiAtMSxcbiAgICAgICAgICAgICAgICAgICAgYXJlYTogKGZvb3RlciAmJiBmb290ZXIudmlzaWJsZSAmJiAhZm9vdGVyLmNvbGxhcHNlV2l0aEdyb3VwKSA/IEdST1VQX0ZPT1RFUiA6IEdST1VQX0hFQURFUlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1JbmRleDogKGZvb3RlciAmJiBmb290ZXIudmlzaWJsZSkgPyAtMSA6IGxhc3RJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgYXJlYTogKGZvb3RlciAmJiBmb290ZXIudmlzaWJsZSkgPyBHUk9VUF9GT09URVIgOiBHUk9VUF9IRUFERVJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0R3JvdXBJbmZvQXRJbnRlcm5hbF8ocGF0aCwgb2Zmc2V0VG9wLCBzdGFydFBvc2l0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZ3JvdXBJbmZvID0gc2VsZi5ncmlkLmdldEdyb3VwSW5mb18ocGF0aCk7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cEluZm8uZGF0YTtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgdmFyIGxlbjtcbiAgICAgICAgICAgIHZhciBoZWlnaHQ7XG4gICAgICAgICAgICBpZiAob2Zmc2V0VG9wIDw9IGdyb3VwSW5mby5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBzZWxmLmdldEdyb3VwSGVhZGVySGVpZ2h0Xyhncm91cCk7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldFRvcCA8PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtSW5kZXg6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRQb3NpdGlvbjogc3RhcnRQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZWE6IEdST1VQX0hFQURFUlxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zaXRpb24gKz0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXAuaXNCb3R0b21MZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZ3JvdXAuaXRlbUNvdW50OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBzZWxmLmdldFJvd0hlaWdodF8oZ3JvdXAuZ2V0SXRlbShpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldFRvcCA8PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtSW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydFBvc2l0aW9uOiBzdGFydFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlYTogR1JPVVBfQ09OVEVOVFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRUb3AgLT0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zaXRpb24gKz0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZ3JvdXBJbmZvLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGdldEdyb3VwSW5mb0F0SW50ZXJuYWxfLmNhbGwoc2VsZiwgcGF0aC5zbGljZSgpLmNvbmNhdChbaV0pLCBvZmZzZXRUb3AsIHN0YXJ0UG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gZ3JvdXBJbmZvLmNoaWxkcmVuW2ldLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRUb3AgLT0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zaXRpb24gKz0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUluZGV4OiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zaXRpb246IHN0YXJ0UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmVhOiBHUk9VUF9GT09URVJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0R3JvdXBIZWFkZXJUZW1wbGF0ZV8oZ3JvdXBJbmZvLCBhcmVhKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZ3JvdXBQYXRoID0gZ3JvdXBJbmZvLnBhdGg7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cEluZm8uZGF0YTtcbiAgICAgICAgICAgIHNlbGYuY2FjaGVkR3JvdXBIZWFkZXJGbl8gPSBzZWxmLmNhY2hlZEdyb3VwSGVhZGVyRm5fIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGNhY2hlT2JqID0gc2VsZi5jYWNoZWRHcm91cEhlYWRlckZuXztcbiAgICAgICAgICAgIGNhY2hlT2JqW2FyZWFdID0gY2FjaGVPYmpbYXJlYV0gfHwgW107XG4gICAgICAgICAgICBpZiAoY2FjaGVPYmpbYXJlYV1bZ3JvdXBQYXRoLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlT2JqW2FyZWFdW2dyb3VwUGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzZWxmLmdldEdyb3VwSGVhZGVySGVpZ2h0Xyhncm91cCk7XG4gICAgICAgICAgICB2YXIgaGVhZGVyID0gZ3JvdXAuZ3JvdXBEZXNjcmlwdG9yLmhlYWRlcjtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVN0cjtcbiAgICAgICAgICAgIGlmICghc2VsZi5oYXNMZWZ0UGlubmVkQ29sdW1uXyB8fCBhcmVhID09PSBQSU5ORURfVklFV1BPUlQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sR3JvdXBIZWFkZXJzID0gJyc7XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKHNlbGYuZ3JpZC5jb2x1bW5zLCBmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5ncm91cEhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sR3JvdXBIZWFkZXJzID0gY29sR3JvdXBIZWFkZXJzICsgKGNvbEdyb3VwSGVhZGVycyA/ICcsICcgOiAnJykgKyBjb2x1bW4uZ3JvdXBIZWFkZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IGNvbEdyb3VwSGVhZGVycyA/ICcoJyArIGNvbEdyb3VwSGVhZGVycyArICcpJyA6ICcoe3s9aXQuY291bnR9fSBpdGVtcyknO1xuICAgICAgICAgICAgICAgIC8vVE9ETzogcHJlcHJvY2VzcyB1c2VyIGdpdmVuIGhlYWRlciB0ZW1wbGF0ZSwgYWRkIGhlaWdodFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlU3RyID0gKGhlYWRlciAmJiBoZWFkZXIudGVtcGxhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZ2MtZ3JvdXAtaGVhZGVyIGdjLWdyb3VwLWhlYWRlci1jZWxsIFwiIHN0eWxlPVwiaGVpZ2h0OicgKyBoZWlnaHQgKyAncHg7bGluZS1oZWlnaHQ6JyArXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCArICdweDtcIj48c3BhbiBjbGFzcz1cImdjLWljb24gZ2MtZ3JvdXBpbmctdG9nZ2xlIHt7PWl0Lmdyb3VwU3RhdHVzfX1cIiBzdHlsZT1cIm1hcmdpbi1sZWZ0Ont7PWl0Lm1hcmdpbn19cHg7XCI+PC9zcGFuPjxzcGFuIGxldmVsPVwie3s9aXQubGV2ZWx9fVwiPiB7ez1pdC5uYW1lfX08c3Bhbj4gJyArIGFubm90YXRpb24gKyAnPC9zcGFuPjwvc3Bhbj48L2Rpdj4nO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlU3RyID0gJzxkaXYgY2xhc3M9XCJnYy1ncm91cC1oZWFkZXIgZ2MtZ3JvdXAtaGVhZGVyLWNlbGwgXCIgc3R5bGU9XCJoZWlnaHQ6JyArIGhlaWdodCArICdweDtsaW5lLWhlaWdodDonICsgaGVpZ2h0ICsgJ3B4O1wiPjwvZGl2Pic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhY2hlT2JqW2FyZWFdW2dyb3VwUGF0aC5sZW5ndGggLSAxXSA9IGRvVC50ZW1wbGF0ZSh0ZW1wbGF0ZVN0ciwgbnVsbCwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVPYmpbYXJlYV1bZ3JvdXBQYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0R3JvdXBGb290ZXJUZW1wbGF0ZV8oZ3JvdXBJbmZvLCBhcmVhKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZ3JpZCA9IHNlbGYuZ3JpZDtcbiAgICAgICAgICAgIHZhciBncm91cFBhdGggPSBncm91cEluZm8ucGF0aDtcbiAgICAgICAgICAgIHNlbGYuY2FjaGVkR3JvdXBGb290ZXJGbl8gPSBzZWxmLmNhY2hlZEdyb3VwRm9vdGVyRm5fIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGNhY2hlZE9iaiA9IHNlbGYuY2FjaGVkR3JvdXBGb290ZXJGbl87XG4gICAgICAgICAgICBjYWNoZWRPYmpbYXJlYV0gPSBjYWNoZWRPYmpbYXJlYV0gfHwgW107XG4gICAgICAgICAgICBpZiAoY2FjaGVkT2JqW2FyZWFdW2dyb3VwUGF0aC5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRPYmpbYXJlYV1bZ3JvdXBQYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZvb3RlciA9IGdyb3VwSW5mby5kYXRhLmdyb3VwRGVzY3JpcHRvci5mb290ZXI7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVTdHI7XG4gICAgICAgICAgICBpZiAoZm9vdGVyICYmIGFyZWEgPT09IFBJTk5FRF9WSUVXUE9SVCkge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlU3RyID0gZm9vdGVyLnBpbm5lZExlZnRUZW1wbGF0ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9vdGVyICYmIGFyZWEgPT09IFBJTk5FRF9SSUdIVF9WSUVXUE9SVCkge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlU3RyID0gZm9vdGVyLnBpbm5lZFJpZ2h0VGVtcGxhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wbGF0ZVN0ciA9IHRlbXBsYXRlU3RyIHx8IGdldFJhd1Jvd1RlbXBsYXRlXy5jYWxsKHNlbGYsIGZhbHNlLCBhcmVhKTtcbiAgICAgICAgICAgIHZhciBvbGRDb2xUbXBsO1xuICAgICAgICAgICAgdmFyIG5ld0NvbFRtcGw7XG4gICAgICAgICAgICB2YXIgY3NzTmFtZTtcbiAgICAgICAgICAgIHZhciB0YWdOYW1lO1xuICAgICAgICAgICAgdmFyIGNvbFRtcGw7XG4gICAgICAgICAgICB0ZW1wbGF0ZVN0ciA9IGZpbHRlckFjdGlvbkNvbHVtbi5jYWxsKHRoaXMsIHRlbXBsYXRlU3RyLCBhcmVhKTtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9tVXRpbC5jcmVhdGVUZW1wbGF0ZUVsZW1lbnQodGVtcGxhdGVTdHIpO1xuICAgICAgICAgICAgLy9EaWZmZXJlbnQgYnJvd3NlcnMgbWF5IHJldHVybiBkaWZmZXJlbnQgaW5uZXJIVE1McyBjb21wYXJlZCB3aXRoIHRoZSBvcmlnaW5hbCBIVE1MLFxuICAgICAgICAgICAgLy90aGV5IG1heSByZW9yZGVyIHRoZSBhdHRyaWJ1dGUgb2YgYSB0YWcsZXNjYXBlcyB0YWdzIHdpdGggaW5zaWRlIGEgbm9zY3JpcHQgdGFnIGV0Yy5cbiAgICAgICAgICAgIHRlbXBsYXRlU3RyID0gZG9tVXRpbC5nZXRFbGVtZW50SW5uZXJUZXh0KGVsZW1lbnQpO1xuXG4gICAgICAgICAgICB2YXIgYW5ub3RhdGlvbkNvbHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWNvbHVtbl0nKTtcbiAgICAgICAgICAgIF8uZWFjaChhbm5vdGF0aW9uQ29scywgZnVuY3Rpb24oYW5ub3RhdGlvbkNvbCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sID0gZ3JpZC5nZXRDb2xCeUlkXyhhbm5vdGF0aW9uQ29sLmdldEF0dHJpYnV0ZSgnZGF0YS1jb2x1bW4nKSk7XG4gICAgICAgICAgICAgICAgLy9UT0RPOiBoYW5kZWwgdGhlIGNhc2UgdGhhdCBjb2wgYWdncmFnYXRpb24gaXMgYW4gYXJyYXlcbiAgICAgICAgICAgICAgICB2YXIgY29sQW5ub3RhdGlvbiA9IGNvbC5ncm91cEZvb3RlciB8fCAnJztcbiAgICAgICAgICAgICAgICBjb2xUbXBsID0gYW5ub3RhdGlvbkNvbDtcbiAgICAgICAgICAgICAgICB0YWdOYW1lID0gY29sVG1wbC50YWdOYW1lO1xuICAgICAgICAgICAgICAgIG9sZENvbFRtcGwgPSBjb2xUbXBsLm91dGVySFRNTDtcbiAgICAgICAgICAgICAgICBjc3NOYW1lID0gJ2djLWNlbGwgZ2MtZ3JvdXAtZm9vdGVyLWNlbGwnICsgJyBjJyArIGluZGV4O1xuICAgICAgICAgICAgICAgIG5ld0NvbFRtcGwgPSBvbGRDb2xUbXBsLnNsaWNlKDAsIG9sZENvbFRtcGwubGVuZ3RoIC0gKHRhZ05hbWUubGVuZ3RoICsgMykpICtcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgc3R5bGU9XCJoZWlnaHQ6MTAwJTtvdmVyZmxvdzpoaWRkZW47XCI+PGRpdiBzdHlsZT1cImhlaWdodDoxMDAlO1wiIGNsYXNzPVwiJyArIGNzc05hbWUgKyAnXCI+JyArXG4gICAgICAgICAgICAgICAgICAgIGNvbEFubm90YXRpb24gK1xuICAgICAgICAgICAgICAgICAgICAnPC9kaXY+PC9kaXY+PC8nICsgdGFnTmFtZSArICc+JztcblxuICAgICAgICAgICAgICAgIC8vb3V0ZXJIVE1MIHJldHVybnMgZG91YmxlIHF1b3RlcyBpbiBhdHRyaWJ1dGUgc29tZXRpbWVzXG4gICAgICAgICAgICAgICAgaWYgKHRlbXBsYXRlU3RyLmluZGV4T2Yob2xkQ29sVG1wbCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGpzY3M6ZGlzYWJsZSB2YWxpZGF0ZVF1b3RlTWFya3NcbiAgICAgICAgICAgICAgICAgICAgLypqc2hpbnQgcXVvdG1hcms6IGRvdWJsZSAqL1xuICAgICAgICAgICAgICAgICAgICBvbGRDb2xUbXBsID0gb2xkQ29sVG1wbC5yZXBsYWNlKC9cIi9nLCBcIidcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGpzY3M6ZW5hYmxlIHZhbGlkYXRlUXVvdGVNYXJrc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVN0ciA9IHRlbXBsYXRlU3RyLnJlcGxhY2Uob2xkQ29sVG1wbCwgbmV3Q29sVG1wbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgY2FjaGVkT2JqW2FyZWFdW2dyb3VwUGF0aC5sZW5ndGggLSAxXSA9IGRvVC50ZW1wbGF0ZSh0ZW1wbGF0ZVN0ciwgbnVsbCwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqW2FyZWFdW2dyb3VwUGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEdyb3VwRm9vdGVyRGF0YV8oZ3JvdXBJbmZvKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cEluZm8uZGF0YTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogZ3JvdXAubmFtZSxcbiAgICAgICAgICAgICAgICBjb3VudDogZ3JvdXAuaXRlbUNvdW50LFxuICAgICAgICAgICAgICAgIGxldmVsOiBncm91cC5sZXZlbCxcbiAgICAgICAgICAgICAgICBtYXJnaW46IGdyb3VwLmxldmVsICogMTgsXG4gICAgICAgICAgICAgICAgZ3JvdXBTdGF0dXM6IGdyb3VwLmNvbGxhcHNlZCA/ICdjb2xsYXBzZWQnIDogJ2V4cGFuZCcsXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uOiBncm91cC5ncm91cERlc2NyaXB0b3IuZmllbGQsXG4gICAgICAgICAgICAgICAgZXZhbDogZnVuY3Rpb24oZm9ybXVsYSwgZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYWxjU291cmNlID0gc2VsZi5ncmlkLmRhdGEuY2FsY1NvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNhbGNTb3VyY2UuZ2V0RXZhbHVhdG9yKCkuZXZhbHVhdGVGb3JtdWxhKGZvcm11bGEsIGNhbGNTb3VyY2UuZ2V0UGFyc2VyQ29udGV4dCgpLCBjYWxjU291cmNlLmdldEV2YWx1YXRvckNvbnRleHQoLTEsIGdyb3VwSW5mby5wYXRoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRWYWx1ZS5jYWxsKHNlbGYsIHJlc3VsdCwgZm9ybWF0LCBmb3JtdWxhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEdyb3VwRm9vdGVyUmVuZGVySW5mb18oZ3JvdXBJbmZvLCBvZmZzZXQsIGFyZWEpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzZWxmLmdldEdyb3VwRm9vdGVySGVpZ2h0Xyhncm91cEluZm8uZGF0YSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY3NzQ2xhc3M6ICdnYy1yb3cgZycgKyBncm91cEluZm8ucGF0aC5qb2luKCdfJyksXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZW5kZXJlZEhUTUw6IGdldEdyb3VwRm9vdGVyVGVtcGxhdGVfLmNhbGwoc2VsZiwgZ3JvdXBJbmZvLCBhcmVhKShnZXRHcm91cEZvb3RlckRhdGFfLmNhbGwoc2VsZiwgZ3JvdXBJbmZvKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRHcm91cEhlYWRlclJlbmRlckluZm9fKGdyb3VwUGF0aCwgZ3JvdXBJbmZvLCB3aWR0aCwgdG9wLCBhcmVhKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNzc0NsYXNzOiAnZ2Mtcm93IGcnICsgZ3JvdXBQYXRoLmpvaW4oJ18nKSxcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHNlbGYuZ2V0R3JvdXBIZWFkZXJIZWlnaHRfKGdyb3VwSW5mby5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZW5kZXJlZEhUTUw6IHJlbmRlckdyb3VwSGVhZGVyXy5jYWxsKHNlbGYsIGdyb3VwSW5mbywgYXJlYSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRHcm91cFJvd1JlbmRlckluZm9fKHJvd0luZGV4LCBncm91cEluZm8sIGhlaWdodCwgb2Zmc2V0LCBhZGRpdGlvbmFsQ1NTQ2xhc3MsIGFkZGl0aW9uYWxTdHlsZSwgYXJlYSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0ge1xuICAgICAgICAgICAgICAgIHRvcDogb2Zmc2V0LFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3R5bGUgPSBhZGRpdGlvbmFsU3R5bGUgPyBfLmFzc2lnbihhZGRpdGlvbmFsU3R5bGUsIHN0eWxlKSA6IHN0eWxlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjc3NDbGFzczogJ2djLXJvdycgKyAoYWRkaXRpb25hbENTU0NsYXNzID8gKCcgJyArIGFkZGl0aW9uYWxDU1NDbGFzcykgOiAnJyksXG4gICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVkSFRNTDogc2VsZi5nZXRSb3dUZW1wbGF0ZShhcmVhKShzZWxmLmdyaWQuZm9ybWF0RGF0YUl0ZW0oZ3JvdXBJbmZvLmRhdGEuZ2V0SXRlbShyb3dJbmRleCkpKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEdyb3VwUmVuZGVySW5mb18oc3RhcnRJbmZvLCBlbmRJbmZvLCBvZmZzZXRUb3AsIGlzUm93SGVhZGVyLCBnZXRVcGRhdGVLZXksIGFyZWEpIHtcbiAgICAgICAgICAgIGlmICghc3RhcnRJbmZvIHx8ICFlbmRJbmZvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJvd3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZ3JpZCA9IHNjb3BlLmdyaWQ7XG4gICAgICAgICAgICB2YXIgZ3JvdXBJbmZvcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHJlbmRlckl0ZW0gPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBhbGxEb25lID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgY3VyckluZm87XG4gICAgICAgICAgICB2YXIgZ3JvdXBJbmZvO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgbGVuO1xuICAgICAgICAgICAgdmFyIHRwUm93O1xuXG4gICAgICAgICAgICB2YXIgZ3JvdXBSb3dIZWFkZXJDb250ZW50V2lkdGggPSBzY29wZS5nZXRMYXlvdXRJbmZvKClbYXJlYV0uY29udGVudFdpZHRoO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSBzdGFydEluZm8ucGF0aFswXSwgbGVuID0gZW5kSW5mby5wYXRoWzBdOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBJbmZvcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogW2ldLFxuICAgICAgICAgICAgICAgICAgICBpdGVtSW5kZXg6IC0xLFxuICAgICAgICAgICAgICAgICAgICBhcmVhOiBHUk9VUF9IRUFERVJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKGdyb3VwSW5mb3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChhbGxEb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJySW5mbyA9IGdyb3VwSW5mb3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlbmRlckl0ZW0gJiYgZ3JvdXBJbmZvQXJlU2FtZV8oY3VyckluZm8sIHN0YXJ0SW5mbykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVySXRlbSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZW5kZXJJdGVtICYmIGdyb3VwSW5mb0FyZVNhbWVfKGN1cnJJbmZvLCBlbmRJbmZvKSkge1xuICAgICAgICAgICAgICAgICAgICBhbGxEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlbmRlckl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJJbmZvLmFyZWEgPT09IEdST1VQX0hFQURFUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHBSb3cgPSBnZXRHcm91cEhlYWRlcl8uY2FsbChzY29wZSwgY3VyckluZm8sIGlzUm93SGVhZGVyLCBncm91cFJvd0hlYWRlckNvbnRlbnRXaWR0aCwgb2Zmc2V0VG9wLCBnZXRVcGRhdGVLZXksIGFyZWEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJJbmZvLmFyZWEgPT09IEdST1VQX0NPTlRFTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRwUm93ID0gZ2V0R3JvdXBDb250ZW50Xy5jYWxsKHNjb3BlLCBjdXJySW5mbywgaXNSb3dIZWFkZXIsIG9mZnNldFRvcCwgZ2V0VXBkYXRlS2V5LCBhcmVhKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRwUm93ID0gZ2V0R3JvdXBGb290ZXJfLmNhbGwoc2NvcGUsIGN1cnJJbmZvLCBpc1Jvd0hlYWRlciwgb2Zmc2V0VG9wLCBnZXRVcGRhdGVLZXksIGFyZWEpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRwUm93LnJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93cyA9IHJvd3MuY29uY2F0KHRwUm93LnJvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRUb3AgKz0gdHBSb3cuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJJbmZvLmFyZWEgPT09IEdST1VQX0hFQURFUikge1xuICAgICAgICAgICAgICAgICAgICBncm91cEluZm8gPSBncmlkLmdldEdyb3VwSW5mb18oY3VyckluZm8ucGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cCA9IGdyb3VwSW5mby5kYXRhO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXAuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXAgJiYgIWdyb3VwLmlzQm90dG9tZUxldmVsICYmICEoZ3JvdXAuZ3JvdXBEZXNjcmlwdG9yLmZvb3RlciAmJiBncm91cC5ncm91cERlc2NyaXB0b3IuZm9vdGVyLmNvbGxhcHNlV2l0aEdyb3VwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwSW5mb3MudW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN1cnJJbmZvLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1JbmRleDogLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZWE6IEdST1VQX0ZPT1RFUlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBJbmZvcy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdXJySW5mby5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1JbmRleDogLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlYTogR1JPVVBfRk9PVEVSXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gZ3JvdXAuaXNCb3R0b21MZXZlbCA/IGdyb3VwLml0ZW1Db3VudCA6IGdyb3VwSW5mby5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChncm91cC5pc0JvdHRvbUxldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwSW5mb3MudW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdXJySW5mby5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlYTogR1JPVVBfQ09OVEVOVFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cEluZm9zLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogY3VyckluZm8ucGF0aC5zbGljZSgpLmNvbmNhdChbaV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUluZGV4OiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZWE6IEdST1VQX0hFQURFUlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByb3dzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0R3JvdXBIZWFkZXJfKGN1cnJJbmZvLCBpc1Jvd0hlYWRlciwgd2lkdGgsIG9mZnNldFRvcCwgZ2V0VXBkYXRlS2V5LCBhcmVhKSB7XG4gICAgICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGdyaWQgPSBzY29wZS5ncmlkO1xuICAgICAgICAgICAgdmFyIHJvd3M7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGdyb3VwSW5mbyA9IGdyaWQuZ2V0R3JvdXBJbmZvXyhjdXJySW5mby5wYXRoKTtcbiAgICAgICAgICAgIHZhciBoZWFkZXIgPSBncm91cEluZm8uZGF0YS5ncm91cERlc2NyaXB0b3IuaGVhZGVyO1xuICAgICAgICAgICAgaWYgKGhlYWRlciAmJiBoZWFkZXIudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHJvd3MgPSBbXTtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBzY29wZS5nZXRHcm91cEhlYWRlckhlaWdodF8oZ3JvdXBJbmZvLmRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChpc1Jvd0hlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICByb3dzLnB1c2goZ2V0R3JvdXBSb3dIZWFkZXJDZWxsLmNhbGwoc2NvcGUsIGN1cnJJbmZvLCBvZmZzZXRUb3AsIGhlaWdodCwgZ2V0VXBkYXRlS2V5KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGdyaWQudWlkICsgKGFyZWEgPT09IFBJTk5FRF9WSUVXUE9SVCA/ICctcGdoJyA6IChhcmVhID09PSBWSUVXUE9SVCA/ICctZ2gnIDogJy1wcmdoJykpICsgY3VyckluZm8ucGF0aC5qb2luKCdfJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXRVcGRhdGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbzogY3VyckluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBvZmZzZXRUb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZWE6IEdST1VQX0hFQURFUlxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dzLnB1c2goZ2V0R3JvdXBIZWFkZXJSb3dfLmNhbGwoc2NvcGUsIGtleSwgY3VyckluZm8sIGdyb3VwSW5mbywgd2lkdGgsIG9mZnNldFRvcCwgYXJlYSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge3Jvdzogcm93cywgaGVpZ2h0OiBoZWlnaHR9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0R3JvdXBIZWFkZXJSb3dfKGtleSwgY3VyckluZm8sIGdyb3VwSW5mbywgd2lkdGgsIHRvcCwgYXJlYSkge1xuICAgICAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgaXNSb3dSb2xlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZW5kZXJJbmZvOiBnZXRHcm91cEhlYWRlclJlbmRlckluZm9fLmNhbGwoc2NvcGUsIGN1cnJJbmZvLnBhdGgsIGdyb3VwSW5mbywgd2lkdGgsIHRvcCwgYXJlYSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRSZW5kZXJlZEdyb3VwQ29udGVudEl0ZW1JbmZvXyhyb3dJbmRleCwgZ3JvdXBJbmZvLCBoZWlnaHQsIG9mZnNldFRvcCwgZ2V0VXBkYXRlS2V5LCBhZGRpdGlvbmFsQ1NTQ2xhc3MsIGFkZGl0aW9uYWxTdHlsZSwgYXJlYSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGtleSA9IHNlbGYuZ3JpZC51aWQgKyAoYXJlYSA9PT0gVklFV1BPUlQgPyAnLWdyJyA6IChhcmVhID09PSBQSU5ORURfVklFV1BPUlQgPyAnLXBncicgOiAnLXByZ3InKSkgKyBncm91cEluZm8ucGF0aC5qb2luKCdfJykgKyAnLXInICsgcm93SW5kZXg7XG4gICAgICAgICAgICBpZiAoZ2V0VXBkYXRlS2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgIGluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGdyb3VwSW5mby5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUluZGV4OiByb3dJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZWE6IEdST1VQX0NPTlRFTlRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBvZmZzZXRUb3AsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogZ2V0R3JvdXBJdGVtUm93SGVpZ2h0Xy5jYWxsKHNlbGYpLFxuICAgICAgICAgICAgICAgICAgICBhcmVhOiBHUk9VUF9DT05URU5UXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEdyb3VwQ29udGVudFJvd18uY2FsbChzZWxmLCBrZXksIHJvd0luZGV4LCBncm91cEluZm8sIGhlaWdodCwgb2Zmc2V0VG9wLCBhZGRpdGlvbmFsQ1NTQ2xhc3MsIGFkZGl0aW9uYWxTdHlsZSwgYXJlYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRHcm91cENvbnRlbnRfKGN1cnJJbmZvLCBpc1Jvd0hlYWRlciwgb2Zmc2V0VG9wLCBnZXRVcGRhdGVLZXksIGFyZWEpIHtcbiAgICAgICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZ3JpZCA9IHNjb3BlLmdyaWQ7XG4gICAgICAgICAgICB2YXIgcm93cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGdyb3VwSW5mbyA9IGdyaWQuZ2V0R3JvdXBJbmZvXyhjdXJySW5mby5wYXRoKTtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBnZXRHcm91cEl0ZW1Sb3dIZWlnaHRfLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBpZiAoaXNSb3dIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICByb3dzLnB1c2goZ2V0R3JvdXBSb3dIZWFkZXJDZWxsLmNhbGwoc2NvcGUsIGN1cnJJbmZvLCBvZmZzZXRUb3AsIGhlaWdodCwgZ2V0VXBkYXRlS2V5KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvd3MucHVzaChnZXRSZW5kZXJlZEdyb3VwQ29udGVudEl0ZW1JbmZvXy5jYWxsKHNjb3BlLCBjdXJySW5mby5pdGVtSW5kZXgsIGdyb3VwSW5mbywgaGVpZ2h0LCBvZmZzZXRUb3AsIGdldFVwZGF0ZUtleSwgbnVsbCwgbnVsbCwgYXJlYSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge3Jvdzogcm93cywgaGVpZ2h0OiBoZWlnaHR9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0R3JvdXBDb250ZW50Um93XyhrZXksIHJvd0luZGV4LCBncm91cEluZm8sIGhlaWdodCwgdG9wLCBhZGRpdGlvbmFsQ1NTQ2xhc3MsIGFkZGl0aW9uYWxTdHlsZSwgYXJlYSkge1xuICAgICAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgaXNSb3dSb2xlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBzY29wZS5zZWxlY3RlZFJvd3NfICYmIHNjb3BlLnNlbGVjdGVkUm93c18uaW5kZXhPZihncm91cEluZm8uZGF0YS50b1NvdXJjZVJvdyhyb3dJbmRleCkpICE9PSAtMSxcbiAgICAgICAgICAgICAgICByZW5kZXJJbmZvOiBnZXRHcm91cFJvd1JlbmRlckluZm9fLmNhbGwoc2NvcGUsIHJvd0luZGV4LCBncm91cEluZm8sIGhlaWdodCwgdG9wLCBhZGRpdGlvbmFsQ1NTQ2xhc3MsIGFkZGl0aW9uYWxTdHlsZSwgYXJlYSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRHcm91cEZvb3Rlcl8oY3VyckluZm8sIGlzUm93SGVhZGVyLCBvZmZzZXRUb3AsIGdldFVwZGF0ZUtleSwgYXJlYSkge1xuICAgICAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICAgICAgICAgIHZhciBncmlkID0gc2NvcGUuZ3JpZDtcbiAgICAgICAgICAgIHZhciByb3dzO1xuICAgICAgICAgICAgdmFyIGdyb3VwSW5mbyA9IGdyaWQuZ2V0R3JvdXBJbmZvXyhjdXJySW5mby5wYXRoKTtcbiAgICAgICAgICAgIHZhciBoZWlnaHQ7XG4gICAgICAgICAgICB2YXIgZm9vdGVyID0gZ3JvdXBJbmZvLmRhdGEuZ3JvdXBEZXNjcmlwdG9yLmZvb3RlcjtcbiAgICAgICAgICAgIGlmIChmb290ZXIgJiYgZm9vdGVyLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICByb3dzID0gW107XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gc2NvcGUuZ2V0R3JvdXBGb290ZXJIZWlnaHRfKGdyb3VwSW5mby5kYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNSb3dIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93cy5wdXNoKGdldEdyb3VwUm93SGVhZGVyQ2VsbC5jYWxsKHNjb3BlLCBjdXJySW5mbywgb2Zmc2V0VG9wLCBoZWlnaHQsIGdldFVwZGF0ZUtleSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBncmlkLnVpZCArIChhcmVhID09PSBQSU5ORURfVklFV1BPUlQgPyAnLXBnZicgOiAoYXJlYSA9PT0gUElOTkVEX1JJR0hUX1ZJRVdQT1JUID8gJy1wcmdmJyA6ICctZ2YnKSkgKyBjdXJySW5mby5wYXRoLmpvaW4oJ18nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdldFVwZGF0ZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvOiBjdXJySW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IG9mZnNldFRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmVhOiBHUk9VUF9GT09URVJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93cy5wdXNoKGdldEdyb3VwRm9vdGVyUm93Xy5jYWxsKHNjb3BlLCBrZXksIGN1cnJJbmZvLCBncm91cEluZm8sIG9mZnNldFRvcCwgYXJlYSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge3Jvdzogcm93cywgaGVpZ2h0OiBoZWlnaHR9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0R3JvdXBGb290ZXJSb3dfKGtleSwgY3VyckluZm8sIGdyb3VwSW5mbywgdG9wLCBhcmVhKSB7XG4gICAgICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICBpc1Jvd1JvbGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlbmRlckluZm86IGdldEdyb3VwRm9vdGVyUmVuZGVySW5mb18uY2FsbChzY29wZSwgZ3JvdXBJbmZvLCB0b3AsIGFyZWEpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0R3JvdXBSb3dIZWFkZXJDZWxsKGN1cnJJbmZvLCBvZmZzZXRUb3AsIGhlaWdodCwgZ2V0VXBkYXRlS2V5KSB7XG4gICAgICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKGdldFVwZGF0ZUtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogZ2V0Um93SGVhZGVyQ2VsbEtleS5jYWxsKHRoaXMsIGN1cnJJbmZvKSxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBvZmZzZXRUb3AsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBpbmZvOiBjdXJySW5mb1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRSb3dIZWFkZXJDZWxsUmVuZGVySW5mb18uY2FsbChzY29wZSwgY3VyckluZm8sIG51bGwsIGhlaWdodCwgb2Zmc2V0VG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlbmRlckdyb3VwSGVhZGVyXyhncm91cEluZm8sIGFyZWEpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBnZXRHcm91cEhlYWRlclRlbXBsYXRlXy5jYWxsKHNlbGYsIGdyb3VwSW5mbywgYXJlYSkoZ2V0R3JvdXBGb290ZXJEYXRhXy5jYWxsKHNlbGYsIGdyb3VwSW5mbykpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Um93SGVhZGVyQ2VsbFJlbmRlckluZm9fKGN1cnJlbnRJbmZvLCBpdGVtSW5kZXgsIGhlaWdodCwgb2Zmc2V0VG9wKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIga2V5ID0gZ2V0Um93SGVhZGVyQ2VsbEtleS5jYWxsKHNlbGYsIGN1cnJlbnRJbmZvLCBpdGVtSW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkSGVhZGVyQ2VsbC5jYWxsKHNlbGYsIGtleSwgY3VycmVudEluZm8sIChjdXJyZW50SW5mbyA/IGZhbHNlIDogdHJ1ZSksIChpdGVtSW5kZXggPyAoaXRlbUluZGV4ICogaGVpZ2h0KSA6IG9mZnNldFRvcCksIGhlaWdodCwgaXRlbUluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFJvd0hlYWRlckNlbGxLZXkoY3VycmVudEluZm8sIGl0ZW1JbmRleCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGtleSA9IHNlbGYuZ3JpZC51aWQ7XG4gICAgICAgICAgICBpZiAoY3VycmVudEluZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEluZm8uYXJlYSA9PT0gR1JPVVBfSEVBREVSKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSArPSAoJy1naGgnICsgY3VycmVudEluZm8ucGF0aC5qb2luKCctJykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudEluZm8uYXJlYSA9PT0gR1JPVVBfQ09OVEVOVCkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgKz0gKCctZ3JoJyArIGN1cnJlbnRJbmZvLnBhdGguam9pbignLScpICsgJy1yJyArIGN1cnJlbnRJbmZvLml0ZW1JbmRleCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ICs9ICgnLWdmaCcgKyBjdXJyZW50SW5mby5wYXRoLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXkgKz0gKCctcmgnICsgaXRlbUluZGV4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkSGVhZGVyQ2VsbChrZXksIGluZm8sIGlzUm93Um9sZSwgdG9wLCBoZWlnaHQsIGl0ZW1JbmRleCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGdyaWQgPSBzZWxmLmdyaWQ7XG4gICAgICAgICAgICB2YXIgc2hvd0NoZWNrYm94ID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBpc0NoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZFJvd3MgPSBzZWxmLnNlbGVjdGVkUm93c187XG4gICAgICAgICAgICB2YXIgY2hlY2tib3hTZWxlY3RhYmxlID0gc2VsZi5vcHRpb25zLmFsbG93SGVhZGVyU2VsZWN0O1xuICAgICAgICAgICAgaWYgKGNoZWNrYm94U2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmZvLmFyZWEgPT09IEdST1VQX0hFQURFUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcHBpbmdzID0gZ2V0R3JvdXBNYXBwaW5nXyhncmlkLmdldEdyb3VwSW5mb18oaW5mby5wYXRoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NoZWNrZWQgPSBzZWxlY3RlZFJvd3MgJiYgc2VsZWN0ZWRSb3dzLmluZGV4T2YobWFwcGluZ3NbaV0pICE9PSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5mby5hcmVhID09PSBHUk9VUF9GT09URVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dDaGVja2JveCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdyA9IGdyaWQuZ2V0R3JvdXBJbmZvXyhpbmZvLnBhdGgpLmRhdGEudG9Tb3VyY2VSb3coaW5mby5pdGVtSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNDaGVja2VkID0gc2VsZWN0ZWRSb3dzICYmIHNlbGVjdGVkUm93cy5pbmRleE9mKHJvdykgIT09IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXNDaGVja2VkID0gc2VsZWN0ZWRSb3dzICYmIHNlbGVjdGVkUm93cy5pbmRleE9mKGl0ZW1JbmRleCkgIT09IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICBpc1Jvd1JvbGU6IGlzUm93Um9sZSxcbiAgICAgICAgICAgICAgICByZW5kZXJJbmZvOiB7XG4gICAgICAgICAgICAgICAgICAgIGNzc0NsYXNzOiAnZ2Mtcm93LWhlYWRlcicsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHNlbGYub3B0aW9ucy5yb3dIZWFkZXJXaWR0aFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZEhUTUw6ICc8ZGl2IGNsYXNzPVwiZ2Mtcm93LWhlYWRlci1jZWxsXCI+JyArIChjaGVja2JveFNlbGVjdGFibGUgJiYgc2hvd0NoZWNrYm94ID8gJzxkaXYgaWQ9XCInICsga2V5ICsgJy1zZWxlY3RcIiBjbGFzcz1cImdjLWljb24gZ2MtaGVhZGVyLXNlbGVjdC1pY29uJyArIChpc0NoZWNrZWQgPyAnIHNlbGVjdGVkJyA6ICcnKSArICdcIj48L2Rpdj4nIDogJycpICsgJzwvZGl2PidcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvL1RPRE86IGltcGxlbWVudCBpZiB3ZSBhbGxvdyBkaWZmZXJlbnQgcm93IGhlaWdodFxuICAgICAgICBmdW5jdGlvbiBnZXRHcm91cEl0ZW1Sb3dIZWlnaHRfKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yb3dIZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRSb3dJbmZvQXQob2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgc3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICB2YXIgZGF0YUxlbiA9IHNlbGYuZ3JpZC5kYXRhLml0ZW1Db3VudDtcbiAgICAgICAgICAgIHZhciBjYWNoZWRSb3dPZmZzZXQgPSBzZWxmLmNhY2hlZFJvd09mZnNldF87XG4gICAgICAgICAgICB2YXIgb2Zmc2V0VG9wID0gb2Zmc2V0LnRvcDtcbiAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gMDtcbiAgICAgICAgICAgIHZhciByb3dIZWlnaHQgPSBzZWxmLm9wdGlvbnMucm93SGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgICAgIGlmIChjYWNoZWRSb3dPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBjYWNoZWRSb3dPZmZzZXQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGNhY2hlZFJvd09mZnNldFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0gPD0gb2Zmc2V0VG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gaSAqIDEwMDAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VG9wIC09IGl0ZW07XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFBvc2l0aW9uID0gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSBzdGFydEluZGV4OyBpIDwgZGF0YUxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldFRvcCA8PSByb3dIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRQb3NpdGlvbjogc3RhcnRQb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSAlIDEwMDAwID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2FjaGVkUm93T2Zmc2V0XyA9IGNhY2hlZFJvd09mZnNldCB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWNoZWRSb3dPZmZzZXRfW2kgLyAxMDAwMF0gPSBzdGFydFBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXRUb3AgLT0gcm93SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHN0YXJ0UG9zaXRpb24gKz0gcm93SGVpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHN0YXJ0RHJhZ0Ryb3BpbmdfKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGdyaWQgPSBzZWxmLmdyaWQ7XG4gICAgICAgICAgICB2YXIgc2VsZWN0b3I7XG4gICAgICAgICAgICB2YXIgaGl0VGVzdCA9IHNlbGYuZHJhZ1N0YXJ0SW5mb18uaGl0VGVzdEluZm87XG4gICAgICAgICAgICB2YXIgaGl0Q29sR3JvdXBDYXB0aW9uID0gaGl0VGVzdC5jb2x1bW5Hcm91cEluZm8gPyBoaXRUZXN0LmNvbHVtbkdyb3VwSW5mby5jYXB0aW9uIDogbnVsbDtcbiAgICAgICAgICAgIHZhciBjYXBpdG9uO1xuICAgICAgICAgICAgdmFyIGFyZWEgPSBoaXRUZXN0LmFyZWE7XG4gICAgICAgICAgICBpZiAoYXJlYSA9PT0gQ09MVU1OX0hFQURFUiB8fCBhcmVhID09PSBQSU5ORURfQ09MVU1OX0hFQURFUiB8fCBhcmVhID09PSBQSU5ORURfUklHSFRfQ09MVU1OX0hFQURFUikge1xuICAgICAgICAgICAgICAgIGlmIChoaXRUZXN0LmNvbHVtbiA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gJyMnICsgc2VsZi5ncmlkLnVpZCArICctJyArIGFyZWEgKyAnIC5nYy1jb2x1bW4taGVhZGVyLWNlbGwuYycgKyBoaXRUZXN0LmNvbHVtbjtcbiAgICAgICAgICAgICAgICAgICAgY2FwaXRvbiA9IGdyaWQuY29sdW1uc1toaXRUZXN0LmNvbHVtbl0uY2FwdGlvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhpdENvbEdyb3VwQ2FwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9ICcjJyArIHNlbGYuZ3JpZC51aWQgKyAnLScgKyBhcmVhICsgJyBbZGF0YS1jb2x1bW4tZ3JvdXAtaGVhZGVyPVwiJyArIGhpdENvbEdyb3VwQ2FwdGlvbiArICdcIl0nO1xuICAgICAgICAgICAgICAgICAgICBjYXBpdG9uID0gaGl0Q29sR3JvdXBDYXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmVhID09PSBHUk9VUF9EUkFHX1BBTkVMICYmIGhpdFRlc3QuZ3JvdXBpbmdQYW5lbEluZm8pIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9ICcjJyArIHNlbGYuZ3JpZC51aWQgKyAnLWdyb3VwaW5nLWluZGljYXRvci0nICsgaGl0VGVzdC5ncm91cGluZ1BhbmVsSW5mby5maWVsZDtcbiAgICAgICAgICAgICAgICBjYXBpdG9uID0gZ3JpZC5nZXRDb2xCeUlkXyhoaXRUZXN0Lmdyb3VwaW5nUGFuZWxJbmZvLmZpZWxkKS5jYXB0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gZG9tVXRpbC5vZmZzZXQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50T2Zmc2V0ID0gc2VsZi5kcmFnU3RhcnRJbmZvXy5wb2ludE9mZnNldDtcbiAgICAgICAgICAgICAgICBzZWxmLmRyYWdTdGFydEluZm9fLnBvaW50T2Zmc2V0ID0ge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBvZmZzZXQubGVmdCAtIHBvaW50T2Zmc2V0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogb2Zmc2V0LnRvcCAtIHBvaW50T2Zmc2V0LnRvcFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGRvbVV0aWwuY3JlYXRlRWxlbWVudCgnPGRpdiBjbGFzcz1cImdjLWRyYWctY2x1ZVwiICBzdHlsZT1cInotaW5kZXg6OTk5XCI+PHNwYW4gY2xhc3M9XCJnYy1pY29uIGdjLWljb24tZ3JvdXBpbmctYWRkXCI+PC9zcGFuPjxkaXYgc3R5bGU9XCJkaXNwbGF5OmlubGluZS1ibG9jaztvdmVyZmxvdzogaGlkZGVuO3doaXRlLXNwYWNlOnByZTtcIj48c3Bhbj4gJyArIGNhcGl0b24gKyAnPC9zcGFuPjwvZGl2PjwvZGl2PicpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuaWQgPSAnJztcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnRvcCA9IG9mZnNldC50b3AgKyAncHgnO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUubGVmdCA9IG9mZnNldC5sZWZ0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICAvL2VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gUE9TX0FCUztcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHNlbGYuZHJhZ0Ryb3BpbmdFbGVtZW50XyA9IGVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2x1ZUluZGljYXRvckVsZW1lbnQgPSBkb21VdGlsLmNyZWF0ZUVsZW1lbnQoJzxkaXYgY2xhc3M9XCJnYy1kcmFnLWNsdWUtaW5kaWNhdG9yXCI+PHNwYW4gY2xhc3M9XCJnYy1pY29uIHRvcFwiPjwvc3Bhbj48c3BhbiBjbGFzcz1cImdjLWljb24gYm90dG9tXCI+PC9zcGFuPjwvZGl2PicpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2x1ZUluZGljYXRvckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50U3R5bGUgPSBkb21VdGlsLmdldFN0eWxlKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nTGVmdCA9IHBhcnNlU3R5bGVQcm9wZXJ0eVZhbHVlXyhlbGVtZW50U3R5bGUsIFBBRERJTkdfTEVGVCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhZGRpbmdSaWdodCA9IHBhcnNlU3R5bGVQcm9wZXJ0eVZhbHVlXyhlbGVtZW50U3R5bGUsIFBBRERJTkdfUklHSFQpO1xuXG4gICAgICAgICAgICAgICAgd2lkdGggPSB3aWR0aCAtIHBhZGRpbmdMZWZ0IC0gcGFkZGluZ1JpZ2h0IC0gMTY7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcignZGl2Jyk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICBpZiAod2lkdGggPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYuZHJhZ0Ryb3BpbmdJbmRpY2F0b3JFbGVtZW50XyA9IGNsdWVJbmRpY2F0b3JFbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGhpdFRlc3RHcm91cF8oZ3JvdXBJbmZvLCBoZWlnaHRMZWZ0LCBhY2NIZWlnaHQsIG9mZnNldExlZnQsIG9mZnNldFRvcCwgYXJlYSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgdWlkID0gc2VsZi5ncmlkLnVpZDtcbiAgICAgICAgICAgIHZhciBncm91cCA9IGdyb3VwSW5mby5kYXRhO1xuICAgICAgICAgICAgdmFyIGdyb3VwUGF0aCA9IGdyb3VwSW5mby5wYXRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGdyb3VwSW5mby5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIHZhciBsZW47XG4gICAgICAgICAgICB2YXIgZWxlbWVudDtcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB2YXIgb25Hcm91cFRvZ2dsZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGhpdEdyb3VwSW5mbztcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbjtcbiAgICAgICAgICAgIGlmIChoZWlnaHRMZWZ0IDw9IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IHNlbGYuZ2V0R3JvdXBIZWFkZXJIZWlnaHRfKGdyb3VwKTtcbiAgICAgICAgICAgICAgICAvL1RPRE86IGhvdyB0byBoYW5kbGUgY3VzdG9tIGhlYWRlciB0ZW1wbGF0ZVxuICAgICAgICAgICAgICAgIGlmIChoZWlnaHRMZWZ0IDw9IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJlYSA9PT0gUk9XX0hFQURFUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGl0R3JvdXBJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZWE6IFJPV19IRUFERVIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93OiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwSW5mbzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBncm91cFBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZWE6IEdST1VQX0hFQURFUlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmFsbG93SGVhZGVyU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZi5ncmlkLnVpZCArICctZ2hoJyArIGdyb3VwUGF0aC5qb2luKCctJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSByZWxhdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLmdjLWhlYWRlci1zZWxlY3QtaWNvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIHBvaW50SW5fLmNhbGwoc2VsZiwgb2Zmc2V0TGVmdCwgb2Zmc2V0VG9wIC0gYWNjSGVpZ2h0LCBlbGVtZW50LCByZWxhdGl2ZUVsZW1lbnQsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdEdyb3VwSW5mby5ncm91cEluZm8uY2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhpdEdyb3VwSW5mbztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHVpZCArIChzZWxmLmhhc0xlZnRQaW5uZWRDb2x1bW5fID8gJy1wZ2gnIDogJy1naCcpICsgZ3JvdXBQYXRoLmpvaW4oJ18nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gcmVsYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5nYy1ncm91cGluZy10b2dnbGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIHBvaW50SW5fLmNhbGwoc2VsZiwgb2Zmc2V0TGVmdCwgb2Zmc2V0VG9wIC0gYWNjSGVpZ2h0LCBlbGVtZW50LCByZWxhdGl2ZUVsZW1lbnQsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Hcm91cFRvZ2dsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZWE6IFZJRVdQT1JULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cEluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogZ3JvdXBQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmVhOiBHUk9VUF9IRUFERVIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXhwYW5kVG9nZ2xlOiBvbkdyb3VwVG9nZ2xlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0TGVmdCAtPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGFjY0hlaWdodCArPSBoZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwLmdyb3VwRGVzY3JpcHRvci5mb290ZXIgJiYgZ3JvdXAuZ3JvdXBEZXNjcmlwdG9yLmZvb3Rlci5jb2xsYXBzZVdpdGhHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICdncm91cCBoaXRUZXN0IGVycm9yJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlaWdodExlZnQgPD0gc2VsZi5nZXRHcm91cEZvb3RlckhlaWdodF8oZ3JvdXApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoaXRUZXN0R3JvdXBGb290ZXJfLmNhbGwoc2VsZiwgZ3JvdXBJbmZvLCBvZmZzZXRMZWZ0LCBvZmZzZXRUb3AsIGFyZWEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICdncm91cCBoaXRUZXN0IGVycm9yJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWdyb3VwSW5mby5pc0JvdHRvbUxldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IGdyb3VwSW5mby5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gc2VsZi5nZXRHcm91cEhlaWdodF8oY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoZWlnaHRMZWZ0IDw9IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGl0VGVzdEdyb3VwXy5jYWxsKHNlbGYsIGdyb3VwSW5mby5jaGlsZHJlbltpXSwgaGVpZ2h0TGVmdCwgYWNjSGVpZ2h0LCBvZmZzZXRMZWZ0LCBvZmZzZXRUb3AsIGFyZWEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHRMZWZ0IC09IGhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NIZWlnaHQgKz0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGl0R3JvdXBJbmZvID0gc2VsZi5oaXRUZXN0R3JvdXBDb250ZW50Xyhncm91cEluZm8sIGFyZWEsIG9mZnNldExlZnQsIG9mZnNldFRvcCAtIGFjY0hlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGl0R3JvdXBJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhpdEdyb3VwSW5mbztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGl0VGVzdEdyb3VwRm9vdGVyXy5jYWxsKHNlbGYsIGdyb3VwSW5mbywgb2Zmc2V0TGVmdCwgb2Zmc2V0VG9wLCBhcmVhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGhpdFRlc3RHcm91cEZvb3Rlcl8oZ3JvdXBJbmZvLCBvZmZzZXRMZWZ0LCBvZmZzZXRUb3AsIGFyZWEpIHtcbiAgICAgICAgICAgIHZhciBncm91cFBhdGggPSBncm91cEluZm8ucGF0aDtcbiAgICAgICAgICAgIGlmIChhcmVhID09PSBST1dfSEVBREVSKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYXJlYTogUk9XX0hFQURFUixcbiAgICAgICAgICAgICAgICAgICAgcm93OiAtMSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBJbmZvOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBncm91cFBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmVhOiBHUk9VUF9GT09URVIsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3c6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiAtMVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgdWlkID0gc2VsZi5ncmlkLnVpZDtcbiAgICAgICAgICAgIHZhciBjZWxsRWxlbWVudDtcbiAgICAgICAgICAgIHZhciBjZWxsT2Zmc2V0O1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgbGVuID0gc2VsZi5ncmlkLmNvbHVtbnMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGZvb3RlckVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh1aWQgKyAnLWdmJyArIGdyb3VwUGF0aC5qb2luKCdfJykpO1xuICAgICAgICAgICAgdmFyIGZvb3RlckVsZW1lbnRPZmZzZXQgPSBkb21VdGlsLm9mZnNldChmb290ZXJFbGVtZW50KTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2VsbEVsZW1lbnQgPSBmb290ZXJFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jJyArIGkpO1xuICAgICAgICAgICAgICAgIGlmIChjZWxsRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjZWxsT2Zmc2V0ID0gZG9tVXRpbC5vZmZzZXQoY2VsbEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IGNlbGxPZmZzZXQubGVmdCAtIGZvb3RlckVsZW1lbnRPZmZzZXQubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldExlZnQgPj0gbGVmdCAmJiBvZmZzZXRMZWZ0IDw9IChsZWZ0ICsgY2VsbEVsZW1lbnQuY2xpZW50V2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYXJlYTogVklFV1BPUlQsXG4gICAgICAgICAgICAgICAgcm93OiAtMSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IC0xLFxuICAgICAgICAgICAgICAgIGdyb3VwSW5mbzoge1xuICAgICAgICAgICAgICAgICAgICBwYXRoOiBncm91cFBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGFyZWE6IEdST1VQX0ZPT1RFUixcbiAgICAgICAgICAgICAgICAgICAgcm93OiAtMSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBpID09PSBsZW4gPyAtMSA6IGlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaGl0VGVzdFRvdWNoUGFuZWxfKGdyaWQsIGNvbHMsIG9mZnNldExlZnQsIG9mZnNldFRvcEZyb21DdXJyZW50Um93LCByb3dFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgYWN0aW9uVG91Y2hQYW5lbCA9IGdldFRvdWNoUGFuZWwoKTtcbiAgICAgICAgICAgIHZhciBhY3Rpb25Db2x1bW47XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIHZhciBhY3RJbmRleDtcbiAgICAgICAgICAgIHZhciBhY3RMZW47XG4gICAgICAgICAgICB2YXIgYWN0aW9uRWxlbWVudHM7XG4gICAgICAgICAgICB2YXIgYWN0aW9uO1xuICAgICAgICAgICAgaWYgKGFjdGlvblRvdWNoUGFuZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWN0aW9uTGVuID0gc3dpcGVTdGF0dXMuY29sdW1ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFjdGlvbkxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW5JbmRleCA9IHN3aXBlU3RhdHVzLmNvbHVtbnNbaV0uaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkNvbHVtbiA9IGFjdGlvblRvdWNoUGFuZWwucXVlcnlTZWxlY3RvcignLmdjLWFjdGlvbmNvbHVtbicgKyBjb2x1bW5JbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb25Db2x1bW4gJiYgcG9pbnRJbl8ob2Zmc2V0TGVmdCwgb2Zmc2V0VG9wRnJvbUN1cnJlbnRSb3csIGFjdGlvbkNvbHVtbiwgcm93RWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xzW2NvbHVtbkluZGV4XS5hY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25FbGVtZW50cyA9IGFjdGlvbkNvbHVtbi5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1hY3Rpb25dJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChhY3RJbmRleCA9IDAsIGFjdExlbiA9IGFjdGlvbkVsZW1lbnRzLmxlbmd0aDsgYWN0SW5kZXggPCBhY3RMZW47IGFjdEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50SW5fKG9mZnNldExlZnQsIG9mZnNldFRvcEZyb21DdXJyZW50Um93LCBhY3Rpb25FbGVtZW50c1thY3RJbmRleF0sIHJvd0VsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24gPSBncmlkLmdldEFjdGlvbkhhbmRsZXJfKGNvbHNbY29sdW1uSW5kZXhdLmlkLCBhY3Rpb25FbGVtZW50c1thY3RJbmRleF0uZ2V0QXR0cmlidXRlKCdkYXRhLWFjdGlvbicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0R3JvdXBJbnNlcnRpbmdMb2NhdGlvbl8obGVmdCwgdG9wKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZ3JpZCA9IHNlbGYuZ3JpZDtcbiAgICAgICAgICAgIHZhciBncm91cERlcyA9IGdyaWQuZGF0YS5ncm91cERlc2NyaXB0b3JzO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgbGVuID0gZ3JvdXBEZXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHRvID0gMDtcbiAgICAgICAgICAgIHZhciBncm91cGluZ0VsZW1lbnQ7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0O1xuICAgICAgICAgICAgdmFyIGdyb3VwaW5nUGFuZWxJbmZvID0gc2VsZi5oaXRUZXN0SW5mb18uZ3JvdXBpbmdQYW5lbEluZm87XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBncm91cGluZ1BhbmVsSW5mbyA/IGdyb3VwaW5nUGFuZWxJbmZvLmZpZWxkIDogJyc7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNMZWZ0ID0gMDtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c1RvcCA9IDA7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNIZWlnaHQgPSAwO1xuICAgICAgICAgICAgdmFyIGNsaWVudEhlaWdodDtcbiAgICAgICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICAgICAgICB0byA9IGxlbjtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBpbmdFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZ3JpZC51aWQgKyAnLWdyb3VwaW5nLWluZGljYXRvci0nICsgZ3JvdXBEZXNbaV0uZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICBjbGllbnRIZWlnaHQgPSBncm91cGluZ0VsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBkb21VdGlsLm9mZnNldChncm91cGluZ0VsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCA8IG9mZnNldC5sZWZ0ICYmIHRvcCA+PSBvZmZzZXQudG9wICYmIHRvcCA8PSAob2Zmc2V0LnRvcCArIGNsaWVudEhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXQubGVmdCA8IHByZXZpb3VzTGVmdCAmJiB0b3AgPj0gcHJldmlvdXNUb3AgJiYgdG9wIDw9IChwcmV2aW91c1RvcCArIHByZXZpb3VzSGVpZ2h0KSkgeyAvL2xpbmUgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzTGVmdCA9IG9mZnNldC5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1RvcCA9IG9mZnNldC50b3A7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzSGVpZ2h0ID0gY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBpbmdFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZ3JpZC51aWQgKyAnLWdyb3VwaW5nLWluZGljYXRvci0nICsgZmllbGQpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IGRvbVV0aWwub2Zmc2V0KGdyb3VwaW5nRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldC5sZWZ0IDw9IGxlZnQgJiYgbGVmdCA8PSAob2Zmc2V0LmxlZnQgKyBncm91cGluZ0VsZW1lbnQuY2xpZW50V2lkdGgpICYmIHRvcCA+PSBvZmZzZXQudG9wICYmIHRvcCA8PSAob2Zmc2V0LnRvcCArIGdyb3VwaW5nRWxlbWVudC5jbGllbnRIZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwRGVzW2ldLmZpZWxkID09PSBmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRvO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKHNlbmRlciwgZSkge1xuICAgICAgICAgICAgaGFuZGxlUG9pbnRlckRvd24oc2VuZGVyLCBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnQoc2VuZGVyLCBlKSB7XG4gICAgICAgICAgICB2YXIgYWdycyA9IHtwYWdlWDogZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYLCBwYWdlWTogZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZfTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVQb2ludGVyRG93bihzZW5kZXIsIGFncnMsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgZS5oYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJEb3duKHNlbmRlciwgZSwgdG91Y2hFdmVudCkge1xuICAgICAgICAgICAgdmFyIGdyaWQgPSBzZW5kZXI7XG4gICAgICAgICAgICB2YXIgZWRpdGluZ0hhbmRsZXIgPSBncmlkLmVkaXRpbmdIYW5kbGVyO1xuICAgICAgICAgICAgdmFyIGxheW91dEVuZ2luZSA9IGdyaWQubGF5b3V0RW5naW5lO1xuICAgICAgICAgICAgbGF5b3V0RW5naW5lLmhpdFRlc3RJbmZvXyA9IGxheW91dEVuZ2luZS5oaXRUZXN0KGUpO1xuICAgICAgICAgICAgdmFyIGhpdEluZm8gPSBsYXlvdXRFbmdpbmUuaGl0VGVzdEluZm9fO1xuICAgICAgICAgICAgaWYgKCFoaXRJbmZvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVkaXRpbmdIYW5kbGVyLmlzRWRpdGluZ18pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXlvdXRFbmdpbmUubW91c2VEb3duUG9pbnRfID0ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IGUucGFnZVgsXG4gICAgICAgICAgICAgICAgdG9wOiBlLnBhZ2VZXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgYXJlYSA9IGhpdEluZm8uYXJlYTtcbiAgICAgICAgICAgIHZhciBlbGVtZW50O1xuICAgICAgICAgICAgaWYgKGFyZWEgPT09IENPTFVNTl9IRUFERVIgfHwgYXJlYSA9PT0gUElOTkVEX0NPTFVNTl9IRUFERVIgfHwgYXJlYSA9PT0gUElOTkVEX1JJR0hUX0NPTFVNTl9IRUFERVIgfHwgYXJlYSA9PT0gR1JPVVBfRFJBR19QQU5FTCkge1xuICAgICAgICAgICAgICAgIGxheW91dEVuZ2luZS5kcmFnU3RhcnRJbmZvXyA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGluUmVzaXplR3JhcGhpY0FyZWEuY2FsbChsYXlvdXRFbmdpbmUuZ3JpZCwgZSkgJiYgdG91Y2hFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICBsYXlvdXRFbmdpbmUubW91c2VEb3duSGl0SW5mb18gPSBsYXlvdXRFbmdpbmUudG91Y2hEb3duSGl0SW5mb187XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoaXRJbmZvLmhlYWRlckluZm8gJiYgaGl0SW5mby5oZWFkZXJJbmZvLmluUmVzaXplTW9kZSAmJiAhdG91Y2hFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICBsYXlvdXRFbmdpbmUubW91c2VEb3duSGl0SW5mb18gPSBoaXRJbmZvO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FuU3RhcnREcmFnaW5nXy5jYWxsKGxheW91dEVuZ2luZSwgaGl0SW5mbykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0RW5naW5lLmRyYWdTdGFydEluZm9fID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGl0VGVzdEluZm86IF8uY2xvbmUoaGl0SW5mbywgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludE9mZnNldDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGUucGFnZVgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBlLnBhZ2VZXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmVhID09PSBUT09MUEFORUwgJiYgbGF5b3V0RW5naW5lLm9wdGlvbnMuYWxsb3dDb2x1bW5SZW9yZGVyICYmIGhpdEluZm8uY29sdW1uTGlzdEluZm8gJiYgaGl0SW5mby5jb2x1bW5MaXN0SW5mby5jb2x1bW4pIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gZ3JpZC5jb250YWluZXIucXVlcnlTZWxlY3RvcignLmdjLXRvb2wtcGFuZWwtY29udGFpbmVyIC5jb2x1bW4tbGlzdCBbZGF0YS1jb2wtaWQ9XCInICsgaGl0SW5mby5jb2x1bW5MaXN0SW5mby5jb2x1bW4gKyAnXCJdJyk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZSArICcgc2VsZWN0ZWQnO1xuICAgICAgICAgICAgICAgIGxheW91dEVuZ2luZS5kcmFnU3RhcnRDb2x1bW5fID0gaGl0SW5mby5jb2x1bW5MaXN0SW5mby5jb2x1bW47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZWEgPT09IFRPT0xQQU5FTCAmJiBoaXRJbmZvLmdyb3VwTGlzdEluZm8gJiYgaGl0SW5mby5ncm91cExpc3RJbmZvLmdyb3VwKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGdyaWQuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5nYy10b29sLXBhbmVsLWNvbnRhaW5lciAuZ3JvdXAtbGlzdCBbZGF0YS1ncm91cC1pZD1cIicgKyBoaXRJbmZvLmdyb3VwTGlzdEluZm8uZ3JvdXAgKyAnXCJdJyk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZSArICcgc2VsZWN0ZWQnO1xuICAgICAgICAgICAgICAgIGxheW91dEVuZ2luZS5kcmFnU3RhcnRHcm91cF8gPSBoaXRJbmZvLmdyb3VwTGlzdEluZm8uZ3JvdXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpblJlc2l6ZUdyYXBoaWNBcmVhKGUpIHtcbiAgICAgICAgICAgIHZhciBncmlkID0gdGhpcztcbiAgICAgICAgICAgIHZhciBncmFwaGljID0gZ2V0UmVzaXplR3JhcGhpYy5jYWxsKGdyaWQpO1xuICAgICAgICAgICAgaWYgKGdyYXBoaWMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZ3JpZC51aWQpO1xuICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJJbmZvID0gZG9tVXRpbC5nZXRDb250ZW50UmVjdChjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRMZWZ0ID0gZS5wYWdlWCAtIGNvbnRhaW5lckluZm8ubGVmdDtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0VG9wID0gZS5wYWdlWSAtIGNvbnRhaW5lckluZm8udG9wO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50SW5fKG9mZnNldExlZnQsIG9mZnNldFRvcCwgZ3JhcGhpYywgY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlXyhzZW5kZXIsIGUpIHtcbiAgICAgICAgICAgIHZhciBhZ3JzID0ge3BhZ2VYOiBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVgsIHBhZ2VZOiBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVl9O1xuICAgICAgICAgICAgaWYgKGhhbmRsZVBvaW50ZXJNb3ZlXy5jYWxsKHRoaXMsIHNlbmRlciwgYWdycywgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgZS5oYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZV8oc2VuZGVyLCBlKSB7XG4gICAgICAgICAgICBoYW5kbGVQb2ludGVyTW92ZV8uY2FsbCh0aGlzLCBzZW5kZXIsIGUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0UmVzaXppbmdDaGlsZENvdW50XyhncmlkLCBjYXB0aW9uLCBwaW5uZWQsIGluY2x1ZGVNaW4pIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbktleXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBjb2xUcmVlID0gZ3JpZC5jb2xUcmVlXztcbiAgICAgICAgICAgIF8uZWFjaChjb2xUcmVlLCBmdW5jdGlvbihpdGVtLCBrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5wYXJlbnQgPT09IGNhcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5LZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHZpc2libGVDb3VudCA9IDA7XG4gICAgICAgICAgICB2YXIgY29sO1xuICAgICAgICAgICAgXy5lYWNoKGNoaWxkcmVuS2V5cywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgLy9ncm91cCBoZWFkZXJcbiAgICAgICAgICAgICAgICBjb2wgPSBncmlkLmdldENvbEJ5SWRfKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKCFjb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZUNvdW50ICs9IGdldFJlc2l6aW5nQ2hpbGRDb3VudF8oZ3JpZCwga2V5LCBwaW5uZWQsIGluY2x1ZGVNaW4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZ3JpZC5pc0NvbFZpc2libGVfKGNvbCwgcGlubmVkKSAmJiAoKGluY2x1ZGVNaW4gJiYgY29sLnZpc2libGVXaWR0aCA+PSBNSU5fQ09MX1dJRFRIKSB8fCAoY29sLnZpc2libGVXaWR0aCA+IE1JTl9DT0xfV0lEVEgpKSkge1xuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlQ291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB2aXNpYmxlQ291bnQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZXNpemluZ0NvbHVtbkdyb3VwXyhncmlkLCBjYXB0aW9uLCBvZmZzZXQsIHBpbm5lZCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuS2V5cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGNvbFRyZWUgPSBncmlkLmNvbFRyZWVfO1xuICAgICAgICAgICAgXy5lYWNoKGNvbFRyZWUsIGZ1bmN0aW9uKGl0ZW0sIGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLnBhcmVudCA9PT0gY2FwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbktleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgdmlzaWJsZUNvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciByZXNpemVDb2xzXyA9IFtdO1xuICAgICAgICAgICAgdmFyIHJlc2l6ZUNvbEdyb3Vwc18gPSBbXTtcbiAgICAgICAgICAgIHZhciBjb2w7XG5cbiAgICAgICAgICAgIF8uZWFjaChjaGlsZHJlbktleXMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIC8vZ3JvdXAgaGVhZGVyXG4gICAgICAgICAgICAgICAgY29sID0gZ3JpZC5nZXRDb2xCeUlkXyhrZXkpO1xuICAgICAgICAgICAgICAgIGlmICghY29sICYmIChvZmZzZXQgPiAwIHx8IGdldFJlc2l6aW5nQ2hpbGRDb3VudF8oZ3JpZCwga2V5LCBwaW5uZWQsIGZhbHNlKSA+IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpc2libGVDb3VudCArPSAxO1xuICAgICAgICAgICAgICAgICAgICByZXNpemVDb2xHcm91cHNfLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCAmJiBncmlkLmlzQ29sVmlzaWJsZV8oY29sLCBwaW5uZWQpICYmICgob2Zmc2V0IDwgMCAmJiBjb2wudmlzaWJsZVdpZHRoID4gTUlOX0NPTF9XSURUSCkgfHwgb2Zmc2V0ID4gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZUNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZUNvbHNfLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGNoaWxkT2Zmc2V0ID0gTWF0aC5mbG9vcihvZmZzZXQgLyB2aXNpYmxlQ291bnQpO1xuICAgICAgICAgICAgdmFyIGxhc3RDb2w7XG4gICAgICAgICAgICB2YXIgbGFzdENvbEdyb3VwO1xuICAgICAgICAgICAgaWYgKHJlc2l6ZUNvbHNfLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0Q29sID0gcmVzaXplQ29sc19bcmVzaXplQ29sc18ubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgcmVzaXplQ29sc18gPSByZXNpemVDb2xzXy5zbGljZSgwLCByZXNpemVDb2xzXy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzaXplQ29sR3JvdXBzXy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGFzdENvbEdyb3VwID0gcmVzaXplQ29sR3JvdXBzX1tyZXNpemVDb2xHcm91cHNfLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIHJlc2l6ZUNvbEdyb3Vwc18gPSByZXNpemVDb2xHcm91cHNfLnNsaWNlKDAsIHJlc2l6ZUNvbEdyb3Vwc18ubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfLmVhY2gocmVzaXplQ29sc18sIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIGNvbCA9IGdyaWQuZ2V0Q29sQnlJZF8oa2V5KTtcbiAgICAgICAgICAgICAgICBjb2wudmlzaWJsZVdpZHRoID0gTWF0aC5tYXgoTUlOX0NPTF9XSURUSCwgY29sLnZpc2libGVXaWR0aCArIGNoaWxkT2Zmc2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXy5lYWNoKHJlc2l6ZUNvbEdyb3Vwc18sIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIHJlc2l6aW5nQ29sdW1uR3JvdXBfKGdyaWQsIGtleSwgY2hpbGRPZmZzZXQsIHBpbm5lZCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHJlbWFpbmluZ09mZnNldCA9IG9mZnNldCAtIGNoaWxkT2Zmc2V0ICogKHJlc2l6ZUNvbHNfLmxlbmd0aCArIHJlc2l6ZUNvbEdyb3Vwc18ubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChsYXN0Q29sKSB7XG4gICAgICAgICAgICAgICAgY29sID0gZ3JpZC5nZXRDb2xCeUlkXyhsYXN0Q29sKTtcbiAgICAgICAgICAgICAgICBjb2wudmlzaWJsZVdpZHRoID0gTWF0aC5tYXgoTUlOX0NPTF9XSURUSCwgY29sLnZpc2libGVXaWR0aCArIHJlbWFpbmluZ09mZnNldCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RDb2xHcm91cCkge1xuICAgICAgICAgICAgICAgIHJlc2l6aW5nQ29sdW1uR3JvdXBfKGdyaWQsIGxhc3RDb2xHcm91cCwgcmVtYWluaW5nT2Zmc2V0LCBwaW5uZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2FuUmVvcmRlckNvbHVtbl8oaGl0SW5mbykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGdyaWQgPSBzZWxmLmdyaWQ7XG4gICAgICAgICAgICB2YXIgY29scyA9IGdyaWQuY29sdW1ucztcbiAgICAgICAgICAgIGlmICghc2VsZi5vcHRpb25zLmFsbG93Q29sdW1uUmVvcmRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkcmFnU3RhcnRIaXRJbmZvID0gc2VsZi5kcmFnU3RhcnRJbmZvXy5oaXRUZXN0SW5mbztcbiAgICAgICAgICAgIHZhciBkcmFnQ29sdW1uSWQ7XG4gICAgICAgICAgICB2YXIgZHJvcENvbHVtbklkO1xuICAgICAgICAgICAgaWYgKGhpdEluZm8gJiYgKGhpdEluZm8uYXJlYSA9PT0gQ09MVU1OX0hFQURFUiB8fCBoaXRJbmZvLmFyZWEgPT09IFBJTk5FRF9DT0xVTU5fSEVBREVSIHx8IGhpdEluZm8uYXJlYSA9PT0gUElOTkVEX1JJR0hUX0NPTFVNTl9IRUFERVIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhpdEluZm8uY29sdW1uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBkcm9wQ29sdW1uSWQgPSBjb2xzW2hpdEluZm8uY29sdW1uXS5pZDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhpdEluZm8uY29sdW1uR3JvdXBJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyb3BDb2x1bW5JZCA9IGhpdEluZm8uY29sdW1uR3JvdXBJbmZvLmNhcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkcmFnU3RhcnRIaXRJbmZvLmNvbHVtbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0NvbHVtbklkID0gY29sc1tkcmFnU3RhcnRIaXRJbmZvLmNvbHVtbl0uaWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkcmFnU3RhcnRIaXRJbmZvLmNvbHVtbkdyb3VwSW5mbykge1xuICAgICAgICAgICAgICAgICAgICBkcmFnQ29sdW1uSWQgPSBkcmFnU3RhcnRIaXRJbmZvLmNvbHVtbkdyb3VwSW5mby5jYXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZHJhZ0FyZWEgPSBkcmFnU3RhcnRIaXRJbmZvLmFyZWE7XG4gICAgICAgICAgICAgICAgdmFyIGRyb3BBcmVhID0gaGl0SW5mby5hcmVhO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYW5SZW9yZGVyQ29sdW1uSW50ZXJuYWxfKGdyaWQsIGRyYWdDb2x1bW5JZCwgZHJvcENvbHVtbklkLCBkcmFnQXJlYSwgZHJvcEFyZWEsIGRyYWdTdGFydEhpdEluZm8uY29sdW1uLCBoaXRJbmZvLmNvbHVtbik7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNhblJlb3JkZXJDb2x1bW5JbnRlcm5hbF8oZ3JpZCwgZHJhZ0NvbHVtbklkLCBkcm9wQ29sdW1uSWQsIGRyYWdBcmVhLCBkcm9wQXJlYSwgZHJhZ0NvbHVtbiwgZHJvcENvbHVtbikge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGdyaWQuY29udGFpbmVyO1xuICAgICAgICAgICAgaWYgKGRyYWdDb2x1bW5JZCAhPT0gZHJvcENvbHVtbklkIHx8IGRyYWdBcmVhICE9PSBkcm9wQXJlYSkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvclByZWZpeCA9ICcjJyArIGdyaWQudWlkO1xuICAgICAgICAgICAgICAgIHZhciBkcmFnRWxlbWVudCA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yUHJlZml4ICsgJy0nICsgZHJhZ0FyZWEgKyAnIC5nYy1jb2x1bW4taGVhZGVyIFsnICsgKGRyYWdDb2x1bW4gIT09IC0xID8gJ2RhdGEtY29sdW1uJyA6ICdkYXRhLWNvbHVtbi1ncm91cC1oZWFkZXInKSArXG4gICAgICAgICAgICAgICAgICAgICc9XCInICsgZHJhZ0NvbHVtbklkICsgJ1wiXScpO1xuICAgICAgICAgICAgICAgIHZhciBkcm9wRWxlbWVudCA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yUHJlZml4ICsgJy0nICsgZHJvcEFyZWEgKyAnIC5nYy1jb2x1bW4taGVhZGVyIFsnICsgKGRyb3BDb2x1bW4gIT09IC0xID8gJ2RhdGEtY29sdW1uJyA6ICdkYXRhLWNvbHVtbi1ncm91cC1oZWFkZXInKSArXG4gICAgICAgICAgICAgICAgICAgICc9XCInICsgZHJvcENvbHVtbklkICsgJ1wiXScpO1xuICAgICAgICAgICAgICAgIHZhciBkcmFnRWxlbWVudFBhcmVudCA9IGRyYWdFbGVtZW50O1xuICAgICAgICAgICAgICAgIGlmIChkcmFnRWxlbWVudCA9PT0gbnVsbCB8fCBkcm9wRWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JpZC5jb2xUcmVlXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyaWQuY29sVHJlZV9bZHJhZ0NvbHVtbklkXS5wYXJlbnQgPT09IGdyaWQuY29sVHJlZV9bZHJvcENvbHVtbklkXS5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRyYWdBcmVhICE9PSBkcm9wQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWxDb2xzQ291bnQgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvclByZWZpeCArICctJyArIGRyYWdBcmVhICsgJyBbZGF0YS1jb2x1bW5dJykubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW92ZUNvbHNDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkcmFnQ29sdW1uID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVDb2xzQ291bnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBOb2RlID0gZHJhZ0VsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kTm9kZSA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yUHJlZml4ICsgJy0nICsgZHJhZ0FyZWEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRlbXBOb2RlICYmIHRlbXBOb2RlICE9PSBlbmROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBOb2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS1jb2x1bW4tZ3JvdXAnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcE5vZGUgPSB0ZW1wTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZUNvbHNDb3VudCA9IHRlbXBOb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWNvbHVtbl0nKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9uZWVkIGF0IGxlYXN0IG9uZSBjb2x1bW4gYXQgdGhlIGFyZWFcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvdGFsQ29sc0NvdW50ID09PSBtb3ZlQ29sc0NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vdmFyIG9mZnNldDEgPSBkb21VdGlsLmdldEVsZW1lbnRSZWN0KGRyYWdFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAvL3ZhciBvZmZzZXQyID0gZG9tVXRpbC5nZXRFbGVtZW50UmVjdChkcm9wRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgLy9pZiAoZHJhZ0FyZWEgPT09IGRyb3BBcmVhICYmIChvZmZzZXQxLmxlZnQgKyBvZmZzZXQxLndpZHRoID09PSBvZmZzZXQyLmxlZnQpKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vfVxuXG4gICAgICAgICAgICAgICAgdmFyIGluSXRzZWxmR3JvdXAgPSAoZHJhZ0NvbHVtbiA9PT0gLTEpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChkcmFnRWxlbWVudFBhcmVudCAmJiBkcmFnRWxlbWVudFBhcmVudCAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkcmFnRWxlbWVudFBhcmVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtY29sdW1uLWdyb3VwJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbkl0c2VsZkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5JdHNlbGZHcm91cCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkcmFnRWxlbWVudFBhcmVudCA9IGRyYWdFbGVtZW50UGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkcm9wRWxlbWVudFBhcmVudCA9IGRyb3BFbGVtZW50O1xuICAgICAgICAgICAgICAgIGluSXRzZWxmR3JvdXAgPSAoZHJvcENvbHVtbiA9PT0gLTEpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChkcm9wRWxlbWVudFBhcmVudCAmJiBkcm9wRWxlbWVudFBhcmVudCAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkcm9wRWxlbWVudFBhcmVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtY29sdW1uLWdyb3VwJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbkl0c2VsZkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5JdHNlbGZHcm91cCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkcm9wRWxlbWVudFBhcmVudCA9IGRyb3BFbGVtZW50UGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRyYWdFbGVtZW50UGFyZW50ID09PSBkcm9wRWxlbWVudFBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRyYWdFbGVtZW50UGFyZW50Lmhhc0F0dHJpYnV0ZSgnZGF0YS1jb2x1bW4tZ3JvdXAnKSAmJiBkcm9wRWxlbWVudFBhcmVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtY29sdW1uLWdyb3VwJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyYWdHcm91cEhlYWRlcjtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0VsZW1lbnRQYXJlbnQgPSBkcmFnRWxlbWVudFBhcmVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jb2x1bW4tZ3JvdXAtaGVhZGVyXScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZ0VsZW1lbnRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdHcm91cEhlYWRlciA9IGRyYWdFbGVtZW50UGFyZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1jb2x1bW4tZ3JvdXAtaGVhZGVyJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyb3BHcm91cEhlYWRlcjtcbiAgICAgICAgICAgICAgICAgICAgZHJvcEVsZW1lbnRQYXJlbnQgPSBkcm9wRWxlbWVudFBhcmVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jb2x1bW4tZ3JvdXAtaGVhZGVyXScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHJvcEVsZW1lbnRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BHcm91cEhlYWRlciA9IGRyb3BFbGVtZW50UGFyZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1jb2x1bW4tZ3JvdXAtaGVhZGVyJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRyYWdHcm91cEhlYWRlciAmJiBkcmFnR3JvdXBIZWFkZXIgPT09IGRyb3BHcm91cEhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJNb3ZlXyhzZW5kZXIsIGUsIG1vdXNlRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBncmlkID0gdGhpcztcbiAgICAgICAgICAgIHZhciBsYXlvdXRFbmdpbmUgPSBncmlkLmxheW91dEVuZ2luZTtcbiAgICAgICAgICAgIHZhciBvZmZzZXQ7XG4gICAgICAgICAgICB2YXIgaW5kaWNhdG9yRWxlbWVudDtcbiAgICAgICAgICAgIC8vY2FsbCBmcm9tIGRvY3VtZW50IG1vdXNlbW92ZVxuICAgICAgICAgICAgaWYgKCFlICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzZW5kZXIpID09PSAnW29iamVjdCBNb3VzZUV2ZW50XScpIHtcbiAgICAgICAgICAgICAgICBlID0gc2VuZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRvd25Qb2ludDtcbiAgICAgICAgICAgIHZhciBtb3VzZURvd25IaXRJbmZvID0gbGF5b3V0RW5naW5lLm1vdXNlRG93bkhpdEluZm9fO1xuICAgICAgICAgICAgdmFyIGdyb3VwRGVzID0gZ3JpZC5kYXRhLmdyb3VwRGVzY3JpcHRvcnM7XG4gICAgICAgICAgICB2YXIgY29sO1xuICAgICAgICAgICAgdmFyIGhpdEluZm8gPSBsYXlvdXRFbmdpbmUuaGl0VGVzdEluZm9fID0gbGF5b3V0RW5naW5lLmhpdFRlc3QoZSk7XG4gICAgICAgICAgICB2YXIgbGVuO1xuICAgICAgICAgICAgdmFyIG1pbldpZHRoID0gMDtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2hhbmRsZSBwb2ludGVyIG1vdmUnKTtcbiAgICAgICAgICAgIGlmIChsYXlvdXRFbmdpbmUuaXNSZXNpemluZ0NvbF8pIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBnZXRSZXNpemVFbGVtZW50U2VsZWN0b3IuY2FsbChncmlkKTtcbiAgICAgICAgICAgICAgICB2YXIgbW91c2VIaXRBcmVhID0gbW91c2VEb3duSGl0SW5mby5hcmVhO1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0TW9zdE9mZnNldDtcbiAgICAgICAgICAgICAgICB2YXIgcGFnZVg7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbiA9IG1vdXNlRG93bkhpdEluZm8uY29sdW1uO1xuICAgICAgICAgICAgICAgIHZhciBwaW5uZWQgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgaWYgKG1vdXNlSGl0QXJlYSA9PT0gUElOTkVEX0NPTFVNTl9IRUFERVIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGlubmVkID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobW91c2VIaXRBcmVhID09PSBQSU5ORURfQ09MVU1OX0hFQURFUikge1xuICAgICAgICAgICAgICAgICAgICBwaW5uZWQgPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWdyaWQub3B0aW9ucy5yb3dUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRNb3N0T2Zmc2V0ID0gTWF0aC5jZWlsKGRvbVV0aWwub2Zmc2V0KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpKS5sZWZ0ICsgTUlOX0NPTF9XSURUSCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobW91c2VEb3duSGl0SW5mby5jb2x1bW5Hcm91cEluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IGdldFJlc2l6aW5nQ2hpbGRDb3VudF8oZ3JpZCwgbW91c2VEb3duSGl0SW5mby5jb2x1bW5Hcm91cEluZm8uY2FwdGlvbiwgcGlubmVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRNb3N0T2Zmc2V0ID0gTWF0aC5jZWlsKGRvbVV0aWwub2Zmc2V0KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpKS5sZWZ0ICsgKGNvdW50ICogTUlOX0NPTF9XSURUSCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsYXlvdXRFbmdpbmUuY29sc1Jlc2l6ZUluZm9fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0Q29sc1Jlc2l6ZUluZm9fLmNhbGwobGF5b3V0RW5naW5lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNpemVJbmZvID0gbGF5b3V0RW5naW5lLmNvbHNSZXNpemVJbmZvX1tjb2x1bW5dO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sTGF5b3V0cyA9IGxheW91dEVuZ2luZS5jb2xMYXlvdXRzXztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbExheW91dCA9IGNvbExheW91dHNbY29sdW1uXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFmZmVjdGVkQ29scyA9IHJlc2l6ZUluZm8uYWZmZWN0ZWRDb2xzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gYWZmZWN0ZWRDb2xzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gYWZmZWN0ZWRDb2xzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgIT09IGNvbHVtbiAmJiBjb2xMYXlvdXQub2Zmc2V0LmxlZnQgPCBjb2xMYXlvdXRzW2NdLm9mZnNldC5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluV2lkdGggPSBNYXRoLm1heChtaW5XaWR0aCwgY29sTGF5b3V0c1tjXS5vZmZzZXQubGVmdCAtIGNvbExheW91dC5vZmZzZXQubGVmdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGggPSBNYXRoLm1heChtaW5XaWR0aCwgTUlOX0NPTF9XSURUSCk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRNb3N0T2Zmc2V0ID0gTWF0aC5mbG9vcihkb21VdGlsLm9mZnNldChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSkubGVmdCkgKyBtaW5XaWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFnZVggPSBNYXRoLm1heChlLnBhZ2VYLCBsZWZ0TW9zdE9mZnNldCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gcGFnZVggLSBsYXlvdXRFbmdpbmUucmVzaXppbmdMYXN0UG9pbnRfLmxlZnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ3JpZC5vcHRpb25zLnJvd1RlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW91c2VEb3duSGl0SW5mby5jb2x1bW4gPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IGdyaWQuY29sdW1uc1ttb3VzZURvd25IaXRJbmZvLmNvbHVtbl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sLnZpc2libGVXaWR0aCA9IGNvbC52aXNpYmxlV2lkdGggKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sLndpZHRoID0gY29sLnZpc2libGVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuZ2MtZ3JpZCcpLnN0eWxlLmN1cnNvciA9ICdjb2wtcmVzaXplJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobW91c2VEb3duSGl0SW5mby5jb2x1bW5Hcm91cEluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNpemluZ0NvbHVtbkdyb3VwXyhncmlkLCBtb3VzZURvd25IaXRJbmZvLmNvbHVtbkdyb3VwSW5mby5jYXB0aW9uLCBvZmZzZXQsIHBpbm5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE86IHN1cHBvcnQgcmVpc3plIGNvbHVtbiBncm91cFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vdXNlRG93bkhpdEluZm8uY29sdW1uID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sV2lkdGggPSBncmlkLmNvbHVtbnNbbW91c2VEb3duSGl0SW5mby5jb2x1bW5dLnZpc2libGVXaWR0aCArIG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZpeCBhIHdpcmVkIGJ1Zy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2RvbVV0aWwub2Zmc2V0KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpKS5sZWZ0IG1heSByZXR1cm4gZmxvYXQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2dyaWQuY29sdW1uc1ttb3VzZURvd25IaXRJbmZvLmNvbHVtbl0udmlzaWJsZVdpZHRoICsgb2Zmc2V0IHdpbGwgbm90IGVxdWFsIHRvIHRoZSBtaW5XaWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYWdlWCA9PT0gbGVmdE1vc3RPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sV2lkdGggPSBtaW5XaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGVtcGxhdGVDb2x1bW5XaWR0aF8uY2FsbChsYXlvdXRFbmdpbmUsIGNvbHVtbiwgY29sV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vZ3JpZC5pbnZhbGlkYXRlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUZW1wbGF0ZUNhY2hlXy5jYWxsKGxheW91dEVuZ2luZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3VzZUhpdEFyZWEgIT09IFBJTk5FRF9SSUdIVF9DT0xVTU5fSEVBREVSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmlkLmludmFsaWRhdGUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZC5yZWZyZXNoKFBJTk5FRF9SSUdIVF9DT0xVTU5fSEVBREVSKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyaWQucmVmcmVzaChQSU5ORURfUklHSFRfVklFV1BPUlQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmVzaXplR3JhcGhpY3MuY2FsbChncmlkLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXlvdXRFbmdpbmUucmVzaXppbmdMYXN0UG9pbnRfID0ge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBwYWdlWFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxheW91dEVuZ2luZS5pc0RyYWdEcm9waW5nXykge1xuICAgICAgICAgICAgICAgIHZhciBkcmFnU3RhcnRJbmZvID0gbGF5b3V0RW5naW5lLmRyYWdTdGFydEluZm9fO1xuICAgICAgICAgICAgICAgIHZhciBwb2ludE9mZnNldCA9IGRyYWdTdGFydEluZm8ucG9pbnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBsYXlvdXRFbmdpbmUuZHJhZ0Ryb3BpbmdFbGVtZW50XztcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnRvcCA9IGUucGFnZVkgKyBwb2ludE9mZnNldC50b3AgKyAncHgnO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUubGVmdCA9IGUucGFnZVggKyBwb2ludE9mZnNldC5sZWZ0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICBpZiAoaGl0SW5mbyAmJiBoaXRJbmZvLmFyZWEgPT09IEdST1VQX0RSQUdfUEFORUwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyYWdDb2x1bW4gPSBkcmFnU3RhcnRJbmZvLmhpdFRlc3RJbmZvLmNvbHVtbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRyYWdTdGFydEluZm8uaGl0VGVzdEluZm8uYXJlYSA9PT0gR1JPVVBfRFJBR19QQU5FTCB8fCAoZHJhZ0NvbHVtbiA+PSAwICYmIGdldEdyb3VwRGVzY3JpcHRvckluZGV4Xyhncm91cERlcywgZ3JpZC5jb2x1bW5zW2RyYWdDb2x1bW5dLmlkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dEVuZ2luZS5kcmFnRHJvcGluZ0VsZW1lbnRfLnF1ZXJ5U2VsZWN0b3IoJy5nYy1pY29uJykuY2xhc3NOYW1lID0gJ2djLWljb24gZ2MtaWNvbi1ncm91cGluZy1hZGQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvID0gZ2V0R3JvdXBJbnNlcnRpbmdMb2NhdGlvbl8uY2FsbChsYXlvdXRFbmdpbmUsIGUucGFnZVgsIGUucGFnZVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gZ3JvdXBEZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZCA9ICh0byA9PT0gbGVuID8gZ3JvdXBEZXNbbGVuIC0gMV0uZmllbGQgOiBncm91cERlc1t0b10uZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cGluZ0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChncmlkLnVpZCArICctZ3JvdXBpbmctaW5kaWNhdG9yLScgKyBmaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yRWxlbWVudCA9IGxheW91dEVuZ2luZS5kcmFnRHJvcGluZ0luZGljYXRvckVsZW1lbnRfO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGRvbVV0aWwub2Zmc2V0KGdyb3VwaW5nRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yRWxlbWVudC5zdHlsZS5sZWZ0ID0gKHRvIDwgbGVuID8gKG9mZnNldC5sZWZ0IC0gMTUpIDogKG9mZnNldC5sZWZ0ICsgZ3JvdXBpbmdFbGVtZW50LmNsaWVudFdpZHRoKSkgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGljYXRvckVsZW1lbnQuc3R5bGUudG9wID0gKG9mZnNldC50b3ApICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRpY2F0b3JFbGVtZW50LnN0eWxlLmhlaWdodCA9IGdyb3VwaW5nRWxlbWVudC5jbGllbnRIZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFuZWxFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZ3JpZC51aWQgKyAnLWdyb3VwaW5nUGFuZWwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRpY2F0b3JFbGVtZW50ID0gbGF5b3V0RW5naW5lLmRyYWdEcm9waW5nSW5kaWNhdG9yRWxlbWVudF87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gZG9tVXRpbC5vZmZzZXQocGFuZWxFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRpY2F0b3JFbGVtZW50LnN0eWxlLmxlZnQgPSBvZmZzZXQubGVmdCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yRWxlbWVudC5zdHlsZS50b3AgPSAob2Zmc2V0LnRvcCArIDgpICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRpY2F0b3JFbGVtZW50LnN0eWxlLmhlaWdodCA9ICcyMHB4JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dEVuZ2luZS5kcmFnRHJvcGluZ0luZGljYXRvckVsZW1lbnRfLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjYW5SZW9yZGVyQ29sdW1uXy5jYWxsKGxheW91dEVuZ2luZSwgaGl0SW5mbykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0RW5naW5lLmRyYWdEcm9waW5nRWxlbWVudF8ucXVlcnlTZWxlY3RvcignLmdjLWljb24nKS5jbGFzc05hbWUgPSAnZ2MtaWNvbiBnYy1pY29uLWdyb3VwaW5nLWFkZCc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkcm9wRWxlbWVudCA9IGdyaWQuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJyMnICsgZ3JpZC51aWQgKyAnLScgKyBoaXRJbmZvLmFyZWEgKyAnIC5nYy1jb2x1bW4taGVhZGVyIFsnICsgKGhpdEluZm8uY29sdW1uICE9PSAtMSA/ICdkYXRhLWNvbHVtbicgOiAnZGF0YS1jb2x1bW4tZ3JvdXAtaGVhZGVyJykgKyAnPVwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoaGl0SW5mby5jb2x1bW4gIT09IC0xID8gZ3JpZC5jb2x1bW5zW2hpdEluZm8uY29sdW1uXS5pZCA6IGhpdEluZm8uY29sdW1uR3JvdXBJbmZvLmNhcHRpb24pICsgJ1wiXScpO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBkb21VdGlsLm9mZnNldChkcm9wRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGluZGljYXRvckVsZW1lbnQgPSBsYXlvdXRFbmdpbmUuZHJhZ0Ryb3BpbmdJbmRpY2F0b3JFbGVtZW50XztcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yRWxlbWVudC5zdHlsZS5sZWZ0ID0gKG9mZnNldC5sZWZ0IC0gOCkgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICBpbmRpY2F0b3JFbGVtZW50LnN0eWxlLnRvcCA9IChvZmZzZXQudG9wKSArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIGluZGljYXRvckVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gZHJvcEVsZW1lbnQuY2xpZW50SGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsYXlvdXRFbmdpbmUuZHJhZ0Ryb3BpbmdFbGVtZW50Xy5xdWVyeVNlbGVjdG9yKCcuZ2MtaWNvbicpLmNsYXNzTmFtZSA9ICdnYy1pY29uIGdjLWljb24tZ3JvdXBpbmctZm9yYmlkZGVuJztcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0RW5naW5lLmRyYWdEcm9waW5nSW5kaWNhdG9yRWxlbWVudF8uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxheW91dEVuZ2luZS5kcmFnU3RhcnRDb2x1bW5fIHx8IGxheW91dEVuZ2luZS5kcmFnU3RhcnRHcm91cF8pIHtcbiAgICAgICAgICAgICAgICBpZiAobW91c2VFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICBsYXlvdXRFbmdpbmUuaGFuZGxlTW91c2VVcEZuXyA9IGhhbmRsZU1vdXNlVXBfLmJpbmQoZ3JpZCk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBsYXlvdXRFbmdpbmUuaGFuZGxlTW91c2VVcEZuXyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzZWwgPSBsYXlvdXRFbmdpbmUuZHJhZ1N0YXJ0Q29sdW1uXyA/ICcuY29sdW1uLWxpc3QtaXRlbScgOiAnLmdyb3VwLWxpc3QtaXRlbSc7XG4gICAgICAgICAgICAgICAgdmFyIG9sZERyb3BFbGVtZW50ID0gZ3JpZC5jb250YWluZXIucXVlcnlTZWxlY3RvcignLmdjLXRvb2wtcGFuZWwtY29udGFpbmVyICcgKyBzZWwgKyAnLmRyb3AtYWJvdmUnKTtcbiAgICAgICAgICAgICAgICBpZiAob2xkRHJvcEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkRHJvcEVsZW1lbnQuY2xhc3NOYW1lID0gb2xkRHJvcEVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UoJ2Ryb3AtYWJvdmUnLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9sZERyb3BFbGVtZW50ID0gZ3JpZC5jb250YWluZXIucXVlcnlTZWxlY3RvcignLmdjLXRvb2wtcGFuZWwtY29udGFpbmVyICcgKyBzZWwgKyAnLmRyb3AtYmVsb3cnKTtcbiAgICAgICAgICAgICAgICBpZiAob2xkRHJvcEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkRHJvcEVsZW1lbnQuY2xhc3NOYW1lID0gb2xkRHJvcEVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UoJ2Ryb3AtYmVsb3cnLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBncm91cExpc3RFbGVtZW50ID0gZ3JpZC5jb250YWluZXIucXVlcnlTZWxlY3RvcignLmdjLXRvb2wtcGFuZWwtY29udGFpbmVyIC5ncm91cC1saXN0Jyk7XG4gICAgICAgICAgICAgICAgZ3JvdXBMaXN0RWxlbWVudC5jbGFzc05hbWUgPSBncm91cExpc3RFbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKCdkcmFnLW92ZXInLCAnJyk7XG4gICAgICAgICAgICAgICAgaWYgKGhpdEluZm8gJiYgaGl0SW5mby5hcmVhID09PSBUT09MUEFORUwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxheW91dEVuZ2luZS5kcmFnU3RhcnRDb2x1bW5fICYmIGhpdEluZm8uY29sdW1uTGlzdEluZm8gJiYgaGl0SW5mby5jb2x1bW5MaXN0SW5mby5jb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkcmFnQ29sdW1uSW5kZXggPSBnZXRDb2xJbmRleF8uY2FsbChsYXlvdXRFbmdpbmUsIGxheW91dEVuZ2luZS5kcmFnU3RhcnRDb2x1bW5fKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkcm9wQ29sdW1uID0gaGl0SW5mby5jb2x1bW5MaXN0SW5mby5jb2x1bW47XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHJvcENvbHVtbkluZGV4ID0gZ2V0Q29sSW5kZXhfLmNhbGwobGF5b3V0RW5naW5lLCBkcm9wQ29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5SZW9yZGVyQ29sdW1uSW50ZXJuYWxfKGdyaWQsIGxheW91dEVuZ2luZS5kcmFnU3RhcnRDb2x1bW5fLCBkcm9wQ29sdW1uLCBnZXRDb2x1bW5BcmVhXy5jYWxsKGxheW91dEVuZ2luZSwgbGF5b3V0RW5naW5lLmRyYWdTdGFydENvbHVtbl8pLCBnZXRDb2x1bW5BcmVhXy5jYWxsKGxheW91dEVuZ2luZSwgZHJvcENvbHVtbiksIGRyYWdDb2x1bW5JbmRleCwgZHJvcENvbHVtbkluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xFbGVtZW50ID0gZ3JpZC5jb250YWluZXIucXVlcnlTZWxlY3RvcignLmdjLXRvb2wtcGFuZWwtY29udGFpbmVyIC5jb2x1bW4tbGlzdCBbZGF0YS1jb2wtaWQ9XCInICsgZHJvcENvbHVtbiArICdcIl0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xFbGVtZW50LmNsYXNzTmFtZSArPSAoKGRyYWdDb2x1bW5JbmRleCA8IGRyb3BDb2x1bW5JbmRleCkgPyAnIGRyb3AtYmVsb3cnIDogJyBkcm9wLWFib3ZlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGl0SW5mby5ncm91cExpc3RJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGF5b3V0RW5naW5lLmRyYWdTdGFydENvbHVtbl8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cExpc3RFbGVtZW50LmNsYXNzTmFtZSArPSAnIGRyYWctb3Zlcic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxheW91dEVuZ2luZS5kcmFnU3RhcnRHcm91cF8gJiYgaGl0SW5mby5ncm91cExpc3RJbmZvLmdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRyYWdHcm91cEluZGV4ID0gZ2V0R3JvdXBEZXNjcmlwdG9ySW5kZXhfKGdyaWQuZGF0YS5ncm91cERlc2NyaXB0b3JzLCBsYXlvdXRFbmdpbmUuZHJhZ1N0YXJ0R3JvdXBfKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHJvcEdyb3VwID0gaGl0SW5mby5ncm91cExpc3RJbmZvLmdyb3VwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkcm9wR3JvdXBJbmRleCA9IGdldEdyb3VwRGVzY3JpcHRvckluZGV4XyhncmlkLmRhdGEuZ3JvdXBEZXNjcmlwdG9ycywgZHJvcEdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZ0dyb3VwSW5kZXggIT09IC0xICYmIGRyYWdHcm91cEluZGV4ICE9PSBkcm9wR3JvdXBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBFbGVtZW50ID0gZ3JpZC5jb250YWluZXIucXVlcnlTZWxlY3RvcignLmdjLXRvb2wtcGFuZWwtY29udGFpbmVyIC5ncm91cC1saXN0IFtkYXRhLWdyb3VwLWlkPVwiJyArIGRyb3BHcm91cCArICdcIl0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBFbGVtZW50LmNsYXNzTmFtZSArPSAoKGRyYWdHcm91cEluZGV4IDwgZHJvcEdyb3VwSW5kZXgpID8gJyBkcm9wLWJlbG93JyA6ICcgZHJvcC1hYm92ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZG93blBvaW50ID0gbGF5b3V0RW5naW5lLm1vdXNlRG93blBvaW50XztcbiAgICAgICAgICAgICAgICBtb3VzZURvd25IaXRJbmZvID0gbGF5b3V0RW5naW5lLm1vdXNlRG93bkhpdEluZm9fO1xuICAgICAgICAgICAgICAgIHZhciBjdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgICAgICAgICAgICAgaWYgKGhpdEluZm8gJiYgKGhpdEluZm8uYXJlYSA9PT0gQ09MVU1OX0hFQURFUiB8fCBoaXRJbmZvLmFyZWEgPT09IFBJTk5FRF9DT0xVTU5fSEVBREVSIHx8IGhpdEluZm8uYXJlYSA9PT0gUElOTkVEX1JJR0hUX0NPTFVNTl9IRUFERVIpICYmIG1vdXNlRG93bkhpdEluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxheW91dEVuZ2luZS5vcHRpb25zLmFsbG93Q29sdW1uUmVzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRFbmdpbmUuaXNSZXNpemluZ0NvbF8gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0RW5naW5lLnJlc2l6aW5nTGFzdFBvaW50XyA9IGRvd25Qb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb3VzZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0RW5naW5lLmhhbmRsZU1vdXNlVXBGbl8gPSBoYW5kbGVNb3VzZVVwXy5iaW5kKGdyaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBsYXlvdXRFbmdpbmUuaGFuZGxlTW91c2VVcEZuXyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlUmVzaXplR3JhcGhpY3MuY2FsbChncmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGF5b3V0RW5naW5lLmRyYWdTdGFydEluZm9fICYmICFsYXlvdXRFbmdpbmUuaXNEcmFnRHJvcGluZ18gJiZcbiAgICAgICAgICAgICAgICAgICAgKChkb3duUG9pbnQgJiYgZS5wYWdlWCAhPT0gZG93blBvaW50LmxlZnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChkb3duUG9pbnQgJiYgZS5wYWdlWSAhPT0gZG93blBvaW50LnRvcCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdWNlc3MgPSBzdGFydERyYWdEcm9waW5nXy5jYWxsKGxheW91dEVuZ2luZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWNlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dEVuZ2luZS5pc0RyYWdEcm9waW5nXyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW91c2VFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dEVuZ2luZS5oYW5kbGVNb3VzZVVwRm5fID0gaGFuZGxlTW91c2VVcF8uYmluZChncmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZpeCBhIHdpcmVkIGJ1ZywgaWYgd2UgYmluZCBtb3VzZSBtb3ZlIGVhcmxpZXIgYXQgdGhlIHJlZ2lzdGVyIG1ldGhvZCwgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3dpbGwgZmFpbCB0byByZW1vdmUgdGhlIGV2ZW50IGxpc3Rlcm5lciBsYXRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRFbmdpbmUuaGFuZGxlTW91c2VNb3ZlRm4yXyA9IGhhbmRsZU1vdXNlTW92ZV8uYmluZChncmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBsYXlvdXRFbmdpbmUuaGFuZGxlTW91c2VNb3ZlRm4yXyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGxheW91dEVuZ2luZS5oYW5kbGVNb3VzZVVwRm5fKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc05hbWUgPSBkb2N1bWVudC5ib2R5LmNsYXNzTmFtZSArICcgbm8tc2VsZWN0JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvciA9ICdkZWZhdWx0JztcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0RW5naW5lLmN1cnNvcl8gPSBsYXlvdXRFbmdpbmUuY3Vyc29yXyB8fCAnZGVmYXVsdCc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoaXRJbmZvICYmIGhpdEluZm8uaGVhZGVySW5mbyAmJiBoaXRJbmZvLmhlYWRlckluZm8uaW5SZXNpemVNb2RlICYmIGxheW91dEVuZ2luZS5vcHRpb25zLmFsbG93Q29sdW1uUmVzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IgPSAnY29sLXJlc2l6ZSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxheW91dEVuZ2luZS5jdXJzb3JfICE9PSBjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dEVuZ2luZS5jdXJzb3JfID0gY3Vyc29yO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZC5jb250YWluZXIucXVlcnlTZWxlY3RvcignLmdjLWdyaWQnKS5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gISFsYXlvdXRFbmdpbmUuZHJhZ1N0YXJ0SW5mb18gfHwgbGF5b3V0RW5naW5lLmlzUmVzaXppbmdDb2xfIHx8IGxheW91dEVuZ2luZS5kcmFnU3RhcnRDb2x1bW5fIHx8IGxheW91dEVuZ2luZS5kcmFnU3RhcnRHcm91cF87XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRDb2x1bW5BcmVhXyhjb2xJZCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHNlbGYuZ3JpZC5jb250YWluZXI7XG4gICAgICAgICAgICB2YXIgaGVhZGVyRWxlbWVudHMgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnLmdjLWNvbHVtbkhlYWRlcicpO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgbGVuO1xuICAgICAgICAgICAgdmFyIGhlYWRlcjtcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWU7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBoZWFkZXJFbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGhlYWRlciA9IGhlYWRlckVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXIucXVlcnlTZWxlY3RvcignW2RhdGEtY29sdW1uPVwiJyArIGNvbElkICsgJ1wiXScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IGhlYWRlci5jbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUuaW5kZXhPZignZ2MtcGlubmVkLWxlZnQnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUElOTkVEX0NPTFVNTl9IRUFERVI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lLmluZGV4T2YoJ2djLXBpbm5lZC1yaWdodCcpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBJTk5FRF9SSUdIVF9DT0xVTU5fSEVBREVSO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDT0xVTU5fSEVBREVSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0UmVzaXplRWxlbWVudFNlbGVjdG9yKGhpdEluZm8pIHtcbiAgICAgICAgICAgIHZhciBncmlkID0gdGhpcztcbiAgICAgICAgICAgIHZhciBtb3VzZURvd25IaXRJbmZvID0gaGl0SW5mbyA/IGhpdEluZm8gOiBncmlkLmxheW91dEVuZ2luZS5tb3VzZURvd25IaXRJbmZvXztcbiAgICAgICAgICAgIGlmICghbW91c2VEb3duSGl0SW5mbykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1vdXNlSGl0QXJlYSA9IG1vdXNlRG93bkhpdEluZm8uYXJlYTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvciA9ICcjJyArIGdyaWQudWlkICsgJy0nICsgbW91c2VIaXRBcmVhO1xuICAgICAgICAgICAgaWYgKG1vdXNlRG93bkhpdEluZm8uY29sdW1uID49IDApIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciArPSAnIFtkYXRhLWNvbHVtbj1cIicgKyBncmlkLmNvbHVtbnNbbW91c2VEb3duSGl0SW5mby5jb2x1bW5dLmlkICsgJ1wiXSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yICs9ICcgW2RhdGEtY29sdW1uLWdyb3VwLWhlYWRlcj1cIicgKyBtb3VzZURvd25IaXRJbmZvLmNvbHVtbkdyb3VwSW5mby5jYXB0aW9uICsgJ1wiXSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFJlc2l6ZUdyYXBoaWMoKSB7XG4gICAgICAgICAgICB2YXIgZ3JpZCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgaWQgPSBncmlkLnVpZCArICctcmVzaXplR3JhcGhpYyc7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5zZXJ0UmVzaXplR3JhcGhpYyhoaXRJbmZvKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBnZXRSZXNpemVFbGVtZW50U2VsZWN0b3IuY2FsbChzZWxmLCBoaXRJbmZvKTtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxmLnVpZCk7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gMjQ7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSAyNDtcbiAgICAgICAgICAgIHNlbGYubGF5b3V0RW5naW5lLnRvdWNoRG93bkhpdEluZm9fID0gaGl0SW5mbztcblxuICAgICAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICB2YXIgZWxlUmVjdCA9IGRvbVV0aWwuZ2V0Q29udGVudFJlY3QoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lclJlY3QgPSBkb21VdGlsLmdldENvbnRlbnRSZWN0KGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBlbGVSZWN0LmxlZnQgLSBjb250YWluZXJSZWN0LmxlZnQ7XG4gICAgICAgICAgICAgICAgdmFyIHRvcCA9IGVsZVJlY3QudG9wIC0gY29udGFpbmVyUmVjdC50b3A7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gc2VsZi51aWQgKyAnLXJlc2l6ZUdyYXBoaWMnO1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSAnZ2MtcmVzaXplR3JhcGhpYyc7XG4gICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQgKyBlbGVSZWN0LndpZHRoIC0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHZhciBodG1sID0gJzxkaXYgaWQgPScgKyBpZCArICcgY2xhc3MgPScgKyBjbGFzc05hbWUgKyAnIHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OicgKyBoZWlnaHQgKyAncHg7d2lkdGg6JyArIHdpZHRoICsgJ3B4O2xlZnQ6JyArIGxlZnQgKyAncHg7dG9wOicgKyB0b3AgKyAncHg7XCI+PC9kaXY+JztcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZG9tVXRpbC5jcmVhdGVFbGVtZW50KGh0bWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVJlc2l6ZUdyYXBoaWNzKG9mZnNldFgpIHtcbiAgICAgICAgICAgIHZhciBncmlkID0gdGhpcztcbiAgICAgICAgICAgIHZhciByZXNpemVHcmFwaGljID0gZ2V0UmVzaXplR3JhcGhpYy5jYWxsKGdyaWQpO1xuICAgICAgICAgICAgaWYgKHJlc2l6ZUdyYXBoaWMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IHBhcnNlRmxvYXQocmVzaXplR3JhcGhpYy5zdHlsZS5sZWZ0KTtcbiAgICAgICAgICAgICAgICByZXNpemVHcmFwaGljLnN0eWxlLmxlZnQgPSAobGVmdCArIG9mZnNldFgpICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZVJlc2l6ZUdyYXBoaWNzKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHJlc2l6ZUdyYXBoaWMgPSBnZXRSZXNpemVHcmFwaGljLmNhbGwoc2VsZik7XG4gICAgICAgICAgICBpZiAocmVzaXplR3JhcGhpYykge1xuICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxmLnVpZCk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKHJlc2l6ZUdyYXBoaWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi50b3VjaERvd25IaXRJbmZvXyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzZXRUZW1wbGF0ZUNvbHVtbldpZHRoXyhjb2x1bW4sIHdpZHRoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY29scyA9IHNlbGYuZ3JpZC5jb2x1bW5zO1xuICAgICAgICAgICAgdmFyIGNvbCA9IGNvbHNbY29sdW1uXTtcbiAgICAgICAgICAgIHZhciBjb2xzUmVzaXplSW5mbyA9IHNlbGYuY29sc1Jlc2l6ZUluZm9fO1xuICAgICAgICAgICAgdmFyIHJlc2l6ZUluZm8gPSBjb2xzUmVzaXplSW5mb1tjb2x1bW5dO1xuICAgICAgICAgICAgdmFyIGFmZmVjdGVkQ29scyA9IHJlc2l6ZUluZm8uYWZmZWN0ZWRDb2xzO1xuICAgICAgICAgICAgdmFyIHNoaWZ0Q29scyA9IHJlc2l6ZUluZm8uc2hpZnRDb2xzO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgbGVuO1xuICAgICAgICAgICAgdmFyIGM7XG4gICAgICAgICAgICB2YXIgajtcbiAgICAgICAgICAgIHZhciBsZW4yO1xuICAgICAgICAgICAgdmFyIHdpZHRoT2Zmc2V0ID0gd2lkdGggLSBjb2wudmlzaWJsZVdpZHRoO1xuICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IGdldFVzZXJEZWZpbmVkVGVtcGxhdGVfLmNhbGwoc2VsZiwgZmFsc2UpO1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkaXYuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICB2YXIgY29sRWxlbWVudDtcbiAgICAgICAgICAgIHZhciBsZWZ0O1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gYWZmZWN0ZWRDb2xzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYyA9IGFmZmVjdGVkQ29sc1tpXTtcbiAgICAgICAgICAgICAgICBjb2wgPSBjb2xzW2NdO1xuICAgICAgICAgICAgICAgIGNvbEVsZW1lbnQgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWNvbHVtbj1cIicgKyBjb2wuaWQgKyAnXCJdJyk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sLnZpc2libGVXaWR0aCArPSB3aWR0aE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgY29sLndpZHRoID0gY29sLnZpc2libGVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgY29sRWxlbWVudC5zdHlsZS53aWR0aCA9IGNvbC52aXNpYmxlV2lkdGggKyAncHgnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IGNvbEVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Lmhhc0F0dHJpYnV0ZSgnZGF0YS1jb2x1bW4tZ3JvdXAnKSkge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHBhcmVudC5zdHlsZS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuc3R5bGUud2lkdGggPSAocGFyc2VJbnQod2lkdGgpICsgd2lkdGhPZmZzZXQpICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhcmVudFNoaWZ0ZWQgPSBbXTtcbiAgICAgICAgICAgIHZhciBhZmZjb2xzO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc2hpZnRDb2xzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYyA9IHNoaWZ0Q29sc1tpXTtcbiAgICAgICAgICAgICAgICBjb2wgPSBjb2xzW2NdO1xuICAgICAgICAgICAgICAgIGNvbEVsZW1lbnQgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWNvbHVtbj1cIicgKyBjb2wuaWQgKyAnXCJdJyk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGNvbEVsZW1lbnQuc3R5bGUubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbEVsZW1lbnQuc3R5bGUubGVmdCA9IChwYXJzZUludChsZWZ0KSArIHdpZHRoT2Zmc2V0KSArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXBhcmVudFNoaWZ0ZWRbY10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaXQgZG9uJ3QgaGF2ZSBwYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IGNvbEVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50Lmhhc0F0dHJpYnV0ZSgnZGF0YS1jb2x1bW4tZ3JvdXAnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gcGFyZW50LnN0eWxlLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuc3R5bGUubGVmdCA9IChwYXJzZUludChsZWZ0KSArIHdpZHRoT2Zmc2V0KSArICdweCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50U2hpZnRlZFtjXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmZmNvbHMgPSBjb2xzUmVzaXplSW5mb1tjXS5hZmZlY3RlZENvbHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbjIgPSBhZmZjb2xzLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50U2hpZnRlZFthZmZjb2xzW2pdXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnN1c3BlbmRUbXBsVXBkYXRlXyA9IHRydWU7XG4gICAgICAgICAgICBzZWxmLm9wdGlvbnMucm93VGVtcGxhdGUgPSBlbGVtZW50Lm91dGVySFRNTDtcbiAgICAgICAgICAgIHNlbGYuc3VzcGVuZFRtcGxVcGRhdGVfID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbml0Q29sc1Jlc2l6ZUluZm9fKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNvbHMgPSBzZWxmLmdyaWQuY29sdW1ucztcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgdmFyIGo7XG4gICAgICAgICAgICB2YXIgbGVuID0gY29scy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgY29sO1xuXG4gICAgICAgICAgICB2YXIgZGl2U3RyID0gJzxkaXYgc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTt0b3A6LTEwMDAwcHg7LTEwMDAwcHg7d2lkdGg6NTAwMHB4O2hlaWdodDo1MDAwcHg7XCI+JztcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IGdldFVzZXJEZWZpbmVkVGVtcGxhdGVfLmNhbGwoc2VsZiwgZmFsc2UpO1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkb21VdGlsLmNyZWF0ZVRlbXBsYXRlRWxlbWVudCh0ZW1wbGF0ZSk7XG4gICAgICAgICAgICBkaXZTdHIgKz0gZWxlbWVudC5pbm5lckhUTUwgKyAnPC9kaXY+JztcbiAgICAgICAgICAgIHZhciBkaXYgPSBkb21VdGlsLmNyZWF0ZUVsZW1lbnQoZGl2U3RyKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcblxuICAgICAgICAgICAgdmFyIGNvbExheW91dHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBjb2xFbGVtZW50O1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29sID0gY29sc1tpXTtcbiAgICAgICAgICAgICAgICBjb2xFbGVtZW50ID0gZGl2LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWNvbHVtbj1cIicgKyBjb2wuaWQgKyAnXCJdJyk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sTGF5b3V0c1tpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogZG9tVXRpbC5vZmZzZXQoY29sRWxlbWVudCksXG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0OiBkb21VdGlsLmdldEVsZW1lbnRSZWN0KGNvbEVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmNvbExheW91dHNfID0gY29sTGF5b3V0cztcbiAgICAgICAgICAgIHNlbGYuY29sc1Jlc2l6ZUluZm9fID0gW107XG5cbiAgICAgICAgICAgIHZhciBjb2xMYXlvdXQ7XG4gICAgICAgICAgICB2YXIgcmVzaXplQ29sRW5kWDtcbiAgICAgICAgICAgIHZhciBhZmZlY3RlZENvbHM7XG4gICAgICAgICAgICB2YXIgc2hpZnRDb2xzO1xuICAgICAgICAgICAgdmFyIGFub3RoZXJDb2xMYXlvdXQ7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbCA9IGNvbHNbaV07XG4gICAgICAgICAgICAgICAgY29sTGF5b3V0ID0gY29sTGF5b3V0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoY29sTGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZUNvbEVuZFggPSBjb2xMYXlvdXQucmVjdC53aWR0aCArIGNvbExheW91dC5vZmZzZXQubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRDb2xzID0gW2ldO1xuICAgICAgICAgICAgICAgICAgICBzaGlmdENvbHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiAhPT0gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFub3RoZXJDb2xMYXlvdXQgPSBjb2xMYXlvdXRzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2wudmlzaWJsZVdpZHRoID4gMCAmJiBhbm90aGVyQ29sTGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNpemVDb2xFbmRYID4gYW5vdGhlckNvbExheW91dC5vZmZzZXQubGVmdCAmJiByZXNpemVDb2xFbmRYIDw9IChhbm90aGVyQ29sTGF5b3V0Lm9mZnNldC5sZWZ0ICsgYW5vdGhlckNvbExheW91dC5yZWN0LndpZHRoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRDb2xzLnB1c2goaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYW5vdGhlckNvbExheW91dC5vZmZzZXQubGVmdCA+PSByZXNpemVDb2xFbmRYKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdENvbHMucHVzaChqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbHNSZXNpemVJbmZvX1tpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkQ29sczogYWZmZWN0ZWRDb2xzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRDb2xzOiBzaGlmdENvbHNcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaEVuZF8oc2VuZGVyLCBlKSB7XG4gICAgICAgICAgICB2YXIgYWdycyA9IHtwYWdlWDogZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCwgcGFnZVk6IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVl9O1xuICAgICAgICAgICAgaWYgKGhhbmRsZVBvaW50ZXJVcF8uY2FsbCh0aGlzLCBhZ3JzLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBlLmhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlTW91c2VVcF8oZSkge1xuICAgICAgICAgICAgaGFuZGxlUG9pbnRlclVwXy5jYWxsKHRoaXMsIGUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlUG9pbnRlclVwXyhlLCBtb3VzZUV2ZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnbW91c2UgdXAnKTtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcy5sYXlvdXRFbmdpbmU7XG4gICAgICAgICAgICB2YXIgZ3JpZCA9IHNlbGYuZ3JpZDtcbiAgICAgICAgICAgIHZhciBncm91cERlcyA9IGdyaWQuZGF0YS5ncm91cERlc2NyaXB0b3JzLnNsaWNlKCk7XG4gICAgICAgICAgICB2YXIgbmVlZEludmFsaWRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHN1Y2Nlc3M7XG4gICAgICAgICAgICB2YXIgZHJhZ0hpdEluZm87XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIHZhciBsZW47XG4gICAgICAgICAgICB2YXIgaGl0VGVzdEluZm8gPSBzZWxmLmhpdFRlc3RJbmZvXztcbiAgICAgICAgICAgIGlmIChzZWxmLmlzRHJhZ0Ryb3BpbmdfKSB7XG4gICAgICAgICAgICAgICAgZHJhZ0hpdEluZm8gPSBzZWxmLmRyYWdTdGFydEluZm9fLmhpdFRlc3RJbmZvO1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZDtcbiAgICAgICAgICAgICAgICBpZiAoaGl0VGVzdEluZm8gJiYgaGl0VGVzdEluZm8uYXJlYSA9PT0gR1JPVVBfRFJBR19QQU5FTCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG8gPSBnZXRHcm91cEluc2VydGluZ0xvY2F0aW9uXy5jYWxsKHNlbGYsIGUucGFnZVgsIGUucGFnZVkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBpbmdQYW5lbEluZm8gPSBzZWxmLmhpdFRlc3RJbmZvXy5ncm91cGluZ1BhbmVsSW5mbztcbiAgICAgICAgICAgICAgICAgICAgaWYgKChkcmFnSGl0SW5mby5hcmVhID09PSBDT0xVTU5fSEVBREVSIHx8IGRyYWdIaXRJbmZvLmFyZWEgPT09IFBJTk5FRF9DT0xVTU5fSEVBREVSIHx8IGRyYWdIaXRJbmZvLmFyZWEgPT09IFBJTk5FRF9SSUdIVF9DT0xVTU5fSEVBREVSKSAmJiBkcmFnSGl0SW5mby5jb2x1bW4gPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0dvcnVwQ29sSWQgPSBncmlkLmNvbHVtbnNbZHJhZ0hpdEluZm8uY29sdW1uXS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZXRHcm91cERlc2NyaXB0b3JJbmRleF8oZ3JvdXBEZXMsIG5ld0dvcnVwQ29sSWQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwRGVzLnNwbGljZSh0bywgMCwgXy5kZWZhdWx0cyh7ZmllbGQ6IG5ld0dvcnVwQ29sSWR9LCBzZWxmLmdldEdyb3VwSW5mb0RlZmF1bHRzXygpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZC5kYXRhLmdyb3VwRGVzY3JpcHRvcnMgPSBncm91cERlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkcmFnSGl0SW5mby5hcmVhID09PSBHUk9VUF9EUkFHX1BBTkVMICYmIGRyYWdIaXRJbmZvLmdyb3VwaW5nUGFuZWxJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJvbUdyb3VwRmllbGQgPSBkcmFnSGl0SW5mby5ncm91cGluZ1BhbmVsSW5mby5maWVsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkID0gZ3JvdXBpbmdQYW5lbEluZm8gPyBncm91cGluZ1BhbmVsSW5mby5maWVsZCA6ICcnO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQgPT09IGZyb21Hcm91cEZpZWxkIHx8ICghZmllbGQgJiYgZ3JvdXBEZXNbZ3JvdXBEZXMubGVuZ3RoIC0gMV0uZmllbGQgPT09IGZyb21Hcm91cEZpZWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRJbnZhbGlkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gZ3JvdXBEZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcm9tO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChncm91cERlc1tpXS5maWVsZCA9PT0gZnJvbUdyb3VwRmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPCB0bykgeyAvL2ZpeCBidWcsIGlmIHJlb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LCB3ZSBzaG91bGQgaW5zZXJ0IGJlZm9yZSB0byBpdGVtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvID0gdG8gLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG8gPT09IGZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVlZEludmFsaWRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cERlcy5zcGxpY2UodG8sIDAsIGdyb3VwRGVzLnNwbGljZShmcm9tLCAxKVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWQuZGF0YS5ncm91cERlc2NyaXB0b3JzID0gZ3JvdXBEZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjYW5SZW9yZGVyQ29sdW1uXy5jYWxsKHNlbGYsIGhpdFRlc3RJbmZvKSkge1xuICAgICAgICAgICAgICAgICAgICBkcmFnSGl0SW5mbyA9IHNlbGYuZHJhZ1N0YXJ0SW5mb18uaGl0VGVzdEluZm87XG4gICAgICAgICAgICAgICAgICAgIHZhciBwaW5uZWQgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoaXRUZXN0SW5mby5hcmVhID09PSBQSU5ORURfQ09MVU1OX0hFQURFUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGlubmVkID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhpdFRlc3RJbmZvLmFyZWEgPT09IFBJTk5FRF9SSUdIVF9DT0xVTU5fSEVBREVSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaW5uZWQgPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IGdldFVzZXJEZWZpbmVkVGVtcGxhdGVfLmNhbGwoc2VsZiwgcGlubmVkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW9yZGVyQ29sdW1uc1dpZHRoVGVtcGxhdGVfLmNhbGwoc2VsZiwgdGVtcGxhdGUsIGRyYWdIaXRJbmZvLmNvbHVtbkdyb3VwSW5mbyAmJiBkcmFnSGl0SW5mby5jb2x1bW5Hcm91cEluZm8uY2FwdGlvbiwgZHJhZ0hpdEluZm8uY29sdW1uLCBoaXRUZXN0SW5mby5hcmVhLCBoaXRUZXN0SW5mby5jb2x1bW5Hcm91cEluZm8gJiYgaGl0VGVzdEluZm8uY29sdW1uR3JvdXBJbmZvLmNhcHRpb24sIGhpdFRlc3RJbmZvLmNvbHVtbiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3VwZGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVvcmRlckNvbHVtbnNfLmNhbGwoc2VsZiwgZHJhZ0hpdEluZm8uYXJlYSwgZHJhZ0hpdEluZm8uY29sdW1uR3JvdXBJbmZvICYmIGRyYWdIaXRJbmZvLmNvbHVtbkdyb3VwSW5mby5jYXB0aW9uLCBkcmFnSGl0SW5mby5jb2x1bW4sIGhpdFRlc3RJbmZvLmFyZWEsIGhpdFRlc3RJbmZvLmNvbHVtbkdyb3VwSW5mbyAmJiBoaXRUZXN0SW5mby5jb2x1bW5Hcm91cEluZm8uY2FwdGlvbiwgaGl0VGVzdEluZm8uY29sdW1uLCBwaW5uZWQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgIC8vcmVtb3ZlIGdyb3VwaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChkcmFnSGl0SW5mby5hcmVhID09PSBHUk9VUF9EUkFHX1BBTkVMICYmIGRyYWdIaXRJbmZvLmdyb3VwaW5nUGFuZWxJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IGRyYWdIaXRJbmZvLmdyb3VwaW5nUGFuZWxJbmZvLmZpZWxkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9zZWxmLmdyaWQucmVtb3ZlR3JvdXAoZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5ncmlkLmRhdGEuZ3JvdXBEZXNjcmlwdG9ycyA9IF8ucmVtb3ZlKHNlbGYuZ3JpZC5kYXRhLmdyb3VwRGVzY3JpcHRvcnMsIGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5mby5maWVsZCAhPT0gZmllbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHNlbGYuZHJhZ0Ryb3BpbmdFbGVtZW50Xyk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzZWxmLmRyYWdEcm9waW5nSW5kaWNhdG9yRWxlbWVudF8pO1xuICAgICAgICAgICAgICAgIHNlbGYuZHJhZ0Ryb3BpbmdFbGVtZW50XyA9IG51bGw7XG4gICAgICAgICAgICAgICAgc2VsZi5kcmFnRHJvcGluZ0luZGljYXRvckVsZW1lbnRfID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAobW91c2VFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBzZWxmLmhhbmRsZU1vdXNlTW92ZUZuMl8pO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgc2VsZi5oYW5kbGVNb3VzZVVwRm5fKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5oYW5kbGVNb3VzZU1vdmVGbjJfID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5oYW5kbGVNb3VzZVVwRm5fID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTmFtZSA9IGRvY3VtZW50LmJvZHkuY2xhc3NOYW1lLnJlcGxhY2UoJ25vLXNlbGVjdCcsICcnKTtcbiAgICAgICAgICAgICAgICBpZiAobmVlZEludmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3VjY2VzcyA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYuaXNSZXNpemluZ0NvbF8pIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlc2l6aW5nTGFzdFBvaW50XyA9IG51bGw7XG4gICAgICAgICAgICAgICAgZ3JpZC5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYuZHJhZ1N0YXJ0Q29sdW1uXyB8fCBzZWxmLmRyYWdTdGFydEdyb3VwXykge1xuICAgICAgICAgICAgICAgIGlmIChoaXRUZXN0SW5mby5hcmVhID09PSBUT09MUEFORUwpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0RyYWdDb2x1bW5JblRvb2xQYW5lbC5jYWxsKHNlbGYsIGhpdFRlc3RJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdXNlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgc2VsZi5oYW5kbGVNb3VzZVVwRm5fKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZHJhZ1N0YXJ0Q29sdW1uXyA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLmRyYWdTdGFydEdyb3VwXyA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLmNvbHNSZXNpemVJbmZvXyA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLmNvbExheW91dHNfID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYuaXNSZXNpemluZ0NvbF8gPSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGYubW91c2VEb3duSGl0SW5mb18gPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5tb3VzZURvd25Qb2ludF8gPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5pc0RyYWdEcm9waW5nXyA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZi5kcmFnU3RhcnRJbmZvXyA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLmhpdFRlc3RJbmZvXyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gc3VjY2VzcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlb3JkZXJDb2x1bW5zV2lkdGhUZW1wbGF0ZV8odGVtcGxhdGUsIGRyYWdHcm91cENhcHRpb24sIGRyYWdDb2x1bW4sIGRyb3BBcmVhLCBkcm9wR3JvdXBDYXB0aW9uLCBkcm9wQ29sdW1uLCBpbnNlcnRCZWZvcmUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjb2xzID0gc2VsZi5ncmlkLmNvbHVtbnM7XG4gICAgICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gdGVtcGxhdGU7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGRpdi5jaGlsZHJlblswXTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvcjtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbENvbDtcbiAgICAgICAgICAgIHZhciBkZXN0Q29sO1xuICAgICAgICAgICAgaWYgKGRyYWdDb2x1bW4gPj0gMCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gJ1tkYXRhLWNvbHVtbj1cIicgKyBjb2xzW2RyYWdDb2x1bW5dLmlkICsgJ1wiXSc7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxDb2wgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkcmFnR3JvdXBDYXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSAnW2RhdGEtY29sdW1uLWdyb3VwLWhlYWRlcj1cIicgKyBkcmFnR3JvdXBDYXB0aW9uICsgJ1wiXSc7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxDb2wgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChvcmlnaW5hbENvbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxDb2wuaGFzQXR0cmlidXRlKCdkYXRhLWNvbHVtbi1ncm91cCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbENvbCA9IG9yaWdpbmFsQ29sLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRyb3BDb2x1bW4gPj0gMCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gJ1tkYXRhLWNvbHVtbj1cIicgKyBjb2xzW2Ryb3BDb2x1bW5dLmlkICsgJ1wiXSc7XG4gICAgICAgICAgICAgICAgZGVzdENvbCA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRyb3BHcm91cENhcHRpb24pIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9ICdbZGF0YS1jb2x1bW4tZ3JvdXAtaGVhZGVyPVwiJyArIGRyb3BHcm91cENhcHRpb24gKyAnXCJdJztcbiAgICAgICAgICAgICAgICBkZXN0Q29sID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZGVzdENvbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzdENvbC5oYXNBdHRyaWJ1dGUoJ2RhdGEtY29sdW1uLWdyb3VwJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlc3RDb2wgPSBkZXN0Q29sLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy92YXIgY2xvbmVPcmlnaW5hbENvbCA9IG9yaWdpbmFsQ29sLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgICAgIC8vdmFyIGNsb25lRGVzdENvbCA9IGRlc3RDb2wuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgICAgb3JpZ2luYWxDb2wucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChvcmlnaW5hbENvbCk7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0QmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgZGVzdENvbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShvcmlnaW5hbENvbCwgZGVzdENvbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlc3RDb2wucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUob3JpZ2luYWxDb2wsIGRlc3RDb2wubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5zdXNwZW5kVG1wbFVwZGF0ZV8gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGRyb3BBcmVhID09PSBQSU5ORURfQ09MVU1OX0hFQURFUikge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMucGlubmVkUm93VGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vcHRpb25zLnBpbm5lZFJvd1RlbXBsYXRlID0gZWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vcHRpb25zLnJvd1RlbXBsYXRlID0gZWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLm9wdGlvbnMucm93VGVtcGxhdGUgPSBlbGVtZW50Lm91dGVySFRNTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuc3VzcGVuZFRtcGxVcGRhdGVfID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChkcmFnQ29sdW1uID49IDAgJiYgZHJvcENvbHVtbiA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBjb2xzW2RyYWdDb2x1bW5dO1xuICAgICAgICAgICAgICAgIHZhciBkcm9wQ29sdW1uSWQgPSBjb2xzW2Ryb3BDb2x1bW5dLmlkO1xuICAgICAgICAgICAgICAgIGNvbHMuc3BsaWNlKGRyYWdDb2x1bW4sIDEpO1xuICAgICAgICAgICAgICAgIGRyb3BDb2x1bW4gPSBfLmZpbmRJbmRleChjb2xzLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmlkID09PSBkcm9wQ29sdW1uSWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29scy5zcGxpY2UoaW5zZXJ0QmVmb3JlID8gZHJvcENvbHVtbiA6IGRyb3BDb2x1bW4gKyAxLCAwLCB0ZW1wKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVvcmRlckNvbHVtbnNfKGRyYXBBcmVhLCBkcmFnR3JvdXBDYXB0aW9uLCBkcmFnQ29sdW1uLCBkcm9wQXJlYSwgZHJvcEdyb3VwQ2FwdGlvbiwgZHJvcENvbHVtbiwgcGlubmVkLCBpbnNlcnRCZWZvcmUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBncmlkID0gc2VsZi5ncmlkO1xuICAgICAgICAgICAgdmFyIGNvbHMgPSBncmlkLmNvbHVtbnM7XG4gICAgICAgICAgICB2YXIgcGFyZW50cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGNvbFRyZWUgPSBncmlkLmNvbFRyZWVfO1xuICAgICAgICAgICAgdmFyIHRlbXA7XG4gICAgICAgICAgICB0ZW1wID0gZHJhZ0NvbHVtbiA+PSAwID8gY29sc1tkcmFnQ29sdW1uXS5pZCA6IGRyYWdHcm91cENhcHRpb247XG4gICAgICAgICAgICBpZiAoZ3JpZC5jb2xUcmVlXykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBjb2xUcmVlW3RlbXBdLnBhcmVudDtcbiAgICAgICAgICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBjb2xUcmVlW3BhcmVudF0ucGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpO1xuXG4gICAgICAgICAgICB2YXIgcm9vdCA9IGdyaWQuY29sdW1uc0NvbmZpZ187XG4gICAgICAgICAgICB2YXIgajtcbiAgICAgICAgICAgIHZhciBsZW4yO1xuICAgICAgICAgICAgaWYgKHBhcmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IHBhcmVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9IHJvb3QuY29sdW1ucyB8fCByb290O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4yID0gcm9vdC5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb290W2pdLmNhcHRpb24gPT09IHBhcmVudHNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290ID0gcm9vdFtqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcm9vdCA9IHJvb3QuY29sdW1ucyB8fCByb290O1xuICAgICAgICAgICAgdmFyIGluZGV4MSA9IF8uZmluZEluZGV4KHJvb3QsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZHJhZ0NvbHVtbiA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmlkID09PSBjb2xzW2RyYWdDb2x1bW5dLmlkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmNhcHRpb24gPT09IGRyYWdHcm91cENhcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0ZW1wID0gcm9vdFtpbmRleDFdO1xuICAgICAgICAgICAgcm9vdC5zcGxpY2UoaW5kZXgxLCAxKTtcbiAgICAgICAgICAgIHZhciBpbmRleDIgPSBfLmZpbmRJbmRleChyb290LCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRyb3BDb2x1bW4gPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5pZCA9PT0gY29sc1tkcm9wQ29sdW1uXS5pZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5jYXB0aW9uID09PSBkcm9wR3JvdXBDYXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXgyID49IDApIHtcbiAgICAgICAgICAgICAgICByb290LnNwbGljZShpbnNlcnRCZWZvcmUgPyBpbmRleDIgOiBpbmRleDIgKyAxLCAwLCB0ZW1wKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcm9vdC5wdXNoKHRlbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRyYXBBcmVhICE9PSBkcm9wQXJlYSkge1xuICAgICAgICAgICAgICAgIHNldENvbHVtblBpbm5lZF8odGVtcCwgcGlubmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyaWQuY29sdW1ucyA9IGdyaWQuZmxhdHRlcm5Db2x1bW5zXyhncmlkLmNvbHVtbnNDb25maWdfKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNldENvbHVtblBpbm5lZF8oY29sLCBwaW5uZWQpIHtcbiAgICAgICAgICAgIGlmICghY29sLmNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICBjb2wucGlubmVkID0gcGlubmVkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgdmFyIGxlbjtcbiAgICAgICAgICAgIHZhciBjb2xzID0gY29sLmNvbHVtbnM7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb2xzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2V0Q29sdW1uUGlubmVkXyhjb2xzW2ldLCBwaW5uZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5Ub29sUGFuZWxfKGUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gZS5wYWdlWDtcbiAgICAgICAgICAgIHZhciB0b3AgPSBlLnBhZ2VZO1xuICAgICAgICAgICAgdmFyIGxheW91dEluZm8gPSBzZWxmLmdldExheW91dEluZm8oKTtcbiAgICAgICAgICAgIHZhciBlbXB0eUxheW91dCA9IHt3aWR0aDogMCwgaGVpZ2h0OiAwLCBjb250ZW50V2lkdGg6IDAsIGNvbnRlbnRIZWlnaHQ6IDB9O1xuICAgICAgICAgICAgdmFyIHRvb2xQYW5lbExheW91dCA9IGxheW91dEluZm9bVE9PTFBBTkVMXSB8fCBlbXB0eUxheW91dDtcbiAgICAgICAgICAgIHZhciBjb250YWluZXJJbmZvID0gc2VsZi5ncmlkLmdldENvbnRhaW5lckluZm9fKCkuY29udGVudFJlY3Q7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0TGVmdCA9IGxlZnQgLSBjb250YWluZXJJbmZvLmxlZnQ7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0VG9wID0gdG9wIC0gY29udGFpbmVySW5mby50b3A7XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSB7XG4gICAgICAgICAgICAgICAgbGVmdDogb2Zmc2V0TGVmdCxcbiAgICAgICAgICAgICAgICB0b3A6IG9mZnNldFRvcFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluc18odG9vbFBhbmVsTGF5b3V0LCBwb2ludCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZVdoZWVsKHNlbmRlciwgZSkge1xuICAgICAgICAgICAgdmFyIGdyaWQgPSBzZW5kZXI7XG4gICAgICAgICAgICB2YXIgbGF5b3V0RW5naW5lID0gZ3JpZC5sYXlvdXRFbmdpbmU7XG4gICAgICAgICAgICBpZiAobGF5b3V0RW5naW5lLm9wdGlvbnMuc2hvd1Rvb2xQYW5lbCAmJiBpblRvb2xQYW5lbF8uY2FsbChsYXlvdXRFbmdpbmUsIGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsYXlvdXRFbmdpbmUuc2hvd1Njcm9sbFBhbmVsKFZJRVdQT1JUKSAmJiAhbGF5b3V0RW5naW5lLnNob3dTY3JvbGxQYW5lbChQSU5ORURfUklHSFRfVklFV1BPUlQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgLy9zaW11bGF0ZSBzY3JvbGxcbiAgICAgICAgICAgIHZhciBvZmZzZXREZWx0YVkgPSBlLmRlbHRhWTtcbiAgICAgICAgICAgIHZhciBvZmZzZXREZWx0YVggPSBlLmRlbHRhWDtcbiAgICAgICAgICAgIGlmIChvZmZzZXREZWx0YVkgIT09IDAgfHwgb2Zmc2V0RGVsdGFYICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLypqc2hpbnQgLVcwNjkgKi9cbiAgICAgICAgICAgICAgICB2YXIgbGF5b3V0ID0gbGF5b3V0RW5naW5lLmdldExheW91dEluZm8oKVtWSUVXUE9SVF07XG4gICAgICAgICAgICAgICAgdmFyIG1heE9mZnNldFRvcCA9IE1hdGgubWF4KGxheW91dC5jb250ZW50SGVpZ2h0ICsgZ3JpZC5vcHRpb25zLmNvbEhlYWRlckhlaWdodCAtIGxheW91dC5oZWlnaHQsIDApO1xuICAgICAgICAgICAgICAgIHZhciBtYXhPZmZzZXRMZWZ0ID0gTWF0aC5tYXgobGF5b3V0LmNvbnRlbnRXaWR0aCAtIGxheW91dC53aWR0aCwgMCk7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldFRvcCA9IGdyaWQuc2Nyb2xsT2Zmc2V0LnRvcDtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0TGVmdCA9IGdyaWQuc2Nyb2xsT2Zmc2V0LmxlZnQ7XG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMob2Zmc2V0RGVsdGFYKSA8PSBNYXRoLmFicyhvZmZzZXREZWx0YVkpICYmIG9mZnNldERlbHRhWSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldFRvcCA+PSBtYXhPZmZzZXRUb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFRvcCA9IE1hdGgubWluKG9mZnNldFRvcCArIG9mZnNldERlbHRhWSwgbWF4T2Zmc2V0VG9wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkb21VdGlsLmdldEVsZW1lbnQoJyMnICsgZ3JpZC51aWQgKyAnIC5nYy1ncmlkLXZpZXdwb3J0LXNjcm9sbC1wYW5lbC5zY3JvbGwtdG9wJykuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMob2Zmc2V0RGVsdGFYKSA8PSBNYXRoLmFicyhvZmZzZXREZWx0YVkpICYmIG9mZnNldERlbHRhWSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldFRvcCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9wID0gTWF0aC5tYXgob2Zmc2V0VG9wICsgb2Zmc2V0RGVsdGFZLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkb21VdGlsLmdldEVsZW1lbnQoJyMnICsgZ3JpZC51aWQgKyAnIC5nYy1ncmlkLXZpZXdwb3J0LXNjcm9sbC1wYW5lbC5zY3JvbGwtdG9wJykuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMob2Zmc2V0RGVsdGFYKSA+IE1hdGguYWJzKG9mZnNldERlbHRhWSkgJiYgb2Zmc2V0RGVsdGFYID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0TGVmdCA+PSBtYXhPZmZzZXRMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxMZWZ0ID0gTWF0aC5taW4ob2Zmc2V0TGVmdCArIG9mZnNldERlbHRhWCwgbWF4T2Zmc2V0TGVmdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZG9tVXRpbC5nZXRFbGVtZW50KCcjJyArIGdyaWQudWlkICsgJyAuZ2MtZ3JpZC12aWV3cG9ydC1zY3JvbGwtcGFuZWwuc2Nyb2xsLWxlZnQnKS5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKG9mZnNldERlbHRhWCkgPiBNYXRoLmFicyhvZmZzZXREZWx0YVkpICYmIG9mZnNldERlbHRhWCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldExlZnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbExlZnQgPSBNYXRoLm1heChvZmZzZXRMZWZ0ICsgb2Zmc2V0RGVsdGFYLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkb21VdGlsLmdldEVsZW1lbnQoJyMnICsgZ3JpZC51aWQgKyAnIC5nYy1ncmlkLXZpZXdwb3J0LXNjcm9sbC1wYW5lbC5zY3JvbGwtbGVmdCcpLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ21vdXNlIHdoZWVsJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZUNsaWNrXyhzZW5kZXIsIGUsIHRvdWNoRXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdtb3VzZSBjbGljaycpO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSBzZW5kZXIubGF5b3V0RW5naW5lO1xuICAgICAgICAgICAgc2VsZi5tb3VzZURvd25Qb2ludF8gPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5tb3VzZURvd25IaXRJbmZvXyA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLmlzRHJhZ0Ryb3BpbmdfID0gZmFsc2U7XG4gICAgICAgICAgICBzZWxmLmRyYWdTdGFydEluZm9fID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYuaGl0VGVzdEluZm9fID0gc2VsZi5oaXRUZXN0KGUpO1xuICAgICAgICAgICAgdmFyIGhpdEluZm8gPSBzZWxmLmhpdFRlc3RJbmZvXztcbiAgICAgICAgICAgIGlmICghaGl0SW5mbykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoaXRBcmVhID0gaGl0SW5mby5hcmVhO1xuICAgICAgICAgICAgdmFyIGdyb3VwSW5mbztcbiAgICAgICAgICAgIHZhciBncm91cDtcbiAgICAgICAgICAgIHZhciBncmlkID0gc2VsZi5ncmlkO1xuICAgICAgICAgICAgdmFyIGVkaXRpbmdIYW5kbGVyID0gZ3JpZC5lZGl0aW5nSGFuZGxlcjtcblxuICAgICAgICAgICAgcmVtb3ZlUmVzaXplR3JhcGhpY3MuY2FsbChncmlkKTtcbiAgICAgICAgICAgIGlmIChlZGl0aW5nSGFuZGxlci5pc0VkaXRpbmdfICYmICFpc0VkaXRpbmdTYW1lUm93XyhoaXRJbmZvLCBlZGl0aW5nSGFuZGxlci5lZGl0aW5nSW5mb18pICYmIGdyaWQuaGFzRWRpdEFjdGlvbl8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYWN0aW9uSGFuZGxlcjtcbiAgICAgICAgICAgIGlmIChoaXRBcmVhID09PSBWSUVXUE9SVCB8fCBoaXRBcmVhID09PSBQSU5ORURfVklFV1BPUlQgfHwgaGl0QXJlYSA9PT0gUElOTkVEX1JJR0hUX1ZJRVdQT1JUKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uSGFuZGxlciA9IGhpdEluZm8uYWN0aW9uIHx8IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGl0QXJlYSA9PT0gR1JPVVBfRFJBR19QQU5FTCkge1xuICAgICAgICAgICAgICAgIHZhciBncm91cGluZ0luZm8gPSBoaXRJbmZvLmdyb3VwaW5nUGFuZWxJbmZvO1xuICAgICAgICAgICAgICAgIGlmIChncm91cGluZ0luZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwaW5nSW5mby5hY3Rpb24gPT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmdyaWQuZGF0YS5ncm91cERlc2NyaXB0b3JzID0gXy5yZW1vdmUoc2VsZi5ncmlkLmRhdGEuZ3JvdXBEZXNjcmlwdG9ycywgZnVuY3Rpb24oaW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmZvLmZpZWxkICE9PSBncm91cGluZ0luZm8uZmllbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGl0QXJlYSA9PT0gQ09MVU1OX0hFQURFUiB8fCBoaXRBcmVhID09PSBQSU5ORURfQ09MVU1OX0hFQURFUiB8fCBoaXRBcmVhID09PSBQSU5ORURfUklHSFRfQ09MVU1OX0hFQURFUikge1xuICAgICAgICAgICAgICAgIGlmIChoaXRJbmZvLmNvbHVtbkdyb3VwSW5mbyAmJiBoaXRJbmZvLmNvbHVtbkdyb3VwSW5mby5vbkV4cGFuZFRvZ2dsZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IGdyaWQuY29sVHJlZV9baGl0SW5mby5jb2x1bW5Hcm91cEluZm8uY2FwdGlvbl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChoaXRBcmVhID09PSBDT0xVTU5fSEVBREVSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvLnN0YXR1cy5pc0NvbGxhcHNlZCA9ICFpbmZvLnN0YXR1cy5pc0NvbGxhcHNlZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoaXRBcmVhID09PSBQSU5ORURfQ09MVU1OX0hFQURFUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5waW5uZWRTdGF0dXMuaXNDb2xsYXBzZWQgPSAhaW5mby5waW5uZWRTdGF0dXMuaXNDb2xsYXBzZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvLnBpbm5lZFJpZ2h0U3RhdHVzLmlzQ29sbGFwc2VkID0gIWluZm8ucGlubmVkUmlnaHRTdGF0dXMuaXNDb2xsYXBzZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlQ2xpY2tDb2xIZWFkZXJfLmNhbGwoc2VsZiwgaGl0SW5mbyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCgoaGl0SW5mby5oZWFkZXJJbmZvICYmIGhpdEluZm8uY29sdW1uID4gLTEpIHx8IGhpdEluZm8uY29sdW1uR3JvdXBJbmZvKSAmJiB0b3VjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydFJlc2l6ZUdyYXBoaWMuY2FsbChncmlkLCBoaXRJbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhpdEFyZWEgPT09IFZJRVdQT1JUIHx8IGhpdEFyZWEgPT09IFBJTk5FRF9WSUVXUE9SVCB8fCBoaXRBcmVhID09PSBQSU5ORURfUklHSFRfVklFV1BPUlQpIHtcbiAgICAgICAgICAgICAgICBncm91cEluZm8gPSBzZWxmLmhpdFRlc3RJbmZvXy5ncm91cEluZm87XG4gICAgICAgICAgICAgICAgaWYgKGhpdEluZm8uZ3JvdXBJbmZvICYmIGhpdEluZm8uZ3JvdXBJbmZvLmFyZWEgPT09IEdST1VQX0hFQURFUikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXBJbmZvICYmIGdyb3VwSW5mby5vbkV4cGFuZFRvZ2dsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXAgPSBncmlkLmdldEdyb3VwSW5mb18oZ3JvdXBJbmZvLnBhdGgpLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cC5jb2xsYXBzZWQgPSAhZ3JvdXAuY29sbGFwc2VkO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZC5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhpdEluZm8uZ3JvdXBJbmZvICYmIGhpdEluZm8uZ3JvdXBJbmZvLmFyZWEgPT09IEdST1VQX0NPTlRFTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uSGFuZGxlciA9IGhpdEluZm8uZ3JvdXBJbmZvLmFjdGlvbiB8fCBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChoaXRJbmZvLmluVHJlZU5vZGUgfHwgKGdyb3VwSW5mbyAmJiBncm91cEluZm8uaW5UcmVlTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlVHJlZU5vZGUoc2VsZik7XG4gICAgICAgICAgICAgICAgICAgIGdyaWQuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghZWRpdGluZ0hhbmRsZXIuaXNFZGl0aW5nXykge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24oc2VsZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vdmFyIGRhdGFJdGVtID0gZ3JpZC5nZXREYXRhSXRlbTJfKGhpdEluZm8uZ3JvdXBJbmZvID8gZ3JpZC5nZXRHcm91cEluZm9fKGhpdEluZm8uZ3JvdXBJbmZvLnBhdGgpLmRhdGEgOiBudWxsLCBoaXRJbmZvLmdyb3VwSW5mbyA/IGhpdEluZm8uZ3JvdXBJbmZvLnJvdyA6IGhpdEluZm8ucm93KTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25IYW5kbGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRNb2RlbDogZ3JpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdEluZm86IGhpdEluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhSXRlbTogZ2V0RGF0YUl0ZW0uY2FsbChzZWxmLmdyaWQsIGhpdEluZm8pLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VBY3Rpb25Db2x1bW5QYW5lbDogY2xvc2VUb3VjaFBhbmVsLmJpbmQoZ3JpZClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChoaXRBcmVhID09PSBST1dfSEVBREVSIHx8IGhpdEFyZWEgPT09IENPUk5FUl9IRUFERVIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGl0SW5mby5jaGVja2VkIHx8IChoaXRJbmZvLmdyb3VwSW5mbyAmJiBoaXRJbmZvLmdyb3VwSW5mby5jaGVja2VkKSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24oc2VsZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChoaXRBcmVhID09PSBUT09MUEFORUwpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sSWQgPSBoaXRJbmZvLmNvbHVtbkxpc3RJbmZvICYmIGhpdEluZm8uY29sdW1uTGlzdEluZm8uY29sdW1uO1xuICAgICAgICAgICAgICAgIHZhciBncm91cElkID0gaGl0SW5mby5ncm91cExpc3RJbmZvICYmIGhpdEluZm8uZ3JvdXBMaXN0SW5mby5ncm91cDtcbiAgICAgICAgICAgICAgICBpZiAoY29sSWQgJiYgaGl0SW5mby5jb2x1bW5MaXN0SW5mby5hY3Rpb24gPT09ICd2aXNpYmxlJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sID0gZ3JpZC5nZXRDb2xCeUlkXyhjb2xJZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbC52aXNpYmxlID0gIWNvbC52aXNpYmxlO1xuICAgICAgICAgICAgICAgICAgICBncmlkLmludmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhpdEluZm8uY29sdW1uTGlzdEluZm8gJiYgaGl0SW5mby5jb2x1bW5MaXN0SW5mby5hY3Rpb24gPT09ICdzaG93QWRkQ29sdW1uV2luZG93Jykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWRpdFBvcHVwT3ZlcmxheSA9IGRvbVV0aWwuY3JlYXRlRWxlbWVudCgnPGRpdiBjbGFzcz1cImdjLWVkaXRpbmctb3ZlcmxheVwiPjwvZGl2PicpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWRpdENvbnRhaW5lciA9IGRvbVV0aWwuY3JlYXRlRWxlbWVudCgnPGRpdiBpZD1cIicgKyBncmlkLnVpZCArICctcG9wdXAtYWRkQ29sdW1uXCIgY2xhc3M9XCJnYy1wb3B1cC1hZGQtY29sdW1uIGdjLWVkaXRpbmctYXJlYVwiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJnYy1wb3B1cC1oZWFkZXJcIj48c3BhbiBjbGFzcz1cImhlYWRlci10ZXh0XCI+QWRkIGNvbHVtbjwvc3Bhbj48ZGl2IGNsYXNzPVwiZ2MtZWRpdGluZy1jbG9zZVwiPjxzcGFuIGNsYXNzPVwiZ2MtaWNvbiBjbG9zZS1pY29uXCI+PC9zcGFuPjwvZGl2PjwvZGl2PicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJnYy1wb3B1cC1jb250ZW50XCI+JyArICc8dGV4dGFyZWEgc3R5bGU9XCJ3aWR0aDoxMDAlXCIgcm93cz1cIjNcIiBwbGFjZWhvbGRlcj1cImlucHV0IGNvbHVtbiBvciBjb2x1bW4gYXJyYXkgSlNPTiBvYmplY3RcIj48L3RleHRhcmVhPjxzcGFuIGNsYXNzPVwiZXJyb3ItdGV4dFwiPjxzcGFuPicgKyAnPC9kaXY+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImdjLXBvcHVwLWZvb3RlclwiPjxkaXYgY2xhc3M9XCJnYy1lZGl0aW5nLWNhbmNlbCBnYy1lZGl0aW5nLWJ1dHRvblwiPjxzcGFuIGNsYXNzPVwiY2FuY2VsLXRleHRcIj5DYW5jZWw8L3NwYW4+PC9kaXY+PGRpdiBjbGFzcz1cImdjLWVkaXRpbmctdXBkYXRlIGdjLWVkaXRpbmctYnV0dG9uXCI+PHNwYW4gY2xhc3M9XCJ1cGRhdGUtdGV4dFwiPkFkZDwvc3Bhbj48L2Rpdj48L2Rpdj48L2Rpdj4nKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGRDb2x1bW5XaW5kb3dNb3VzZURvd25IYW5kbGVyXyA9IGFkZENvbHVtbldpbmRvd01vdXNlRG93bkhhbmRsZXIuYmluZChzZWxmKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzZWxmLmFkZENvbHVtbldpbmRvd01vdXNlRG93bkhhbmRsZXJfKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlZGl0Q29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlZGl0UG9wdXBPdmVybGF5KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lclJlY3QgPSBkb21VdGlsLmdldEVsZW1lbnRSZWN0KGVkaXRDb250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IHBhcnNlSW50KCh3aW5kb3cuaW5uZXJXaWR0aCAtIGNvbnRhaW5lclJlY3Qud2lkdGgpIC8gMiArIHdpbmRvdy5wYWdlWE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3AgPSBwYXJzZUludCgod2luZG93LmlubmVySGVpZ2h0IC0gY29udGFpbmVyUmVjdC5oZWlnaHQpIC8gMiArIHdpbmRvdy5wYWdlWU9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGRvbVV0aWwuc2V0Q3NzKGVkaXRDb250YWluZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHRvcFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGdyb3VwSWQgJiYgaGl0SW5mby5ncm91cExpc3RJbmZvLmFjdGlvbiA9PT0gJ3JlbW92ZUdyb3VwJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcEdyb3VwRGVzID0gZ3JpZC5kYXRhLmdyb3VwRGVzY3JpcHRvcnMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcEdyb3VwRGVzLnNwbGljZShnZXRHcm91cERlc2NyaXB0b3JJbmRleF8odGVtcEdyb3VwRGVzLCBncm91cElkKSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGdyaWQuZGF0YS5ncm91cERlc2NyaXB0b3JzID0gdGVtcEdyb3VwRGVzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZEVsZW1lbnQgPSBncmlkLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuZ2MtdG9vbC1wYW5lbC1jb250YWluZXIgLnNlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEVsZW1lbnQuY2xhc3NOYW1lID0gc2VsZWN0ZWRFbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKCdzZWxlY3QnLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9wcm9jZXNzRHJhZ0NvbHVtbkluVG9vbFBhbmVsLmNhbGwoc2VsZiwgaGl0SW5mbyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzRHJhZ0NvbHVtbkluVG9vbFBhbmVsKGhpdEluZm8pIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBncmlkID0gc2VsZi5ncmlkO1xuICAgICAgICAgICAgdmFyIHRlbXBHcm91cERlcztcbiAgICAgICAgICAgIHZhciBkcmFnQ29sSWQgPSBzZWxmLmRyYWdTdGFydENvbHVtbl87XG4gICAgICAgICAgICB2YXIgZHJhZ0dyb3VwSWQgPSBzZWxmLmRyYWdTdGFydEdyb3VwXztcbiAgICAgICAgICAgIHNlbGYuZHJhZ1N0YXJ0Q29sdW1uXyA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLmRyYWdTdGFydEdyb3VwXyA9IG51bGw7XG4gICAgICAgICAgICB2YXIgY29sSWQgPSBoaXRJbmZvLmNvbHVtbkxpc3RJbmZvICYmIGhpdEluZm8uY29sdW1uTGlzdEluZm8uY29sdW1uO1xuICAgICAgICAgICAgdmFyIGdyb3VwSWQgPSBoaXRJbmZvLmdyb3VwTGlzdEluZm8gJiYgaGl0SW5mby5ncm91cExpc3RJbmZvLmdyb3VwO1xuICAgICAgICAgICAgaWYgKGNvbElkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRyYWdDb2xJZCAmJiBkcmFnQ29sSWQgIT09IGNvbElkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkcm9wRWxlbWVudCA9IGdyaWQuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5nYy10b29sLXBhbmVsLWNvbnRhaW5lciAuY29sdW1uLWxpc3QgW2RhdGEtY29sLWlkPVwiJyArIGNvbElkICsgJ1wiXScpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gZHJvcEVsZW1lbnQuY2xhc3NOYW1lO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHJvcENvbHVtbiA9IGdyaWQuZ2V0Q29sQnlJZF8oY29sSWQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGlubmVkID0gZHJvcENvbHVtbi5waW5uZWQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IGdldFVzZXJEZWZpbmVkVGVtcGxhdGVfLmNhbGwoc2VsZiwgcGlubmVkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lLmluZGV4T2YoJ2Ryb3AtYWJvdmUnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVvcmRlckNvbHVtbnNXaWR0aFRlbXBsYXRlXy5jYWxsKHNlbGYsIHRlbXBsYXRlLCBudWxsLCBnZXRDb2xJbmRleF8uY2FsbChzZWxmLCBkcmFnQ29sSWQpLCBnZXRDb2x1bW5BcmVhXy5jYWxsKHNlbGYsIGNvbElkKSwgbnVsbCwgZ2V0Q29sSW5kZXhfLmNhbGwoc2VsZiwgY29sSWQpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lLmluZGV4T2YoJ2Ryb3AtYmVsb3cnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVvcmRlckNvbHVtbnNXaWR0aFRlbXBsYXRlXy5jYWxsKHNlbGYsIHRlbXBsYXRlLCBudWxsLCBnZXRDb2xJbmRleF8uY2FsbChzZWxmLCBkcmFnQ29sSWQpLCBnZXRDb2x1bW5BcmVhXy5jYWxsKHNlbGYsIGNvbElkKSwgbnVsbCwgZ2V0Q29sSW5kZXhfLmNhbGwoc2VsZiwgY29sSWQpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lLmluZGV4T2YoJ2Ryb3AtYWJvdmUnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVvcmRlckNvbHVtbnNfLmNhbGwoc2VsZiwgZ2V0Q29sdW1uQXJlYV8uY2FsbChzZWxmLCBkcmFnQ29sSWQpLCBudWxsLCBnZXRDb2xJbmRleF8uY2FsbChzZWxmLCBkcmFnQ29sSWQpLCBnZXRDb2x1bW5BcmVhXy5jYWxsKHNlbGYsIGNvbElkKSwgbnVsbCwgZ2V0Q29sSW5kZXhfLmNhbGwoc2VsZiwgY29sSWQpLCBwaW5uZWQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUuaW5kZXhPZignZHJvcC1iZWxvdycpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW9yZGVyQ29sdW1uc18uY2FsbChzZWxmLCBnZXRDb2x1bW5BcmVhXy5jYWxsKHNlbGYsIGRyYWdDb2xJZCksIG51bGwsIGdldENvbEluZGV4Xy5jYWxsKHNlbGYsIGRyYWdDb2xJZCksIGdldENvbHVtbkFyZWFfLmNhbGwoc2VsZiwgY29sSWQpLCBudWxsLCBnZXRDb2xJbmRleF8uY2FsbChzZWxmLCBjb2xJZCksIHBpbm5lZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdyaWQuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZHJhZ0NvbElkICYmIGhpdEluZm8uZ3JvdXBMaXN0SW5mbykge1xuICAgICAgICAgICAgICAgIGlmIChnZXRHcm91cERlc2NyaXB0b3JJbmRleF8oZ3JpZC5kYXRhLmdyb3VwRGVzY3JpcHRvcnMsIGRyYWdDb2xJZCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBHcm91cERlcyA9IGdyaWQuZGF0YS5ncm91cERlc2NyaXB0b3JzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBHcm91cERlcy5wdXNoKF8uZGVmYXVsdHMoe2ZpZWxkOiBkcmFnQ29sSWR9LCBzZWxmLmdldEdyb3VwSW5mb0RlZmF1bHRzXygpKSk7XG4gICAgICAgICAgICAgICAgICAgIGdyaWQuZGF0YS5ncm91cERlc2NyaXB0b3JzID0gdGVtcEdyb3VwRGVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZHJhZ0dyb3VwSWQgJiYgaGl0SW5mby5ncm91cExpc3RJbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRyYWdHcm91cElkICE9PSBncm91cElkICYmIGdyb3VwSWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyb3BHcm91cEVsZW1lbnQgPSBncmlkLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuZ2MtdG9vbC1wYW5lbC1jb250YWluZXIgLmdyb3VwLWxpc3QgW2RhdGEtZ3JvdXAtaWQ9XCInICsgZ3JvdXBJZCArICdcIl0nKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyb3BHcm91cEVsZW1lbnRDbGFzc05hbWUgPSBkcm9wR3JvdXBFbGVtZW50LmNsYXNzTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcEdyb3VwRGVzID0gZ3JpZC5kYXRhLmdyb3VwRGVzY3JpcHRvcnMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldEl0ZW0gPSB0ZW1wR3JvdXBEZXMuc3BsaWNlKGdldEdyb3VwRGVzY3JpcHRvckluZGV4Xyh0ZW1wR3JvdXBEZXMsIGRyYWdHcm91cElkKSwgMSlbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnNlcnRJbmRleCA9IGdldEdyb3VwRGVzY3JpcHRvckluZGV4Xyh0ZW1wR3JvdXBEZXMsIGdyb3VwSWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHJvcEdyb3VwRWxlbWVudENsYXNzTmFtZS5pbmRleE9mKCdkcm9wLWFib3ZlJykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcEdyb3VwRGVzLnNwbGljZShpbnNlcnRJbmRleCwgMCwgdGFyZ2V0SXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZHJvcEdyb3VwRWxlbWVudENsYXNzTmFtZS5pbmRleE9mKCdkcm9wLWJlbG93JykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcEdyb3VwRGVzLnNwbGljZShpbnNlcnRJbmRleCArIDEsIDAsIHRhcmdldEl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdyaWQuZGF0YS5ncm91cERlc2NyaXB0b3JzID0gdGVtcEdyb3VwRGVzO1xuICAgICAgICAgICAgICAgICAgICBncmlkLmludmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRFbGVtZW50ID0gZ3JpZC5jb250YWluZXIucXVlcnlTZWxlY3RvcignLmdjLXRvb2wtcGFuZWwtY29udGFpbmVyIC5zZWxlY3RlZCcpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkRWxlbWVudC5jbGFzc05hbWUgPSBzZWxlY3RlZEVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UoJ3NlbGVjdCcsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBncm91cExpc3RFbGVtZW50ID0gZ3JpZC5jb250YWluZXIucXVlcnlTZWxlY3RvcignLmdjLXRvb2wtcGFuZWwtY29udGFpbmVyIC5ncm91cC1saXN0Jyk7XG4gICAgICAgICAgICBncm91cExpc3RFbGVtZW50LmNsYXNzTmFtZSA9IGdyb3VwTGlzdEVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UoJ2RyYWctb3ZlcicsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZUFkZENvbHVtbldpbmRvd18oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgb3ZlcmxheSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5nYy1lZGl0aW5nLW92ZXJsYXknKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQob3ZlcmxheSk7XG4gICAgICAgICAgICB2YXIgZWRpdG9yRm9ybSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbGYuZ3JpZC51aWQgKyAnLXBvcHVwLWFkZENvbHVtbicpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlZGl0b3JGb3JtKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc2VsZi5hZGRDb2x1bW5XaW5kb3dNb3VzZURvd25IYW5kbGVyXyk7XG4gICAgICAgICAgICBzZWxmLmFkZENvbHVtbldpbmRvd01vdXNlRG93bkhhbmRsZXJfID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZENvbHVtbldpbmRvd01vdXNlRG93bkhhbmRsZXIoZSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGdyaWQgPSBzZWxmLmdyaWQ7XG4gICAgICAgICAgICB2YXIgY3VyVGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gY3VyVGFyZ2V0LmNsYXNzTmFtZTtcbiAgICAgICAgICAgIHZhciB0YWdOYW1lID0gY3VyVGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBhcnIgPSBjbGFzc05hbWUgPyBjbGFzc05hbWUuc3BsaXQoJyAnKSA6IFtdO1xuICAgICAgICAgICAgd2hpbGUgKHRhZ05hbWUgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIGlmIChhcnIuaW5kZXhPZignZ2MtZWRpdGluZy1jbG9zZScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVBZGRDb2x1bW5XaW5kb3dfLmNhbGwoc2VsZik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJyLmluZGV4T2YoJ2djLWVkaXRpbmctdXBkYXRlJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWRpdFRleHRhcmVhID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignIycgKyBzZWxmLmdyaWQudWlkICsgJy1wb3B1cC1hZGRDb2x1bW4gdGV4dGFyZWEnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW5zID0gSlNPTi5wYXJzZShlZGl0VGV4dGFyZWEudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQWRkQ29sdW1uV2luZG93Xy5jYWxsKHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZC5pbnNlcnRDb2x1bW5zXyhjb2x1bW5zKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3JTcGFuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignIycgKyBzZWxmLmdyaWQudWlkICsgJy1wb3B1cC1hZGRDb2x1bW4gLmVycm9yLXRleHQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yU3Bhbi50ZXh0Q29udGVudCA9ICdpbnB1dCBpcyBub3QgYSB2YWxpZCBKU09OIG9iamVjdCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcnIuaW5kZXhPZignZ2MtZWRpdGluZy1jYW5jZWwnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQWRkQ29sdW1uV2luZG93Xy5jYWxsKHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyci5pbmRleE9mKCdnYy1wb3B1cC1oZWFkZXInKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGdyaWQudWlkICsgJy1wb3B1cC1hZGRDb2x1bW4nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGRDb2x1bW5XaW5kb3dNb3VzZU1vdmVIYW5kbGVyXyA9IGFkZENvbHVtbldpbmRvd01vdXNlTW92ZUhhbmRsZXJfLmJpbmQoc2VsZik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFkZENvbHVtbldpbmRvd01vdXNlVXBIYW5kbGVyXyA9IGFkZENvbHVtbldpbmRvd01vdXNlVXBIYW5kbGVyXy5iaW5kKHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgc2VsZi5hZGRDb2x1bW5XaW5kb3dNb3VzZU1vdmVIYW5kbGVyXyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgc2VsZi5hZGRDb2x1bW5XaW5kb3dNb3VzZVVwSGFuZGxlcl8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lck9mZnNldCA9IGRvbVV0aWwub2Zmc2V0KGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyU3R5bGUgPSBkb21VdGlsLmdldFN0eWxlKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyTWFyZ2luVG9wID0gcGFyc2VGbG9hdChjb250YWluZXJTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tdG9wJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lck1hcmdpbkxlZnQgPSBwYXJzZUZsb2F0KGNvbnRhaW5lclN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ21hcmdpbi1sZWZ0JykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zdGFydE1vdmVJbmZvXyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VzZU9mZnNldDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBlLnBhZ2VYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGUucGFnZVlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lck9mZnNldDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBjb250YWluZXJPZmZzZXQubGVmdCAtIGNvbnRhaW5lck1hcmdpbkxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogY29udGFpbmVyT2Zmc2V0LnRvcCAtIGNvbnRhaW5lck1hcmdpblRvcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1clRhcmdldCA9IGN1clRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIHRhZ05hbWUgPSBjdXJUYXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IGN1clRhcmdldC5jbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgYXJyID0gY2xhc3NOYW1lID8gY2xhc3NOYW1lLnNwbGl0KCcgJykgOiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZENvbHVtbldpbmRvd01vdXNlVXBIYW5kbGVyXygpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHNlbGYuc3RhcnRNb3ZlSW5mb18gPSBudWxsO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgc2VsZi5hZGRDb2x1bW5XaW5kb3dNb3VzZU1vdmVIYW5kbGVyXyk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgc2VsZi5hZGRDb2x1bW5XaW5kb3dNb3VzZVVwSGFuZGxlcl8pO1xuICAgICAgICAgICAgc2VsZi5kb2N1bWVudE1vdXNlTW92ZUhhbmRsZXJfID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYuZG9jdW1lbnRNb3VzZVVwSGFuZGxlcl8gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkQ29sdW1uV2luZG93TW91c2VNb3ZlSGFuZGxlcl8oZSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGluZm8gPSBzZWxmLnN0YXJ0TW92ZUluZm9fO1xuICAgICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZi5ncmlkLnVpZCArICctcG9wdXAtYWRkQ29sdW1uJyk7XG4gICAgICAgICAgICAgICAgdmFyIG1vdXNlT2Zmc2V0ID0gaW5mby5tb3VzZU9mZnNldDtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyT2Zmc2V0ID0gaW5mby5jb250YWluZXJPZmZzZXQ7XG4gICAgICAgICAgICAgICAgZG9tVXRpbC5zZXRDc3MoY29udGFpbmVyLCB7XG4gICAgICAgICAgICAgICAgICAgICdsZWZ0JzogY29udGFpbmVyT2Zmc2V0LmxlZnQgKyAoZS5wYWdlWCAtIG1vdXNlT2Zmc2V0LmxlZnQpLFxuICAgICAgICAgICAgICAgICAgICAndG9wJzogY29udGFpbmVyT2Zmc2V0LnRvcCArIChlLnBhZ2VZIC0gbW91c2VPZmZzZXQudG9wKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2tDb2xIZWFkZXJfKGhpdEluZm8pIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBncmlkID0gc2VsZi5ncmlkO1xuICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSBncmlkLmNvbHVtbnM7XG4gICAgICAgICAgICB2YXIgY29sID0gaGl0SW5mby5jb2x1bW47XG4gICAgICAgICAgICBpZiAoY29sID49IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sT2JqID0gY29sdW1uc1tjb2xdO1xuICAgICAgICAgICAgICAgIHZhciBjYW5Tb3J0ID0gY29sT2JqLmhhc093blByb3BlcnR5KCdhbGxvd1NvcnRpbmcnKSA/IGNvbE9iai5hbGxvd1NvcnRpbmcgOiBzZWxmLm9wdGlvbnMuYWxsb3dTb3J0aW5nO1xuICAgICAgICAgICAgICAgIGlmIChjYW5Tb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50U29ydEluZm8gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JpZC5kYXRhLnNvcnREZXNjcmlwdG9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNvcnRJbmZvID0gXy5maW5kKGdyaWQuZGF0YS5zb3J0RGVzY3JpcHRvcnMsIF8ubWF0Y2hlc1Byb3BlcnR5KCdmaWVsZCcsIGNvbE9iai5pZCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcFNvcnRJbmZvO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JpZC5vcHRpb25zLnNvcnRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wU29ydEluZm8gPSBfLmZpbmQoZ3JpZC5vcHRpb25zLnNvcnRpbmcsIF8ubWF0Y2hlc1Byb3BlcnR5KCdmaWVsZCcsIGNvbE9iai5pZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wU29ydEluZm8gJiYgIW9wU29ydEluZm8uaGFzT3duUHJvcGVydHkoJ2FzY2VuZGluZycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BTb3J0SW5mby5hc2NlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3BTb3J0SW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BTb3J0SW5mbyA9IHtmaWVsZDogY29sT2JqLmlkLCBhc2NlbmRpbmc6IHRydWV9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U29ydEluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U29ydEluZm8uYXNjZW5kaW5nICE9PSBvcFNvcnRJbmZvLmFzY2VuZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTb3J0SW5mbyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTb3J0SW5mby5hc2NlbmRpbmcgPSAhY3VycmVudFNvcnRJbmZvLmFzY2VuZGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTb3J0SW5mbyA9IF8uY2xvbmUob3BTb3J0SW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5kYXRhLnNvcnREZXNjcmlwdG9ycyA9IGN1cnJlbnRTb3J0SW5mbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXREYXRhSXRlbShoaXRJbmZvKSB7XG4gICAgICAgICAgICB2YXIgZGF0YUl0ZW07XG4gICAgICAgICAgICB2YXIgZ3JvdXBJbmZvO1xuICAgICAgICAgICAgdmFyIGdyb3VwO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKGhpdEluZm8uZ3JvdXBJbmZvICYmIGhpdEluZm8uZ3JvdXBJbmZvLmFyZWEgPT09IEdST1VQX0NPTlRFTlQpIHtcbiAgICAgICAgICAgICAgICBncm91cEluZm8gPSBoaXRJbmZvLmdyb3VwSW5mbztcbiAgICAgICAgICAgICAgICBncm91cCA9IHNlbGYuZ2V0R3JvdXBJbmZvXyhncm91cEluZm8ucGF0aCkuZGF0YTtcbiAgICAgICAgICAgICAgICBkYXRhSXRlbSA9IGdyb3VwLmdldEl0ZW0oZ3JvdXBJbmZvLnJvdyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGFJdGVtID0gc2VsZi5nZXREYXRhSXRlbShoaXRJbmZvLnJvdyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkYXRhSXRlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoVGFwKHNlbmRlciwgZSkge1xuICAgICAgICAgICAgaGFuZGxlTW91c2VDbGlja18oc2VuZGVyLCBlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoU2Nyb2xsKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgc2VsZi5zdG9wRWRpdGluZygpO1xuICAgICAgICAgICAgY2xvc2VUb3VjaFBhbmVsLmNhbGwoc2VsZik7XG4gICAgICAgICAgICByZW1vdmVSZXNpemVHcmFwaGljcy5jYWxsKHNlbGYpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlU3dpcGVfKHNlbmRlciwgZSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGxheW91dEVuZ2luZSA9IHNlbmRlci5sYXlvdXRFbmdpbmU7XG4gICAgICAgICAgICB2YXIgcmVsYXRlZFJvdztcblxuICAgICAgICAgICAgaWYgKGUuc3dpcGVTdGF0dXMgPT09ICdzd2lwZXN0YXJ0Jykge1xuICAgICAgICAgICAgICAgIHZhciBoaXRUZXN0SW5mb18gPSBsYXlvdXRFbmdpbmUuaGl0VGVzdCh7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2VYOiBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVgsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VZOiBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaGl0VGVzdEluZm9fICYmIGhpdFRlc3RJbmZvXy5hcmVhID09PSBWSUVXUE9SVCkge1xuICAgICAgICAgICAgICAgICAgICByZWxhdGVkUm93ID0gZ2V0UmVsYXRlZE1vdmVSb3cuY2FsbChsYXlvdXRFbmdpbmUsIGhpdFRlc3RJbmZvXyk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN3aXBlU3RhdHVzLnJvdyAmJiByZWxhdGVkUm93ICE9PSBzd2lwZVN0YXR1cy5yb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlVG91Y2hQYW5lbC5jYWxsKHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc3dpcGVTdGF0dXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgc3dpcGVTdGF0dXMucm93ID0gcmVsYXRlZFJvdztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN3aXBlU3RhdHVzLnJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpcGVTdGF0dXMuYWN0aW9uVHlwZSA9IGdldEFjdGlvblR5cGUoZS5tb3ZlRGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpcGVTdGF0dXMuY29sdW1ucyA9IGNyZWF0ZUFjdGlvbkNvbHVtbnMuY2FsbChsYXlvdXRFbmdpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpcGVTdGF0dXMuY29sdW1uc1RvdGFsV2lkdGggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5lYWNoKHN3aXBlU3RhdHVzLmNvbHVtbnMsIGZ1bmN0aW9uKGNvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXBlU3RhdHVzLmNvbHVtbnNUb3RhbFdpZHRoICs9IGNvbC5wZXJmZXJyZWRTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0VG91Y2hQYW5lbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2lwZVN0YXR1cy5iZWdpbldpdGhUb3VjaFBhbmVsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5zd2lwZVN0YXR1cyA9PT0gJ3N3aXBlbW92aW5nJykge1xuICAgICAgICAgICAgICAgIGlmIChzd2lwZVN0YXR1cy5yb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpcGVTdGF0dXMubW92ZURpc3RhbmNlID0gZS5tb3ZlRGlzdGFuY2UgKyAoc3dpcGVTdGF0dXMuYmVnaW5XaXRoVG91Y2hQYW5lbCA/IChzd2lwZVN0YXR1cy5hY3Rpb25UeXBlID09PSAnbGVmdCcgPyAxIDogLTEpICogc3dpcGVTdGF0dXMuY29sdW1uc1RvdGFsV2lkdGggOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmV2ZXJzZU1vdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaEFjdGlvblJvdy5jYWxsKHNlbGYsIC1zd2lwZVN0YXR1cy5tb3ZlRGlzdGFuY2UsIDApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKHN3aXBlU3RhdHVzLm1vdmVEaXN0YW5jZSkgPiBzd2lwZVN0YXR1cy5jb2x1bW5zVG90YWxXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaEFjdGlvblJvdy5jYWxsKHNlbGYsIC1zd2lwZVN0YXR1cy5tb3ZlRGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaEFjdGlvblJvdy5jYWxsKHNlbGYsIC1zd2lwZVN0YXR1cy5tb3ZlRGlzdGFuY2UsIE1hdGguYWJzKHN3aXBlU3RhdHVzLm1vdmVEaXN0YW5jZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc3dpcGVTdGF0dXMucm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXBlU3RhdHVzLm1vdmVEaXN0YW5jZSA9IGUubW92ZURpc3RhbmNlICsgKHN3aXBlU3RhdHVzLmJlZ2luV2l0aFRvdWNoUGFuZWwgPyAoc3dpcGVTdGF0dXMuYWN0aW9uVHlwZSA9PT0gJ2xlZnQnID8gMSA6IC0xKSAqIHN3aXBlU3RhdHVzLmNvbHVtbnNUb3RhbFdpZHRoIDogMCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gTWF0aC5hYnMoZS52ZWxvY2l0eSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1JldmVyc2VNb3ZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hBY3Rpb25Sb3cuY2FsbChzZWxmLCAwLCAwLCB0cnVlLCB2KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2ID4gRkxJQ0tfVEhSRVNIT0xEX1YpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzd2lwZVN0YXR1cy5iZWdpbldpdGhUb3VjaFBhbmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaEFjdGlvblJvdy5jYWxsKHNlbGYsIDAsIDAsIHRydWUsIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVGbGlja0dlc3R1cmUuY2FsbChzZWxmLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhzd2lwZVN0YXR1cy5tb3ZlRGlzdGFuY2UpIDwgc3dpcGVTdGF0dXMuY29sdW1uc1RvdGFsV2lkdGggLyAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaEFjdGlvblJvdy5jYWxsKHNlbGYsIDAsIDAsIHRydWUsIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoQWN0aW9uUm93LmNhbGwoc2VsZiwgKHN3aXBlU3RhdHVzLm1vdmVEaXN0YW5jZSA+IDAgPyAtMSA6IDEpICogc3dpcGVTdGF0dXMuY29sdW1uc1RvdGFsV2lkdGgsIHN3aXBlU3RhdHVzLmNvbHVtbnNUb3RhbFdpZHRoLCB0cnVlLCB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUZsaWNrR2VzdHVyZShlKSB7XG4gICAgICAgICAgICB2YXIgZ3JpZCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgbGF5b3V0RW5naW5lID0gZ3JpZC5sYXlvdXRFbmdpbmU7XG4gICAgICAgICAgICB2YXIgYWdycztcbiAgICAgICAgICAgIHZhciBoaXRJbmZvO1xuICAgICAgICAgICAgdmFyIGZuO1xuXG4gICAgICAgICAgICB2YXIgYWN0aW9uID0gZmluZEV4ZWN1dGVGbGlja0FjdGlvbi5jYWxsKGdyaWQpO1xuICAgICAgICAgICAgaWYgKGFjdGlvbiAmJiBhY3Rpb24uYWN0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHJlZnJlc2hBY3Rpb25Sb3cuY2FsbChncmlkLCAoc3dpcGVTdGF0dXMubW92ZURpc3RhbmNlID4gMCA/IC0xIDogMSkgKiBzd2lwZVN0YXR1cy5jb2x1bW5zVG90YWxXaWR0aCwgc3dpcGVTdGF0dXMuY29sdW1uc1RvdGFsV2lkdGgsIGZhbHNlLCBlLnZlbG9jaXR5KTtcbiAgICAgICAgICAgICAgICBhZ3JzID0ge3BhZ2VYOiBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYLCBwYWdlWTogZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWX07XG4gICAgICAgICAgICAgICAgbGF5b3V0RW5naW5lLmhpdFRlc3RJbmZvXyA9IGxheW91dEVuZ2luZS5oaXRUZXN0KGFncnMpO1xuICAgICAgICAgICAgICAgIGhpdEluZm8gPSBsYXlvdXRFbmdpbmUuaGl0VGVzdEluZm9fO1xuICAgICAgICAgICAgICAgIGZuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbi5hY3Rpb25IYW5kbGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRNb2RlbDogZ3JpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdEluZm86IGhpdEluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhSXRlbTogZ2V0RGF0YUl0ZW0uY2FsbChncmlkLCBoaXRJbmZvKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlQWN0aW9uQ29sdW1uUGFuZWw6IGNsb3NlVG91Y2hQYW5lbC5iaW5kKGdyaWQpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmbiwgMTAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVmcmVzaEFjdGlvblJvdy5jYWxsKGdyaWQsIChzd2lwZVN0YXR1cy5tb3ZlRGlzdGFuY2UgPiAwID8gLTEgOiAxKSAqIHN3aXBlU3RhdHVzLmNvbHVtbnNUb3RhbFdpZHRoLCBzd2lwZVN0YXR1cy5jb2x1bW5zVG90YWxXaWR0aCwgdHJ1ZSwgZS52ZWxvY2l0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmaW5kRXhlY3V0ZUZsaWNrQWN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGFjdGlvblByZXNlbnRlcjtcbiAgICAgICAgICAgIHZhciBhY3Rpb25IYW5kbGVyO1xuICAgICAgICAgICAgdmFyIGNvbDtcbiAgICAgICAgICAgIHZhciBhY3Rpb25JbmZvcztcbiAgICAgICAgICAgIHZhciBpdGVtO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgY29sbGVuZ3RoID0gc2VsZi5jb2x1bW5zLmxlbmd0aDsgaSA8IGNvbGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29sID0gc2VsZi5jb2x1bW5zW2ldO1xuICAgICAgICAgICAgICAgIGFjdGlvbkluZm9zID0gc2VsZi5jb2x1bW5BY3Rpb25zX1tjb2wuaWRdO1xuICAgICAgICAgICAgICAgIGlmICghYWN0aW9uSW5mb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbmd0aCA9IGFjdGlvbkluZm9zLmxlbmd0aDsgaiA8IGxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBhY3Rpb25JbmZvc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uZmxpY2tBY3Rpb24gPT09IHN3aXBlU3RhdHVzLmFjdGlvblR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvblByZXNlbnRlciA9IChpdGVtLnByZXNlbnRlciA/IGl0ZW0ucHJlc2VudGVyIDogKCc8YnV0dG9uIGNsYXNzPVwiZ2MtYWN0aW9uXCIgZGF0YS1hY3Rpb249XCInICsgaXRlbS5uYW1lICsgJ1wiPicgKyBpdGVtLm5hbWUgKyAnPC9idXR0b24+JykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uSGFuZGxlciA9IHNlbGYuZ2V0QWN0aW9uSGFuZGxlcl8oY29sLmlkLCBpdGVtLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uUHJlc2VudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFjdGlvblByZXNlbnRlciAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwcmVzZW50ZXI6ICc8ZGl2IGNsYXNzPVwiZ2MtYWN0aW9uLWFyZWFcIj4nICsgYWN0aW9uUHJlc2VudGVyICsgJzwvZGl2PicsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkhhbmRsZXI6IGFjdGlvbkhhbmRsZXJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEFjdGlvblR5cGUobW92ZURpc3RhbmNlKSB7XG4gICAgICAgICAgICB2YXIgYWN0aW9uUGFuZWw7XG4gICAgICAgICAgICB2YXIgYWNUeXBlO1xuICAgICAgICAgICAgXy5lYWNoKFsnbGVmdCcsICdyaWdodCddLCBmdW5jdGlvbihhY3Rpb25UeXBlKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uUGFuZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzd2lwZVN0YXR1cy5yb3cuaWQgKyAnLScgKyBhY3Rpb25UeXBlICsgJy1hY3Rpb25QYW5lbCcpO1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb25QYW5lbCkge1xuICAgICAgICAgICAgICAgICAgICBhY1R5cGUgPSBhY3Rpb25UeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWFjVHlwZSkge1xuICAgICAgICAgICAgICAgIGFjVHlwZSA9IG1vdmVEaXN0YW5jZSA+IDAgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYWNUeXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0VG91Y2hQYW5lbCgpIHtcbiAgICAgICAgICAgIGlmIChzd2lwZVN0YXR1cy5yb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc3dpcGVTdGF0dXMucm93LmlkICsgJy1sZWZ0LWFjdGlvblBhbmVsJykgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc3dpcGVTdGF0dXMucm93LmlkICsgJy1yaWdodC1hY3Rpb25QYW5lbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNSZXZlcnNlTW92ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiAoc3dpcGVTdGF0dXMubW92ZURpc3RhbmNlID4gMCA/ICdsZWZ0JyA6ICdyaWdodCcpICE9PSBzd2lwZVN0YXR1cy5hY3Rpb25UeXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVmcmVzaEFjdGlvblJvdyhyb3dsZWZ0LCBwYW5lbFdpZHRoLCB1c2VBbmltYXRpb24sIHZlbG9jaXR5KSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmICghc3dpcGVTdGF0dXMucm93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodXNlQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRSb3dsZWZ0ID0gcGFyc2VGbG9hdChzd2lwZVN0YXR1cy5yb3cuc3R5bGUubGVmdCk7XG4gICAgICAgICAgICAgICAgdmFyIHRvdWNoUGFuZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzd2lwZVN0YXR1cy5yb3cuaWQgKyAnLScgKyBzd2lwZVN0YXR1cy5hY3Rpb25UeXBlICsgJy1hY3Rpb25QYW5lbCcpO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50UGFuZWxXaWR0aCA9IHRvdWNoUGFuZWwgPyBwYXJzZUZsb2F0KHRvdWNoUGFuZWwuc3R5bGUud2lkdGgpIDogMDtcblxuICAgICAgICAgICAgICAgIHZhciByb3dPZmZzZXQgPSByb3dsZWZ0IC0gY3VycmVudFJvd2xlZnQ7XG4gICAgICAgICAgICAgICAgdmFyIHBhbmVsT2Zmc2V0ID0gcGFuZWxXaWR0aCAtIGN1cnJlbnRQYW5lbFdpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IDAuMjUgKiAoMSAvIHZlbG9jaXR5KTtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IGR1cmF0aW9uID4gMC4xMCA/IDAuMTAgOiBkdXJhdGlvbjtcblxuICAgICAgICAgICAgICAgIGFuaS5wbGF5KGR1cmF0aW9uLCBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJvdy5jYWxsKHNlbGYsIHJvd09mZnNldCAqIHAgKyBjdXJyZW50Um93bGVmdCk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRvdWNoUGFuZWwuY2FsbChzZWxmLCBwYW5lbE9mZnNldCAqIHAgKyBjdXJyZW50UGFuZWxXaWR0aCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVJvdy5jYWxsKHNlbGYsIHJvd2xlZnQpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVRvdWNoUGFuZWwuY2FsbChzZWxmLCBwYW5lbFdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVJvdyhuZXdsZWZ0KSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgbGF5b3V0SW5mbyA9IHNlbGYuZ2V0TGF5b3V0SW5mbygpW1ZJRVdQT1JUXTtcbiAgICAgICAgICAgIHN3aXBlU3RhdHVzLnJvdy5zdHlsZS5sZWZ0ID0gbmV3bGVmdCArICdweCc7XG4gICAgICAgICAgICBpZiAobmV3bGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICBzd2lwZVN0YXR1cy5yb3cuc3R5bGVbJ2JvcmRlci1yaWdodCddID0gJzFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuMiknO1xuICAgICAgICAgICAgICAgIHN3aXBlU3RhdHVzLnJvdy5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgICAgIHN3aXBlU3RhdHVzLnJvdy5zdHlsZS53aWR0aCA9IChsYXlvdXRJbmZvLmNvbnRlbnRXaWR0aCAtIG5ld2xlZnQpICsgJ3B4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpcGVTdGF0dXMucm93LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdib3JkZXItcmlnaHQnKTtcbiAgICAgICAgICAgICAgICBzd2lwZVN0YXR1cy5yb3cuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ292ZXJmbG93Jyk7XG4gICAgICAgICAgICAgICAgc3dpcGVTdGF0dXMucm93LnN0eWxlLnJlbW92ZVByb3BlcnR5KCd3aWR0aCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlVG91Y2hQYW5lbChwYW5lbFdpZHRoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoZ2NVdGlscy5pc051bWJlcihwYW5lbFdpZHRoKSkge1xuICAgICAgICAgICAgICAgIHZhciB2aWV3UG9ydCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbGYudWlkICsgJy12aWV3cG9ydC1pbm5lcicpO1xuICAgICAgICAgICAgICAgIHZhciBhY3Rpb25QYW5lbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHN3aXBlU3RhdHVzLnJvdy5pZCArICctJyArIHN3aXBlU3RhdHVzLmFjdGlvblR5cGUgKyAnLWFjdGlvblBhbmVsJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uUGFuZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlld1BvcnQucmVtb3ZlQ2hpbGQoYWN0aW9uUGFuZWwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYW5lbFdpZHRoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3UG9ydC5hcHBlbmRDaGlsZChjcmVhdGVDb2x1bW5Ub3VjaFBhbmVsLmNhbGwoc2VsZiwgcGFuZWxXaWR0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNsb3NlVG91Y2hQYW5lbCgpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGFuaS5zdG9wKCk7XG4gICAgICAgICAgICByZWZyZXNoQWN0aW9uUm93LmNhbGwoc2VsZiwgMCwgMCk7XG4gICAgICAgICAgICBzd2lwZVN0YXR1cyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFuaSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzdGFydFRpbWUgPSAwO1xuICAgICAgICAgICAgdmFyIF90aW1lID0gMDtcbiAgICAgICAgICAgIHZhciBfY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHBsYXlUeXBlID0gMDsvLzAgPSB0aW1lciwgMSA9IHJhZlxuICAgICAgICAgICAgdmFyIF9sYXN0VGltZSA9IDA7XG4gICAgICAgICAgICB2YXIgX3N0b3BBbmltYXRpb247XG4gICAgICAgICAgICB2YXIgcmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBwbGF5QW5pbWF0aW9uKHRpbWUsIGNiKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICBfc3RvcEFuaW1hdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF90aW1lID0gdGltZSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgX2NhbGxiYWNrID0gY2I7XG5cbiAgICAgICAgICAgICAgICBpZiAocGxheVR5cGUgJiYgcmFmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhZihfYW5pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KF9hbmksIDE2LjYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gX2FuaSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm93ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICB2YXIgY291bnQgPSBub3cgLSBzdGFydFRpbWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2IgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhbGxiYWNrKHZhbCB8fCBlYXNlT3V0KGNvdW50LCAwLCAxLCBfdGltZSkpO1xuXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChjb3VudCA+PSBfdGltZSB8fCBfc3RvcEFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjYigxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNiKCk7XG5cbiAgICAgICAgICAgICAgICBfbGFzdFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBsYXlUeXBlICYmIHJhZikge1xuICAgICAgICAgICAgICAgICAgICByYWYoX2FuaSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChfYW5pLCAxNi42KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGVhc2VPdXQodCwgYiwgYywgZCkge1xuICAgICAgICAgICAgICAgIHQgLz0gZCAvIDI7XG4gICAgICAgICAgICAgICAgaWYgKHQgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjIC8gMiAqIHQgKiB0ICsgYjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0LS07XG4gICAgICAgICAgICAgICAgcmV0dXJuIC1jIC8gMiAqICh0ICogKHQgLSAyKSAtIDEpICsgYjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9mdW5jdGlvbiBlYXNlSW5PdXQodCwgYiwgYywgZCkge1xuICAgICAgICAgICAgLy8gICAgaWYgKCh0IC89IGQgLyAyKSA8IDEpIHtcbiAgICAgICAgICAgIC8vICAgICAgICByZXR1cm4gYyAvIDIgKiB0ICogdCArIGI7XG4gICAgICAgICAgICAvLyAgICB9XG4gICAgICAgICAgICAvLyAgICByZXR1cm4gLWMgLyAyICogKCgtLXQpICogKHQgLSAyKSAtIDEpICsgYjtcbiAgICAgICAgICAgIC8vfVxuXG4gICAgICAgICAgICAvL2Z1bmN0aW9uIGxpbmVhcih0LCBkKSB7XG4gICAgICAgICAgICAvLyAgICByZXR1cm4gdCAvIGQ7XG4gICAgICAgICAgICAvL31cblxuICAgICAgICAgICAgZnVuY3Rpb24gc3RvcEFuaW1hdGlvbigpIHtcbiAgICAgICAgICAgICAgICBfc3RvcEFuaW1hdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGxheTogcGxheUFuaW1hdGlvbixcbiAgICAgICAgICAgICAgICBzdG9wOiBzdG9wQW5pbWF0aW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldFJlbGF0ZWRNb3ZlUm93KGhpdFRlc3RJbmZvKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgdWlkID0gc2VsZi5ncmlkLnVpZDtcbiAgICAgICAgICAgIHZhciBrZXk7XG4gICAgICAgICAgICB2YXIgZ3JvdXBJbmZvID0gaGl0VGVzdEluZm8uZ3JvdXBJbmZvO1xuICAgICAgICAgICAgaWYgKGdyb3VwSW5mbykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gZ3JvdXBJbmZvLmFyZWE7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQgPT09IEdST1VQX0hFQURFUikge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSB1aWQgKyAnLWdoJyArIGdyb3VwSW5mby5wYXRoLmpvaW4oJ18nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQgPT09IEdST1VQX0NPTlRFTlQpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gdWlkICsgJy1ncicgKyBncm91cEluZm8ucGF0aC5qb2luKCdfJykgKyAnLXInICsgZ3JvdXBJbmZvLnJvdztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSB1aWQgKyAnLWdmJyArIGdyb3VwSW5mby5wYXRoLmpvaW4oJ18nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGtleSA9IHVpZCArICctcicgKyBoaXRUZXN0SW5mby5yb3c7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaGFzR3JvdXBfKGdyaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBncmlkLmRhdGEuZ3JvdXBzICYmIGdyaWQuZGF0YS5ncm91cHMubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBvaW50SW5fKG9mZnNldExlZnQsIG9mZnNldFRvcCwgZWxlbWVudCwgcmVsYXRpdmVFbGVtZW50LCBlbmxhcmdlKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZWxlT2Zmc2V0ID0gZG9tVXRpbC5vZmZzZXQoZWxlbWVudCk7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0RWxlT2Zmc2V0ID0gZG9tVXRpbC5vZmZzZXQocmVsYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gZWxlT2Zmc2V0LmxlZnQgLSB0YXJnZXRFbGVPZmZzZXQubGVmdDtcbiAgICAgICAgICAgIHZhciB0b3AgPSBlbGVPZmZzZXQudG9wIC0gdGFyZ2V0RWxlT2Zmc2V0LnRvcDtcbiAgICAgICAgICAgIHZhciBlbGVtZW50UmVjdCA9IGRvbVV0aWwuZ2V0RWxlbWVudFJlY3QoZWxlbWVudCk7XG4gICAgICAgICAgICB2YXIgZW5sYXJnZWxlbmd0aCA9IChlbmxhcmdlICYmIHNlbGYuZ3JpZC5pc1RvdWNoTW9kZSkgPyAxMCA6IDA7XG4gICAgICAgICAgICBsZWZ0IC09IGVubGFyZ2VsZW5ndGg7XG4gICAgICAgICAgICB0b3AgLT0gZW5sYXJnZWxlbmd0aDtcbiAgICAgICAgICAgIHZhciByaWdodCA9IGxlZnQgKyBlbGVtZW50UmVjdC53aWR0aCArIDIgKiBlbmxhcmdlbGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGJvdHRvbSA9IHRvcCArIGVsZW1lbnRSZWN0LmhlaWdodCArIDIgKiBlbmxhcmdlbGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAob2Zmc2V0TGVmdCA+PSBsZWZ0ICYmIG9mZnNldExlZnQgPD0gcmlnaHQgJiZcbiAgICAgICAgICAgICAgICBvZmZzZXRUb3AgPj0gdG9wICYmIG9mZnNldFRvcCA8PSBib3R0b20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNhblN0YXJ0RHJhZ2luZ18oaGl0VGVzdEluZm8pIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBncmlkID0gc2VsZi5ncmlkO1xuICAgICAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgICAgICB2YXIgY29sdW1uO1xuICAgICAgICAgICAgdmFyIGdyb3VwRGVzY3JpcHRvcnM7XG4gICAgICAgICAgICB2YXIgYXJlYTtcbiAgICAgICAgICAgIGlmIChoaXRUZXN0SW5mbykge1xuICAgICAgICAgICAgICAgIGFyZWEgPSBoaXRUZXN0SW5mby5hcmVhO1xuICAgICAgICAgICAgICAgIGlmIChhcmVhID09PSBHUk9VUF9EUkFHX1BBTkVMKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKGFyZWEgPT09IENPTFVNTl9IRUFERVIgfHwgYXJlYSA9PT0gUElOTkVEX0NPTFVNTl9IRUFERVIgfHwgYXJlYSA9PT0gUElOTkVEX1JJR0hUX0NPTFVNTl9IRUFERVIpICYmIChoaXRUZXN0SW5mby5jb2x1bW4gPj0gMCB8fCAoaGl0VGVzdEluZm8uY29sdW1uR3JvdXBJbmZvICYmIGhpdFRlc3RJbmZvLmNvbHVtbkdyb3VwSW5mby5jYXB0aW9uKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5hbGxvd0NvbHVtblJlb3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBncmlkLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwRGVzY3JpcHRvcnMgPSBkYXRhLmdyb3VwRGVzY3JpcHRvcnM7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IGdyaWQuY29sdW1uc1toaXRUZXN0SW5mby5jb2x1bW5dO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBlZCA9ICEhXy5maW5kKGdyb3VwRGVzY3JpcHRvcnMsIF8ubWF0Y2hlc1Byb3BlcnR5KCdmaWVsZCcsIGNvbHVtbi5pZCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ3JvdXBlZCA/IGZhbHNlIDogISEoY29sdW1uLmhhc093blByb3BlcnR5KCdhbGxvd0dyb3VwaW5nJykgPyBjb2x1bW4uYWxsb3dHcm91cGluZyA6IHRoaXMuZ3JpZC5vcHRpb25zLmFsbG93R3JvdXBpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRyZWVOb2RlKGxheW91dEVuZ2luZSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSBsYXlvdXRFbmdpbmU7XG4gICAgICAgICAgICB2YXIgaGl0SW5mbyA9IHNlbGYuaGl0VGVzdEluZm9fO1xuICAgICAgICAgICAgdmFyIGhpdEdyb3VwSW5mbyA9IGhpdEluZm8uZ3JvdXBJbmZvO1xuICAgICAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgICAgICBpZiAoaGl0R3JvdXBJbmZvKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gc2VsZi5ncmlkLmdldEdyb3VwSW5mb18oaGl0R3JvdXBJbmZvLnBhdGgpLmRhdGE7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGdyb3VwLnJvb3ROb2RlLmZpbmROb2RlKGhpdEdyb3VwSW5mby5yb3cpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gc2VsZi5ncmlkLmRhdGEucm9vdE5vZGUuZmluZE5vZGUoaGl0SW5mby5yb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLmNvbGxhcHNlZCA9ICFub2RlLmNvbGxhcHNlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGlvbihsYXlvdXRFbmdpbmUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gbGF5b3V0RW5naW5lO1xuICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5hbGxvd0hlYWRlclNlbGVjdCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUNoZWNrYm94U2VsZWN0aW9uXyhzZWxmKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlR2VuZXJhbFNlbGVjdGlvbl8oc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVDaGVja2JveFNlbGVjdGlvbl8obGF5b3V0RW5naW5lKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IGxheW91dEVuZ2luZTtcbiAgICAgICAgICAgIHZhciBoaXRJbmZvID0gc2VsZi5oaXRUZXN0SW5mb187XG4gICAgICAgICAgICB2YXIgZ3JvdXBIaXRJbmZvID0gaGl0SW5mby5ncm91cEluZm87XG4gICAgICAgICAgICBpZiAoIWhpdEluZm8uY2hlY2tlZCAmJiAoIWdyb3VwSGl0SW5mbyB8fCAhZ3JvdXBIaXRJbmZvLmNoZWNrZWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZ3JvdXBJbmZvID0gZ3JvdXBIaXRJbmZvID8gc2VsZi5ncmlkLmdldEdyb3VwSW5mb18oZ3JvdXBIaXRJbmZvLnBhdGgpIDogbnVsbDtcbiAgICAgICAgICAgIHZhciB2aWV3Um93ID0gZ3JvdXBIaXRJbmZvID8gZ3JvdXBIaXRJbmZvLnJvdyA6IGhpdEluZm8ucm93O1xuICAgICAgICAgICAgdmFyIHNyY1JvdyA9IGdyb3VwSW5mbyA/IGdyb3VwSW5mby5kYXRhLnRvU291cmNlUm93KHZpZXdSb3cpIDogc2VsZi5ncmlkLmRhdGEudG9Tb3VyY2VSb3codmlld1Jvdyk7XG5cbiAgICAgICAgICAgIHZhciBzZWxlY3RlZFJvd3MgPSBzZWxmLnNlbGVjdGVkUm93c18gPSBzZWxmLnNlbGVjdGVkUm93c18gfHwgW107XG4gICAgICAgICAgICB2YXIgc2VsTW9kZU9wdCA9IHNlbGYub3B0aW9ucy5zZWxlY3Rpb25Nb2RlO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHRhcmdldEVsZW1lbnQ7XG4gICAgICAgICAgICB2YXIgY2hlY2tlZDsgIC8vY3VycmVudCBjaGVja2VkIHN0YXR1cztcblxuICAgICAgICAgICAgaWYgKHNlbE1vZGVPcHQgPT09IFNlbGVjdE1vZGUuTk9ORSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkUm93cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIHNldEFsbFN0YXR1c18oc2VsZiwgZmFsc2UsIFZJRVdQT1JUKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5oYXNMZWZ0UGlubmVkQ29sdW1uXykge1xuICAgICAgICAgICAgICAgICAgICBzZXRBbGxTdGF0dXNfKHNlbGYsIGZhbHNlLCBQSU5ORURfVklFV1BPUlQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5oYXNSaWdodFBpbm5lZENvbHVtbl8pIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QWxsU3RhdHVzXyhzZWxmLCBmYWxzZSwgUElOTkVEX1JJR0hUX1ZJRVdQT1JUKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlbE1vZGVPcHQgPT09IFNlbGVjdE1vZGUuU0lOR0xFKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudCA9IGdldENoZWNrRWxlbWVudF8oc2VsZiwgaGl0SW5mbyk7XG4gICAgICAgICAgICAgICAgaWYgKGhpdEluZm8uYXJlYSA9PT0gQ09STkVSX0hFQURFUiB8fCAoZ3JvdXBIaXRJbmZvICYmIGdyb3VwSGl0SW5mby5hcmVhID09PSBHUk9VUF9IRUFERVIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldENoZWNrRWxlbWVudFNlbGVjdF8odGFyZ2V0RWxlbWVudCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNOYU4oc3JjUm93KSAmJiBzZWxlY3RlZFJvd3MuaW5kZXhPZihzcmNSb3cpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFJvd3MubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRSb3dzLnB1c2goc3JjUm93KTtcbiAgICAgICAgICAgICAgICAgICAgc2V0QWxsU3RhdHVzXyhzZWxmLCBmYWxzZSwgVklFV1BPUlQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGdldFJvd0VsZW1lbnRfKHNlbGYsIHZpZXdSb3csIGdyb3VwSGl0SW5mbywgVklFV1BPUlQpO1xuICAgICAgICAgICAgICAgICAgICBzZXRSb3dFbGVtZW50U2VsZWN0XyhlbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuaGFzTGVmdFBpbm5lZENvbHVtbl8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEFsbFN0YXR1c18oc2VsZiwgZmFsc2UsIFBJTk5FRF9WSUVXUE9SVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZ2V0Um93RWxlbWVudF8oc2VsZiwgdmlld1JvdywgaGl0SW5mby5ncm91cEluZm8sIFBJTk5FRF9WSUVXUE9SVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRSb3dFbGVtZW50U2VsZWN0XyhlbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5oYXNSaWdodFBpbm5lZENvbHVtbl8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEFsbFN0YXR1c18oc2VsZiwgZmFsc2UsIFBJTk5FRF9SSUdIVF9WSUVXUE9SVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZ2V0Um93RWxlbWVudF8oc2VsZiwgdmlld1JvdywgaGl0SW5mby5ncm91cEluZm8sIFBJTk5FRF9SSUdIVF9WSUVXUE9SVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRSb3dFbGVtZW50U2VsZWN0XyhlbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRDaGVja0VsZW1lbnRTZWxlY3RfKHRhcmdldEVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaGl0SW5mby5hcmVhID09PSBDT1JORVJfSEVBREVSKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQgPSBzZWxlY3RlZFJvd3MubGVuZ3RoID09PSBzZWxmLmdyaWQuZGF0YS5pdGVtQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkUm93cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYuZ3JpZC5kYXRhLnNvdXJjZUNvbGxlY3Rpb24ubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFJvd3MucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRBbGxTdGF0dXNfKHNlbGYsICFjaGVja2VkLCBWSUVXUE9SVCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmhhc0xlZnRQaW5uZWRDb2x1bW5fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBbGxTdGF0dXNfKHNlbGYsICFjaGVja2VkLCBQSU5ORURfVklFV1BPUlQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmhhc1JpZ2h0UGlubmVkQ29sdW1uXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QWxsU3RhdHVzXyhzZWxmLCAhY2hlY2tlZCwgUElOTkVEX1JJR0hUX1ZJRVdQT1JUKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGl0SW5mby5hcmVhID09PSBST1dfSEVBREVSKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChncm91cEhpdEluZm8gJiYgZ3JvdXBIaXRJbmZvLmFyZWEgPT09IEdST1VQX0hFQURFUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcHBpbmdzID0gZ2V0R3JvdXBNYXBwaW5nXyhzZWxmLmdyaWQuZ2V0R3JvdXBJbmZvXyhncm91cEhpdEluZm8ucGF0aCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZCA9IF8uZGlmZmVyZW5jZShtYXBwaW5ncywgc2VsZWN0ZWRSb3dzKS5sZW5ndGggPD0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IF8uaW50ZXJzZWN0aW9uKHNlbGVjdGVkUm93cywgbWFwcGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGludGVyc2VjdGlvbi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFJvd3Muc3BsaWNlKHNlbGVjdGVkUm93cy5pbmRleE9mKGludGVyc2VjdGlvbltpXSksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRSb3dzID0gc2VsZi5zZWxlY3RlZFJvd3NfID0gXy51bmlvbihtYXBwaW5ncywgc2VsZWN0ZWRSb3dzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtSW5kZXggPSBzZWxlY3RlZFJvd3MuaW5kZXhPZihzcmNSb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZCA9IGl0ZW1JbmRleCAhPT0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkUm93cy5zcGxpY2UoaXRlbUluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRSb3dzLnB1c2goc3JjUm93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkID0gIWNoZWNrZWQ7IC8vIGFmdGVyIGNsaWNrLCB0aGUgY2hlY2tlZCBzdGF0dXMgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICAgICAgc2V0TXVsdGlTdGF0dXNfKHNlbGYsIGNoZWNrZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUdlbmVyYWxTZWxlY3Rpb25fKGxheW91dEVuZ2luZSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSBsYXlvdXRFbmdpbmU7XG4gICAgICAgICAgICB2YXIgaGl0SW5mbyA9IHNlbGYuaGl0VGVzdEluZm9fO1xuICAgICAgICAgICAgdmFyIGdyb3VwSGl0SW5mbyA9IGhpdEluZm8uZ3JvdXBJbmZvO1xuICAgICAgICAgICAgdmFyIGhpdEluZm9Db2x1bW4gPSBncm91cEhpdEluZm8gPyBncm91cEhpdEluZm8uY29sdW1uIDogaGl0SW5mby5jb2x1bW47XG4gICAgICAgICAgICBpZiAoaGl0SW5mb0NvbHVtbiA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBncm91cEluZm8gPSBncm91cEhpdEluZm8gPyBzZWxmLmdyaWQuZ2V0R3JvdXBJbmZvXyhncm91cEhpdEluZm8ucGF0aCkgOiBudWxsO1xuICAgICAgICAgICAgdmFyIHZpZXdSb3cgPSBncm91cEhpdEluZm8gPyBncm91cEhpdEluZm8ucm93IDogaGl0SW5mby5yb3c7XG4gICAgICAgICAgICB2YXIgc3JjUm93ID0gZ3JvdXBJbmZvID8gZ3JvdXBJbmZvLmRhdGEudG9Tb3VyY2VSb3codmlld1JvdykgOiBzZWxmLmdyaWQuZGF0YS50b1NvdXJjZVJvdyh2aWV3Um93KTtcblxuICAgICAgICAgICAgaWYgKGlzTmFOKHZpZXdSb3cpIHx8IGlzTmFOKHNyY1JvdykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzZWxNb2RlT3B0ID0gc2VsZi5vcHRpb25zLnNlbGVjdGlvbk1vZGU7XG4gICAgICAgICAgICB2YXIgZWxlbWVudDtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZFJvd3MgPSBzZWxmLnNlbGVjdGVkUm93c18gPSBzZWxmLnNlbGVjdGVkUm93c18gfHwgW107XG4gICAgICAgICAgICB2YXIgcm93ID0gdmlld1JvdztcbiAgICAgICAgICAgIGlmIChzZWxNb2RlT3B0ID09PSBTZWxlY3RNb2RlLk5PTkUpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFJvd3MubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBzZXRBbGxTdGF0dXNfKHNlbGYsIGZhbHNlLCBWSUVXUE9SVCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaGFzTGVmdFBpbm5lZENvbHVtbl8pIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QWxsU3RhdHVzXyhzZWxmLCBmYWxzZSwgUElOTkVEX1ZJRVdQT1JUKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaGFzUmlnaHRQaW5uZWRDb2x1bW5fKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEFsbFN0YXR1c18oc2VsZiwgZmFsc2UsIFBJTk5FRF9SSUdIVF9WSUVXUE9SVCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxNb2RlT3B0ID09PSBTZWxlY3RNb2RlLk1VTFRJUExFKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1JbmRleCA9IHNlbGVjdGVkUm93cy5pbmRleE9mKHNyY1Jvdyk7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGdldFJvd0VsZW1lbnRfKHNlbGYsIHJvdywgZ3JvdXBIaXRJbmZvLCBWSUVXUE9SVCk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbVV0aWwuaGFzQ2xhc3MoZWxlbWVudCwgJ2djLXNlbGVjdGVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRSb3dzLnNwbGljZShpdGVtSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBzZXRSb3dFbGVtZW50U2VsZWN0XyhlbGVtZW50LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1JbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkUm93cy5wdXNoKHNyY1Jvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRSb3dFbGVtZW50U2VsZWN0XyhlbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5oYXNMZWZ0UGlubmVkQ29sdW1uXykge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZ2V0Um93RWxlbWVudF8oc2VsZiwgcm93LCBncm91cEhpdEluZm8sIFBJTk5FRF9WSUVXUE9SVCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21VdGlsLmhhc0NsYXNzKGVsZW1lbnQsICdnYy1zZWxlY3RlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRSb3dFbGVtZW50U2VsZWN0XyhlbGVtZW50LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbUluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFJvd0VsZW1lbnRTZWxlY3RfKGVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmhhc1JpZ2h0UGlubmVkQ29sdW1uXykge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZ2V0Um93RWxlbWVudF8oc2VsZiwgcm93LCBncm91cEhpdEluZm8sIFBJTk5FRF9SSUdIVF9WSUVXUE9SVCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21VdGlsLmhhc0NsYXNzKGVsZW1lbnQsICdnYy1zZWxlY3RlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRSb3dFbGVtZW50U2VsZWN0XyhlbGVtZW50LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbUluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFJvd0VsZW1lbnRTZWxlY3RfKGVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFJvd3MubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFJvd3MucHVzaChzcmNSb3cpO1xuICAgICAgICAgICAgICAgIHNldEFsbFN0YXR1c18oc2VsZiwgZmFsc2UsIFZJRVdQT1JUKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gZ2V0Um93RWxlbWVudF8oc2VsZiwgcm93LCBncm91cEhpdEluZm8sIFZJRVdQT1JUKTtcbiAgICAgICAgICAgICAgICBzZXRSb3dFbGVtZW50U2VsZWN0XyhlbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5oYXNMZWZ0UGlubmVkQ29sdW1uXykge1xuICAgICAgICAgICAgICAgICAgICBzZXRBbGxTdGF0dXNfKHNlbGYsIGZhbHNlLCBQSU5ORURfVklFV1BPUlQpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZ2V0Um93RWxlbWVudF8oc2VsZiwgcm93LCBncm91cEhpdEluZm8sIFBJTk5FRF9WSUVXUE9SVCk7XG4gICAgICAgICAgICAgICAgICAgIHNldFJvd0VsZW1lbnRTZWxlY3RfKGVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5oYXNSaWdodFBpbm5lZENvbHVtbl8pIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QWxsU3RhdHVzXyhzZWxmLCBmYWxzZSwgUElOTkVEX1JJR0hUX1ZJRVdQT1JUKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGdldFJvd0VsZW1lbnRfKHNlbGYsIHJvdywgZ3JvdXBIaXRJbmZvLCBQSU5ORURfUklHSFRfVklFV1BPUlQpO1xuICAgICAgICAgICAgICAgICAgICBzZXRSb3dFbGVtZW50U2VsZWN0XyhlbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vVE9ETzogaXRlcmF0ZSBhbGwgaXMgbm90IHZlcnkgZWZmaWNpZW50XG4gICAgICAgIGZ1bmN0aW9uIHNldEFsbFN0YXR1c18obGF5b3V0RW5naW5lLCBzdGF0dXMsIGFyZWEpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gbGF5b3V0RW5naW5lO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5hbGxvd0hlYWRlclNlbGVjdCkge1xuICAgICAgICAgICAgICAgIHZhciByb3dDaGVja0VsZW1lbnRzID0gc2VsZi5ncmlkLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCcuZ2MtaGVhZGVyLXNlbGVjdC1pY29uJyk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gcm93Q2hlY2tFbGVtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzZXRDaGVja0VsZW1lbnRTZWxlY3RfKHJvd0NoZWNrRWxlbWVudHNbaV0sIHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZpZXdwb3J0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZi5ncmlkLnVpZCArICctJyArIGFyZWEgKyAnLWlubmVyJyk7XG4gICAgICAgICAgICB2YXIgcm93cyA9IHZpZXdwb3J0LmNoaWxkcmVuO1xuICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHJvd3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tVXRpbC5hZGRDbGFzcyhyb3dzW2ldLCAnZ2Mtc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgcm93c1tpXS5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCAndHJ1ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gcm93cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBkb21VdGlsLnJlbW92ZUNsYXNzKHJvd3NbaV0sICdnYy1zZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICByb3dzW2ldLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNldE11bHRpU3RhdHVzXyhsYXlvdXRFbmdpbmUsIGNoZWNrZWRTdGF0dXMpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gbGF5b3V0RW5naW5lO1xuICAgICAgICAgICAgdmFyIGhpdEluZm8gPSBzZWxmLmhpdFRlc3RJbmZvXztcbiAgICAgICAgICAgIHZhciBncm91cEhpdEluZm8gPSBoaXRJbmZvLmdyb3VwSW5mbztcbiAgICAgICAgICAgIHZhciB1aWQgPSBzZWxmLmdyaWQudWlkO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHJvd0VsZW1lbnQ7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0RWxlbWVudCA9IGdldENoZWNrRWxlbWVudF8oc2VsZiwgaGl0SW5mbyk7XG4gICAgICAgICAgICB2YXIgcm9vdENoZWNrRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHVpZCArICctY29ybmVyLXNlbGVjdCcpO1xuICAgICAgICAgICAgc2V0Q2hlY2tFbGVtZW50U2VsZWN0Xyhyb290Q2hlY2tFbGVtZW50LCBzZWxmLnNlbGVjdGVkUm93c18ubGVuZ3RoID09PSBzZWxmLmdyaWQuZGF0YS5pdGVtQ291bnQpO1xuICAgICAgICAgICAgLy91cGRhdGUgcm93IGhlYWRlciBjaGVja2JveFxuICAgICAgICAgICAgaWYgKCFncm91cEhpdEluZm8pIHtcbiAgICAgICAgICAgICAgICByb3dFbGVtZW50ID0gZ2V0Um93RWxlbWVudF8oc2VsZiwgaGl0SW5mby5yb3csIG51bGwsIFZJRVdQT1JUKTtcbiAgICAgICAgICAgICAgICBzZXRSb3dFbGVtZW50U2VsZWN0Xyhyb3dFbGVtZW50LCBjaGVja2VkU3RhdHVzKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5oYXNMZWZ0UGlubmVkQ29sdW1uXykge1xuICAgICAgICAgICAgICAgICAgICByb3dFbGVtZW50ID0gZ2V0Um93RWxlbWVudF8oc2VsZiwgaGl0SW5mby5yb3csIG51bGwsIFBJTk5FRF9WSUVXUE9SVCk7XG4gICAgICAgICAgICAgICAgICAgIHNldFJvd0VsZW1lbnRTZWxlY3RfKHJvd0VsZW1lbnQsIGNoZWNrZWRTdGF0dXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5oYXNSaWdodFBpbm5lZENvbHVtbl8pIHtcbiAgICAgICAgICAgICAgICAgICAgcm93RWxlbWVudCA9IGdldFJvd0VsZW1lbnRfKHNlbGYsIGhpdEluZm8ucm93LCBudWxsLCBQSU5ORURfUklHSFRfVklFV1BPUlQpO1xuICAgICAgICAgICAgICAgICAgICBzZXRSb3dFbGVtZW50U2VsZWN0Xyhyb3dFbGVtZW50LCBjaGVja2VkU3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0Q2hlY2tFbGVtZW50U2VsZWN0Xyh0YXJnZXRFbGVtZW50LCBjaGVja2VkU3RhdHVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9JZiB0aGVyZSBhcmUgZ3JvdXBzLCBuZWVkIHRvIHN5bmMgcGFyZW50IGFuZCBjaGlsZHJlbiBzdGF0dXNcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0R3JvdXBJbmZvO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbjtcbiAgICAgICAgICAgICAgICB2YXIgbWFwcGluZ3M7XG4gICAgICAgICAgICAgICAgLy9zZXQgcGFyZW50IHN0YXR1cy5cbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IF8uY2xvbmUoZ3JvdXBIaXRJbmZvLnBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChncm91cEhpdEluZm8uYXJlYSA9PT0gR1JPVVBfSEVBREVSKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHNldENoZWNrRWxlbWVudFNlbGVjdF8odGFyZ2V0RWxlbWVudCwgY2hlY2tlZFN0YXR1cyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChncm91cEhpdEluZm8uYXJlYSA9PT0gR1JPVVBfQ09OVEVOVCkge1xuICAgICAgICAgICAgICAgICAgICByb3dFbGVtZW50ID0gZ2V0Um93RWxlbWVudF8oc2VsZiwgbnVsbCwgZ3JvdXBIaXRJbmZvLCBWSUVXUE9SVCk7XG4gICAgICAgICAgICAgICAgICAgIHNldFJvd0VsZW1lbnRTZWxlY3RfKHJvd0VsZW1lbnQsIGNoZWNrZWRTdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5oYXNMZWZ0UGlubmVkQ29sdW1uXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93RWxlbWVudCA9IGdldFJvd0VsZW1lbnRfKHNlbGYsIGhpdEluZm8ucm93LCBudWxsLCBQSU5ORURfVklFV1BPUlQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Um93RWxlbWVudFNlbGVjdF8ocm93RWxlbWVudCwgY2hlY2tlZFN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuaGFzUmlnaHRQaW5uZWRDb2x1bW5fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dFbGVtZW50ID0gZ2V0Um93RWxlbWVudF8oc2VsZiwgaGl0SW5mby5yb3csIG51bGwsIFBJTk5FRF9SSUdIVF9WSUVXUE9SVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRSb3dFbGVtZW50U2VsZWN0Xyhyb3dFbGVtZW50LCBjaGVja2VkU3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRDaGVja0VsZW1lbnRTZWxlY3RfKHRhcmdldEVsZW1lbnQsIGNoZWNrZWRTdGF0dXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAocGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh1aWQgKyAnLWdoaCcgKyBwYXRoLmpvaW4oJy0nKSArICctc2VsZWN0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRHcm91cEluZm8gPSBzZWxmLmdyaWQuZ2V0R3JvdXBJbmZvXyhwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmdzID0gZ2V0R3JvdXBNYXBwaW5nXyh0YXJnZXRHcm91cEluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q2hlY2tFbGVtZW50U2VsZWN0Xyh0YXJnZXRFbGVtZW50LCBfLmRpZmZlcmVuY2UobWFwcGluZ3MsIHNlbGYuc2VsZWN0ZWRSb3dzXykubGVuZ3RoIDw9IDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhdGgucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vc2V0IGNoaWxkcmVuIHN0YXR1cy5cbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBIaXRJbmZvLmFyZWEgPT09IEdST1VQX0hFQURFUikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudEdyb3VwSW5mbyA9IHNlbGYuZ3JpZC5nZXRHcm91cEluZm9fKGdyb3VwSGl0SW5mby5wYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRHcm91cEluZm8uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gXy5jbG9uZShjdXJyZW50R3JvdXBJbmZvLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRHcm91cEluZm8gPSBjaGlsZHJlbi5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gdGFyZ2V0R3JvdXBJbmZvLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHVpZCArICctZ2hoJyArIHBhdGguam9pbignLScpICsgJy1zZWxlY3QnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRDaGVja0VsZW1lbnRTZWxlY3RfKHRhcmdldEVsZW1lbnQsIGNoZWNrZWRTdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRHcm91cEluZm8uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uY29uY2F0KHRhcmdldEdyb3VwSW5mby5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gdGFyZ2V0R3JvdXBJbmZvLmRhdGEuaXRlbUNvdW50OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh1aWQgKyAnLWdyaCcgKyBwYXRoLmpvaW4oJy0nKSArICctcicgKyBpICsgJy1zZWxlY3QnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldENoZWNrRWxlbWVudFNlbGVjdF8odGFyZ2V0RWxlbWVudCwgY2hlY2tlZFN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodWlkICsgJy1ncicgKyBwYXRoLmpvaW4oJ18nKSArICctcicgKyBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFJvd0VsZW1lbnRTZWxlY3RfKHJvd0VsZW1lbnQsIGNoZWNrZWRTdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuaGFzTGVmdFBpbm5lZENvbHVtbl8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodWlkICsgJy1wZ3InICsgcGF0aC5qb2luKCdfJykgKyAnLXInICsgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Um93RWxlbWVudFNlbGVjdF8ocm93RWxlbWVudCwgY2hlY2tlZFN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5oYXNSaWdodFBpbm5lZENvbHVtbl8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodWlkICsgJy1wcmdyJyArIHBhdGguam9pbignXycpICsgJy1yJyArIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFJvd0VsZW1lbnRTZWxlY3RfKHJvd0VsZW1lbnQsIGNoZWNrZWRTdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gY3VycmVudEdyb3VwSW5mby5kYXRhLml0ZW1Db3VudDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHVpZCArICctZ3JoJyArIGN1cnJlbnRHcm91cEluZm8ucGF0aC5qb2luKCctJykgKyAnLXInICsgaSArICctc2VsZWN0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q2hlY2tFbGVtZW50U2VsZWN0Xyh0YXJnZXRFbGVtZW50LCBjaGVja2VkU3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodWlkICsgJy1ncicgKyBjdXJyZW50R3JvdXBJbmZvLnBhdGguam9pbignXycpICsgJy1yJyArIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFJvd0VsZW1lbnRTZWxlY3RfKHJvd0VsZW1lbnQsIGNoZWNrZWRTdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmhhc0xlZnRQaW5uZWRDb2x1bW5fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh1aWQgKyAnLXBncicgKyBjdXJyZW50R3JvdXBJbmZvLnBhdGguam9pbignXycpICsgJy1yJyArIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRSb3dFbGVtZW50U2VsZWN0Xyhyb3dFbGVtZW50LCBjaGVja2VkU3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuaGFzUmlnaHRQaW5uZWRDb2x1bW5fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh1aWQgKyAnLXByZ3InICsgY3VycmVudEdyb3VwSW5mby5wYXRoLmpvaW4oJ18nKSArICctcicgKyBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Um93RWxlbWVudFNlbGVjdF8ocm93RWxlbWVudCwgY2hlY2tlZFN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0Um93RWxlbWVudFNlbGVjdF8oZWxlbWVudCwgc3RhdHVzKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tVXRpbC5hZGRDbGFzcyhlbGVtZW50LCAnZ2Mtc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCAndHJ1ZScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbVV0aWwucmVtb3ZlQ2xhc3MoZWxlbWVudCwgJ2djLXNlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0Q2hlY2tFbGVtZW50U2VsZWN0XyhlbGVtZW50LCBzdGF0dXMpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBkb21VdGlsLmFkZENsYXNzKGVsZW1lbnQsICdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbVV0aWwucmVtb3ZlQ2xhc3MoZWxlbWVudCwgJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Um93RWxlbWVudF8obGF5b3V0RW5naW5lLCByb3csIGdyb3VwSW5mbywgYXJlYSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSBsYXlvdXRFbmdpbmU7XG4gICAgICAgICAgICB2YXIgdWlkID0gc2VsZi5ncmlkLnVpZDtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvcjtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBhcmVhID09PSBQSU5ORURfVklFV1BPUlQgPyAncCcgOiAoYXJlYSA9PT0gUElOTkVEX1JJR0hUX1ZJRVdQT1JUID8gJ3ByJyA6ICcnKTtcbiAgICAgICAgICAgIGlmICghZ3JvdXBJbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gdWlkICsgJy0nICsgcHJlZml4ICsgJ3InICsgcm93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwSW5mby5hcmVhID09PSBHUk9VUF9DT05URU5UICYmIGdyb3VwSW5mby5yb3cgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHVpZCArICctJyArIHByZWZpeCArICdncicgKyBncm91cEluZm8ucGF0aC5qb2luKCdfJykgKyAnLXInICsgZ3JvdXBJbmZvLnJvdztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGdyb3VwSW5mby5hcmVhID09PSBHUk9VUF9GT09URVIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB1aWQgKyAnLScgKyBwcmVmaXggKyAnZ2YnICsgZ3JvdXBJbmZvLnBhdGguam9pbignXycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBJbmZvLmFyZWEgPT09IEdST1VQX0hFQURFUikge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHVpZCArICctJyArIHByZWZpeCArICdnaCcgKyBncm91cEluZm8ucGF0aC5qb2luKCdfJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZWN0b3IpIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldENoZWNrRWxlbWVudF8obGF5b3V0RW5naW5lLCBoaXRJbmZvKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IGxheW91dEVuZ2luZTtcbiAgICAgICAgICAgIHZhciB1aWQgPSBzZWxmLmdyaWQudWlkO1xuICAgICAgICAgICAgdmFyIHNlbGVjdG9yO1xuICAgICAgICAgICAgdmFyIGdyb3VwSW5mbyA9IGhpdEluZm8uZ3JvdXBJbmZvO1xuICAgICAgICAgICAgaWYgKGhpdEluZm8uYXJlYSA9PT0gQ09STkVSX0hFQURFUikge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gdWlkICsgJy1jb3JuZXInO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChoaXRJbmZvLmFyZWEgPT09IFJPV19IRUFERVIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWdyb3VwSW5mbykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gaGl0SW5mby5yb3c7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3cgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB1aWQgKyAnLXJoJyArIHJvdztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChncm91cEluZm8uYXJlYSA9PT0gR1JPVVBfQ09OVEVOVCAmJiBncm91cEluZm8ucm93ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gdWlkICsgJy1ncmgnICsgZ3JvdXBJbmZvLnBhdGguam9pbignLScpICsgJy1yJyArIGdyb3VwSW5mby5yb3c7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBJbmZvLmFyZWEgPT09IEdST1VQX0hFQURFUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB1aWQgKyAnLWdoaCcgKyBncm91cEluZm8ucGF0aC5qb2luKCctJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0b3IgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxlY3RvciArICctc2VsZWN0JykgOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0R3JvdXBNYXBwaW5nXyhncm91cEluZm8pIHtcbiAgICAgICAgICAgIHZhciBtYXBwaW5ncyA9IFtdO1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBJbmZvLmRhdGE7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGdyb3VwLml0ZW1Db3VudCkge1xuICAgICAgICAgICAgICAgIG1hcHBpbmdzLnB1c2goZ3JvdXAudG9Tb3VyY2VSb3coaSkpO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXBwaW5ncztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbHVlLCBmb3JtYXQsIGZvcm11bGEpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBTcGFya2xpbmUgPSBnY1V0aWxzLmZpbmRQbHVnaW4oJ1NwYXJrbGluZScpO1xuICAgICAgICAgICAgaWYgKFNwYXJrbGluZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIFNwYXJrbGluZS5CYXNlU3BhcmtsaW5lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lckhlaWdodCA9IHNlbGYub3B0aW9ucy5yb3dIZWlnaHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuICc8c3BhbiBkYXRhLWZvcm11bGE9XFwnJyArIGZvcm11bGEgKyAnXFwnIGNsYXNzPVwiZ2MtZ3JvdXAtc3BhcmtsaW5lXCIgc3R5bGU9XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7d2lkdGg6JyArIGNvbnRhaW5lckhlaWdodCAqIDQgKyAncHg7aGVpZ2h0OicgKyBjb250YWluZXJIZWlnaHQgKyAncHg7XCI+PC9zcGFuPic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2NVdGlscy5pc0Z1bmN0aW9uKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0KHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWdjVXRpbHMuaXNVbmRlZmluZWRPck51bGwod2luZG93LkdjU3ByZWFkKSkge1xuICAgICAgICAgICAgICAgIHZhciBGb3JtYXR0ZXIgPSBnY1V0aWxzLmZpbmRQbHVnaW4oJ0Zvcm1hdHRlcicpO1xuICAgICAgICAgICAgICAgIHZhciBFeGNlbEZvcm1hdHRlciA9IEZvcm1hdHRlciA/IEZvcm1hdHRlci5FeGNlbEZvcm1hdHRlciA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKEV4Y2VsRm9ybWF0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3JtYXRPYmogPSBuZXcgRXhjZWxGb3JtYXR0ZXIoZm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE9iai5mb3JtYXQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFNvcnRJbmRpY2F0b3JIdG1sXyhsYXlvdXRFbmdpbmUsIGNvbE9iaiwgY29sSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBncmlkID0gbGF5b3V0RW5naW5lLmdyaWQ7XG4gICAgICAgICAgICB2YXIgc29ydEluZm87XG4gICAgICAgICAgICBpZiAoZ3JpZC5kYXRhLnNvcnREZXNjcmlwdG9ycykge1xuICAgICAgICAgICAgICAgIHNvcnRJbmZvID0gXy5maW5kKGdyaWQuZGF0YS5zb3J0RGVzY3JpcHRvcnMsIF8ubWF0Y2hlc1Byb3BlcnR5KCdmaWVsZCcsIGNvbE9iai5pZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvcnRJbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyaWQub3B0aW9ucy5zb3J0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcFNvcnRJbmZvID0gXy5maW5kKGdyaWQub3B0aW9ucy5zb3J0aW5nLCBfLm1hdGNoZXNQcm9wZXJ0eSgnZmllbGQnLCBjb2xPYmouaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wU29ydEluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRJbmZvID0gXy5kZWZhdWx0cyhzb3J0SW5mbywgb3BTb3J0SW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHNvcnRDc3MgPSBnZXRTb3J0Q3NzQ2xhc3NfKHNvcnRJbmZvLCBjb2xJbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICc8ZGl2IGNsYXNzPVwic29ydENvbnRhaW5lclwiIHN0eWxlPVwiZmxvYXQ6IHJpZ2h0XCI+PGRpdiBjbGFzcz1cIicgKyBzb3J0Q3NzICsgJ1wiPjwvZGl2PjwvZGl2Pic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRTb3J0Q3NzQ2xhc3NfKHNvcnRJbmZvLCBjb2xJbmRleCkge1xuICAgICAgICAgICAgdmFyIGFzY2VuZGluZztcbiAgICAgICAgICAgIGlmICghc29ydEluZm8pIHtcbiAgICAgICAgICAgICAgICBhc2NlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc2NlbmRpbmcgPSBnY1V0aWxzLmlzVW5kZWZpbmVkT3JOdWxsKHNvcnRJbmZvLmFzY2VuZGluZykgPyB0cnVlIDogISFzb3J0SW5mby5hc2NlbmRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXNjZW5kaW5nID8gKCdnYy1pY29uIGdjLXNvcnRpbmcgYXNjZW5kaW5nIGMnICsgY29sSW5kZXgpIDogKCdnYy1pY29uIGdjLXNvcnRpbmcgZGVzY2VuZGluZyBjJyArIGNvbEluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzRWRpdGluZ1NhbWVSb3dfKGhpdEluZm8sIGVkaXRpbmdJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gaGl0SW5mby5ncm91cEluZm8gP1xuICAgICAgICAgICAgICAgIChoaXRJbmZvLmdyb3VwSW5mby5ncm91cCA9PT0gZWRpdGluZ0luZm8uZ3JvdXBJbmZvLnBhdGggJiYgaGl0SW5mby5ncm91cEluZm8ucm93ID09PSBlZGl0aW5nSW5mby5yb3dJbmRleCkgOlxuICAgICAgICAgICAgaGl0SW5mby5yb3cgPT09IGVkaXRpbmdJbmZvLnJvd0luZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBHcmlkTGF5b3V0RW5naW5lO1xuICAgIH1cbiAgICAoKVxuKVxuO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2FwcC9zY3JpcHRzL2dyaWQvbGF5b3V0RW5naW5lcy9ncmlkTGF5b3V0RW5naW5lLmpzXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIHZhciBDYWxjQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICAvL3ZhciBDYWxjRnVuY3Rpb25zID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMnKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICB2YXIgQ2FsY0NvbnRleHQgPSByZXF1aXJlKCcuL2NhbGNDb250ZXh0Jyk7XHJcbiAgICB2YXIgQ2FsY1BhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2VyJyk7XHJcbiAgICB2YXIgQ2FsY0V4cHJlc3Npb25zID0gcmVxdWlyZSgnLi9leHByZXNzaW9ucycpO1xyXG4gICAgdmFyIENhbGNFdmFsdWF0b3IgPSByZXF1aXJlKCcuL2V2YWx1YXRvcicpO1xyXG4gICAgdmFyIENhbGNIZWxwZXIgPSByZXF1aXJlKCcuL2NhbGNIZWxwZXInKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICB2YXIgQ2FsY01hbmFnZXIgPSByZXF1aXJlKCcuL2NhbGNNYW5hZ2VyJyk7XHJcbiAgICB2YXIgQ2FsY01vZGVscyA9IHJlcXVpcmUoJy4vY2FsY01vZGVscycpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIHZhciBDYWxjU291cmNlID0gcmVxdWlyZSgnLi9jYWxjU291cmNlJyk7XHJcbiAgICB2YXIgQ2FsY0NvbGxlY3Rpb25zID0gcmVxdWlyZSgnLi9jYWxjQ29sbGVjdGlvbicpO1xyXG4gICAgdmFyIENhbGNGdW5jdGlvbnMgPSByZXF1aXJlKCcuL2NhbGNGdW5jdGlvbnMnKTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgICAgICBDb21tb246IENhbGNDb21tb24sXHJcbiAgICAgICAgSGVscGVyOiBDYWxjSGVscGVyLFxyXG4gICAgICAgIENhbGNNYW5hZ2VyOiBDYWxjTWFuYWdlcixcclxuICAgICAgICBQYXJzZXJDb250ZXh0OiBDYWxjQ29udGV4dC5QYXJzZXJDb250ZXh0LFxyXG4gICAgICAgIEV2YWx1YXRvckNvbnRleHQ6IENhbGNDb250ZXh0LkV2YWx1YXRlQ29udGV4dCxcclxuICAgICAgICBFeHByZXNzaW9uczogQ2FsY0V4cHJlc3Npb25zLFxyXG4gICAgICAgIFBhcnNlcjogQ2FsY1BhcnNlci5QYXJzZXIsXHJcbiAgICAgICAgRXZhbHVhdG9yOiBDYWxjRXZhbHVhdG9yLFxyXG4gICAgICAgIENhbGNTb3VyY2U6IENhbGNTb3VyY2UuQ2FsY1NvdXJjZSxcclxuICAgICAgICBDb2xsZWN0aW9uczogQ2FsY0NvbGxlY3Rpb25zLFxyXG4gICAgICAgIEZ1bmN0aW9uczogQ2FsY0Z1bmN0aW9uc1xyXG4gICAgfTtcclxufSgpKTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2FwcC9zY3JpcHRzL2dyaWQvY2FsYy9jYWxjLmVudHJ5LmpzXG4gKiogbW9kdWxlIGlkID0gN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZG9ULmpzXG4vLyAyMDExLTIwMTQsIExhdXJhIERva3Rvcm92YSwgaHR0cHM6Ly9naXRodWIuY29tL29sYWRvL2RvVFxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4vKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG5cbihmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBkb1QgPSB7XG4gICAgICAgIHZlcnNpb246IFwiMS4wLjNcIixcbiAgICAgICAgdGVtcGxhdGVTZXR0aW5nczoge1xuICAgICAgICAgICAgZXZhbHVhdGU6IC9cXHtcXHsoW1xcc1xcU10rPyhcXH0/KSspXFx9XFx9L2csXG4gICAgICAgICAgICBpbnRlcnBvbGF0ZTogL1xce1xcez0oW1xcc1xcU10rPylcXH1cXH0vZyxcbiAgICAgICAgICAgIGVuY29kZTogL1xce1xceyEoW1xcc1xcU10rPylcXH1cXH0vZyxcbiAgICAgICAgICAgIHVzZTogL1xce1xceyMoW1xcc1xcU10rPylcXH1cXH0vZyxcbiAgICAgICAgICAgIHVzZVBhcmFtczogLyhefFteXFx3JF0pZGVmKD86XFwufFxcW1tcXCdcXFwiXSkoW1xcdyRcXC5dKykoPzpbXFwnXFxcIl1cXF0pP1xccypcXDpcXHMqKFtcXHckXFwuXSt8XFxcIlteXFxcIl0rXFxcInxcXCdbXlxcJ10rXFwnfFxce1teXFx9XStcXH0pL2csXG4gICAgICAgICAgICBkZWZpbmU6IC9cXHtcXHsjI1xccyooW1xcd1xcLiRdKylcXHMqKFxcOnw9KShbXFxzXFxTXSs/KSNcXH1cXH0vZyxcbiAgICAgICAgICAgIGRlZmluZVBhcmFtczogL15cXHMqKFtcXHckXSspOihbXFxzXFxTXSspLyxcbiAgICAgICAgICAgIGNvbmRpdGlvbmFsOiAvXFx7XFx7XFw/KFxcPyk/XFxzKihbXFxzXFxTXSo/KVxccypcXH1cXH0vZyxcbiAgICAgICAgICAgIGl0ZXJhdGU6IC9cXHtcXHt+XFxzKig/OlxcfVxcfXwoW1xcc1xcU10rPylcXHMqXFw6XFxzKihbXFx3JF0rKVxccyooPzpcXDpcXHMqKFtcXHckXSspKT9cXHMqXFx9XFx9KS9nLFxuICAgICAgICAgICAgdmFybmFtZTogXCJpdFwiLFxuICAgICAgICAgICAgc3RyaXA6IHRydWUsXG4gICAgICAgICAgICBhcHBlbmQ6IHRydWUsXG4gICAgICAgICAgICBzZWxmY29udGFpbmVkOiBmYWxzZSxcbiAgICAgICAgICAgIGRvTm90U2tpcEVuY29kZWQ6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIHRlbXBsYXRlOiB1bmRlZmluZWQsIC8vZm4sIGNvbXBpbGUgdGVtcGxhdGVcbiAgICAgICAgY29tcGlsZTogdW5kZWZpbmVkICAvL2ZuLCBmb3IgZXhwcmVzc1xuICAgIH0sIF9nbG9iYWxzO1xuXG4gICAgZG9ULmVuY29kZUhUTUxTb3VyY2UgPSBmdW5jdGlvbihkb05vdFNraXBFbmNvZGVkKSB7XG4gICAgICAgIHZhciBlbmNvZGVIVE1MUnVsZXMgPSB7XCImXCI6IFwiJiMzODtcIiwgXCI8XCI6IFwiJiM2MDtcIiwgXCI+XCI6IFwiJiM2MjtcIiwgJ1wiJzogXCImIzM0O1wiLCBcIidcIjogXCImIzM5O1wiLCBcIi9cIjogXCImIzQ3O1wifSxcbiAgICAgICAgICAgIG1hdGNoSFRNTCA9IGRvTm90U2tpcEVuY29kZWQgPyAvWyY8PlwiJ1xcL10vZyA6IC8mKD8hIz9cXHcrOyl8PHw+fFwifCd8XFwvL2c7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gY29kZSA/IGNvZGUudG9TdHJpbmcoKS5yZXBsYWNlKG1hdGNoSFRNTCwgZnVuY3Rpb24obSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVIVE1MUnVsZXNbbV0gfHwgbTtcbiAgICAgICAgICAgIH0pIDogXCJcIjtcbiAgICAgICAgfTtcbiAgICB9O1xuXG5cbiAgICBfZ2xvYmFscyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgfHwgKDAsIGV2YWwpKFwidGhpc1wiKTtcbiAgICB9KCkpO1xuXG4gICAgLy9IaWJlclxuICAgIC8vcmVwbGF0ZSB0aGUgbW9kdWxlIGRlZmluaXRpb24gd2l0aCBzaW1wbGUgbW9kdWxlLmV4cG9ydHMgc2luY2Ugd2Ugb25seSBydW5cbiAgICAvL2l0IGluIG5vZGUgbGlrZSBlbnZpcm9ubWVudFxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkb1Q7XG4gICAgLy9pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIC8vXG4gICAgLy99IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy9cdGRlZmluZShmdW5jdGlvbigpe3JldHVybiBkb1Q7fSk7XG4gICAgLy99IGVsc2Uge1xuICAgIC8vXHRfZ2xvYmFscy5kb1QgPSBkb1Q7XG4gICAgLy99XG5cbiAgICB2YXIgc3RhcnRlbmQgPSB7XG4gICAgICAgIGFwcGVuZDoge3N0YXJ0OiBcIicrKFwiLCBlbmQ6IFwiKSsnXCIsIHN0YXJ0ZW5jb2RlOiBcIicrZW5jb2RlSFRNTChcIn0sXG4gICAgICAgIHNwbGl0OiB7c3RhcnQ6IFwiJztvdXQrPShcIiwgZW5kOiBcIik7b3V0Kz0nXCIsIHN0YXJ0ZW5jb2RlOiBcIic7b3V0Kz1lbmNvZGVIVE1MKFwifVxuICAgIH0sIHNraXAgPSAvJF4vO1xuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZURlZnMoYywgYmxvY2ssIGRlZikge1xuICAgICAgICByZXR1cm4gKCh0eXBlb2YgYmxvY2sgPT09IFwic3RyaW5nXCIpID8gYmxvY2sgOiBibG9jay50b1N0cmluZygpKVxuICAgICAgICAgICAgLnJlcGxhY2UoYy5kZWZpbmUgfHwgc2tpcCwgZnVuY3Rpb24obSwgY29kZSwgYXNzaWduLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChjb2RlLmluZGV4T2YoXCJkZWYuXCIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnN1YnN0cmluZyg0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEoY29kZSBpbiBkZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhc3NpZ24gPT09IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYy5kZWZpbmVQYXJhbXMpIHZhbHVlLnJlcGxhY2UoYy5kZWZpbmVQYXJhbXMsIGZ1bmN0aW9uKG0sIHBhcmFtLCB2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmW2NvZGVdID0ge2FyZzogcGFyYW0sIHRleHQ6IHZ9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjb2RlIGluIGRlZikpIGRlZltjb2RlXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEZ1bmN0aW9uKFwiZGVmXCIsIFwiZGVmWydcIiArIGNvZGUgKyBcIiddPVwiICsgdmFsdWUpKGRlZik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlcGxhY2UoYy51c2UgfHwgc2tpcCwgZnVuY3Rpb24obSwgY29kZSkge1xuICAgICAgICAgICAgICAgIGlmIChjLnVzZVBhcmFtcykgY29kZSA9IGNvZGUucmVwbGFjZShjLnVzZVBhcmFtcywgZnVuY3Rpb24obSwgcywgZCwgcGFyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZltkXSAmJiBkZWZbZF0uYXJnICYmIHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcncgPSAoZCArIFwiOlwiICsgcGFyYW0pLnJlcGxhY2UoLyd8XFxcXC9nLCBcIl9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWYuX19leHAgPSBkZWYuX19leHAgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWYuX19leHBbcnddID0gZGVmW2RdLnRleHQucmVwbGFjZShuZXcgUmVnRXhwKFwiKF58W15cXFxcdyRdKVwiICsgZGVmW2RdLmFyZyArIFwiKFteXFxcXHckXSlcIiwgXCJnXCIpLCBcIiQxXCIgKyBwYXJhbSArIFwiJDJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcyArIFwiZGVmLl9fZXhwWydcIiArIHJ3ICsgXCInXVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSBuZXcgRnVuY3Rpb24oXCJkZWZcIiwgXCJyZXR1cm4gXCIgKyBjb2RlKShkZWYpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2ID8gcmVzb2x2ZURlZnMoYywgdiwgZGVmKSA6IHY7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmVzY2FwZShjb2RlKSB7XG4gICAgICAgIHJldHVybiBjb2RlLnJlcGxhY2UoL1xcXFwoJ3xcXFxcKS9nLCBcIiQxXCIpLnJlcGxhY2UoL1tcXHJcXHRcXG5dL2csIFwiIFwiKTtcbiAgICB9XG5cbiAgICBkb1QudGVtcGxhdGUgPSBmdW5jdGlvbih0bXBsLCBjLCBkZWYsIGRvbnRSZW5kZXJOdWxsT3JVbmRlZmluZWQpIHtcbiAgICAgICAgYyA9IGMgfHwgZG9ULnRlbXBsYXRlU2V0dGluZ3M7XG4gICAgICAgIHZhciBjc2UgPSBjLmFwcGVuZCA/IHN0YXJ0ZW5kLmFwcGVuZCA6IHN0YXJ0ZW5kLnNwbGl0LCBuZWVkaHRtbGVuY29kZSwgc2lkID0gMCwgaW5kdixcbiAgICAgICAgICAgIHN0ciA9IChjLnVzZSB8fCBjLmRlZmluZSkgPyByZXNvbHZlRGVmcyhjLCB0bXBsLCBkZWYgfHwge30pIDogdG1wbDtcblxuICAgICAgICB2YXIgdW5lc2NhcGVDb2RlO1xuXG4gICAgICAgIHN0ciA9IChcInZhciBvdXQ9J1wiICsgKGMuc3RyaXAgPyBzdHIucmVwbGFjZSgvKF58XFxyfFxcbilcXHQqICt8ICtcXHQqKFxccnxcXG58JCkvZywgXCIgXCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxyfFxcbnxcXHR8XFwvXFwqW1xcc1xcU10qP1xcKlxcLy9nLCBcIlwiKSA6IHN0cilcbiAgICAgICAgICAgIC5yZXBsYWNlKC8nfFxcXFwvZywgXCJcXFxcJCZcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKGMuaW50ZXJwb2xhdGUgfHwgc2tpcCwgZnVuY3Rpb24obSwgY29kZSkge1xuICAgICAgICAgICAgICAgIGlmICghIWRvbnRSZW5kZXJOdWxsT3JVbmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5lc2NhcGVDb2RlID0gdW5lc2NhcGUoY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmluZGV4T2YoJ3x8JykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNzZS5zdGFydCArIHVuZXNjYXBlQ29kZSArIGNzZS5lbmQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3NlLnN0YXJ0ICsgJyh0eXBlb2YgJyArIGNvZGUgKyAnICE9PSBcInVuZGVmaW5lZFwiICYmICcgKyBjb2RlICsgJyE9PSBudWxsKT8nICsgdW5lc2NhcGVDb2RlICsgJzogXCJcIicgKyBjc2UuZW5kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNzZS5zdGFydCArIHVuZXNjYXBlKGNvZGUpICsgY3NlLmVuZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY3NlLnN0YXJ0ICsgdW5lc2NhcGUoY29kZSkgKyBjc2UuZW5kO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXBsYWNlKGMuZW5jb2RlIHx8IHNraXAsIGZ1bmN0aW9uKG0sIGNvZGUpIHtcbiAgICAgICAgICAgICAgICBuZWVkaHRtbGVuY29kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNzZS5zdGFydGVuY29kZSArIHVuZXNjYXBlKGNvZGUpICsgY3NlLmVuZDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVwbGFjZShjLmNvbmRpdGlvbmFsIHx8IHNraXAsIGZ1bmN0aW9uKG0sIGVsc2VjYXNlLCBjb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsc2VjYXNlID9cbiAgICAgICAgICAgICAgICAgICAgKGNvZGUgPyBcIic7fWVsc2UgaWYoXCIgKyB1bmVzY2FwZShjb2RlKSArIFwiKXtvdXQrPSdcIiA6IFwiJzt9ZWxzZXtvdXQrPSdcIikgOlxuICAgICAgICAgICAgICAgICAgICAoY29kZSA/IFwiJztpZihcIiArIHVuZXNjYXBlKGNvZGUpICsgXCIpe291dCs9J1wiIDogXCInO31vdXQrPSdcIik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlcGxhY2UoYy5pdGVyYXRlIHx8IHNraXAsIGZ1bmN0aW9uKG0sIGl0ZXJhdGUsIHZuYW1lLCBpbmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXRlcmF0ZSkgcmV0dXJuIFwiJzt9IH0gb3V0Kz0nXCI7XG4gICAgICAgICAgICAgICAgc2lkICs9IDE7XG4gICAgICAgICAgICAgICAgaW5kdiA9IGluYW1lIHx8IFwiaVwiICsgc2lkO1xuICAgICAgICAgICAgICAgIGl0ZXJhdGUgPSB1bmVzY2FwZShpdGVyYXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xcJzt2YXIgYXJyJyArIHNpZCArICc9JyArIGl0ZXJhdGUgKyBcIjtpZihhcnJcIiArIHNpZCArIFwiKXt2YXIgXCIgKyB2bmFtZSArIFwiLFwiICsgaW5kdiArIFwiPS0xLGxcIiArIHNpZCArIFwiPWFyclwiICsgc2lkICsgXCIubGVuZ3RoLTE7d2hpbGUoXCIgKyBpbmR2ICsgXCI8bFwiICsgc2lkICsgXCIpe1wiXG4gICAgICAgICAgICAgICAgICAgICsgdm5hbWUgKyBcIj1hcnJcIiArIHNpZCArIFwiW1wiICsgaW5kdiArIFwiKz0xXTtvdXQrPSdcIjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVwbGFjZShjLmV2YWx1YXRlIHx8IHNraXAsIGZ1bmN0aW9uKG0sIGNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCInO1wiICsgdW5lc2NhcGUoY29kZSkgKyBcIm91dCs9J1wiO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKyBcIic7cmV0dXJuIG91dDtcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKS5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0JykucmVwbGFjZSgvXFxyL2csIFwiXFxcXHJcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC8oXFxzfDt8XFx9fF58XFx7KW91dFxcKz0nJzsvZywgJyQxJykucmVwbGFjZSgvXFwrJycvZywgXCJcIik7XG4gICAgICAgIC8vLnJlcGxhY2UoLyhcXHN8O3xcXH18XnxcXHspb3V0XFwrPScnXFwrL2csJyQxb3V0Kz0nKTtcblxuICAgICAgICBpZiAobmVlZGh0bWxlbmNvZGUpIHtcbiAgICAgICAgICAgIGlmICghYy5zZWxmY29udGFpbmVkICYmIF9nbG9iYWxzICYmICFfZ2xvYmFscy5fZW5jb2RlSFRNTCkgX2dsb2JhbHMuX2VuY29kZUhUTUwgPSBkb1QuZW5jb2RlSFRNTFNvdXJjZShjLmRvTm90U2tpcEVuY29kZWQpO1xuICAgICAgICAgICAgc3RyID0gXCJ2YXIgZW5jb2RlSFRNTCA9IHR5cGVvZiBfZW5jb2RlSFRNTCAhPT0gJ3VuZGVmaW5lZCcgPyBfZW5jb2RlSFRNTCA6IChcIlxuICAgICAgICAgICAgICAgICsgZG9ULmVuY29kZUhUTUxTb3VyY2UudG9TdHJpbmcoKSArIFwiKFwiICsgKGMuZG9Ob3RTa2lwRW5jb2RlZCB8fCAnJykgKyBcIikpO1wiXG4gICAgICAgICAgICAgICAgKyBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oYy52YXJuYW1lLCBzdHIpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpIGNvbnNvbGUubG9nKFwiQ291bGQgbm90IGNyZWF0ZSBhIHRlbXBsYXRlIGZ1bmN0aW9uOiBcIiArIHN0cik7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGRvVC5jb21waWxlID0gZnVuY3Rpb24odG1wbCwgZGVmKSB7XG4gICAgICAgIHJldHVybiBkb1QudGVtcGxhdGUodG1wbCwgbnVsbCwgZGVmKTtcbiAgICB9O1xuXG59KCkpO1xuXG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2FwcC9zY3JpcHRzL2dyaWQvZG9ULmpzXG4gKiogbW9kdWxlIGlkID0gOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqXG4gKiBTcHJlYWRKUyBMaWJyYXJ5IDEuMC4wXG4gKiBodHRwOi8vd2lqbW8uY29tL1xuICpcbiAqIENvcHlyaWdodChjKSBHcmFwZUNpdHksIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIFdpam1vIENvbW1lcmNpYWwgTGljZW5zZS4gQWxzbyBhdmFpbGFibGUgdW5kZXIgdGhlIEdOVSBHUEwgVmVyc2lvbiAzIGxpY2Vuc2UuXG4gKiBsaWNlbnNpbmdAd2lqbW8uY29tXG4gKiBodHRwOi8vd2lqbW8uY29tL3dpZGdldHMvbGljZW5zZS9cbiAqXG4gKlxuICoqL1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgQ2FsYyA9IHt9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDYWxjO1xuXG4gICAgdmFyIENPTlNUX1VOREVGSU5FRCA9ICd1bmRlZmluZWQnO1xuICAgIHZhciBDT05TVF9OVU1CRVIgPSAnbnVtYmVyJztcbiAgICB2YXIgQ09OU1RfU1RSSU5HID0gJ3N0cmluZyc7XG4gICAgdmFyIENPTlNUX0JPT0xFQU4gPSAnYm9vbGVhbic7XG4gICAgdmFyIENPTlNUX1RSVUUgPSAnVFJVRSc7XG4gICAgdmFyIENPTlNUX0ZBTFNFID0gJ0ZBTFNFJztcbiAgICB2YXIgQ09OU1RfQVJSQVkgPSAnQVJSQVknOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICB2YXIgQ09OU1RfQVJSQVlST1cgPSAnQVJSQVlST1cnOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICB2YXIgQ09OU1RfTlVMTCA9ICcjTlVMTCEnO1xuICAgIHZhciBDT05TVF9ESVYwID0gJyNESVYvMCEnO1xuICAgIHZhciBDT05TVF9WQUxVRSA9ICcjVkFMVUUhJztcbiAgICB2YXIgQ09OU1RfUkVGID0gJyNSRUYhJztcbiAgICB2YXIgQ09OU1RfTkFNRSA9ICcjTkFNRT8nO1xuICAgIHZhciBDT05TVF9OQSA9ICcjTi9BJztcbiAgICB2YXIgQ09OU1RfTlVNID0gJyNOVU0hJztcbiAgICB2YXIgQ09OU1RfRVhQUiA9ICdleHByJzsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgdmFyIEVSUk9SX0xJU1QgPSBbQ09OU1RfTlVMTCwgQ09OU1RfRElWMCwgQ09OU1RfVkFMVUUsIENPTlNUX1JFRiwgQ09OU1RfTkFNRSwgQ09OU1RfTkEsIENPTlNUX05VTV07XG4gICAgdmFyIEVSUk9SQ09ERV9MSVNUID0gWzB4MDAsIDB4MDcsIDB4MEYsIDB4MTcsIDB4MUQsIDB4MkEsIDB4MjRdO1xuICAgIHZhciBMRVRURVJfUE9XUyA9IFsxLCAyNiwgNjc2XTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgdmFyIEtFWVdPUkRfTlVMTCA9IG51bGw7XG4gICAgdmFyIEtFWVdPUkRfVU5ERUZJTkVEID0gdW5kZWZpbmVkO1xuICAgIHZhciBNQVRIX01JTiA9IE1hdGgubWluOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICB2YXIgTUFUSF9NQVggPSBNYXRoLm1heDsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgdmFyIE1BVEhfQUJTID0gTWF0aC5hYnM7XG4gICAgdmFyIE1BVEhfUE9XID0gTWF0aC5wb3c7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIHZhciBTUiA9IHJlcXVpcmUoJy4vc3RyaW5nUmVzb3VyY2UnKTtcbiAgICBDYWxjLnNyID0gU1I7XG4gICAgQ2FsYy5wYXJzZU9wdGlvbiA9IG51bGw7XG5cbiAgICB2YXIgU1JIZWxwZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNSSGVscGVyKCkge1xuXG4gICAgICAgIH1cblxuICAgICAgICBTUkhlbHBlci50aHJvd1NSID0gZnVuY3Rpb24oc3IpIHtcbiAgICAgICAgICAgIC8vdGhyb3cgU1JIZWxwZXIuc3Ioc3IpXG4gICAgICAgIH1cblxuICAgICAgICBTUkhlbHBlci5zciA9IGZ1bmN0aW9uKHNyKSB7XG4gICAgICAgICAgICAvL3JldHVybiBnbG9iYWxpemUuQ3VsdHVyZXMuU1Jbc3JdO1xuICAgICAgICB9XG5cbiAgICAgICAgU1JIZWxwZXIuY3IgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAvL3JldHVybiBnbG9iYWxpemUuQ3VsdHVyZXMuQ1JbbmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gU1JIZWxwZXI7XG4gICAgfSkoKTtcbiAgICBDYWxjLlNSSGVscGVyID0gU1JIZWxwZXI7XG5cbiAgICB2YXIgdGhyb3dTUiA9IENhbGMuU1JIZWxwZXIudGhyb3dTUjtcbiAgICB2YXIgc3IgPSBDYWxjLlNSSGVscGVyLnNyO1xuICAgIHZhciBjciA9IENhbGMuU1JIZWxwZXIuY3I7XG4gICAgdmFyIGludmFsaWRDYXN0ID0gJ0V4cF9JbnZhbGlkQ2FzdCc7XG5cbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIHRoZSBtaXNzaW5nIGFyZ3VtZW50IGNvbnN0YW50LlxuICAgICAqL1xuICAgIENhbGMubWlzc2luZ0FyZ3VtZW50ID0ge307XG5cbiAgICB2YXIgX19leHRlbmRzID0gZnVuY3Rpb24oZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIHtcbiAgICAgICAgICAgIGlmIChiLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgICAgICAgZFtwXSA9IGJbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX18oKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgICAgICAgfVxuXG4gICAgICAgIF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICAgICAgICBkLnByb3RvdHlwZSA9IG5ldyBfXygpO1xuICAgIH07XG4gICAgQ2FsYy5fX2V4dGVuZHMgPSBfX2V4dGVuZHM7XG5cbiAgICAoZnVuY3Rpb24oQ2FsY1ZhbHVlVHlwZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogIFRoZSBhbnkgdHlwZS5cbiAgICAgICAgICovXG4gICAgICAgIENhbGNWYWx1ZVR5cGVbQ2FsY1ZhbHVlVHlwZVsnYW55VHlwZSddID0gMF0gPSAnYW55VHlwZSc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqICBUaGUgbnVtYmVyIHR5cGUuXG4gICAgICAgICAqL1xuICAgICAgICBDYWxjVmFsdWVUeXBlW0NhbGNWYWx1ZVR5cGVbJ251bWJlclR5cGUnXSA9IDFdID0gJ251bWJlclR5cGUnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgVGhlIHN0cmluZyB0eXBlLlxuICAgICAgICAgKi9cbiAgICAgICAgQ2FsY1ZhbHVlVHlwZVtDYWxjVmFsdWVUeXBlWydzdHJpbmdUeXBlJ10gPSAyXSA9ICdzdHJpbmdUeXBlJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogIFRoZSBib29sZWFuIHR5cGUuXG4gICAgICAgICAqL1xuICAgICAgICBDYWxjVmFsdWVUeXBlW0NhbGNWYWx1ZVR5cGVbJ2Jvb2xlYW5UeXBlJ10gPSAzXSA9ICdib29sZWFuVHlwZSc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqICBUaGUgZGF0ZSB0eXBlLlxuICAgICAgICAgKi9cbiAgICAgICAgQ2FsY1ZhbHVlVHlwZVtDYWxjVmFsdWVUeXBlWydkYXRlVHlwZSddID0gNF0gPSAnZGF0ZVR5cGUnO1xuICAgIH0pKENhbGMuQ2FsY1ZhbHVlVHlwZSB8fCAoQ2FsYy5DYWxjVmFsdWVUeXBlID0ge30pKTtcblxuICAgIHZhciBDb252ZXJ0ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBDb252ZXJ0KCkge1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pc051bWJlciB1c2Ugc2hvcnQgbmFtZSB0byByZWR1Y2Ugc2l6ZVxuICAgICAgICBDb252ZXJ0Lm51bSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gQ09OU1RfTlVNQkVSKSB8fCAodHlwZW9mIHZhbHVlID09PSBDT05TVF9CT09MRUFOKSB8fCAoIWlzTmFOKHZhbHVlKSAmJiAhaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpKSB8fCAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL3N0YXRpYyBpc051bWJlcih2YWx1ZTogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIC8vICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSBjb25zdF9udW1iZXIpIHx8ICghaXNOYU4odmFsdWUpICYmICFpc05hTihwYXJzZUZsb2F0KHZhbHVlKSkpIHx8XG4gICAgICAgIC8vICAgICAgICAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKTtcbiAgICAgICAgLy99XG4gICAgICAgIC8vIGlzRXJyb3IsIHVzZSBzaG9ydCBuYW1lIHRvIHJlZHVjZSBzaXplXG4gICAgICAgIENvbnZlcnQuZXJyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIENhbGNFcnJvcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBpc0FycmF5LCB1c2Ugc2hvcnQgbmFtZSB0byByZWR1Y2Ugc2l6ZVxuICAgICAgICBDb252ZXJ0LmFyciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBBcnJheTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL2lzUmVmZXJlbmNlLCB1c2Ugc2hvcnQgbmFtZSB0byByZWR1Y2Ugc2l6ZVxuICAgICAgICBDb252ZXJ0LnJlZiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBSZWZlcmVuY2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgQ29udmVydC50b1Jlc3VsdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2FsYy5DYWxjRXJyb3JzTnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIENvbnZlcnQudG9BcnIgPSBmdW5jdGlvbih2YWx1ZSwgdmFsdWVUeXBlLCB0b09uZURpbWVuc2lvbiwgYnJlYWtPbkVycm9yLCBicmVha09uQ29udmVydEVycm9yLCBpZ25vcmVCbGFuaykge1xuICAgICAgICAgICAgcmV0dXJuIEtFWVdPUkRfTlVMTDtcbiAgICAgICAgfTtcblxuICAgICAgICBDb252ZXJ0LmNvbnZlcnRWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlLCB2YWx1ZVR5cGUsIGNvbnZlcnQsIGlnbm9yZUJsYW5rKSB7XG4gICAgICAgICAgICBpZiAoQ29udmVydC5lcnIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlZlZhbHVlID0ge3ZhbHVlOiBLRVlXT1JEX05VTEx9O1xuICAgICAgICAgICAgdmFyIGVycm9yID0gQ29udmVydC5DYWxjQ29udmVydGVkRXJyb3I7XG4gICAgICAgICAgICBpZiAoaWdub3JlQmxhbmsgJiYgdmFsdWVUeXBlICE9PSAwIC8qIGFueVR5cGUgKi8gJiYgKHZhbHVlID09PSBLRVlXT1JEX05VTEwgfHwgdmFsdWUgPT09IEtFWVdPUkRfVU5ERUZJTkVEKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodmFsdWVUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIG51bWJlclR5cGUgKi9cbiAgICAgICAgICAgICAgICA6XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udmVydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YgdmFsdWUpICE9PSBDT05TVF9OVU1CRVIgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChDb252ZXJ0LnJEKHZhbHVlLCByZWZWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlZlZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNCAvKiBkYXRlVHlwZSAqL1xuICAgICAgICAgICAgICAgIDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBDT05TVF9TVFJJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRlID0gQ29udmVydC5fcGFyc2VMb2NhbGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRlICE9PSBDT05TVF9VTkRFRklORUQgJiYgZGF0ZSAhPT0gS0VZV09SRF9OVUxMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBDb252ZXJ0Ll90b09BRGF0ZShkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghY29udmVydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YgdmFsdWUpICE9PSBDT05TVF9OVU1CRVIgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChDb252ZXJ0LnJEKHZhbHVlLCByZWZWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlZlZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBib29sZWFuVHlwZSAqL1xuICAgICAgICAgICAgICAgIDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb252ZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiB2YWx1ZSkgIT09IENPTlNUX0JPT0xFQU4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKENvbnZlcnQuckIodmFsdWUsIHJlZlZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVmVmFsdWUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIHN0cmluZ1R5cGUgKi9cbiAgICAgICAgICAgICAgICA6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPT09IEtFWVdPUkRfTlVMTCB8fCB2YWx1ZSA9PT0gS0VZV09SRF9VTkRFRklORUQgPyAnJyA6IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIENvbnZlcnQuX2lzTmFOT3JJbmZpbml0ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gdG9JbnQsIHVzZSBJIGZvciBjb2RlIHNpemUuXG4gICAgICAgIENvbnZlcnQuSSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgZFZhbCA9IENvbnZlcnQuRCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoTUFUSF9BQlMoZFZhbCkgPCAxRSsyMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChkVmFsLCAxMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93U1IoJ0V4cF9JbnZhbGlkQ2FzdCcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHRvRG91YmxlLCB1c2UgRCBmb3IgY29kZSBzaXplLlxuICAgICAgICBDb252ZXJ0LkQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGRvdWJsZVZhbHVlID0ge3ZhbHVlOiAwfTtcbiAgICAgICAgICAgIGlmIChDb252ZXJ0LnJEKHZhbHVlLCBkb3VibGVWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG91YmxlVmFsdWUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvd1NSKGludmFsaWRDYXN0KTtcbiAgICAgICAgICAgIDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyB0cnlUb0RvdWJsZSwgdXNlIHJEIGZvciBjb2RlIHNpemUuXG4gICAgICAgIENvbnZlcnQuckQgPSBmdW5jdGlvbih2YWx1ZSwgZG91YmxlVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBLRVlXT1JEX05VTEw7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBDT05TVF9VTkRFRklORUQgfHwgdmFsdWUgPT09IEtFWVdPUkRfTlVMTCkge1xuICAgICAgICAgICAgICAgIGRvdWJsZVZhbHVlLnZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0eXBlc3RyID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZXN0ciA9PT0gQ09OU1RfTlVNQkVSKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBOdW1iZXIodmFsdWUpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKENvbnZlcnQuX2lzTmFOT3JJbmZpbml0ZShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVzdHIgPT09IENPTlNUX1NUUklORykge1xuICAgICAgICAgICAgICAgICAgICAvLyBDeWxqIGNvbW1lbnQgdGhpcyBjb2RlIGF0IDIwMTQvMi8xMS5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBjb2RlIHdpbGwgdGFrZSB0aGUgcGVyZm9ybWVuY2UgcHJvYmxlbSwgYW5kIFNwcmVhZFggZG9zZSBub3QgaGF2ZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvZGUgdG9vLlxuICAgICAgICAgICAgICAgICAgICAvL3ZhciBkYXRlID0gc3ByZWFkLl9EYXRlVGltZUhlbHBlci5wYXJzZUxvY2FsZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vaWYgKHR5cGVvZiBkYXRlICE9PSBjb25zdF91bmRlZmluZWQgJiYgZGF0ZSAhPT0ga2V5d29yZF9udWxsKVxuICAgICAgICAgICAgICAgICAgICAvLyAgICByZXN1bHQgPSBuZXcgc3ByZWFkLl9EYXRlVGltZUhlbHBlcihkYXRlKS50b09BRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAvL2Vsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG91YmxlVmFsdWUudmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzUGVyY2VudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuY2hhckF0KHZhbHVlLmxlbmd0aCAtIDEpID09PSAnJScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUGVyY2VudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigwLCB2YWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgTnVtYmVyKHZhbHVlKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChDb252ZXJ0Ll9pc05hTk9ySW5maW5pdGUocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1BlcmNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCAvPSAxMDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy99XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlc3RyID09PSBDT05TVF9CT09MRUFOKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gQ29udmVydC5fdG9PQURhdGUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvdWJsZVZhbHVlLnZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gdHJ5VG9Cb29sLCB1c2UgckIgZm9yIGNvZGUgc2l6ZS5cbiAgICAgICAgQ29udmVydC5yQiA9IGZ1bmN0aW9uKHZhbHVlLCBib29sVmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gQ09OU1RfVU5ERUZJTkVEIHx8IHZhbHVlID09PSBLRVlXT1JEX05VTEwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBDT05TVF9CT09MRUFOKSB7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBDb252ZXJ0Ll90b09BRGF0ZSh2YWx1ZSkgIT09IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChDb252ZXJ0Lm51bSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAhPT0gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd1NSKGludmFsaWRDYXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9vbFZhbHVlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyB0b0Jvb2wsIHVzZSBCIGZvciBjb2RlIHNpemUuXG4gICAgICAgIENvbnZlcnQuQiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBDT05TVF9VTkRFRklORUQgfHwgdmFsdWUgPT09IEtFWVdPUkRfTlVMTCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBDT05TVF9CT09MRUFOKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29udmVydC5fdG9PQURhdGUodmFsdWUpICE9PSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChDb252ZXJ0Lm51bSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKENvbnZlcnQuZXJyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3dTUihpbnZhbGlkQ2FzdCk7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHRvU3RyaW5nLCB1c2UgUyBmb3IgY29kZSBzaXplLlxuICAgICAgICBDb252ZXJ0LlMgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBDT05TVF9VTkRFRklORUQgfHwgdmFsdWUgPT09IEtFWVdPUkRfTlVMTCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IENPTlNUX0JPT0xFQU4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gQ09OU1RfVFJVRSA6IENPTlNUX0ZBTFNFO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBDT05TVF9TVFJJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gbmV3IF9EYXRlVGltZUhlbHBlcih2YWx1ZSkubG9jYWxlRm9ybWF0KCdNL2QveXl5eSBoOm1tOnNzJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChDb252ZXJ0LmFycih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dTUihpbnZhbGlkQ2FzdCk7XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aHJvd1NSKGludmFsaWRDYXN0KTtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gdG9EYXRlVGltZSwgdXNlIERUIGZvciBjb2RlIHNpemUuXG4gICAgICAgIENvbnZlcnQuRFQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGRhdGVWYWx1ZSA9IHt2YWx1ZTogS0VZV09SRF9OVUxMfTtcbiAgICAgICAgICAgIGlmIChDb252ZXJ0LnJEVCh2YWx1ZSwgZGF0ZVZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlVmFsdWUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvd1NSKGludmFsaWRDYXN0KTtcbiAgICAgICAgICAgIDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyB0cnlUb0RhdGVUaW1lLCB1c2UgckRUIGZvciBjb2RlIHNpemUuXG4gICAgICAgIENvbnZlcnQuckRUID0gZnVuY3Rpb24odmFsdWUsIGRhdGVWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gQ09OU1RfVU5ERUZJTkVEIHx8IHZhbHVlID09PSBLRVlXT1JEX05VTEwpIHtcbiAgICAgICAgICAgICAgICBkYXRlVmFsdWUudmFsdWUgPSBDb252ZXJ0Ll9mcm9tT0FEYXRlKDApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICBkYXRlVmFsdWUudmFsdWUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gQ09OU1RfU1RSSU5HKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgICAgIHZhciBkYXRlVGltZSA9IENvbnZlcnQuX3BhcnNlTG9jYWxlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiBkYXRlVGltZSA9PT0gQ09OU1RfVU5ERUZJTkVEIHx8IGRhdGVUaW1lID09PSBLRVlXT1JEX05VTEwpICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVRpbWUgPSBDb252ZXJ0Ll9mcm9tT0FEYXRlKHBhcnNlRmxvYXQodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGVUaW1lID09PSBLRVlXT1JEX1VOREVGSU5FRCB8fCBkYXRlVGltZSA9PT0gS0VZV09SRF9OVUxMKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0ZVZhbHVlLnZhbHVlID0gZGF0ZVRpbWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gQ09OU1RfTlVNQkVSKSB7XG4gICAgICAgICAgICAgICAgZGF0ZVZhbHVlLnZhbHVlID0gQ29udmVydC5fZnJvbU9BRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIDE0NDA6IDYwKjI0ICBvbmVEYXlNaW51dGVcbiAgICAgICAgLy8gODY0MDAwMDA6IG9uZURheU1pbGxTZWNvbmRzXG4gICAgICAgIC8vIDI1NTY5OiBvYURhdGUgb2YgMTk3MC8xLzFcbiAgICAgICAgLy8gRGF0ZS5nZXRUaW1lKCkgbWlsbCBzZWNvbmRzIGZyb20gMTk3MC8xLzEoVVRDKVxuICAgICAgICBDb252ZXJ0Ll90b09BRGF0ZSA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgICAgIGlmIChkYXRlID09PSBLRVlXT1JEX1VOREVGSU5FRCB8fCBkYXRlID09PSBLRVlXT1JEX05VTEwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vcmV0dXJuIChkYXRlLmdldFRpbWUoKSAvIDg2NDAwMDAwKSArIDI1NTY5IC0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpIC8gMTQ0MDtcbiAgICAgICAgICAgIC8vIG11bHRpcGx5IDg2NDAwMDAwIGFuZCAxNDQwIGZpcnN0IHRoZW4gZG8gZGl2aWRlLiBpdCB3aWxsIGNhdXNlIHNvbWUgZmxvYXQgcHJlY2lzaW9uIGVycm9yIGlmIHRoZSBvcmRlciBpcyBub3QuXG4gICAgICAgICAgICByZXR1cm4gKGRhdGUuZ2V0VGltZSgpICogMTQ0MCArIDI1NTY5ICogODY0MDAwMDAgKiAxNDQwIC0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogODY0MDAwMDApIC8gKDg2NDAwMDAwICogMTQ0MCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgQ29udmVydC5fZnJvbU9BRGF0ZSA9IGZ1bmN0aW9uKG9hZGF0ZSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldERheSA9IG9hZGF0ZSAtIDI1NTY5O1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShvZmZzZXREYXkgKiA4NjQwMDAwMCk7XG5cbiAgICAgICAgICAgIC8vIG11bHRpcGx5IDg2NDAwMDAwIGZpcnN0IHRoZW4gZG8gZGl2aWRlLiBpdCB3aWxsIGNhdXNlIHNvbWUgZmxvYXQgcHJlY2lzaW9uIGVycm9yIGlmIHRoZSBvcmRlciBpcyBub3QuXG4gICAgICAgICAgICAvLyAyMDE0LzEwLzE3IGJlbi55aW4gaGVyZSBpcyBhICcrMScgb3IgJy0xJywgaXMgZm9yIGphdmFzY3JpcHQgZGl2aWRlIGxvdyBwcmVjaXNpb24sIGl0IHdpbGwgbG9zcyBsYXN0IGRpZ2l0IHByZWNpc2lvbi5TbyBoZXJlIGFkZCAxLCBmb3IgbG9zcywgZm9yIHJlc3VsdCByaWdodC5cbiAgICAgICAgICAgIC8vIGFkZCAxIHdoZW4gYWZ0ZXIgMTk4Nywgc3ViIDEgd2hlbiBiZWZvcmUgMTk4N1xuICAgICAgICAgICAgdmFyIGFkanVzdFZhbHVlID0gb2Zmc2V0RGF5ID49IDAgPyAxIDogLTE7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoKG9hZGF0ZSAqIDg2NDAwMDAwICogMTQ0MCArIGFkanVzdFZhbHVlIC0gMjU1NjkgKiA4NjQwMDAwMCAqIDE0NDAgKyBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA4NjQwMDAwMCkgLyAxNDQwKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIENvbnZlcnQuX3BhcnNlTG9jYWxlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIENvbnZlcnQuQ2FsY0NvbnZlcnRlZEVycm9yID0ge307XG4gICAgICAgIHJldHVybiBDb252ZXJ0O1xuICAgIH0pKCk7XG4gICAgQ2FsYy5Db252ZXJ0ID0gQ29udmVydDtcblxuICAgIHZhciBfSGVscGVyID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBfSGVscGVyKCkge1xuICAgICAgICB9XG5cbiAgICAgICAgX0hlbHBlci5fYXJndW1lbnRFeGlzdHMgPSBmdW5jdGlvbihhcmdzLCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3MgJiYgaW5kZXggPCBhcmdzLmxlbmd0aCAmJiAoYXJnc1tpbmRleF0gIT09IENhbGMubWlzc2luZ0FyZ3VtZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgX0hlbHBlci5fYXJndW1lbnRWYWxpZCA9IGZ1bmN0aW9uKGFyZ3MsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXJnID0gYXJnc1tpbmRleF07XG4gICAgICAgICAgICByZXR1cm4gYXJnICE9PSBDYWxjLm1pc3NpbmdBcmd1bWVudCAmJiBhcmcgIT09IEtFWVdPUkRfTlVMTCAmJiBhcmcgIT09IEtFWVdPUkRfVU5ERUZJTkVEICYmICFhcmcuX2Vycm9yO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX0hlbHBlcjtcbiAgICB9KSgpO1xuICAgIENhbGMuX0hlbHBlciA9IF9IZWxwZXI7XG5cbiAgICB2YXIgU3RyaW5nVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gU3RyaW5nVXRpbCgpIHtcbiAgICAgICAgfVxuXG4gICAgICAgIFN0cmluZ1V0aWwucmVwbGFjZSA9IGZ1bmN0aW9uKHNyYywgc3Vic3RyLCByZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHNyYy5zcGxpdChzdWJzdHIpLmpvaW4ocmVwbGFjZW1lbnQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIFN0cmluZ1V0aWwuc3RhcnRzV2l0aCA9IGZ1bmN0aW9uKHNyYywgcHJlZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjLmluZGV4T2YocHJlZml4KSA9PT0gMDtcbiAgICAgICAgfTtcblxuICAgICAgICBTdHJpbmdVdGlsLmVuZHNXaXRoID0gZnVuY3Rpb24oc3JjLCBzdWZmaXgpIHtcbiAgICAgICAgICAgIHZhciBsID0gc3JjLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gbCA+PSAwICYmIHNyYy5pbmRleE9mKHN1ZmZpeCwgbCkgPT09IGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgU3RyaW5nVXRpbC5sZWZ0QmVmb3JlID0gZnVuY3Rpb24oc3JjLCBzdWZmZXgpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHNyYy5pbmRleE9mKHN1ZmZleCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3JjO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3JjLnN1YnN0cigwLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgU3RyaW5nVXRpbC5jb250YWlucyA9IGZ1bmN0aW9uKHNyYywgc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBzcmMuaW5kZXhPZihzcykgPj0gMDtcbiAgICAgICAgfTtcblxuICAgICAgICBTdHJpbmdVdGlsLmNvdW50ID0gZnVuY3Rpb24oc3JjLCBzcykge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBwb3MgPSBzcmMuaW5kZXhPZihzcyk7XG4gICAgICAgICAgICB3aGlsZSAocG9zID49IDApIHtcbiAgICAgICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgICAgICAgIHBvcyA9IHNyYy5pbmRleE9mKHNzLCBwb3MgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFN0cmluZ1V0aWw7XG4gICAgfSkoKTtcbiAgICBDYWxjLlN0cmluZ1V0aWwgPSBTdHJpbmdVdGlsO1xuXG4gICAgdmFyIFJlZ1V0aWwgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlZ1V0aWwoKSB7XG4gICAgICAgIH1cblxuICAgICAgICBSZWdVdGlsLmdldFJlZyA9IGZ1bmN0aW9uKHJlZ1N0cikge1xuICAgICAgICAgICAgdmFyIHJlZyA9IFJlZ1V0aWwucmVnRGljdFtyZWdTdHJdO1xuICAgICAgICAgICAgaWYgKCFyZWcpIHtcbiAgICAgICAgICAgICAgICByZWcgPSBSZWdVdGlsLnJlZ0RpY3RbcmVnU3RyXSA9IG5ldyBSZWdFeHAocmVnU3RyLCAnZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVnLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICByZXR1cm4gcmVnO1xuICAgICAgICB9O1xuXG4gICAgICAgIFJlZ1V0aWwuZ2V0UmVnSWdub3JlQ2FzZSA9IGZ1bmN0aW9uKHJlZ1N0cikge1xuICAgICAgICAgICAgdmFyIHJlZyA9IFJlZ1V0aWwucmVnRGljdElnbm9yZUNhc2VbcmVnU3RyXTtcbiAgICAgICAgICAgIGlmICghcmVnKSB7XG4gICAgICAgICAgICAgICAgcmVnID0gUmVnVXRpbC5yZWdEaWN0SWdub3JlQ2FzZVtyZWdTdHJdID0gbmV3IFJlZ0V4cChyZWdTdHIsICdnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVnLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICByZXR1cm4gcmVnO1xuICAgICAgICB9O1xuXG4gICAgICAgIFJlZ1V0aWwuZ2V0V2lsZGNhcmRDcml0ZXJpYSA9IGZ1bmN0aW9uKGNyaXRlcmlhKSB7XG4gICAgICAgICAgICBpZiAoUmVnVXRpbC53aWxkY2FyZFBhcnNlUmVjb3JkW2NyaXRlcmlhXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWdVdGlsLndpbGRjYXJkUGFyc2VSZXN1bHRCdWZmZXJbY3JpdGVyaWFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFJlZ1V0aWwuZ2V0UmVnKCdbfj8qXSsnKS50ZXN0KGNyaXRlcmlhKSkge1xuICAgICAgICAgICAgICAgIHZhciBjcml0ZXJpYVRlbXAgPSBjcml0ZXJpYTtcbiAgICAgICAgICAgICAgICB2YXIgYXN0ZXJpc2tTeW1ib2wgPSBSZWdVdGlsLmdldFJlcGxhY2VTeW1ib2woJ2FzdGVyaXNrJywgY3JpdGVyaWFUZW1wKTtcbiAgICAgICAgICAgICAgICB2YXIgcXVlc3Rpb25TeW1ib2wgPSBSZWdVdGlsLmdldFJlcGxhY2VTeW1ib2woJ3F1ZXN0aW9uJywgY3JpdGVyaWFUZW1wKTtcbiAgICAgICAgICAgICAgICB2YXIgdGlsZGVTeW1ib2wgPSBSZWdVdGlsLmdldFJlcGxhY2VTeW1ib2woJ3RpbGRlJywgY3JpdGVyaWFUZW1wKTtcblxuICAgICAgICAgICAgICAgIGNyaXRlcmlhVGVtcCA9IFN0cmluZ1V0aWwucmVwbGFjZShjcml0ZXJpYVRlbXAsICd+ficsIHRpbGRlU3ltYm9sKTtcbiAgICAgICAgICAgICAgICBjcml0ZXJpYVRlbXAgPSBTdHJpbmdVdGlsLnJlcGxhY2UoY3JpdGVyaWFUZW1wLCAnfionLCBhc3Rlcmlza1N5bWJvbCk7XG4gICAgICAgICAgICAgICAgY3JpdGVyaWFUZW1wID0gU3RyaW5nVXRpbC5yZXBsYWNlKGNyaXRlcmlhVGVtcCwgJ34/JywgcXVlc3Rpb25TeW1ib2wpO1xuXG4gICAgICAgICAgICAgICAgY3JpdGVyaWFUZW1wID0gY3JpdGVyaWFUZW1wLnJlcGxhY2UoUmVnVXRpbC5nZXRSZWcoJyhbLiskXlxcXFxbXFxcXF0oKXt9fFxcL10pJyksICdcXFxcJDEnKTtcbiAgICAgICAgICAgICAgICBjcml0ZXJpYVRlbXAgPSBTdHJpbmdVdGlsLnJlcGxhY2UoY3JpdGVyaWFUZW1wLCAnKicsICcuKicpO1xuICAgICAgICAgICAgICAgIGNyaXRlcmlhVGVtcCA9IFN0cmluZ1V0aWwucmVwbGFjZShjcml0ZXJpYVRlbXAsICc/JywgJy4nKTtcblxuICAgICAgICAgICAgICAgIGNyaXRlcmlhVGVtcCA9IFN0cmluZ1V0aWwucmVwbGFjZShjcml0ZXJpYVRlbXAsIGFzdGVyaXNrU3ltYm9sLCAnXFxcXConKTtcbiAgICAgICAgICAgICAgICBjcml0ZXJpYVRlbXAgPSBTdHJpbmdVdGlsLnJlcGxhY2UoY3JpdGVyaWFUZW1wLCBxdWVzdGlvblN5bWJvbCwgJ1xcXFw/Jyk7XG4gICAgICAgICAgICAgICAgY3JpdGVyaWFUZW1wID0gU3RyaW5nVXRpbC5yZXBsYWNlKGNyaXRlcmlhVGVtcCwgdGlsZGVTeW1ib2wsICd+Jyk7XG4gICAgICAgICAgICAgICAgUmVnVXRpbC53aWxkY2FyZFBhcnNlUmVzdWx0QnVmZmVyW2NyaXRlcmlhXSA9IGNyaXRlcmlhVGVtcDtcbiAgICAgICAgICAgICAgICBSZWdVdGlsLndpbGRjYXJkUGFyc2VSZWNvcmRbY3JpdGVyaWFdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JpdGVyaWFUZW1wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gS0VZV09SRF9OVUxMO1xuICAgICAgICB9O1xuXG4gICAgICAgIFJlZ1V0aWwuZ2V0V2lsZGNhcmRDcml0ZXJpYUZ1bGxNYXRjaCA9IGZ1bmN0aW9uKGNyaXRlcmlhKSB7XG4gICAgICAgICAgICB2YXIgY3JpdGVyaWFUZW1wID0gUmVnVXRpbC5nZXRXaWxkY2FyZENyaXRlcmlhKGNyaXRlcmlhKTtcbiAgICAgICAgICAgIGlmIChjcml0ZXJpYVRlbXApIHtcbiAgICAgICAgICAgICAgICBjcml0ZXJpYVRlbXAgPSAnXicgKyBjcml0ZXJpYVRlbXAgKyAnJCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JpdGVyaWFUZW1wO1xuICAgICAgICB9O1xuXG4gICAgICAgIFJlZ1V0aWwuZ2V0UmVwbGFjZVN5bWJvbCA9IGZ1bmN0aW9uKGV4cGVjdFN5bWJvbCwgc3JjU3RyKSB7XG4gICAgICAgICAgICB2YXIgYXN0ZXJpc2tTeW1ib2wgPSAnIycgKyBleHBlY3RTeW1ib2wgKyAnMCMnO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCAxMDAwMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNyY1N0ci5pbmRleE9mKGFzdGVyaXNrU3ltYm9sKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYXN0ZXJpc2tTeW1ib2wgPSBTdHJpbmdVdGlsLnJlcGxhY2UoYXN0ZXJpc2tTeW1ib2wsICcjJyArIGV4cGVjdFN5bWJvbCArIChpIC0gMSkgKyAnIycsICcjJyArIGV4cGVjdFN5bWJvbCArIGkgKyAnIycpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzdGVyaXNrU3ltYm9sO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBSZWdVdGlsLnJlZ0RpY3QgPSB7fTtcbiAgICAgICAgUmVnVXRpbC5yZWdEaWN0SWdub3JlQ2FzZSA9IHt9O1xuICAgICAgICBSZWdVdGlsLndpbGRjYXJkUGFyc2VSZWNvcmQgPSB7fTtcbiAgICAgICAgUmVnVXRpbC53aWxkY2FyZFBhcnNlUmVzdWx0QnVmZmVyID0ge307XG4gICAgICAgIHJldHVybiBSZWdVdGlsO1xuICAgIH0pKCk7XG4gICAgQ2FsYy5SZWdVdGlsID0gUmVnVXRpbDtcblxuICAgIHZhciBDYWxjRXJyb3IgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXByZXNlbnRzIGFuIGVycm9yIGluIGNhbGN1bGF0aW9uLlxuICAgICAgICAgKiBAY2xhc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGVycm9yIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgZXJyb3IuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlcnJvckNvZGUgVGhlIGVycm9yIGNvZGUuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBDYWxjRXJyb3IoZXJyb3IsIGVycm9yQ29kZSkge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIHRoaXMuX2NvZGUgPSBlcnJvckNvZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGVycm9yIHN0cmluZy5cbiAgICAgICAgICovXG4gICAgICAgIENhbGNFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VzIHRoZSBzcGVjaWZpZWQgZXJyb3IgZnJvbSB0aGUgc3RyaW5nLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIGVycm9yIHN0cmluZy5cbiAgICAgICAgICogQHJldHVybnMgeyQud2lqbW8ud2lqc3ByZWFkLkNhbGMuRXJyb3J9IFRoZSBjYWxjdWxhdGlvbiBlcnJvci5cbiAgICAgICAgICovXG4gICAgICAgIENhbGNFcnJvci5wYXJzZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gQ2FsY0Vycm9yLl9wYXJzZUNvcmUodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGVyciA9PT0gS0VZV09SRF9VTkRFRklORUQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnSW5jb3JyZWN0IGVycm9yISc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9O1xuXG4gICAgICAgIENhbGNFcnJvci5fcGFyc2VDb3JlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IENPTlNUX1VOREVGSU5FRCAmJiB2YWx1ZSAhPT0gS0VZV09SRF9OVUxMICYmIHZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgRVJST1JfTElTVC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJySXRlbSA9IEVSUk9SX0xJU1RbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJJdGVtID09PSB2YWx1ZSB8fCBlcnJJdGVtID09PSB2YWx1ZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENhbGNFcnJvcihlcnJJdGVtLCBFUlJPUkNPREVfTElTVFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gS0VZV09SRF9VTkRFRklORUQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDYWxjRXJyb3I7XG4gICAgfSkoKTtcbiAgICBDYWxjLkNhbGNFcnJvciA9IENhbGNFcnJvcjtcblxuICAgIENhbGMuQ2FsY0Vycm9yc051bGwgPSBuZXcgQ2FsY0Vycm9yKENPTlNUX05VTEwsIDB4MDApO1xuICAgIENhbGMuQ2FsY0Vycm9yc0RpdmlkZUJ5WmVybyA9IG5ldyBDYWxjRXJyb3IoQ09OU1RfRElWMCwgMHgwNyk7XG4gICAgQ2FsYy5DYWxjRXJyb3JzVmFsdWUgPSBuZXcgQ2FsY0Vycm9yKENPTlNUX1ZBTFVFLCAweDBGKTtcbiAgICBDYWxjLkNhbGNFcnJvcnNSZWZlcmVuY2UgPSBuZXcgQ2FsY0Vycm9yKENPTlNUX1JFRiwgMHgxNyk7XG4gICAgQ2FsYy5DYWxjRXJyb3JzTmFtZSA9IG5ldyBDYWxjRXJyb3IoQ09OU1RfTkFNRSwgMHgxRCk7XG4gICAgQ2FsYy5DYWxjRXJyb3JzTm90QXZhaWxhYmxlID0gbmV3IENhbGNFcnJvcihDT05TVF9OQSwgMHgyQSk7XG4gICAgQ2FsYy5DYWxjRXJyb3JzTnVtYmVyID0gbmV3IENhbGNFcnJvcihDT05TVF9OVU0sIDB4MjQpO1xuXG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBFcnJvcnMgb2JqZWN0IHRoYXQgbGlzdHMgYWxsIHRoZSBzdXBwb3J0ZWQgZXJyb3JzLlxuICAgICAqIEBjbGFzcyAkLndpam1vLndpanNwcmVhZC5DYWxjLkVycm9yc1xuICAgICAqL1xuICAgIHZhciBFcnJvcnMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIEVycm9ycygpIHtcbiAgICAgICAgfVxuXG4gICAgICAgIEVycm9ycy5OdWxsID0gQ2FsYy5DYWxjRXJyb3JzTnVsbDtcblxuICAgICAgICBFcnJvcnMuRGl2aWRlQnlaZXJvID0gQ2FsYy5DYWxjRXJyb3JzRGl2aWRlQnlaZXJvO1xuXG4gICAgICAgIEVycm9ycy5WYWx1ZSA9IENhbGMuQ2FsY0Vycm9yc1ZhbHVlO1xuXG4gICAgICAgIEVycm9ycy5SZWZlcmVuY2UgPSBDYWxjLkNhbGNFcnJvcnNSZWZlcmVuY2U7XG5cbiAgICAgICAgRXJyb3JzLk5hbWUgPSBDYWxjLkNhbGNFcnJvcnNOYW1lO1xuXG4gICAgICAgIEVycm9ycy5Ob3RBdmFpbGFibGUgPSBDYWxjLkNhbGNFcnJvcnNOb3RBdmFpbGFibGU7XG5cbiAgICAgICAgRXJyb3JzLk51bWJlciA9IENhbGMuQ2FsY0Vycm9yc051bWJlcjtcbiAgICAgICAgcmV0dXJuIEVycm9ycztcbiAgICB9KSgpO1xuICAgIENhbGMuRXJyb3JzID0gRXJyb3JzO1xuXG4gICAgdmFyIFBhcnNlckNvbnN0YW50cyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gUGFyc2VyQ29uc3RhbnRzKCkge1xuICAgICAgICB9XG5cbiAgICAgICAgUGFyc2VyQ29uc3RhbnRzLkJBTkRfSU5ERVhfQ09OU1QgPSAtMjE0NzQ4MzY0ODtcbiAgICAgICAgUGFyc2VyQ29uc3RhbnRzLm1heFJvd0NvdW50ID0gMTA0ODU3NjtcbiAgICAgICAgUGFyc2VyQ29uc3RhbnRzLm1heENvbHVtbkNvdW50ID0gMTYzODQ7XG4gICAgICAgIHJldHVybiBQYXJzZXJDb25zdGFudHM7XG4gICAgfSkoKTtcbiAgICBDYWxjLlBhcnNlckNvbnN0YW50cyA9IFBhcnNlckNvbnN0YW50cztcblxuICAgIHZhciBDYWxjQ29sdW1uUmVmZXJlbmNlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVwcmVzZW50cyBhbiBhcmVhIHJlZmVyZW5jZWQgaW4gYSBzcHJlYWQgc2hlZXQuXG4gICAgICAgICAqIEBjbGFzcyAkLndpam1vLndpanNwcmVhZC5DYWxjLlJlZmVyZW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQ2FsY0NvbHVtblJlZmVyZW5jZShjYWxjU291cmNlLCBjb2x1bW4pIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHNlbGYuY2FsY1NvdXJjZSA9IGNhbGNTb3VyY2U7XG4gICAgICAgICAgICBzZWxmLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgICAgICAgIHNlbGYuZGF0YVR5cGUgPSBjYWxjU291cmNlLmdldERhdGFUeXBlKGNvbHVtbik7XG4gICAgICAgIH1cblxuICAgICAgICBDYWxjQ29sdW1uUmVmZXJlbmNlLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKGluZGV4LCBncm91cFBhdGgpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNhbGNTb3VyY2UuZ2V0VmFsdWVzKHNlbGYuY29sdW1uLCBncm91cFBhdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxjU291cmNlLmdldFZhbHVlKHNlbGYuY29sdW1uLCBpbmRleCwgZ3JvdXBQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENhbGNDb2x1bW5SZWZlcmVuY2U7XG4gICAgfSkoKTtcbiAgICBDYWxjLkNhbGNDb2x1bW5SZWZlcmVuY2UgPSBDYWxjQ29sdW1uUmVmZXJlbmNlO1xuXG4gICAgdmFyIENhbGNUYWJsZVJlZmVyZW5jZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcHJlc2VudHMgYW4gYXJlYSByZWZlcmVuY2VkIGluIGEgc3ByZWFkIHNoZWV0LlxuICAgICAgICAgKiBAY2xhc3MgJC53aWptby53aWpzcHJlYWQuQ2FsYy5SZWZlcmVuY2VcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIENhbGNUYWJsZVJlZmVyZW5jZShjYWxjU291cmNlKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZWxmLmNhbGNTb3VyY2UgPSBjYWxjU291cmNlO1xuICAgICAgICAgICAgc2VsZi5uYW1lID0gY2FsY1NvdXJjZS5nZXROYW1lKCk7XG4gICAgICAgIH1cblxuICAgICAgICBDYWxjVGFibGVSZWZlcmVuY2UucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGNTb3VyY2UudG9BcnJheSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIENhbGNUYWJsZVJlZmVyZW5jZTtcbiAgICB9KSgpO1xuICAgIENhbGMuQ2FsY1RhYmxlUmVmZXJlbmNlID0gQ2FsY1RhYmxlUmVmZXJlbmNlO1xuXG4gICAgdmFyIENhbGNGaWVsZFJlZmVyZW5jZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcHJlc2VudHMgYW4gYXJlYSByZWZlcmVuY2VkIGluIGEgc3ByZWFkIHNoZWV0LlxuICAgICAgICAgKiBAY2xhc3MgJC53aWptby53aWpzcHJlYWQuQ2FsYy5SZWZlcmVuY2VcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIENhbGNGaWVsZFJlZmVyZW5jZShjYWxjU291cmNlLCBuYW1lKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZWxmLmNhbGNTb3VyY2UgPSBjYWxjU291cmNlO1xuICAgICAgICAgICAgc2VsZi5uYW1lID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIENhbGNGaWVsZFJlZmVyZW5jZS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNhbGNTb3VyY2UuZ2V0RmllbGRWYWx1ZShzZWxmLm5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ2FsY0ZpZWxkUmVmZXJlbmNlO1xuICAgIH0pKCk7XG4gICAgQ2FsYy5DYWxjRmllbGRSZWZlcmVuY2UgPSBDYWxjRmllbGRSZWZlcmVuY2U7XG4gICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cbn0pKCk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXBwL3NjcmlwdHMvZ3JpZC9jYWxjL2NvbW1vbi5qc1xuICoqIG1vZHVsZSBpZCA9IDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKlxuICogU3ByZWFkSlMgTGlicmFyeSAxLjAuMFxuICogaHR0cDovL3dpam1vLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQoYykgR3JhcGVDaXR5LCBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBXaWptbyBDb21tZXJjaWFsIExpY2Vuc2UuIEFsc28gYXZhaWxhYmxlIHVuZGVyIHRoZSBHTlUgR1BMIFZlcnNpb24gMyBsaWNlbnNlLlxuICogbGljZW5zaW5nQHdpam1vLmNvbVxuICogaHR0cDovL3dpam1vLmNvbS93aWRnZXRzL2xpY2Vuc2UvXG4gKlxuICpcbiAqKi9cblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgS0VZV09SRF9VTkRFRklORUQgPSB1bmRlZmluZWQ7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgdmFyIEV2YWx1YXRlQ29udGV4dCA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gRXZhbHVhdGVDb250ZXh0KGNhbGNTb3VyY2UsIGN1cnJlbnRSb3csIGdyb3VwUGF0aCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgc2VsZi5jYWxjU291cmNlID0gY2FsY1NvdXJjZTtcbiAgICAgICAgICAgIHNlbGYuY3VycmVudFJvdyA9IGN1cnJlbnRSb3c7XG4gICAgICAgICAgICBzZWxmLmdyb3VwUGF0aCA9IGdyb3VwUGF0aDtcbiAgICAgICAgICAgIHNlbGYuZXhwYW5kQXJyYXlUb011bHRpQ2FsbENvdW50XyA9IDA7XG4gICAgICAgICAgICBzZWxmLmFnZ3JlZ2F0aW5nQ291bnRfID0gMDtcbiAgICAgICAgICAgIHNlbGYuZmlsdGVyaW5nQ291bnRfID0gMDtcbiAgICAgICAgICAgIHNlbGYuY3VycmVudFJvd0ludGVybmFsXyA9IEtFWVdPUkRfVU5ERUZJTkVEO1xuICAgICAgICB9XG5cbiAgICAgICAgRXZhbHVhdGVDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICAgICAgICAgIGdldEN1cnJlbnRSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jdXJyZW50Um93ICE9PSBLRVlXT1JEX1VOREVGSU5FRCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jdXJyZW50Um93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5pc0FnZ3JlZ2F0aW5nXygpIHx8IHNlbGYuaXNGaWx0ZXJpbmdfKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5jdXJyZW50Um93SW50ZXJuYWxfICE9PSBLRVlXT1JEX1VOREVGSU5FRCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jdXJyZW50Um93SW50ZXJuYWxfO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpc0FnZ3JlZ2F0aW5nXzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWdncmVnYXRpbmdDb3VudF8gPiAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJlZ2luQWdncmVnYXRpbmdfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFnZ3JlZ2F0aW5nQ291bnRfKys7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5kQWdncmVnYXRpbmdfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFnZ3JlZ2F0aW5nQ291bnRfLS07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpc0ZpbHRlcmluZ186IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcmluZ0NvdW50XyA+IDA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmVnaW5GaWx0ZXJfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcmluZ0NvdW50XysrO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuZEZpbHRlcl86IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyaW5nQ291bnRfLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBFdmFsdWF0ZUNvbnRleHQ7XG4gICAgfSkoKTtcbiAgICB2YXIgUGFyc2VyQ29udGV4dCA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gUGFyc2VyQ29udGV4dChjYWxjU291cmNlLCBvcHRpb24pIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHNlbGYuY2FsY1NvdXJjZSA9IGNhbGNTb3VyY2U7XG4gICAgICAgICAgICBzZWxmLm9wdGlvbiA9IG9wdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQYXJzZXJDb250ZXh0O1xuICAgIH0pKCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgRXZhbHVhdGVDb250ZXh0OiBFdmFsdWF0ZUNvbnRleHQsXG4gICAgICAgIFBhcnNlckNvbnRleHQ6IFBhcnNlckNvbnRleHRcbiAgICB9O1xufSkoKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9hcHAvc2NyaXB0cy9ncmlkL2NhbGMvY2FsY0NvbnRleHQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcclxuICpcclxuICogU3ByZWFkSlMgTGlicmFyeSAxLjAuMFxyXG4gKiBodHRwOi8vd2lqbW8uY29tL1xyXG4gKlxyXG4gKiBDb3B5cmlnaHQoYykgR3JhcGVDaXR5LCBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgV2lqbW8gQ29tbWVyY2lhbCBMaWNlbnNlLiBBbHNvIGF2YWlsYWJsZSB1bmRlciB0aGUgR05VIEdQTCBWZXJzaW9uIDMgbGljZW5zZS5cclxuICogbGljZW5zaW5nQHdpam1vLmNvbVxyXG4gKiBodHRwOi8vd2lqbW8uY29tL3dpZGdldHMvbGljZW5zZS9cclxuICpcclxuICpcclxuICoqL1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgdmFyIENhbGMgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xyXG4gICAgdmFyIENhbGNFeHByZXNzaW9ucyA9IHJlcXVpcmUoJy4vZXhwcmVzc2lvbnMnKTtcclxuICAgIHZhciBDYWxjQ29udGV4dCA9IHJlcXVpcmUoJy4vY2FsY0NvbnRleHQnKTtcclxuICAgIHZhciBDYWxjRnVuY3Rpb25zID0gcmVxdWlyZSgnLi9jYWxjRnVuY3Rpb25zJyk7XHJcblxyXG4gICAgdmFyIFNSSGVscGVyID0gQ2FsYy5TUkhlbHBlcjtcclxuICAgIHZhciB0aHJvd1NSID0gU1JIZWxwZXIudGhyb3dTUjtcclxuICAgIHZhciBzciA9IFNSSGVscGVyLnNyOy8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgdmFyIGNyID0gU1JIZWxwZXIuY3I7Ly8ganNoaW50IGlnbm9yZTpsaW5lXHJcblxyXG4gICAgdmFyIG5vdFN1cHBvcnQgPSAnRXhwX05vdFN1cHBvcnQnO1xyXG4gICAgdmFyIGludmFsaWRBcnIgPSAnRXhwX0ludmFsaWRBcnJheSc7Ly8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICB2YXIgYXRJbmRleE9uID0gJ0F0SW5kZXhPbic7XHJcbiAgICB2YXIgc2luZ2xlUXVvdGUgPSAnU2luZ2xlUXVvdGUnO1xyXG4gICAgdmFyIGZ1bGxTdG9wID0gJ0Z1bGxTdG9wJztcclxuICAgIHZhciBmb3JtdWxhSW52YWxpZCA9ICdFeHBfRm9ybXVsYUludmFsaWQnO1xyXG4gICAgdmFyIGludmFsaWRUb2tlbkF0ID0gJ0V4cF9JbnZhbGlkVG9rZW5BdCc7XHJcbiAgICB2YXIgaW52YWxpZFBhcmEgPSAnRXhwX0ludmFsaWRQYXJhbWV0ZXJzJztcclxuICAgIHZhciBub1N5bnRheCA9ICdFeHBfTm9TeW50YXgnO1xyXG4gICAgdmFyIG1hdGNoU3ludGF4ID0gJ0V4cF9NYXRjaFN5bnRheCc7XHJcbiAgICB2YXIgc2luZ2xlUXVvdGVzRnVsbFN0b3AgPSAnU2luZ2xlUXVvdGVzRnVsbFN0b3AnO1xyXG4gICAgdmFyIGlzVmFsaWQgPSAnRXhwX0lzVmFsaWQnOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIHZhciBpbnZhbGlkQXJyYXlBdCA9ICdFeHBfSW52YWxpZEFycmF5QXQnO1xyXG4gICAgdmFyIHNpbmdsZVF1b3RlQXQgPSAnU2luZ2xlUXVvdGVBdCc7Ly8ganNoaW50IGlnbm9yZTpsaW5lXHJcblxyXG4gICAgdmFyIENhbGNQYXJzZXIgPSB7fTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gQ2FsY1BhcnNlcjtcclxuXHJcbiAgICB2YXIgQ09OU1RfVU5ERUZJTkVEID0gJ3VuZGVmaW5lZCc7XHJcbiAgICB2YXIgQ09OU1RfTlVNQkVSID0gJ251bWJlcic7Ly8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICB2YXIgQ09OU1RfU1RSSU5HID0gJ3N0cmluZyc7XHJcbiAgICB2YXIgQ09OU1RfQk9PTEVBTiA9ICdib29sZWFuJztcclxuICAgIHZhciBDT05TVF9UUlVFID0gJ1RSVUUnO1xyXG4gICAgdmFyIENPTlNUX0ZBTFNFID0gJ0ZBTFNFJztcclxuICAgIHZhciBDT05TVF9BUlJBWSA9ICdBUlJBWSc7XHJcbiAgICB2YXIgQ09OU1RfQVJSQVlST1cgPSAnQVJSQVlST1cnO1xyXG4gICAgdmFyIENPTlNUX05VTEwgPSAnI05VTEwhJztcclxuICAgIHZhciBDT05TVF9ESVYwID0gJyNESVYvMCEnO1xyXG4gICAgdmFyIENPTlNUX1ZBTFVFID0gJyNWQUxVRSEnO1xyXG4gICAgdmFyIENPTlNUX1JFRiA9ICcjUkVGISc7XHJcbiAgICB2YXIgQ09OU1RfTkFNRSA9ICcjTkFNRT8nO1xyXG4gICAgdmFyIENPTlNUX05BID0gJyNOL0EnO1xyXG4gICAgdmFyIENPTlNUX05VTSA9ICcjTlVNISc7XHJcbiAgICB2YXIgQ09OU1RfRVhQUiA9ICdleHByJzsvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIHZhciBDT05TVF9BUlJBWUlORk8gPSAnYXJyYXlJbmZvJzsvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIHZhciBDT05TVF9XT1JLSU5HRVhQUiA9ICd3b3JraW5nRXhwcic7Ly8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICB2YXIgRVJST1JfTElTVCA9IFtDT05TVF9OVUxMLCBDT05TVF9ESVYwLCBDT05TVF9WQUxVRSwgQ09OU1RfUkVGLCBDT05TVF9OQU1FLCBDT05TVF9OQSwgQ09OU1RfTlVNXTtcclxuICAgIHZhciBFUlJPUkNPREVfTElTVCA9IFsweDAwLCAweDA3LCAweDBGLCAweDE3LCAweDFELCAweDJBLCAweDI0XTsvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIHZhciBMRVRURVJfUE9XUyA9IFsxLCAyNiwgNjc2XTsvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIHZhciBLRVlXT1JEX05VTEwgPSBudWxsO1xyXG4gICAgdmFyIEtFWVdPUkRfVU5ERUZJTkVEID0gdW5kZWZpbmVkOy8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgdmFyIFNVUFBST1RfUk9XX0NPTFVNTl9GT1JNVUxBID0gZmFsc2U7Ly8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICB2YXIgTUFUSF9NSU4gPSBNYXRoLm1pbjsvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIHZhciBNQVRIX01BWCA9IE1hdGgubWF4Oy8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgdmFyIE1BVEhfQUJTID0gTWF0aC5hYnM7XHJcbiAgICB2YXIgTUFUSF9QT1cgPSBNYXRoLnBvdztcclxuXHJcbiAgICAvLzxlZGl0b3ItZm9sZCBkZXNjPSdDaGFyIEhlbHBlcic+XHJcbiAgICB2YXIgTnVtYmVyU3RhdGUgPSB7XHJcbiAgICAgICAgTm9uZTogMCxcclxuICAgICAgICBTaWduOiAxLFxyXG4gICAgICAgIEludDogMixcclxuICAgICAgICBEb3Q6IDMsXHJcbiAgICAgICAgRGVjaW1hbDogNCxcclxuICAgICAgICBFeHBvbmVudDogNSxcclxuICAgICAgICBTaWduRXhwb25lbnQ6IDYsXHJcbiAgICAgICAgU2NpZW50aWZpY05vdGF0aW9uOiA3LFxyXG4gICAgICAgIE51bWJlcjogOFxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgTGF0aW5Vbmljb2RlQ2F0ZWdvcnkgPSB7XHJcbiAgICAgICAgVXBwZXJjYXNlTGV0dGVyOiAweDAwLFxyXG4gICAgICAgIExvd2VyY2FzZUxldHRlcjogMHgwMSxcclxuICAgICAgICBEZWNpbWFsRGlnaXROdW1iZXI6IDB4MDgsXHJcbiAgICAgICAgT3RoZXJOdW1iZXI6IDB4MGEsXHJcbiAgICAgICAgU3BhY2VTZXBhcmF0b3I6IDB4MGIsXHJcbiAgICAgICAgQ29udHJvbDogMHgwZSxcclxuICAgICAgICBDb25uZWN0b3JQdW5jdHVhdGlvbjogMHgxMixcclxuICAgICAgICBEYXNoUHVuY3R1YXRpb246IDB4MTMsXHJcbiAgICAgICAgT3BlblB1bmN0dWF0aW9uOiAweDE0LFxyXG4gICAgICAgIENsb3NlUHVuY3R1YXRpb246IDB4MTUsXHJcbiAgICAgICAgSW5pdGlhbFF1b3RlUHVuY3R1YXRpb246IDB4MTYsXHJcbiAgICAgICAgRmluYWxRdW90ZVB1bmN0dWF0aW9uOiAweDE3LFxyXG4gICAgICAgIE90aGVyUHVuY3R1YXRpb246IDB4MTgsXHJcbiAgICAgICAgTWF0aFN5bWJvbDogMHgxOSxcclxuICAgICAgICBjdXJyZW5jeVN5bWJvbDogMHgxYSxcclxuICAgICAgICBNb2RpZmllclN5bWJvbDogMHgxYixcclxuICAgICAgICBPdGhlclN5bWJvbDogMHgxY1xyXG4gICAgfTtcclxuICAgIHZhciBjYXRlZ29yeUZvckxhdGluMSA9IFtcclxuICAgICAgICAweGUsIDB4ZSwgMHhlLCAweGUsIDB4ZSwgMHhlLCAweGUsIDB4ZSwgMHhlLCAweGUsIDB4ZSwgMHhlLCAweGUsIDB4ZSwgMHhlLCAweGUsXHJcbiAgICAgICAgMHhlLCAweGUsIDB4ZSwgMHhlLCAweGUsIDB4ZSwgMHhlLCAweGUsIDB4ZSwgMHhlLCAweGUsIDB4ZSwgMHhlLCAweGUsIDB4ZSwgMHhlLFxyXG4gICAgICAgIDB4YiwgMHgxOCwgMHgxOCwgMHgxOCwgMHgxYSwgMHgxOCwgMHgxOCwgMHgxOCwgMHgxNCwgMHgxNSwgMHgxOCwgMHgxOSwgMHgxOCwgMHgxMywgMHgxOCwgMHgxOCxcclxuICAgICAgICAweDgsIDB4OCwgMHg4LCAweDgsIDB4OCwgMHg4LCAweDgsIDB4OCwgMHg4LCAweDgsIDB4MTgsIDB4MTgsIDB4MTksIDB4MTksIDB4MTksIDB4MTgsXHJcbiAgICAgICAgMHgxOCwgMHgwLCAweDAsIDB4MCwgMHgwLCAweDAsIDB4MCwgMHgwLCAweDAsIDB4MCwgMHgwLCAweDAsIDB4MCwgMHgwLCAweDAsIDB4MCxcclxuICAgICAgICAweDAsIDB4MCwgMHgwLCAweDAsIDB4MCwgMHgwLCAweDAsIDB4MCwgMHgwLCAweDAsIDB4MCwgMHgxNCwgMHgxOCwgMHgxNSwgMHgxYiwgMHgxMixcclxuICAgICAgICAweDFiLCAweDEsIDB4MSwgMHgxLCAweDEsIDB4MSwgMHgxLCAweDEsIDB4MSwgMHgxLCAweDEsIDB4MSwgMHgxLCAweDEsIDB4MSwgMHgxLFxyXG4gICAgICAgIDB4MSwgMHgxLCAweDEsIDB4MSwgMHgxLCAweDEsIDB4MSwgMHgxLCAweDEsIDB4MSwgMHgxLCAweDE0LCAweDE5LCAweDE1LCAweDE5LCAweGUsXHJcbiAgICAgICAgMHhlLCAweGUsIDB4ZSwgMHhlLCAweGUsIDB4ZSwgMHhlLCAweGUsIDB4ZSwgMHhlLCAweGUsIDB4ZSwgMHhlLCAweGUsIDB4ZSwgMHhlLFxyXG4gICAgICAgIDB4ZSwgMHhlLCAweGUsIDB4ZSwgMHhlLCAweGUsIDB4ZSwgMHhlLCAweGUsIDB4ZSwgMHhlLCAweGUsIDB4ZSwgMHhlLCAweGUsIDB4ZSxcclxuICAgICAgICAweGIsIDB4MTgsIDB4MWEsIDB4MWEsIDB4MWEsIDB4MWEsIDB4MWMsIDB4MWMsIDB4MWIsIDB4MWMsIDB4MSwgMHgxNiwgMHgxOSwgMHgxMywgMHgxYywgMHgxYixcclxuICAgICAgICAweDFjLCAweDE5LCAweGEsIDB4YSwgMHgxYiwgMHgxLCAweDFjLCAweDE4LCAweDFiLCAweGEsIDB4MSwgMHgxNywgMHhhLCAweGEsIDB4YSwgMHgxOCxcclxuICAgICAgICAweDAsIDB4MCwgMHgwLCAweDAsIDB4MCwgMHgwLCAweDAsIDB4MCwgMHgwLCAweDAsIDB4MCwgMHgwLCAweDAsIDB4MCwgMHgwLCAweDAsXHJcbiAgICAgICAgMHgwLCAweDAsIDB4MCwgMHgwLCAweDAsIDB4MCwgMHgwLCAweDE5LCAweDAsIDB4MCwgMHgwLCAweDAsIDB4MCwgMHgwLCAweDAsIDB4MSxcclxuICAgICAgICAweDEsIDB4MSwgMHgxLCAweDEsIDB4MSwgMHgxLCAweDEsIDB4MSwgMHgxLCAweDEsIDB4MSwgMHgxLCAweDEsIDB4MSwgMHgxLCAweDEsXHJcbiAgICAgICAgMHgxLCAweDEsIDB4MSwgMHgxLCAweDEsIDB4MSwgMHgxLCAweDE5LCAweDEsIDB4MSwgMHgxLCAweDEsIDB4MSwgMHgxLCAweDEsIDB4MVxyXG4gICAgXTtcclxuXHJcbiAgICB2YXIgUGFyc2VyID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFBhcnNlcihvcHRpb24pIHtcclxuICAgICAgICAgICAgaWYgKCh0eXBlb2YgKG9wdGlvbikgPT09IENPTlNUX1VOREVGSU5FRCB8fCBvcHRpb24gPT09IEtFWVdPUkRfTlVMTCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBQYXJzZXIuc2V0UGFyc2VyT3B0aW9uKG9wdGlvbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBQYXJzZXIuc2V0UGFyc2VyT3B0aW9uID0gZnVuY3Rpb24ob3B0aW9uKSB7XHJcbiAgICAgICAgICAgIFBhcnNlci5saXN0U2VwYXJhdG9yID0gZ2V0UHJvcGVydHkob3B0aW9uLCAnbGlzdFNlcGFyYXRvcicsICcsJyk7XHJcbiAgICAgICAgICAgIFBhcnNlci5udW1iZXJEZWNpbWFsU2VwYXJhdG9yID0gZ2V0UHJvcGVydHkob3B0aW9uLCAnbnVtYmVyRGVjaW1hbFNlcGFyYXRvcicsICcuJyk7XHJcbiAgICAgICAgICAgIFBhcnNlci5hcnJheUdyb3VwU2VwYXJhdG9yID0gZ2V0UHJvcGVydHkob3B0aW9uLCAnYXJyYXlHcm91cFNlcGFyYXRvcicsICc7Jyk7XHJcbiAgICAgICAgICAgIFBhcnNlci5fYXJyYXlBcmd1bWVudFNlcGF0YXRvciA9IChQYXJzZXIubGlzdFNlcGFyYXRvciA9PT0gUGFyc2VyLmFycmF5R3JvdXBTZXBhcmF0b3IpID8gJ1xcXFwnIDogUGFyc2VyLmxpc3RTZXBhcmF0b3I7XHJcbiAgICAgICAgICAgIFBhcnNlci5fb3BlcmF0b3JJbmZpeCA9ICdcXFxcKy0qL14mPT48OiAnICsgUGFyc2VyLmxpc3RTZXBhcmF0b3I7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgUGFyc2VyLmdldFBhcnNlck9wdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgJ251bWJlckRlY2ltYWxTZXBhcmF0b3InOiBQYXJzZXIubnVtYmVyRGVjaW1hbFNlcGFyYXRvcixcclxuICAgICAgICAgICAgICAgICdsaXN0U2VwYXJhdG9yJzogUGFyc2VyLmxpc3RTZXBhcmF0b3IsXHJcbiAgICAgICAgICAgICAgICAnYXJyYXlHcm91cFNlcGFyYXRvcic6IFBhcnNlci5hcnJheUdyb3VwU2VwYXJhdG9yXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBvcHRpb247XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFyc2VzIGEgc3RyaW5nIGZvcm11bGEgdG8gdGhlIGV4cHJlc3Npb24gdXNpbmcgdGhlIHNwZWNpZmllZCBQYXJzZXJDb250ZXh0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtdWxhIEEgc3RyaW5nIGZvcm11bGEuXHJcbiAgICAgICAgICogQHBhcmFtIHskLndpam1vLndpanNwcmVhZC5DYWxjLlBhcnNlckNvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNlciBjb250ZXh0IHNldHRpbmcuXHJcbiAgICAgICAgICogQHJldHVybnMgeyQud2lqbW8ud2lqc3ByZWFkLkNhbGNFeHByZXNzaW9ucy5FeHByZXNzaW9ufSBUaGUgZXhwcmVzc2lvbiBmb3IgdGhlIHBhcnNlZCBzdHJpbmcgZm9ybXVsYS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oZm9ybXVsYSwgY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICghY29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEtFWVdPUkRfTlVMTDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29udGV4dC5vcHRpb24pIHtcclxuICAgICAgICAgICAgICAgIFBhcnNlci5zZXRQYXJzZXJPcHRpb24oY29udGV4dC5vcHRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0b2tlbnMgPSBzZWxmLl9wYXJzZVRvVG9rZW4oZm9ybXVsYSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9idWlsZEV4cHJlc3Npb25UcmVlKGNvbnRleHQsIHRva2Vucyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVW5wYXJzZXMgYSBDYWxjRXhwcmVzc2lvbiB0byBhIHN0cmluZyB1c2luZyB0aGUgc3BlY2lmaWVkIFBhcnNlckNvbnRleHQuXHJcbiAgICAgICAgICogQHBhcmFtIHskLndpam1vLndpanNwcmVhZC5DYWxjRXhwcmVzc2lvbnMuRXhwcmVzc2lvbn0gZXhwciBBbiBleHByZXNzaW9uIHRoYXQgaW5kaWNhdGVzIHRoZSBleHByZXNzaW9uIHRyZWUuXHJcbiAgICAgICAgICogQHBhcmFtIHskLndpam1vLndpanNwcmVhZC5DYWxjLlBhcnNlckNvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNlciBjb250ZXh0IHNldHRpbmcuXHJcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHNwZWNpZmllZCBDYWxjRXhwcmVzc2lvbiBhcyBhIHN0cmluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQYXJzZXIucHJvdG90eXBlLnVucGFyc2UgPSBmdW5jdGlvbihleHByLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIFBhcnNlci51bnBhcnNlV2l0aG91dEN1bHR1cmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKCFleHByKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFjb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gbmV3IENhbGNDb250ZXh0LlBhcnNlckNvbnRleHQoS0VZV09SRF9OVUxMKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29udGV4dC5vcHRpb24pIHtcclxuICAgICAgICAgICAgICAgIFBhcnNlci5zZXRQYXJzZXJPcHRpb24oY29udGV4dC5vcHRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBmb3JtdWxhID0ge2NvbnRlbnQ6ICcnfTtcclxuICAgICAgICAgICAgdGhpcy5fdW5wYXJzZUV4cHJlc3Npb24oZXhwciwgY29udGV4dCwgZm9ybXVsYSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmb3JtdWxhLmNvbnRlbnQ7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgUGFyc2VyLnByb3RvdHlwZS51bnBhcnNlV2l0aG91dEN1bHR1cmUgPSBmdW5jdGlvbihleHByLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIFBhcnNlci51bnBhcnNlV2l0aG91dEN1bHR1cmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoIWV4cHIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBuZXcgQ2FsY0NvbnRleHQuUGFyc2VyQ29udGV4dChLRVlXT1JEX05VTEwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0Lm9wdGlvbikge1xyXG4gICAgICAgICAgICAgICAgUGFyc2VyLnNldFBhcnNlck9wdGlvbihjb250ZXh0Lm9wdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGZvcm11bGEgPSB7Y29udGVudDogJyd9O1xyXG4gICAgICAgICAgICB0aGlzLl91bnBhcnNlRXhwcmVzc2lvbihleHByLCBjb250ZXh0LCBmb3JtdWxhKTtcclxuICAgICAgICAgICAgUGFyc2VyLnVucGFyc2VXaXRob3V0Q3VsdHVyZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gZm9ybXVsYS5jb250ZW50O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIHVucGFyc2VcclxuICAgICAgICBQYXJzZXIucHJvdG90eXBlLl91bnBhcnNlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGV4cHIsIGNvbnRleHQsIGZvcm11bGEpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIENhbGMuRXhwcmVzc2lvbnMuQ29uc3RhbnRFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl91bnBhcnNlQ29uc3RhbnRFeHByZXNzaW9uKGV4cHIsIGNvbnRleHQsIGZvcm11bGEpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHIgaW5zdGFuY2VvZiBDYWxjLkV4cHJlc3Npb25zLk9wZXJhdG9yRXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fdW5QYXJzZU9wZXJhdG9yRXhwcmVzc2lvbnMoZXhwciwgY29udGV4dCwgZm9ybXVsYSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwciBpbnN0YW5jZW9mIENhbGMuRXhwcmVzc2lvbnMuU3RydWN0UmVmZXJlbmNlRXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fdW5QYXJzZVN0cnVjdEV4cHJlc3Npb24oZXhwciwgY29udGV4dCwgZm9ybXVsYSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwci50ID09PSA4IC8qIFBhcmVudGhlc2VzICovKSB7XHJcbiAgICAgICAgICAgICAgICBmb3JtdWxhLmNvbnRlbnQgKz0gJygnO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fdW5wYXJzZUV4cHJlc3Npb24oZXhwci5hcmd1bWVudCwgY29udGV4dCwgZm9ybXVsYSk7XHJcbiAgICAgICAgICAgICAgICBmb3JtdWxhLmNvbnRlbnQgKz0gJyknO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHIudCA9PT0gMyAvKiBGdW5jdGlvbiAqLykge1xyXG4gICAgICAgICAgICAgICAgZm9ybXVsYS5jb250ZW50ICs9IGV4cHIuZ2V0RnVuY3Rpb25OYW1lKCk7XHJcbiAgICAgICAgICAgICAgICBmb3JtdWxhLmNvbnRlbnQgKz0gJygnO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByLmFyZ0NvdW50KCk7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChQYXJzZXIudW5wYXJzZVdpdGhvdXRDdWx0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtdWxhLmNvbnRlbnQgKz0gJywnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBnbG9iYWwgbGlzdFNwZXBhcmF0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZm9ybXVsYS5jb250ZW50ICs9IHNwcmVhZC5DUi5saXN0U2VwYXJhdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3VucGFyc2VFeHByZXNzaW9uKGV4cHIuZ2V0QXJnKGkpLCBjb250ZXh0LCBmb3JtdWxhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvcm11bGEuY29udGVudCArPSAnKSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvd1NSKG5vdFN1cHBvcnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xyXG4gICAgICAgIFBhcnNlci5wcm90b3R5cGUuX3VucGFyc2VTb3VyY2UgPSBmdW5jdGlvbihzb3VyY2UsIGNvbnRleHQsIGZvcm11bGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cclxuXHJcbiAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fcmVtb3ZlQXBvc3Ryb3BoZSA9IGZ1bmN0aW9uKGZvcm11bGEpIHtcclxuICAgICAgICAgICAgdmFyIGZvcm11bGFDb250ZW50ID0gZm9ybXVsYS5jb250ZW50O1xyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gZm9ybXVsYUNvbnRlbnQubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoZm9ybXVsYUNvbnRlbnQuY2hhckF0KGxlbmd0aCAtIDEpID09PSAnXFwnJykge1xyXG4gICAgICAgICAgICAgICAgZm9ybXVsYS5jb250ZW50ID0gZm9ybXVsYUNvbnRlbnQuc3Vic3RyKDEsIGxlbmd0aCAtIDIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIFBhcnNlci5wcm90b3R5cGUuX3JlbW92ZVdvcmtib29rID0gZnVuY3Rpb24oZm9ybXVsYSkge1xyXG4gICAgICAgICAgICBpZiAoZm9ybXVsYS5jb250ZW50LmNoYXJBdCgwKSAhPT0gJ1snKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge3N1Y2Nlc3M6IGZhbHNlLCB3b3JrQm9va05hbWU6ICcnfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBmb3JtdWxhLmNvbnRlbnQuaW5kZXhPZignXScpO1xyXG4gICAgICAgICAgICB2YXIgd29ya0Jvb2tOYW1lID0gZm9ybXVsYS5jb250ZW50LnN1YnN0cigwLCBpbmRleCArIDEpO1xyXG4gICAgICAgICAgICBmb3JtdWxhLmNvbnRlbnQgPSBmb3JtdWxhLmNvbnRlbnQuc3Vic3RyKGluZGV4KTtcclxuICAgICAgICAgICAgcmV0dXJuIHtzdWNjZXNzOiB0cnVlLCB3b3JrQm9va05hbWU6IHdvcmtCb29rTmFtZX07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xyXG4gICAgICAgIFBhcnNlci5wcm90b3R5cGUuX3VuUGFyc2VPcGVyYXRvckV4cHJlc3Npb25zID0gZnVuY3Rpb24oZXhwciwgY29udGV4dCwgZm9ybXVsYSkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmIChleHByLnQgPT09IDUgLyogVW5hcnlPcGVyYXRvciAqLykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wID0gZXhwci5vcGVyYXRvcjtcclxuICAgICAgICAgICAgICAgIGlmIChvcCA9PT0gT3BlcmF0b3JzLnBlcmNlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl91bnBhcnNlRXhwcmVzc2lvbihleHByLm9wZXJhbmQsIGNvbnRleHQsIGZvcm11bGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcm11bGEuY29udGVudCArPSBvcC5uYW1lO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3JtdWxhLmNvbnRlbnQgKz0gb3AubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl91bnBhcnNlRXhwcmVzc2lvbihleHByLm9wZXJhbmQsIGNvbnRleHQsIGZvcm11bGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHIudCA9PT0gNCAvKiBCaW5hcnlPcGVyYXRvciAqLykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlZnRQYXJ0ID0ge2NvbnRlbnQ6ICcnfTtcclxuICAgICAgICAgICAgICAgIHZhciByaWdodFBhcnQgPSB7Y29udGVudDogJyd9O1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fdW5wYXJzZUV4cHJlc3Npb24oZXhwci5yaWdodCwgY29udGV4dCwgcmlnaHRQYXJ0KTtcclxuICAgICAgICAgICAgICAgIHZhciBsZWZ0SXNCaW4gPSBleHByLmxlZnQudCA9PT0gNCAvKiBCaW5hcnlPcGVyYXRvciAqLztcclxuICAgICAgICAgICAgICAgIHZhciByaWdodElzQmluID0gZXhwci5yaWdodC50ID09PSA0IC8qIEJpbmFyeU9wZXJhdG9yICovO1xyXG4gICAgICAgICAgICAgICAgdmFyIHByaW9yaXR5ID0gZ2V0T3BlYXRvclByaW9yaXR5KGV4cHIub3BlcmF0b3IubmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVmdElzQmluICYmIGdldE9wZWF0b3JQcmlvcml0eShleHByLmxlZnQub3BlcmF0b3IubmFtZSkgPiBwcmlvcml0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnRQYXJ0LmNvbnRlbnQgKz0gJygnO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3VucGFyc2VFeHByZXNzaW9uKGV4cHIubGVmdCwgY29udGV4dCwgbGVmdFBhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnRQYXJ0LmNvbnRlbnQgKz0gJyknO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl91bnBhcnNlRXhwcmVzc2lvbihleHByLmxlZnQsIGNvbnRleHQsIGxlZnRQYXJ0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyaWdodElzQmluICYmIGdldE9wZWF0b3JQcmlvcml0eShleHByLnJpZ2h0Lm9wZXJhdG9yLm5hbWUpID4gcHJpb3JpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICByaWdodFBhcnQuY29udGVudCArPSAnKCc7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fdW5wYXJzZUV4cHJlc3Npb24oZXhwci5yaWdodCwgY29udGV4dCwgcmlnaHRQYXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICByaWdodFBhcnQuY29udGVudCArPSAnKCc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3JtdWxhLmNvbnRlbnQgKz0gbGVmdFBhcnQuY29udGVudDtcclxuICAgICAgICAgICAgICAgIGZvcm11bGEuY29udGVudCArPSBleHByLm9wZXJhdG9yLnQgPT09IDUgLyogVW5hcnlPcGVyYXRvciAqLyA/IFBhcnNlci5saXN0U2VwYXJhdG9yIDogZXhwci5vcGVyYXRvci5uYW1lO1xyXG4gICAgICAgICAgICAgICAgZm9ybXVsYS5jb250ZW50ICs9IHJpZ2h0UGFydC5jb250ZW50O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3dTUihub3RTdXBwb3J0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIFBhcnNlci5wcm90b3R5cGUuX3VucGFyc2VDb25zdGFudEV4cHJlc3Npb24gPSBmdW5jdGlvbihleHByLCBjb250ZXh0LCBmb3JtdWxhKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGVyck1zZyA9IHNyKGludmFsaWRBcnIpO1xyXG4gICAgICAgICAgICBpZiAoZXhwci50ID09PSAxIC8qIFN0cmluZyAqLykge1xyXG4gICAgICAgICAgICAgICAgZm9ybXVsYS5jb250ZW50ICs9ICdcIic7XHJcbiAgICAgICAgICAgICAgICBmb3JtdWxhLmNvbnRlbnQgKz0gZXhwci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGZvcm11bGEuY29udGVudCArPSAnXCInO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHIudCA9PT0gMCAvKiBEb3VibGUgKi8pIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGV4cHIub3JpZ2luYWxWYWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmICghUGFyc2VyLnVucGFyc2VXaXRob3V0Q3VsdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gcGFyc2VyIGdsb2JhbGl6ZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vdmFsdWUgPSBfTnVtYmVySGVscGVyLnJlcGxhY2VOb3JtYWxUb0N1bHR1cmVTeW1ibGUodmFsdWUudG9TdHJpbmcoKSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvcm11bGEuY29udGVudCArPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChleHByLnQgPT09IDIgLyogQm9vbGVhbiAqLykge1xyXG4gICAgICAgICAgICAgICAgZm9ybXVsYS5jb250ZW50ICs9IGV4cHIudmFsdWUgPyBDT05TVF9UUlVFIDogQ09OU1RfRkFMU0U7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwci50ID09PSA5IC8qIEFycmF5ICovKSB7XHJcbiAgICAgICAgICAgICAgICBmb3JtdWxhLmNvbnRlbnQgKz0gJ3snO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFycmF5ID0gZXhwci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChhcnJheS5nZXRSb3dDb3VudCgpIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJNc2c7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgYmFuZEluZGV4ID0gQ2FsYy5QYXJzZXJDb25zdGFudHMuQkFORF9JTkRFWF9DT05TVDtcclxuICAgICAgICAgICAgICAgIHZhciBjb2xDb3VudCA9IGJhbmRJbmRleDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHJvd0luZGV4ID0gMDsgcm93SW5kZXggPCBhcnJheS5nZXRSb3dDb3VudCgpOyByb3dJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvd0luZGV4ID49IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFBhcnNlci51bnBhcnNlV2l0aG91dEN1bHR1cmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm11bGEuY29udGVudCArPSAnOyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtdWxhLmNvbnRlbnQgKz0gUGFyc2VyLmFycmF5R3JvdXBTZXBhcmF0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY29sdW1uSW5kZXggPSAwOyBjb2x1bW5JbmRleCA8IGFycmF5LmdldENvbHVtbkNvdW50KCk7IGNvbHVtbkluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbENvdW50ICE9PSBiYW5kSW5kZXggJiYgKGNvbENvdW50ICE9PSBhcnJheS5nZXRDb2x1bW5Db3VudCgpIHx8IGFycmF5LmdldENvbHVtbkNvdW50KCkgPT09IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJNc2c7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtbkluZGV4ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXlBcmd1bWVudFNlcGF0YXRvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChQYXJzZXIudW5wYXJzZVdpdGhvdXRDdWx0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlBcmd1bWVudFNlcGF0YXRvciA9ICcsJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlBcmd1bWVudFNlcGF0YXRvciA9IChQYXJzZXIubGlzdFNlcGFyYXRvciA9PT0gUGFyc2VyLmFycmF5R3JvdXBTZXBhcmF0b3IpID8gJ1xcXFwnIDogUGFyc2VyLmxpc3RTZXBhcmF0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtdWxhLmNvbnRlbnQgKz0gYXJyYXlBcmd1bWVudFNlcGF0YXRvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGFycmF5LmdldFZhbHVlKHJvd0luZGV4LCBjb2x1bW5JbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ID09PSBLRVlXT1JEX1VOREVGSU5FRCB8fCB2ID09PSBLRVlXT1JEX05VTEwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVyck1zZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodiBpbnN0YW5jZW9mIENhbGNFeHByZXNzaW9ucy5FeHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl91bnBhcnNlRXhwcmVzc2lvbih2LCBjb250ZXh0LCBmb3JtdWxhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PT0gQ09OU1RfU1RSSU5HKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybXVsYS5jb250ZW50ICs9ICdcIic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybXVsYS5jb250ZW50ICs9IHY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybXVsYS5jb250ZW50ICs9ICdcIic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBDT05TVF9CT09MRUFOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybXVsYS5jb250ZW50ICs9IHYgPyBDT05TVF9UUlVFIDogQ09OU1RfRkFMU0U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFQYXJzZXIudW5wYXJzZVdpdGhvdXRDdWx0dXJlICYmIHR5cGVvZiB2ID09PSBDT05TVF9OVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHBhcnNlciBnbG9iYWxpemVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2Zvcm11bGEuY29udGVudCArPSBfTnVtYmVySGVscGVyLnJlcGxhY2VOb3JtYWxUb0N1bHR1cmVTeW1ibGUodi50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybXVsYS5jb250ZW50ICs9IHYudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvcm11bGEuY29udGVudCArPSAnfSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwci50ID09PSA3IC8qIEV4dGVybmFsRXJyb3IgKi8pIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuX3VucGFyc2VTb3VyY2UoZXhwci5zb3VyY2UsIGNvbnRleHQsIGZvcm11bGEpO1xyXG4gICAgICAgICAgICAgICAgZm9ybXVsYS5jb250ZW50ICs9ICchJztcclxuICAgICAgICAgICAgICAgIGZvcm11bGEuY29udGVudCArPSBleHByLnZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwci50ID09PSA2IC8qIEVycm9yICovKSB7XHJcbiAgICAgICAgICAgICAgICBmb3JtdWxhLmNvbnRlbnQgKz0gZXhwci52YWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHIudCA9PT0gMTIgLyogTWlzc2luZ0FyZ3VtZW50ICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkbyBub3RoaW5nLlxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3dTUihub3RTdXBwb3J0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIFBhcnNlci5wcm90b3R5cGUuX3VuUGFyc2VTdHJ1Y3RFeHByZXNzaW9ucyA9IGZ1bmN0aW9uKGV4cHIsIGNvbnRleHQsIGZvcm11bGEpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICBmb3JtdWxhLmNvbnRlbnQgKz0gZXhwci50YWJsZTtcclxuICAgICAgICAgICAgaWYgKGV4cHIuY29sdW1uKSB7XHJcbiAgICAgICAgICAgICAgICBmb3JtdWxhLmNvbnRlbnQgKz0gJ1snO1xyXG4gICAgICAgICAgICAgICAgZm9ybXVsYS5jb250ZW50ICs9IGV4cHIuY29sdW1uO1xyXG4gICAgICAgICAgICAgICAgZm9ybXVsYS5jb250ZW50ICs9ICddJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cclxuXHJcbiAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VUb1Rva2VuID0gZnVuY3Rpb24oZm9ybXVsYSwgdGhyb3dFcnJvcikge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRocm93RXJyb3IgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBsZW4gPSBmb3JtdWxhLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIHRva2VuczEgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHN0YWNrID0gW107XHJcbiAgICAgICAgICAgIHZhciBzdGFja0VuZCA9IC0xO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSAnJztcclxuICAgICAgICAgICAgdmFyIENPTlNUX0FUX0lOREVYX09OID0gc3IoYXRJbmRleE9uKTtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRUb2tlbjtcclxuICAgICAgICAgICAgdmFyIHRva2VuU3RhcnRJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gMDtcclxuICAgICAgICAgICAgdmFyIHN0YWNrVG9rZW47XHJcbiAgICAgICAgICAgIHdoaWxlIChzdGFydEluZGV4IDwgbGVuICYmIGZvcm11bGEuY2hhckF0KHN0YXJ0SW5kZXgpID09PSAnICcpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXgrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZm9ybXVsYS5jaGFyQXQoc3RhcnRJbmRleCkgPT09ICc9Jykge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRva2VuU3RhcnRJbmRleCA9IHN0YXJ0SW5kZXg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gc3RhcnRJbmRleDsgaW5kZXggPCBsZW47IGluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Q2hhciA9IGZvcm11bGEuY2hhckF0KGluZGV4KTtcclxuICAgICAgICAgICAgICAgIHZhciBycztcclxuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91cztcclxuICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICdcIicpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBkb3VibGUtcXVvdGVkIHN0cmluZ3NcclxuICAgICAgICAgICAgICAgICAgICBycyA9IHJlYWRTdHJpbmcoZm9ybXVsYSwgaW5kZXgsICdcIicsICdcIicsIHRocm93RXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMxLnB1c2gobmV3IEZvcm11bGFUb2tlbihycy5yZXN1bHQsIDAgLyogT3BlcmFuZCAqLywgaW5kZXggKyAxLCAzIC8qIFRleHQgKi8pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBycy5lbmRJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5TdGFydEluZGV4ID0gaW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGZvcm11bGEuc3Vic3RyaW5nKGluZGV4LCBsZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGxlbiAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Q2hhciA9PT0gJ1xcJycpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUtcXVvdGVkIHN0cmluZ3MgKGxpbmtzKSwgaW4gcGF0aC4gc3VjaCBhcyAnU2hlKyBldDEnIUExICsgMlxyXG4gICAgICAgICAgICAgICAgICAgIHJzID0gcmVhZFN0cmluZyhmb3JtdWxhLCBpbmRleCwgJ1xcJycsICdcXCcnLCB0aHJvd0Vycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gJ1xcJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHJzLnJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gJ1xcJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcnMuZW5kSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gJ1xcJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudENoYXIgPT09ICdbJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJyYWNrZWQgc3RyaW5ncyAoUjFDMSByYW5nZSBpbmRleCBvciBsaW5rZWQgd29ya2Jvb2sgbmFtZSksXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUlsxXUNbMV1vclt3b3JrYm9vazFdc2hlZXQxIVIxQzEgb3IgdGFibGUxWyNBbGxdXHJcbiAgICAgICAgICAgICAgICAgICAgLy9ycyA9IHJlYWRTdHJpbmcoZm9ybXVsYSwgaW5kZXgsICdbJywgJ10nKTtcclxuICAgICAgICAgICAgICAgICAgICBycyA9IHJlYWRTdHJpbmcyKGZvcm11bGEsIGluZGV4LCAnWycsICddJywgJ1xcJycsIHRocm93RXJyb3IpOyAvLyB0YWJsZTFbWyNBbGxdLCBbY29sJ1t1bW4xXV1cclxuICAgICAgICAgICAgICAgICAgICBpZiAocnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy92YWx1ZSArPSAnWyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHJzLnJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gJ10nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHJzLmVuZEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ1InIHx8IHZhbHVlID09PSAncicgfHwgdmFsdWUgPT09ICdDJyB8fCB2YWx1ZSA9PT0gJ2MnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBmb3JtdWxhLnN1YnN0cmluZyhpbmRleCwgbGVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBsZW4gLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudENoYXIgPT09ICdcXHInIHx8IGN1cnJlbnRDaGFyID09PSAnXFxuJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Q2hhciA9PT0gJyMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXJyb3IgdmFsdWVzLCBlbmQgbWFya3MgYSB0b2tlbiwgZGV0ZXJtaW5lZCBmcm9tIGFic29sdXRlIGxpc3Qgb2YgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlID0gcmVhZEVycm9yKGZvcm11bGEsIGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRDaGFyID0gaW5kZXggPCBsZW4gPyBmb3JtdWxhLmNoYXJBdChpbmRleCArIDEpIDogJ1xcMCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IDAgJiYgZm9ybXVsYS5jaGFyQXQoaW5kZXggLSAxKSA9PT0gJyEnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSByZS5yZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQ09OU1RfUkVGID09PSByZS5yZXN1bHQudG9VcHBlckNhc2UoKSAmJiBpbmRleCA8IGxlbiAmJiAoaXNMZXR0ZXJPckRpZ2l0KG5leHRDaGFyKSB8fCBuZXh0Q2hhciA9PT0gJyQnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gI1JFRiFBMSAgI1JFRiEkQSQxOiRCJDJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHJlLnJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuczEucHVzaChuZXcgRm9ybXVsYVRva2VuKHJlLnJlc3VsdCwgMCAvKiBPcGVyYW5kICovLCBpbmRleCwgNiAvKiBFcnJvciAqLykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5TdGFydEluZGV4ID0gaW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcmUuZW5kSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gY3VycmVudENoYXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdG9rZW5zMS5wdXNoKG5ldyBGb3JtdWxhVG9rZW4oY3VycmVudENoYXIsIEV4Y2VsRm9ybXVsYVRva2VuVHlwZS5Vbmtub3duLCBpbmRleCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3ZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdG9rZW5TdGFydEluZGV4ID0gaW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudENoYXIgPT09ICcrJyB8fCBjdXJyZW50Q2hhciA9PT0gJy0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMgPSB0b2tlbnMxLmxlbmd0aCA9PT0gMCA/IG51bGwgOiB0b2tlbnMxW3Rva2VuczEubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMxLnB1c2gobmV3IEZvcm11bGFUb2tlbih2YWx1ZSwgMCAvKiBPcGVyYW5kICovLCB0b2tlblN0YXJ0SW5kZXgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zMS5wdXNoKG5ldyBGb3JtdWxhVG9rZW4oY3VycmVudENoYXIsIDUgLyogT3BlcmF0b3JJbmZpeCAqLywgaW5kZXgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5TdGFydEluZGV4ID0gaW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91cyAmJiBwcmV2aW91cy50eXBlID09PSA3IC8qIFdoaXRlc3BhY2UgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuczEucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyA9IHRva2VuczFbdG9rZW5zMS5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXMgJiYgKChwcmV2aW91cy50eXBlID09PSAxIC8qIEZ1bmN0aW9uICovICYmIHByZXZpb3VzLnN1YlR5cGUgPT09IDIgLyogU3RvcCAqLykgfHwgKHByZXZpb3VzLnR5cGUgPT09IDIgLyogU3ViZXhwcmVzc2lvbiAqLyAmJiBwcmV2aW91cy5zdWJUeXBlID09PSAyIC8qIFN0b3AgKi8pIHx8IChwcmV2aW91cy50eXBlID09PSA2IC8qIE9wZXJhdG9yUG9zdGZpeCAqLykgfHwgKHByZXZpb3VzLnR5cGUgPT09IDAgLyogT3BlcmFuZCAqLykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBiaW5hcnkgb3BlcmF0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuczEucHVzaChuZXcgRm9ybXVsYVRva2VuKGN1cnJlbnRDaGFyLCA1IC8qIE9wZXJhdG9ySW5maXggKi8sIGluZGV4KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlblN0YXJ0SW5kZXggPSBpbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMxLnB1c2gobmV3IEZvcm11bGFUb2tlbihjdXJyZW50Q2hhciwgNCAvKiBPcGVyYXRvclByZWZpeCAqLywgaW5kZXgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuU3RhcnRJbmRleCA9IGluZGV4ICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudENoYXIgPT09IFBhcnNlci5udW1iZXJEZWNpbWFsU2VwYXJhdG9yIHx8IGlzRGlnaXQoY3VycmVudENoYXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzTnVtO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGN1cnJlbnRDaGFyO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKGlzTnVtID0gaXNOdW1iZXIyKGZvcm11bGEsIGluZGV4LCBQYXJzZXIubnVtYmVyRGVjaW1hbFNlcGFyYXRvcikpLnJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRJbmRleCA9IGlzTnVtLmVuZEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnVtID0gZm9ybXVsYS5zbGljZShpbmRleCwgZW5kSW5kZXggKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFBhcnNlci5udW1iZXJEZWNpbWFsU2VwYXJhdG9yICE9PSAnLicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gcGFyc2VyIGdsb2JhbGl6ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9udW0gPSBfTnVtYmVySGVscGVyLnJlcGxhY2VDdWx0dXJlU3ltYm9sVG9Ob3JtYWwobnVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZW5kSW5kZXggPD0gbGVuIC0gMiAmJiBmb3JtdWxhLmNoYXJBdChlbmRJbmRleCArIDEpID09PSAnICcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZEluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSBmb3JtdWxhIFNVTSgxIDogMiksIDEgYW5kIDIgaXMgYSByb3cgcmVmZXJlbmNlLCBub3QgYSBudW1iZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmRJbmRleCA8PSBsZW4gLSAyICYmIGZvcm11bGEuY2hhckF0KGVuZEluZGV4ICsgMSkgPT09ICc6Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gbnVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gJzonO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kSW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuU3RhcnRJbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zMS5wdXNoKG5ldyBGb3JtdWxhVG9rZW4obnVtLCAwIC8qIE9wZXJhbmQgKi8sIGluZGV4LCA0IC8qIE51bWJlciAqLykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5TdGFydEluZGV4ID0gaW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gZW5kSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gY3VycmVudENoYXI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Q2hhciA9PT0gJ3snKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDAgJiYgdGhyb3dFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBzcihmb3JtdWxhSW52YWxpZCkgKyBzcihzaW5nbGVRdW90ZSkgKyAneycgKyBDT05TVF9BVF9JTkRFWF9PTiArIGluZGV4ICsgc3IoZnVsbFN0b3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBuZXcgRm9ybXVsYVRva2VuKENPTlNUX0FSUkFZLCAxIC8qIEZ1bmN0aW9uICovLCBpbmRleCwgMSAvKiBTdGFydCAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zMS5wdXNoKGN1cnJlbnRUb2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tbKytzdGFja0VuZF0gPSBjdXJyZW50VG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gbmV3IEZvcm11bGFUb2tlbihDT05TVF9BUlJBWVJPVywgMSAvKiBGdW5jdGlvbiAqLywgaW5kZXgsIDEgLyogU3RhcnQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuczEucHVzaChjdXJyZW50VG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrWysrc3RhY2tFbmRdID0gY3VycmVudFRva2VuO1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuU3RhcnRJbmRleCA9IGluZGV4ICsgMTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudENoYXIgPT09IFBhcnNlci5hcnJheUdyb3VwU2VwYXJhdG9yICYmIHN0YWNrRW5kID49IDAgJiYgKHN0YWNrW3N0YWNrRW5kXS52YWx1ZSA9PT0gQ09OU1RfQVJSQVkgfHwgc3RhY2tbc3RhY2tFbmRdLnZhbHVlID09PSBDT05TVF9BUlJBWVJPVykpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYXJyYXkgc2VwYXJhdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zMS5wdXNoKG5ldyBGb3JtdWxhVG9rZW4odmFsdWUsIDAgLyogT3BlcmFuZCAqLywgdG9rZW5TdGFydEluZGV4KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFja0VuZCA8IDAgJiYgdGhyb3dFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBzcihmb3JtdWxhSW52YWxpZCkgKyBzcihzaW5nbGVRdW90ZSkgKyBjdXJyZW50Q2hhciArIENPTlNUX0FUX0lOREVYX09OICsgaW5kZXggKyBzcihmdWxsU3RvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrVG9rZW4gPSBzdGFja1tzdGFja0VuZC0tXTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFja1Rva2VuID0gbmV3IEZvcm11bGFUb2tlbihjdXJyZW50Q2hhciwgc3RhY2tUb2tlbi50eXBlLCBpbmRleCwgMiAvKiBTdG9wICovKTtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbnMxLnB1c2goc3RhY2tUb2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zMS5wdXNoKG5ldyBGb3JtdWxhVG9rZW4oUGFyc2VyLmxpc3RTZXBhcmF0b3IsIDMgLyogQXJndW1lbnQgKi8sIGluZGV4KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gbmV3IEZvcm11bGFUb2tlbihDT05TVF9BUlJBWVJPVywgMSAvKiBGdW5jdGlvbiAqLywgaW5kZXggKyAxLCAxIC8qIFN0YXJ0ICovKTtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbnMxLnB1c2goY3VycmVudFRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFja1srK3N0YWNrRW5kXSA9IGN1cnJlbnRUb2tlbjtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlblN0YXJ0SW5kZXggPSBpbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRDaGFyID09PSAnfScpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMxLnB1c2gobmV3IEZvcm11bGFUb2tlbih2YWx1ZSwgMCAvKiBPcGVyYW5kICovLCB0b2tlblN0YXJ0SW5kZXgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZEluZGV4IDwgMCAmJiB0aHJvd0Vycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHNyKGZvcm11bGFJbnZhbGlkKSArIHNyKHNpbmdsZVF1b3RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8rY3VycmVudENoYXIgKyBDT05TVF9BVF9JTkRFWF9PTiArIGluZGV4ICsgc3IoZnVsbFN0b3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzdGFja1Rva2VuID0gc3RhY2tbc3RhY2tFbmQtLV07XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tUb2tlbiA9IG5ldyBGb3JtdWxhVG9rZW4oY3VycmVudENoYXIsIHN0YWNrVG9rZW4udHlwZSwgaW5kZXgsIDIgLyogU3RvcCAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zMS5wdXNoKHN0YWNrVG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrVG9rZW4gPSBzdGFja1tzdGFja0VuZC0tXTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFja1Rva2VuID0gbmV3IEZvcm11bGFUb2tlbihjdXJyZW50Q2hhciwgc3RhY2tUb2tlbi50eXBlLCBpbmRleCwgMiAvKiBTdG9wICovKTtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbnMxLnB1c2goc3RhY2tUb2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5TdGFydEluZGV4ID0gaW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Q2hhciA9PT0gJyAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNJbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChpbmRleCA8IGxlbikgJiYgdmFsdWUuY2hhckF0KHZhbHVlLmxlbmd0aCAtIDEpID09PSAnICcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDAgJiYgdmFsdWUuY2hhckF0KHZhbHVlLmxlbmd0aCAtIDEpICE9PSAnOicgJiYgaW5kZXggPCBsZW4gJiYgZm9ybXVsYS5jaGFyQXQoaW5kZXgpICE9PSAnOicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zMS5wdXNoKG5ldyBGb3JtdWxhVG9rZW4odmFsdWUsIDAgLyogT3BlcmFuZCAqLywgdG9rZW5TdGFydEluZGV4KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuczEucHVzaChuZXcgRm9ybXVsYVRva2VuKCcnLCA3IC8qIFdoaXRlc3BhY2UgKi8sIHNJbmRleCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0b2tlblN0YXJ0SW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleC0tO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoaW5kZXggKyAyKSA8PSBsZW4gJiYgY3VycmVudENoYXIgPT09ICc8JyAmJiBmb3JtdWxhLmNoYXJBdChpbmRleCArIDEpID09PSAnPScgfHwgY3VycmVudENoYXIgPT09ICc+JyAmJiBmb3JtdWxhLmNoYXJBdChpbmRleCArIDEpID09PSAnPScgfHwgY3VycmVudENoYXIgPT09ICc8JyAmJiBmb3JtdWxhLmNoYXJBdChpbmRleCArIDEpID09PSAnPicpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMxLnB1c2gobmV3IEZvcm11bGFUb2tlbih2YWx1ZSwgMCAvKiBPcGVyYW5kICovLCB0b2tlblN0YXJ0SW5kZXgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zMS5wdXNoKG5ldyBGb3JtdWxhVG9rZW4oZm9ybXVsYS5zbGljZShpbmRleCwgaW5kZXggKyAyKSwgNSAvKiBPcGVyYXRvckluZml4ICovLCBpbmRleCwgNSAvKiBMb2dpY2FsICovKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICB0b2tlblN0YXJ0SW5kZXggPSBpbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRDaGFyID09PSAnJScpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMxLnB1c2gobmV3IEZvcm11bGFUb2tlbih2YWx1ZSwgMCAvKiBPcGVyYW5kICovLCB0b2tlblN0YXJ0SW5kZXgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zMS5wdXNoKG5ldyBGb3JtdWxhVG9rZW4oZm9ybXVsYS5jaGFyQXQoaW5kZXgpLCA2IC8qIE9wZXJhdG9yUG9zdGZpeCAqLywgaW5kZXgpKTtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlblN0YXJ0SW5kZXggPSBpbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRDaGFyID09PSAnKycgfHwgY3VycmVudENoYXIgPT09ICctJyB8fCBjdXJyZW50Q2hhciA9PT0gJyonIHx8IGN1cnJlbnRDaGFyID09PSAnLycgfHwgY3VycmVudENoYXIgPT09ICc9JyB8fCBjdXJyZW50Q2hhciA9PT0gJz4nIHx8IGN1cnJlbnRDaGFyID09PSAnPCcgfHwgY3VycmVudENoYXIgPT09ICcmJyB8fCBjdXJyZW50Q2hhciA9PT0gJ14nIHx8IGN1cnJlbnRDaGFyID09PSAnfCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZCBpbmZpeCBvcGVyYXRvcnNcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMxLnB1c2gobmV3IEZvcm11bGFUb2tlbih2YWx1ZSwgMCAvKiBPcGVyYW5kICovLCB0b2tlblN0YXJ0SW5kZXgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnJicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm11bGEuY2hhckF0KGluZGV4ICsgMSkgPT09ICcmJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zMS5wdXNoKG5ldyBGb3JtdWxhVG9rZW4oJyYmJywgNSAvKiBPcGVyYXRvckluZml4ICovLCBpbmRleCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5TdGFydEluZGV4ID0gaW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Q2hhciA9PT0gJ3wnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3JtdWxhLmNoYXJBdChpbmRleCArIDEpID09PSAnfCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuczEucHVzaChuZXcgRm9ybXVsYVRva2VuKCd8fCcsIDUgLyogT3BlcmF0b3JJbmZpeCAqLywgaW5kZXgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuU3RhcnRJbmRleCA9IGluZGV4ICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBjdXJyZW50Q2hhcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zMS5wdXNoKG5ldyBGb3JtdWxhVG9rZW4oY3VycmVudENoYXIsIDUgLyogT3BlcmF0b3JJbmZpeCAqLywgaW5kZXgpKTtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlblN0YXJ0SW5kZXggPSBpbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRDaGFyID09PSAnKCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBzdWIgZXhwcmVzc2lvbiBvciBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0Q2hhciA9IHZhbHVlLmNoYXJBdCh2YWx1ZS5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RDaGFyID09PSAnOicgfHwgbGFzdENoYXIgPT09IFBhcnNlci5saXN0U2VwYXJhdG9yIHx8IGxhc3RDaGFyID09PSAnICcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEExOihBMixBMykgfCBBMSwoQTIsQTMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIHZhbHVlLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zMS5wdXNoKG5ldyBGb3JtdWxhVG9rZW4odmFsdWUsIDAgLyogT3BlcmFuZCAqLywgdG9rZW5TdGFydEluZGV4LCA3IC8qIFJhbmdlT3JOYW1lICovKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMxLnB1c2gobmV3IEZvcm11bGFUb2tlbihsYXN0Q2hhciwgNSAvKiBPcGVyYXRvckluZml4ICovLCBpbmRleCAtIDEsIDAgLyogTm90aGluZyAqLykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gbmV3IEZvcm11bGFUb2tlbignJywgMiAvKiBTdWJleHByZXNzaW9uICovLCBpbmRleCwgMSAvKiBTdGFydCAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMxLnB1c2goY3VycmVudFRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrWysrc3RhY2tFbmRdID0gY3VycmVudFRva2VuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90cnkgQTE6SU5ESVJFQ1QoJ0IxJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWZPcEluZGV4ID0gdmFsdWUuaW5kZXhPZignOicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZk9wVG9rZW4gPSAnOic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVmT3BJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZPcEluZGV4ID0gdmFsdWUuaW5kZXhPZihQYXJzZXIubGlzdFNlcGFyYXRvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmT3BUb2tlbiA9IFBhcnNlci5saXN0U2VwYXJhdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZk9wSW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmT3BJbmRleCA9IHZhbHVlLmluZGV4T2YoJyAnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZPcFRva2VuID0gJyAnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZk9wSW5kZXggIT09IC0xICYmIHJlZk9wSW5kZXggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zMS5wdXNoKG5ldyBGb3JtdWxhVG9rZW4odmFsdWUuc3Vic3RyKDAsIHJlZk9wSW5kZXgpLCAwIC8qIE9wZXJhbmQgKi8sIHRva2VuU3RhcnRJbmRleCwgNyAvKiBSYW5nZU9yTmFtZSAqLykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuczEucHVzaChuZXcgRm9ybXVsYVRva2VuKHJlZk9wVG9rZW4sIDUgLyogT3BlcmF0b3JJbmZpeCAqLywgdG9rZW5TdGFydEluZGV4ICsgcmVmT3BJbmRleCwgMCAvKiBOb3RoaW5nICovKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZShyZWZPcEluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gbmV3IEZvcm11bGFUb2tlbih2YWx1ZS50b1VwcGVyQ2FzZSgpLCAxIC8qIEZ1bmN0aW9uICovLCB0b2tlblN0YXJ0SW5kZXggKyByZWZPcEluZGV4ICsgMSwgMSAvKiBTdGFydCAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zMS5wdXNoKGN1cnJlbnRUb2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tbKytzdGFja0VuZF0gPSBjdXJyZW50VG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gbmV3IEZvcm11bGFUb2tlbih2YWx1ZS50b1VwcGVyQ2FzZSgpLCAxIC8qIEZ1bmN0aW9uICovLCBpbmRleCAtIHZhbHVlLmxlbmd0aCwgMSAvKiBTdGFydCAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zMS5wdXNoKGN1cnJlbnRUb2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tbKytzdGFja0VuZF0gPSBjdXJyZW50VG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBuZXcgRm9ybXVsYVRva2VuKCcnLCAyIC8qIFN1YmV4cHJlc3Npb24gKi8sIGluZGV4LCAxIC8qIFN0YXJ0ICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zMS5wdXNoKGN1cnJlbnRUb2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrWysrc3RhY2tFbmRdID0gY3VycmVudFRva2VuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0b2tlblN0YXJ0SW5kZXggPSBpbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRDaGFyID09PSBQYXJzZXIubGlzdFNlcGFyYXRvciB8fCBjdXJyZW50Q2hhciA9PT0gUGFyc2VyLl9hcnJheUFyZ3VtZW50U2VwYXRhdG9yIHx8IGN1cnJlbnRDaGFyID09PSBQYXJzZXIuYXJyYXlHcm91cFNlcGFyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uLCBzdWIgZXhwcmVzc2lvbiwgb3IgYXJyYXkgcGFyYW1ldGVycywgb3Igb3BlcmFuZCB1bmlvbnNcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMxLnB1c2gobmV3IEZvcm11bGFUb2tlbih2YWx1ZSwgMCAvKiBPcGVyYW5kICovLCB0b2tlblN0YXJ0SW5kZXgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrRW5kIDwgMCB8fCBzdGFja1tzdGFja0VuZF0udHlwZSAhPT0gMSAvKiBGdW5jdGlvbiAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMxLnB1c2gobmV3IEZvcm11bGFUb2tlbihQYXJzZXIubGlzdFNlcGFyYXRvciwgNSAvKiBPcGVyYXRvckluZml4ICovLCBpbmRleCwgMTAgLyogVW5pb24gKi8pKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMxLnB1c2gobmV3IEZvcm11bGFUb2tlbihQYXJzZXIuX2FycmF5QXJndW1lbnRTZXBhdGF0b3IsIDMgLyogQXJndW1lbnQgKi8sIGluZGV4KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuU3RhcnRJbmRleCA9IGluZGV4ICsgMTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudENoYXIgPT09ICcpJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuczEucHVzaChuZXcgRm9ybXVsYVRva2VuKHZhbHVlLCAwIC8qIE9wZXJhbmQgKi8sIHRva2VuU3RhcnRJbmRleCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2tFbmQgPCAwICYmIHRocm93RXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgc3IoZm9ybXVsYUludmFsaWQpICsgc3Ioc2luZ2xlUXVvdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLytjdXJyZW50Q2hhciArIENPTlNUX0FUX0lOREVYX09OICsgaW5kZXggKyBzcihmdWxsU3RvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrVG9rZW4gPSBzdGFja1tzdGFja0VuZC0tXTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFja1Rva2VuID0gbmV3IEZvcm11bGFUb2tlbihjdXJyZW50Q2hhciwgc3RhY2tUb2tlbi50eXBlLCBpbmRleCwgMiAvKiBTdG9wICovKTtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbnMxLnB1c2goc3RhY2tUb2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5TdGFydEluZGV4ID0gaW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Q2hhciA9PT0gJzonKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3VjaCBhcyAoQTEgQTIpOkIzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCAmJiB0b2tlbnMxW3Rva2VuczEubGVuZ3RoIC0gMV0uc3ViVHlwZSA9PT0gMiAvKiBTdG9wICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuczEucHVzaChuZXcgRm9ybXVsYVRva2VuKCc6JywgNSAvKiBPcGVyYXRvckluZml4ICovLCBpbmRleCwgMTEgLyogUmFuZ2VPcCAqLykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlblN0YXJ0SW5kZXggPSBpbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gJzonO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gY3VycmVudENoYXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRva2VuczEucHVzaChuZXcgRm9ybXVsYVRva2VuKHZhbHVlLCAwIC8qIE9wZXJhbmQgKi8sIHRva2VuU3RhcnRJbmRleCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fcHJvY2Vzc1Rva2Vucyh0b2tlbnMxLCB0aHJvd0Vycm9yKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9wcm9jZXNzVG9rZW5zID0gZnVuY3Rpb24odG9rZW5zMSwgdGhyb3dFcnJvcikge1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgdW5uZWNlc3Nhcnkgd2hpdGUtc3BhY2UgdG9rZW5zO1xyXG4gICAgICAgICAgICAvLyBpZGVudGlmeWluZyBvcGVyYW5kIGFuZCBpbmZpeC1vcGVyYXRvciBzdWJ0eXBlcztcclxuICAgICAgICAgICAgLy8gcHVsbGluZyAnQCcgZnJvbSBmdW5jdGlvbiBuYW1lcztcclxuICAgICAgICAgICAgLy8gcHJvY2VzcyBlcnJvciB0b2tlbnMuXHJcbiAgICAgICAgICAgIC8vIGJ1aWxkIHRva2VuIHRyZWUuXHJcbiAgICAgICAgICAgIHZhciB0b2tlbnMyID0gdGhpcy5fcmVtb3ZlV2hpdGVTcGFjZSh0b2tlbnMxKTtcclxuICAgICAgICAgICAgdmFyIHN0YWNrID0gW107XHJcbiAgICAgICAgICAgIHZhciByb290VG9rZW4gPSBuZXcgRm9ybXVsYVRva2VuKCcnLCA4IC8qIFVua25vd24gKi8sIDAsIDEgLyogU3RhcnQgKi8pO1xyXG4gICAgICAgICAgICBzdGFjay5wdXNoKHJvb3RUb2tlbik7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnQ7XHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB0b2tlbnMyLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRUb2tlbiA9IHRva2VuczJbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gaSA9PT0gMCA/IEtFWVdPUkRfTlVMTCA6IHRva2VuczJbaSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSBpID09PSBsZW5ndGggLSAxID8gS0VZV09SRF9OVUxMIDogdG9rZW5zMltpICsgMV07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBsb2dpY2FsIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUb2tlbi50eXBlID09PSAwIC8qIE9wZXJhbmQgKi8gJiYgY3VycmVudFRva2VuLnN1YlR5cGUgPT09IDAgLyogTm90aGluZyAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGN1cnJlbnRUb2tlbi52YWx1ZS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gQ09OU1RfVFJVRSB8fCB2YWx1ZSA9PT0gQ09OU1RfRkFMU0UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuLnN1YlR5cGUgPSA1IC8qIExvZ2ljYWwgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbi52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbi5zdWJUeXBlID0gNyAvKiBSYW5nZU9yTmFtZSAqLztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRUb2tlbi50eXBlID09PSAxIC8qIEZ1bmN0aW9uICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBjaGFyICdAJyBiZWZvcmUgdGhlIEZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUb2tlbi52YWx1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VG9rZW4udmFsdWUuY2hhckF0KDApID09PSAnQCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbi52YWx1ZSA9IGN1cnJlbnRUb2tlbi52YWx1ZS5zdWJzdHIoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwICYmIHRocm93RXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBzcihpbnZhbGlkVG9rZW5BdCkgKyBjdXJyZW50VG9rZW4uaW5kZXggKyBzcihmdWxsU3RvcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIHRoZSBwb3NzaWJsZSBlcnJvciB0b2tlbnNcclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQudmFsdWUgPT09IENPTlNUX0FSUkFZUk9XKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRocm93RXJyb3IgJiYgKGN1cnJlbnRUb2tlbi50eXBlICE9PSAzIC8qIEFyZ3VtZW50ICovICYmIGN1cnJlbnRUb2tlbi5zdWJUeXBlICE9PSA2IC8qIEVycm9yICovICYmIGN1cnJlbnRUb2tlbi5zdWJUeXBlICE9PSAyIC8qIFN0b3AgKi8gJiYgY3VycmVudFRva2VuLnN1YlR5cGUgIT09IDUgLyogTG9naWNhbCAqLyAmJiBjdXJyZW50VG9rZW4uc3ViVHlwZSAhPT0gNCAvKiBOdW1iZXIgKi8gJiYgY3VycmVudFRva2VuLnN1YlR5cGUgIT09IDMgLyogVGV4dCAqLyAmJiBjdXJyZW50VG9rZW4udHlwZSAhPT0gNCAvKiBPcGVyYXRvclByZWZpeCAqLykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgc3IoaW52YWxpZEFycmF5QXQpICsgY3VycmVudFRva2VuLmluZGV4ICsgc3IoZnVsbFN0b3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY3VycmVudFRva2VuLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDAgLyogT3BlcmFuZCAqL1xyXG4gICAgICAgICAgICAgICAgICAgIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRocm93RXJyb3IgJiYgKHByZXZpb3VzICYmIChwcmV2aW91cy50eXBlID09PSAwIC8qIE9wZXJhbmQgKi8gfHwgcHJldmlvdXMudHlwZSA9PT0gNiAvKiBPcGVyYXRvclBvc3RmaXggKi8gfHwgcHJldmlvdXMudHlwZSA9PT0gMSAvKiBGdW5jdGlvbiAqLyAmJiBwcmV2aW91cy5zdWJUeXBlID09PSAyIC8qIFN0b3AgKi8gfHwgcHJldmlvdXMudHlwZSA9PT0gMiAvKiBTdWJleHByZXNzaW9uICovICYmIHByZXZpb3VzLnN1YlR5cGUgPT09IDIgLyogU3RvcCAqLykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBzcihpbnZhbGlkVG9rZW5BdCkgKyBjdXJyZW50VG9rZW4uaW5kZXggKyBzcihmdWxsU3RvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxIC8qIEZ1bmN0aW9uICovXHJcbiAgICAgICAgICAgICAgICAgICAgOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBTdWJleHByZXNzaW9uICovXHJcbiAgICAgICAgICAgICAgICAgICAgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFRva2VuLnZhbHVlID09PSBDT05TVF9BUlJBWSAmJiBjdXJyZW50VG9rZW4udHlwZSA9PT0gMSAvKiBGdW5jdGlvbiAqLyAmJiBjdXJyZW50VG9rZW4uc3ViVHlwZSA9PT0gMSAvKiBTdGFydCAqLyAmJiAhcHJldmlvdXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRocm93RXJyb3IgJiYgKGN1cnJlbnRUb2tlbi5zdWJUeXBlID09PSAyIC8qIFN0b3AgKi8gJiYgKCFwcmV2aW91cyB8fCBwcmV2aW91cy50eXBlID09PSA0IC8qIE9wZXJhdG9yUHJlZml4ICovIHx8IHByZXZpb3VzLnR5cGUgPT09IDUgLyogT3BlcmF0b3JJbmZpeCAqLykgfHwgY3VycmVudFRva2VuLnN1YlR5cGUgPT09IDEgLyogU3RhcnQgKi8gJiYgcHJldmlvdXMgJiYgKCFuZXh0IHx8IHByZXZpb3VzLnR5cGUgPT09IDYgLyogT3BlcmF0b3JQb3N0Zml4ICovIHx8IHByZXZpb3VzLnN1YlR5cGUgPT09IDIgLyogU3RvcCAqLykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBzcihpbnZhbGlkVG9rZW5BdCkgKyBjdXJyZW50VG9rZW4uaW5kZXggKyBzcihmdWxsU3RvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRocm93RXJyb3IgJiYgKGN1cnJlbnRUb2tlbi5zdWJUeXBlID09PSAyIC8qIFN0b3AgKi8gJiYgY3VycmVudFRva2VuLnR5cGUgPT09IDIgLyogU3ViZXhwcmVzc2lvbiAqLyAmJiBwcmV2aW91cy5zdWJUeXBlID09PSAxIC8qIFN0YXJ0ICovKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgc3IoaW52YWxpZFRva2VuQXQpICsgY3VycmVudFRva2VuLmluZGV4ICsgc3IoZnVsbFN0b3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aHJvd0Vycm9yICYmIChjdXJyZW50VG9rZW4uc3ViVHlwZSA9PT0gMiAvKiBTdG9wICovICYmIGN1cnJlbnRUb2tlbi50eXBlID09PSAxIC8qIEZ1bmN0aW9uICovICYmIHByZXZpb3VzLnR5cGUgPT09IDIgLyogU3ViZXhwcmVzc2lvbiAqLyAmJiBwcmV2aW91cy5zdWJUeXBlID09PSAxIC8qIFN0YXJ0ICovKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgc3IoaW52YWxpZFRva2VuQXQpICsgY3VycmVudFRva2VuLmluZGV4ICsgc3IoZnVsbFN0b3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aHJvd0Vycm9yICYmIGN1cnJlbnRUb2tlbi5zdWJUeXBlID09PSAxIC8qIFN0YXJ0ICovICYmIHByZXZpb3VzICYmIChwcmV2aW91cy50eXBlID09PSAxIC8qIEZ1bmN0aW9uICovICYmIHByZXZpb3VzLnN1YlR5cGUgPT09IDIgLyogU3RvcCAqLyB8fCBwcmV2aW91cy50eXBlID09PSAwIC8qIE9wZXJhbmQgKi8gfHwgcHJldmlvdXMudHlwZSA9PT0gNiAvKiBPcGVyYXRvclBvc3RmaXggKi8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBzcihpbnZhbGlkVG9rZW5BdCkgKyBjdXJyZW50VG9rZW4uaW5kZXggKyBzcihmdWxsU3RvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzIC8qIEFyZ3VtZW50ICovXHJcbiAgICAgICAgICAgICAgICAgICAgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhyb3dFcnJvciAmJiAoIW5leHQgfHwgIXByZXZpb3VzIHx8IHByZXZpb3VzLnR5cGUgPT09IDUgLyogT3BlcmF0b3JJbmZpeCAqLyB8fCBwcmV2aW91cy50eXBlID09PSA0IC8qIE9wZXJhdG9yUHJlZml4ICovKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgc3IoaW52YWxpZFRva2VuQXQpICsgY3VycmVudFRva2VuLmluZGV4ICsgc3IoZnVsbFN0b3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNCAvKiBPcGVyYXRvclByZWZpeCAqL1xyXG4gICAgICAgICAgICAgICAgICAgIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRocm93RXJyb3IgJiYgKCFuZXh0IHx8IHByZXZpb3VzICYmIChwcmV2aW91cy50eXBlID09PSA2IC8qIE9wZXJhdG9yUG9zdGZpeCAqLykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBzcihpbnZhbGlkVG9rZW5BdCkgKyBjdXJyZW50VG9rZW4uaW5kZXggKyBzcihmdWxsU3RvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1IC8qIE9wZXJhdG9ySW5maXggKi9cclxuICAgICAgICAgICAgICAgICAgICA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aHJvd0Vycm9yICYmICghbmV4dCB8fCAhcHJldmlvdXMgfHwgcHJldmlvdXMudHlwZSA9PT0gNSAvKiBPcGVyYXRvckluZml4ICovIHx8IHByZXZpb3VzLnR5cGUgPT09IDQgLyogT3BlcmF0b3JQcmVmaXggKi8gfHwgcHJldmlvdXMudHlwZSA9PT0gMyAvKiBBcmd1bWVudCAqLyB8fCBwcmV2aW91cy50eXBlID09PSAxIC8qIEZ1bmN0aW9uICovICYmIHByZXZpb3VzLnN1YlR5cGUgPT09IDEgLyogU3RhcnQgKi8gfHwgcHJldmlvdXMudHlwZSA9PT0gMiAvKiBTdWJleHByZXNzaW9uICovICYmIHByZXZpb3VzLnN1YlR5cGUgPT09IDEgLyogU3RhcnQgKi8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBzcihpbnZhbGlkVG9rZW5BdCkgKyBjdXJyZW50VG9rZW4uaW5kZXggKyBzcihmdWxsU3RvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2IC8qIE9wZXJhdG9yUG9zdGZpeCAqL1xyXG4gICAgICAgICAgICAgICAgICAgIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRocm93RXJyb3IgJiYgKCFwcmV2aW91cyB8fCBwcmV2aW91cy50eXBlID09PSA0IC8qIE9wZXJhdG9yUHJlZml4ICovIHx8IHByZXZpb3VzLnR5cGUgPT09IDUgLyogT3BlcmF0b3JJbmZpeCAqLyB8fCBwcmV2aW91cy50eXBlID09PSAxIC8qIEZ1bmN0aW9uICovICYmIHByZXZpb3VzLnN1YlR5cGUgPT09IDEgLyogU3RhcnQgKi8gfHwgcHJldmlvdXMudHlwZSA9PT0gMiAvKiBTdWJleHByZXNzaW9uICovICYmIHByZXZpb3VzLnN1YlR5cGUgPT09IDEgLyogU3RhcnQgKi8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBzcihpbnZhbGlkVG9rZW5BdCkgKyBjdXJyZW50VG9rZW4uaW5kZXggKyBzcihmdWxsU3RvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRocm93RXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHNyKGludmFsaWRUb2tlbkF0KSArIGN1cnJlbnRUb2tlbi5pbmRleCArIHNyKGZ1bGxTdG9wKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vaWYgdGhyb3dFcnJvciBpcyBmYWxzZSwgaXQncyBjYWxsZWQgYnkgZm9ybXVsYSB0ZXh0Ym94LCBzbyByZXR1cm4gdG9rZW4gYXJyYXlcclxuICAgICAgICAgICAgICAgIGlmICh0aHJvd0Vycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9idWlsZCB0b2tlbiB0cmVlLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VG9rZW4uc3ViVHlwZSA9PT0gMSAvKiBTdGFydCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGN1cnJlbnRUb2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKGN1cnJlbnRUb2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50VG9rZW4uc3ViVHlwZSA9PT0gMiAvKiBTdG9wICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Q2hhcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VG9rZW4udmFsdWUgPT09IENPTlNUX0FSUkFZIHx8IGN1cnJlbnRUb2tlbi52YWx1ZSA9PT0gQ09OU1RfQVJSQVlST1cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2hhciA9ICd9JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENoYXIgPSAnKSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhyb3dFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHNyKGZvcm11bGFJbnZhbGlkKSArIHNyKHNpbmdsZVF1b3RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLytjdXJyZW50Q2hhciArIHNyKHNpbmdsZVF1b3RlQXQpICsgY3VycmVudFRva2VuLmluZGV4ICsgc3IoZnVsbFN0b3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKGN1cnJlbnRUb2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aHJvd0Vycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdFRva2VuLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuczI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9yZW1vdmVXaGl0ZVNwYWNlID0gZnVuY3Rpb24odG9rZW5zMSkge1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgdW5uZWNlc3Nhcnkgd2hpdGUtc3BhY2UgdG9rZW5zIGFuZCBjb252ZXJ0aW5nIG5lY2Vzc2FyeSBvbmVzIHRvIGJpbmFyeSBpbnRlcnNlY3Rpb24gb3BlcmF0b3IuXHJcbiAgICAgICAgICAgIHZhciB0b2tlbnMyID0gW107XHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB0b2tlbnMxLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zMVtpXTtcclxuICAgICAgICAgICAgICAgIGlmICghdG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSA3IC8qIFdoaXRlc3BhY2UgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbnMyLnB1c2godG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IGkgPT09IDAgPyBLRVlXT1JEX05VTEwgOiB0b2tlbnMxW2kgLSAxXTtcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gaSA9PT0gbGVuZ3RoIC0gMSA/IEtFWVdPUkRfTlVMTCA6IHRva2VuczFbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2aW91cyB8fCAhbmV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCgoKHByZXZpb3VzLnR5cGUgPT09IDEgLyogRnVuY3Rpb24gKi8pICYmIChwcmV2aW91cy5zdWJUeXBlID09PSAyIC8qIFN0b3AgKi8pKSB8fCAoKHByZXZpb3VzLnR5cGUgPT09IDIgLyogU3ViZXhwcmVzc2lvbiAqLykgJiYgKHByZXZpb3VzLnN1YlR5cGUgPT09IDIgLyogU3RvcCAqLykpIHx8IChwcmV2aW91cy50eXBlID09PSAwIC8qIE9wZXJhbmQgKi8pKSAmJiAoKChuZXh0LnR5cGUgPT09IDEgLyogRnVuY3Rpb24gKi8pICYmIChuZXh0LnN1YlR5cGUgPT09IDEgLyogU3RhcnQgKi8pKSB8fCAoKG5leHQudHlwZSA9PT0gMiAvKiBTdWJleHByZXNzaW9uICovKSAmJiAobmV4dC5zdWJUeXBlID09PSAxIC8qIFN0YXJ0ICovKSkgfHwgKG5leHQudHlwZSA9PT0gMCAvKiBPcGVyYW5kICovKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbnMyLnB1c2gobmV3IEZvcm11bGFUb2tlbignICcsIDUgLyogT3BlcmF0b3JJbmZpeCAqLywgdG9rZW4uaW5kZXgsIDkgLyogSW50ZXJzZWN0aW9uICovKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRva2VuczI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fYnVpbGRFeHByZXNzaW9uTm9kZSA9IGZ1bmN0aW9uKGNvbnRleHQsIHRva2VuKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRFeHByZXNzaW9uO1xyXG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMSAvKiBGdW5jdGlvbiAqLykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSBDT05TVF9BUlJBWSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRFeHByZXNzaW9uID0gc2VsZi5fYnVpbGRBcnJhcnlFeHByZXNzaW9uKGNvbnRleHQsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEV4cHJlc3Npb24gPSBzZWxmLl9idWlsZEZ1bmN0aW9uRXhwcmVzc2lvbihjb250ZXh0LCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gMiAvKiBTdWJleHByZXNzaW9uICovKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RXhwcmVzc2lvbiA9IHNlbGYuX2J1aWxkU3ViRXhwcmVzc2lvbihjb250ZXh0LCB0b2tlbik7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gMCAvKiBPcGVyYW5kICovKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4uc3ViVHlwZSA9PT0gNCAvKiBOdW1iZXIgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RXhwcmVzc2lvbiA9IG5ldyBDYWxjRXhwcmVzc2lvbnMuRG91YmxlRXhwcmVzc2lvbihwYXJzZUZsb2F0KHRva2VuLnZhbHVlKSwgdG9rZW4udmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbi5zdWJUeXBlID09PSA2IC8qIEVycm9yICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEV4cHJlc3Npb24gPSBuZXcgQ2FsY0V4cHJlc3Npb25zLkVycm9yRXhwcmVzc2lvbihDYWxjLkNhbGNFcnJvci5wYXJzZSh0b2tlbi52YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbi5zdWJUeXBlID09PSA1IC8qIExvZ2ljYWwgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyZVN0cmluZ0lnbm9yZUNhc2UodG9rZW4udmFsdWUsIENPTlNUX1RSVUUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRFeHByZXNzaW9uID0gbmV3IENhbGNFeHByZXNzaW9ucy5Cb29sZWFuRXhwcmVzc2lvbih0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbXBhcmVTdHJpbmdJZ25vcmVDYXNlKHRva2VuLnZhbHVlLCBDT05TVF9GQUxTRSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEV4cHJlc3Npb24gPSBuZXcgQ2FsY0V4cHJlc3Npb25zLkJvb2xlYW5FeHByZXNzaW9uKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLnN1YlR5cGUgPT09IDcgLyogU3RydWN0IG9yIEZpZWxkICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEV4cHJlc3Npb24gPSBzZWxmLl9idWlsZFN0cnVjdE9yRmllbGRFeHByZXNzaW9uKGNvbnRleHQsIHRva2VuLnZhbHVlLCB0b2tlbi5pbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRFeHByZXNzaW9uID0gbmV3IENhbGNFeHByZXNzaW9ucy5TdHJpbmdFeHByZXNzaW9uKHRva2VuLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEV4cHJlc3Npb247XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fYnVpbGRFeHByZXNzaW9uVHJlZSA9IGZ1bmN0aW9uKGNvbnRleHQsIHRva2Vucykge1xyXG4gICAgICAgICAgICAvLyBwYXJzZSB0byBleHByZXNzaW9uIGFuZCBiaW5hcnkgb3BlcmF0b3IgbGlzdFxyXG4gICAgICAgICAgICAvLyB0aGUgbGlzdCBzaG91bGQgYmU6IGV4cHJlc3Npb24gb3BlcmF0b3IgZXhwcmVzc2lvbiBvcGVyYXRvciBleHByZXNzaW9uXHJcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gdGhpcy5fcGFyc2VUb0JpbmFyeU9wZXJhdG9yTGlzdChjb250ZXh0LCB0b2tlbnMpO1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudEV4cHJlc3Npb247XHJcbiAgICAgICAgICAgIHZhciBsYXN0RXhwcmVzc2lvbjtcclxuICAgICAgICAgICAgdmFyIG5leHRFeHByZXNzaW9uO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXg7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGluZGV4ID0gMzsgaW5kZXggPCByZXN1bHRzLmxlbmd0aDspIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0VG9rZW4gPSByZXN1bHRzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50VG9rZW4gPSByZXN1bHRzW2luZGV4IC0gMl07XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dFRva2VuICYmIG5leHRUb2tlbi50eXBlID09PSA1IC8qIE9wZXJhdG9ySW5maXggKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPj0gMyAmJiBnZXRPcGVhdG9yUHJpb3JpdHkobmV4dFRva2VuLnZhbHVlKSA+PSBnZXRPcGVhdG9yUHJpb3JpdHkoY3VycmVudFRva2VuLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbXBvc2UgdHdvIGV4cHJlc3Npb25zIGFuZCB0aGUgYmluYXJ5IG9wZXJhdG9yIHRvIG9uZSBleHByZXNzaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RFeHByZXNzaW9uID0gcmVzdWx0c1tpbmRleCAtIDNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0RXhwcmVzc2lvbiA9IHJlc3VsdHNbaW5kZXggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEV4cHJlc3Npb24gPSBuZXcgQ2FsY0V4cHJlc3Npb25zLkJpbmFyeU9wZXJhdG9yRXhwcmVzc2lvbihnZXRCaW5hcnlPcGVyYXRvcihjdXJyZW50VG9rZW4pLCBsYXN0RXhwcmVzc2lvbiwgbmV4dEV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnNwbGljZShpbmRleCAtIDMsIDMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnNwbGljZShpbmRleCAtIDMsIDAsIGN1cnJlbnRFeHByZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggLT0gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IHJlc3VsdHNbaW5kZXggLSAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHNbMF07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gcmVzdWx0cy5sZW5ndGggLSAyOyBpbmRleCA+IDA7IGluZGV4IC09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0RXhwcmVzc2lvbiA9IHJlc3VsdHNbaW5kZXggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0RXhwcmVzc2lvbiA9IHJlc3VsdHNbaW5kZXggKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RXhwcmVzc2lvbiA9IG5ldyBDYWxjRXhwcmVzc2lvbnMuQmluYXJ5T3BlcmF0b3JFeHByZXNzaW9uKGdldEJpbmFyeU9wZXJhdG9yKHJlc3VsdHNbaW5kZXhdKSwgbGFzdEV4cHJlc3Npb24sIG5leHRFeHByZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnNwbGljZShpbmRleCAtIDEsIDMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChjdXJyZW50RXhwcmVzc2lvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEV4cHJlc3Npb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9wYXJzZVRvQmluYXJ5T3BlcmF0b3JMaXN0ID0gZnVuY3Rpb24oY29udGV4dCwgdG9rZW5zKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50RXhwcmVzc2lvbjtcclxuICAgICAgICAgICAgdmFyIE9wZXJhdG9ycyA9IENhbGNQYXJzZXIuT3BlcmF0b3JzO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRUb2tlbiA9IHRva2Vuc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gNCAvKiBPcGVyYXRvclByZWZpeCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcFN0YWNrID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRUb2tlbi50eXBlID09PSA0IC8qIE9wZXJhdG9yUHJlZml4ICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wU3RhY2sucHVzaChjdXJyZW50VG9rZW4udmFsdWUgPT09ICcrJyA/IE9wZXJhdG9ycy5wbHVzIDogT3BlcmF0b3JzLm5lZ2F0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gdG9rZW5zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFRva2VuID0gdG9rZW5zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRFeHByZXNzaW9uID0gbmV3IENhbGNFeHByZXNzaW9ucy5VbmFyeU9wZXJhdG9yRXhwcmVzc2lvbihvcFN0YWNrLnBvcCgpLCB0aGlzLl9idWlsZEV4cHJlc3Npb25Ob2RlKGNvbnRleHQsIG5leHRUb2tlbikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChvcFN0YWNrLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEV4cHJlc3Npb24gPSBuZXcgQ2FsY0V4cHJlc3Npb25zLlVuYXJ5T3BlcmF0b3JFeHByZXNzaW9uKG9wU3RhY2sucG9wKCksIGN1cnJlbnRFeHByZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN1cnJlbnRFeHByZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFRva2VuLnR5cGUgPT09IDYgLyogT3BlcmF0b3JQb3N0Zml4ICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RFeHByZXNzaW9uID0gcmVzdWx0c1tyZXN1bHRzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRFeHByZXNzaW9uID0gbmV3IENhbGNFeHByZXNzaW9ucy5VbmFyeU9wZXJhdG9yRXhwcmVzc2lvbihPcGVyYXRvcnMucGVyY2VudCwgbGFzdEV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN1cnJlbnRFeHByZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFRva2VuLnR5cGUgPT09IDUgLyogT3BlcmF0b3JJbmZpeCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChjdXJyZW50VG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RXhwcmVzc2lvbiA9IHRoaXMuX2J1aWxkRXhwcmVzc2lvbk5vZGUoY29udGV4dCwgY3VycmVudFRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY3VycmVudEV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIFBhcnNlci5wcm90b3R5cGUuX2J1aWxkRnVuY3Rpb25FeHByZXNzaW9uID0gZnVuY3Rpb24oY29udGV4dCwgcm9vdFRva2VuKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgIHZhciBzdWJUb2tlbnMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb290VG9rZW4uY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHJvb3RUb2tlbi5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSAzIC8qIEFyZ3VtZW50ICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViVG9rZW5zLnB1c2godG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3ViVG9rZW5zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2gobmV3IENhbGNFeHByZXNzaW9ucy5NaXNzaW5nQXJndW1lbnRFeHByZXNzaW9uKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh0aGlzLl9idWlsZEV4cHJlc3Npb25UcmVlKGNvbnRleHQsIHN1YlRva2VucykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJUb2tlbnMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN1YlRva2Vucy5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh0aGlzLl9idWlsZEV4cHJlc3Npb25UcmVlKGNvbnRleHQsIHN1YlRva2VucykpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJvb3RUb2tlbi5jaGlsZHJlbi5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChuZXcgQ2FsY0V4cHJlc3Npb25zLk1pc3NpbmdBcmd1bWVudEV4cHJlc3Npb24oKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGZuID0gQ2FsY0Z1bmN0aW9ucy5maW5kR2xvYmFsRnVuY3Rpb24ocm9vdFRva2VuLnZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKGZuKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3NMZW5ndGggPCBmbi5taW5BcmdzIHx8IGFyZ3NMZW5ndGggPiBmbi5tYXhBcmdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgc3IoaW52YWxpZFBhcmEpICsgcm9vdFRva2VuLmluZGV4ICsgc3IoZnVsbFN0b3ApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDYWxjRXhwcmVzc2lvbnMuRnVuY3Rpb25FeHByZXNzaW9uKGZuLCBhcmdzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2FsY0V4cHJlc3Npb25zLkZ1bmN0aW9uRXhwcmVzc2lvbihyb290VG9rZW4udmFsdWUsIGFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fYnVpbGRTdWJFeHByZXNzaW9uID0gZnVuY3Rpb24oY29udGV4dCwgcm9vdFRva2VuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FsY0V4cHJlc3Npb25zLlBhcmVudGhlc2VzRXhwcmVzc2lvbih0aGlzLl9idWlsZEV4cHJlc3Npb25UcmVlKGNvbnRleHQsIHJvb3RUb2tlbi5jaGlsZHJlbikpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIFBhcnNlci5wcm90b3R5cGUuX2J1aWxkU3RydWN0T3JGaWVsZEV4cHJlc3Npb24gPSBmdW5jdGlvbihjb250ZXh0LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IEtFWVdPUkRfVU5ERUZJTkVEIHx8IHZhbHVlID09PSBLRVlXT1JEX05VTEwgfHwgdmFsdWUgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge2VuZEluZGV4OiAwLCBleHByZXNzaW9uOiBLRVlXT1JEX05VTEx9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVnID0gL14oW15cXFtcXF1dKilbXFxbXXsxfShbXlxcW1xcXV0rKVtcXF1dezF9JC9nO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHJlZy5leGVjKHZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzLmxlbmd0aCAhPT0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7ZW5kSW5kZXg6IGxlbmd0aCwgZXhwcmVzc2lvbjogS0VZV09SRF9OVUxMfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IHJlc3VsdHNbMV07XHJcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uID0gcmVzdWx0c1syXTtcclxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5jYWxjU291cmNlLmhhc0NvbHVtbihjb2x1bW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlID0gY29udGV4dC5jYWxjU291cmNlLmdldE5hbWUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENhbGNFeHByZXNzaW9ucy5TdHJ1Y3RSZWZlcmVuY2VFeHByZXNzaW9uKHRhYmxlLCBjb2x1bW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5jYWxjU291cmNlLmhhc0ZpZWxkKGNvbHVtbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDYWxjRXhwcmVzc2lvbnMuRmllbGRSZWZlcmVuY2VFeHByZXNzaW9uKGNvbHVtbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDYWxjRXhwcmVzc2lvbnMuVW5rbm93blJlZmVyZW5jZUV4cHJlc3Npb24oY29sdW1uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENhbGNFeHByZXNzaW9ucy5TdHJ1Y3RSZWZlcmVuY2VFeHByZXNzaW9uKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL3JldHVybiBudWxsO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIFBhcnNlci5wcm90b3R5cGUuX3ZhbGlkYXRlTmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IEtFWVdPUkRfVU5ERUZJTkVEIHx8IG5hbWUgPT09IEtFWVdPUkRfTlVMTCB8fCBuYW1lID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBuYW1lTGVuZ3RoID0gbmFtZS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChuYW1lTGVuZ3RoID09PSAxICYmIChuYW1lID09PSAnUicgfHwgbmFtZSA9PT0gJ3InIHx8IG5hbWUgPT09ICdDJyB8fCBuYW1lID09PSAnYycpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGFyID0gbmFtZS5jaGFyQXQoMCk7XHJcbiAgICAgICAgICAgIGlmICghKGN1cnJlbnRDaGFyID09PSAnXycgfHwgY3VycmVudENoYXIgPT09ICdcXFxcJyB8fCBpc0xldHRlcihjdXJyZW50Q2hhcikgfHwgaXNTeW1ib2woY3VycmVudENoYXIpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbmFtZUxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2hhciA9IG5hbWUuY2hhckF0KGkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoY3VycmVudENoYXIgPT09ICdfJyB8fCBjdXJyZW50Q2hhciA9PT0gJ1xcXFwnIHx8IGN1cnJlbnRDaGFyID09PSAnPycgfHwgY3VycmVudENoYXIgPT09ICcuJyB8fCBpc0xldHRlck9yRGlnaXQoY3VycmVudENoYXIpIHx8IGlzU3ltYm9sKGN1cnJlbnRDaGFyKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQYXJzZXIuX2lzTGV0dGVyID0gaXNMZXR0ZXI7XHJcbiAgICAgICAgUGFyc2VyLl9pc0xldHRlck9yRGlnaXQgPSBpc0xldHRlck9yRGlnaXQ7XHJcblxyXG4gICAgICAgIFBhcnNlci5saXN0U2VwYXJhdG9yID0gJywnO1xyXG4gICAgICAgIFBhcnNlci5udW1iZXJEZWNpbWFsU2VwYXJhdG9yID0gJy4nO1xyXG4gICAgICAgIFBhcnNlci5hcnJheUdyb3VwU2VwYXJhdG9yID0gJzsnO1xyXG4gICAgICAgIFBhcnNlci5fYXJyYXlBcmd1bWVudFNlcGF0YXRvciA9IFBhcnNlci5saXN0U2VwYXJhdG9yO1xyXG4gICAgICAgIFBhcnNlci5fb3BlcmF0b3JJbmZpeCA9ICdcXFxcKy0qL14mPT48OiAnICsgUGFyc2VyLmxpc3RTZXBhcmF0b3I7XHJcbiAgICAgICAgUGFyc2VyLnVucGFyc2VXaXRob3V0Q3VsdHVyZSA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiBQYXJzZXI7XHJcbiAgICB9KSgpO1xyXG4gICAgQ2FsY1BhcnNlci5QYXJzZXIgPSBQYXJzZXI7XHJcblxyXG4gICAgZnVuY3Rpb24gaXNMYXRpbjEoY2MpIHtcclxuICAgICAgICByZXR1cm4gY2MgPD0gMHgwMGZmO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzQXNjaWkoY2MpIHtcclxuICAgICAgICByZXR1cm4gY2MgPD0gMHgwMDdmO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzRGlnaXQoYykge1xyXG4gICAgICAgIHZhciBjYyA9IGMuY2hhckNvZGVBdCgwKTtcclxuXHJcbiAgICAgICAgLy9pZiAoIWlzTGF0aW4xKGNjKSkgeyAvLyBub3QgbGF0aW4gY2hhcmFjdGVyLCBub3Qgc3VwcG9ydGVkIHlldC5cclxuICAgICAgICAvLyAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgLy99XHJcbiAgICAgICAgLy8gMC05XHJcbiAgICAgICAgcmV0dXJuIGNjID49IDQ4ICYmIGNjIDw9IDU3O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzTGV0dGVyKGMpIHtcclxuICAgICAgICB2YXIgY2MgPSBjLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgaWYgKCFpc0xhdGluMShjYykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBmaXggYnVnIDkyOTY0XHJcbiAgICAgICAgaWYgKCFpc0FzY2lpKGNjKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2F0ZWdvcnlGb3JMYXRpbjFbY2NdID09PSBMYXRpblVuaWNvZGVDYXRlZ29yeS5VcHBlcmNhc2VMZXR0ZXIgfHwgY2F0ZWdvcnlGb3JMYXRpbjFbY2NdID09PSBMYXRpblVuaWNvZGVDYXRlZ29yeS5Mb3dlcmNhc2VMZXR0ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG1ha2UgbG93Y2FzZVxyXG4gICAgICAgIGNjIHw9IDB4MjA7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG5cclxuICAgICAgICAvLyAvLyBhLXo7XHJcbiAgICAgICAgcmV0dXJuIChjYyA+PSA5NiAmJiBjYyA8PSAxMjIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzTGV0dGVyT3JEaWdpdChjKSB7XHJcbiAgICAgICAgdmFyIGNjID0gYy5jaGFyQ29kZUF0KDApO1xyXG4gICAgICAgIGlmICghaXNMYXRpbjEoY2MpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZml4IGJ1ZyA5Mjk2NFxyXG4gICAgICAgIGlmICghaXNBc2NpaShjYykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhdGVnb3J5Rm9yTGF0aW4xW2NjXSA9PT0gTGF0aW5Vbmljb2RlQ2F0ZWdvcnkuVXBwZXJjYXNlTGV0dGVyIHx8IGNhdGVnb3J5Rm9yTGF0aW4xW2NjXSA9PT0gTGF0aW5Vbmljb2RlQ2F0ZWdvcnkuTG93ZXJjYXNlTGV0dGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2MgPD0gNTcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNjID49IDQ4O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBtYWtlIGxvd2Nhc2VcclxuICAgICAgICBjYyB8PSAweDIwOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuXHJcbiAgICAgICAgLy8gYS16O1xyXG4gICAgICAgIHJldHVybiAoY2MgPj0gOTYgJiYgY2MgPD0gMTIyKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc1N5bWJvbChjKSB7XHJcbiAgICAgICAgdmFyIGNjID0gYy5jaGFyQ29kZUF0KDApO1xyXG4gICAgICAgIGlmICghaXNMYXRpbjEoY2MpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNhdGVnb3J5Rm9yTGF0aW4xW2NjXSA9PT0gTGF0aW5Vbmljb2RlQ2F0ZWdvcnkuTWF0aFN5bWJvbCB8fCBjYXRlZ29yeUZvckxhdGluMVtjY10gPT09IExhdGluVW5pY29kZUNhdGVnb3J5LmN1cnJlbmN5U3ltYm9sIHx8IGNhdGVnb3J5Rm9yTGF0aW4xW2NjXSA9PT0gTGF0aW5Vbmljb2RlQ2F0ZWdvcnkuTW9kaWZpZXJTeW1ib2wgfHwgY2F0ZWdvcnlGb3JMYXRpbjFbY2NdID09PSBMYXRpblVuaWNvZGVDYXRlZ29yeS5PdGhlclN5bWJvbDtcclxuICAgIH1cclxuXHJcbiAgICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXHJcbiAgICBmdW5jdGlvbiBpc051bWJlcihjKSB7XHJcbiAgICAgICAgdmFyIGNjID0gYy5jaGFyQ29kZUF0KDApO1xyXG5cclxuICAgICAgICAvL2lmICghaXNMYXRpbjEoY2MpKSB7XHJcbiAgICAgICAgLy8gICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIC8vfVxyXG4gICAgICAgIC8vIGZpeCBidWcgOTI5NjRcclxuICAgICAgICBpZiAoIWlzQXNjaWkoY2MpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYXRlZ29yeUZvckxhdGluMVtjY10gPT09IExhdGluVW5pY29kZUNhdGVnb3J5LkRlY2ltYWxEaWdpdE51bWJlciB8fCBjYXRlZ29yeUZvckxhdGluMVtjY10gPT09IExhdGluVW5pY29kZUNhdGVnb3J5Lk90aGVyTnVtYmVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gMC05XHJcbiAgICAgICAgcmV0dXJuIGNjID49IDQ4ICYmIGNjIDw9IDU3O1xyXG4gICAgfVxyXG4gICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cclxuXHJcbiAgICBmdW5jdGlvbiBpc051bWJlcjIoc3RyLCBzdGFydEluZGV4LCBudW1iZXJEZWNpbWFsU2VwYXJhdG9yKSB7XHJcbiAgICAgICAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XHJcbiAgICAgICAgdmFyIHN0YXRlID0gTnVtYmVyU3RhdGUuTm9uZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50Q2hhciA9IHN0ci5jaGFyQXQoaSk7XHJcbiAgICAgICAgICAgIGlmIChpc0RpZ2l0KGN1cnJlbnRDaGFyKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSBOdW1iZXJTdGF0ZS5Ob25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBOdW1iZXJTdGF0ZS5JbnQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBOdW1iZXJTdGF0ZS5Eb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IE51bWJlclN0YXRlLkRlY2ltYWw7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBOdW1iZXJTdGF0ZS5TaWduKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBOdW1iZXJTdGF0ZS5JbnQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBOdW1iZXJTdGF0ZS5FeHBvbmVudCB8fCBzdGF0ZSA9PT0gTnVtYmVyU3RhdGUuU2lnbkV4cG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBOdW1iZXJTdGF0ZS5TY2llbnRpZmljTm90YXRpb247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudENoYXIgPT09IG51bWJlckRlY2ltYWxTZXBhcmF0b3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gTnVtYmVyU3RhdGUuSW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBOdW1iZXJTdGF0ZS5EZWNpbWFsO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gTnVtYmVyU3RhdGUuTm9uZSB8fCBzdGF0ZSA9PT0gTnVtYmVyU3RhdGUuU2lnbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gTnVtYmVyU3RhdGUuRG90O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge3Jlc3VsdDogZmFsc2V9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRDaGFyID09PSAnKycgfHwgY3VycmVudENoYXIgPT09ICctJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSBOdW1iZXJTdGF0ZS5Ob25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBOdW1iZXJTdGF0ZS5TaWduO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gTnVtYmVyU3RhdGUuRXhwb25lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IE51bWJlclN0YXRlLlNpZ25FeHBvbmVudDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtyZXN1bHQ6IHRydWUsIGVuZEluZGV4OiBpIC0gMX07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudENoYXIgPT09ICdFJyB8fCBjdXJyZW50Q2hhciA9PT0gJ2UnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09IE51bWJlclN0YXRlLkludCB8fCBzdGF0ZSA9PT0gTnVtYmVyU3RhdGUuRGVjaW1hbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gTnVtYmVyU3RhdGUuRXhwb25lbnQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7cmVzdWx0OiBmYWxzZX07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IE51bWJlclN0YXRlLkludCB8fCBzdGF0ZSA9PT0gTnVtYmVyU3RhdGUuRGVjaW1hbCB8fCBzdGF0ZSA9PT0gTnVtYmVyU3RhdGUuU2NpZW50aWZpY05vdGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge3Jlc3VsdDogdHJ1ZSwgZW5kSW5kZXg6IGkgLSAxfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhdGUgPT09IE51bWJlclN0YXRlLkludCB8fCBzdGF0ZSA9PT0gTnVtYmVyU3RhdGUuRGVjaW1hbCB8fCBzdGF0ZSA9PT0gTnVtYmVyU3RhdGUuU2NpZW50aWZpY05vdGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7cmVzdWx0OiB0cnVlLCBlbmRJbmRleDogbGVuIC0gMX07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7cmVzdWx0OiBmYWxzZX07XHJcbiAgICB9XHJcblxyXG4gICAgLy88L2VkaXRvci1mb2xkPlxyXG4gICAgLy88ZWRpdG9yLWZvbGQgZGVzYz0nUGFyc2VyIERlZmluaXRpb24nPlxyXG4gICAgdmFyIEV4Y2VsRm9ybXVsYVRva2VuVHlwZTtcclxuICAgIChmdW5jdGlvbihFeGNlbEZvcm11bGFUb2tlblR5cGUpIHtcclxuICAgICAgICBFeGNlbEZvcm11bGFUb2tlblR5cGVbRXhjZWxGb3JtdWxhVG9rZW5UeXBlLk9wZXJhbmQgPSAwXSA9ICdPcGVyYW5kJztcclxuICAgICAgICBFeGNlbEZvcm11bGFUb2tlblR5cGVbRXhjZWxGb3JtdWxhVG9rZW5UeXBlLkZ1bmN0aW9uID0gMV0gPSAnRnVuY3Rpb24nO1xyXG4gICAgICAgIEV4Y2VsRm9ybXVsYVRva2VuVHlwZVtFeGNlbEZvcm11bGFUb2tlblR5cGUuU3ViZXhwcmVzc2lvbiA9IDJdID0gJ1N1YmV4cHJlc3Npb24nO1xyXG4gICAgICAgIEV4Y2VsRm9ybXVsYVRva2VuVHlwZVtFeGNlbEZvcm11bGFUb2tlblR5cGUuQXJndW1lbnQgPSAzXSA9ICdBcmd1bWVudCc7XHJcbiAgICAgICAgRXhjZWxGb3JtdWxhVG9rZW5UeXBlW0V4Y2VsRm9ybXVsYVRva2VuVHlwZS5PcGVyYXRvclByZWZpeCA9IDRdID0gJ09wZXJhdG9yUHJlZml4JztcclxuICAgICAgICBFeGNlbEZvcm11bGFUb2tlblR5cGVbRXhjZWxGb3JtdWxhVG9rZW5UeXBlLk9wZXJhdG9ySW5maXggPSA1XSA9ICdPcGVyYXRvckluZml4JztcclxuICAgICAgICBFeGNlbEZvcm11bGFUb2tlblR5cGVbRXhjZWxGb3JtdWxhVG9rZW5UeXBlLk9wZXJhdG9yUG9zdGZpeCA9IDZdID0gJ09wZXJhdG9yUG9zdGZpeCc7XHJcbiAgICAgICAgRXhjZWxGb3JtdWxhVG9rZW5UeXBlW0V4Y2VsRm9ybXVsYVRva2VuVHlwZS5XaGl0ZXNwYWNlID0gN10gPSAnV2hpdGVzcGFjZSc7XHJcbiAgICAgICAgRXhjZWxGb3JtdWxhVG9rZW5UeXBlW0V4Y2VsRm9ybXVsYVRva2VuVHlwZS5Vbmtub3duID0gOF0gPSAnVW5rbm93bic7XHJcbiAgICB9KShFeGNlbEZvcm11bGFUb2tlblR5cGUgfHwgKEV4Y2VsRm9ybXVsYVRva2VuVHlwZSA9IHt9KSk7XHJcbiAgICB2YXIgRXhjZWxGb3JtdWxhVG9rZW5TdWJ0eXBlO1xyXG4gICAgKGZ1bmN0aW9uKEV4Y2VsRm9ybXVsYVRva2VuU3VidHlwZSkge1xyXG4gICAgICAgIEV4Y2VsRm9ybXVsYVRva2VuU3VidHlwZVtFeGNlbEZvcm11bGFUb2tlblN1YnR5cGUuTm90aGluZyA9IDBdID0gJ05vdGhpbmcnO1xyXG4gICAgICAgIEV4Y2VsRm9ybXVsYVRva2VuU3VidHlwZVtFeGNlbEZvcm11bGFUb2tlblN1YnR5cGUuU3RhcnQgPSAxXSA9ICdTdGFydCc7XHJcbiAgICAgICAgRXhjZWxGb3JtdWxhVG9rZW5TdWJ0eXBlW0V4Y2VsRm9ybXVsYVRva2VuU3VidHlwZS5TdG9wID0gMl0gPSAnU3RvcCc7XHJcbiAgICAgICAgRXhjZWxGb3JtdWxhVG9rZW5TdWJ0eXBlW0V4Y2VsRm9ybXVsYVRva2VuU3VidHlwZS5UZXh0ID0gM10gPSAnVGV4dCc7XHJcbiAgICAgICAgRXhjZWxGb3JtdWxhVG9rZW5TdWJ0eXBlW0V4Y2VsRm9ybXVsYVRva2VuU3VidHlwZS5OdW1iZXIgPSA0XSA9ICdOdW1iZXInO1xyXG4gICAgICAgIEV4Y2VsRm9ybXVsYVRva2VuU3VidHlwZVtFeGNlbEZvcm11bGFUb2tlblN1YnR5cGUuTG9naWNhbCA9IDVdID0gJ0xvZ2ljYWwnO1xyXG4gICAgICAgIEV4Y2VsRm9ybXVsYVRva2VuU3VidHlwZVtFeGNlbEZvcm11bGFUb2tlblN1YnR5cGUuRXJyb3IgPSA2XSA9ICdFcnJvcic7XHJcbiAgICAgICAgRXhjZWxGb3JtdWxhVG9rZW5TdWJ0eXBlW0V4Y2VsRm9ybXVsYVRva2VuU3VidHlwZS5SYW5nZU9yTmFtZSA9IDddID0gJ1JhbmdlT3JOYW1lJztcclxuICAgICAgICBFeGNlbEZvcm11bGFUb2tlblN1YnR5cGVbRXhjZWxGb3JtdWxhVG9rZW5TdWJ0eXBlLkNvbmNhdGVuYXRpb24gPSA4XSA9ICdDb25jYXRlbmF0aW9uJztcclxuICAgICAgICBFeGNlbEZvcm11bGFUb2tlblN1YnR5cGVbRXhjZWxGb3JtdWxhVG9rZW5TdWJ0eXBlLkludGVyc2VjdGlvbiA9IDldID0gJ0ludGVyc2VjdGlvbic7XHJcbiAgICAgICAgRXhjZWxGb3JtdWxhVG9rZW5TdWJ0eXBlW0V4Y2VsRm9ybXVsYVRva2VuU3VidHlwZS5VbmlvbiA9IDEwXSA9ICdVbmlvbic7XHJcbiAgICAgICAgRXhjZWxGb3JtdWxhVG9rZW5TdWJ0eXBlW0V4Y2VsRm9ybXVsYVRva2VuU3VidHlwZS5SYW5nZU9wID0gMTFdID0gJ1JhbmdlT3AnO1xyXG4gICAgfSkoRXhjZWxGb3JtdWxhVG9rZW5TdWJ0eXBlIHx8IChFeGNlbEZvcm11bGFUb2tlblN1YnR5cGUgPSB7fSkpO1xyXG5cclxuICAgIHZhciBGb3JtdWxhVG9rZW4gPSAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRm9ybXVsYVRva2VuKHZhbHVlLCB0eXBlLCBpbmRleCwgc3ViVHlwZSkge1xyXG4gICAgICAgICAgICBpZiAoc3ViVHlwZSA9PT0gS0VZV09SRF9VTkRFRklORUQgfHwgc3ViVHlwZSA9PT0gS0VZV09SRF9OVUxMKSB7XHJcbiAgICAgICAgICAgICAgICBzdWJUeXBlID0gMCAvKiBOb3RoaW5nICovO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHNlbGYudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgc2VsZi50eXBlID0gdHlwZTtcclxuICAgICAgICAgICAgc2VsZi5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICBzZWxmLnN1YlR5cGUgPSBzdWJUeXBlO1xyXG4gICAgICAgICAgICBzZWxmLmNoaWxkcmVuID0gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gRm9ybXVsYVRva2VuO1xyXG4gICAgfSkoKTtcclxuXHJcbiAgICBmdW5jdGlvbiByZWFkU3RyaW5nKGZvcm11bGEsIHN0YXJ0SW5kZXgsIHN0YXJ0U2lnbiwgZW5kU2lnbiwgdGhyb3dFcnJvcikge1xyXG4gICAgICAgIHZhciBsZW4gPSBmb3JtdWxhLmxlbmd0aDtcclxuICAgICAgICB2YXIgc3RhcnRTaWduQ291bnQgPSAoc3RhcnRTaWduID09PSBlbmRTaWduKSA/IDAgOiAxO1xyXG4gICAgICAgIHZhciB0ZXh0ID0gJyc7XHJcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSBzdGFydEluZGV4ICsgMTsgaW5kZXggPCBsZW47IGluZGV4KyspIHtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGFyID0gZm9ybXVsYS5jaGFyQXQoaW5kZXgpO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudENoYXIgPT09IHN0YXJ0U2lnbikge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRTaWduQ291bnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY3VycmVudENoYXIgPT09IGVuZFNpZ24pIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0U2lnbkNvdW50LS07XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRTaWduID09PSBlbmRTaWduICYmIGluZGV4ICsgMiA8IGxlbiAmJiBmb3JtdWxhLmNoYXJBdChpbmRleCArIDEpID09PSBzdGFydFNpZ24pIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IHN0YXJ0U2lnbjtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFydFNpZ25Db3VudCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQgKz0gY3VycmVudENoYXI7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7cmVzdWx0OiB0ZXh0LCBlbmRJbmRleDogaW5kZXh9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGV4dCArPSBjdXJyZW50Q2hhcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhyb3dFcnJvcikge1xyXG4gICAgICAgICAgICB0aHJvdyBzcihub1N5bnRheCkgKyBlbmRTaWduICsgc3IobWF0Y2hTeW50YXgpICsgc3RhcnRTaWduICsgc3Ioc2luZ2xlUXVvdGVzRnVsbFN0b3ApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWFkU3RyaW5nMihmb3JtdWxhLCBzdGFydEluZGV4LCBzdGFydFNpZ24sIGVuZFNpZ24sIGVzY2FwZVNpZ24sIHRocm93RXJyb3IpIHtcclxuICAgICAgICB2YXIgbGVuID0gZm9ybXVsYS5sZW5ndGg7XHJcbiAgICAgICAgdmFyIHN0YXJ0U2lnbkNvdW50ID0gMDtcclxuICAgICAgICB2YXIgdGV4dCA9ICcnO1xyXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gc3RhcnRJbmRleDsgaW5kZXggPCBsZW47IGluZGV4KyspIHtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGFyID0gZm9ybXVsYS5jaGFyQXQoaW5kZXgpO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudENoYXIgPT09IGVzY2FwZVNpZ24pIHtcclxuICAgICAgICAgICAgICAgIHRleHQgKz0gY3VycmVudENoYXI7XHJcbiAgICAgICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudENoYXIgPSBmb3JtdWxhLmNoYXJBdChpbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSBzdGFydFNpZ24pIHtcclxuICAgICAgICAgICAgICAgIHRleHQgKz0gY3VycmVudENoYXI7XHJcbiAgICAgICAgICAgICAgICBzdGFydFNpZ25Db3VudCsrO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRDaGFyID09PSBlbmRTaWduKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydFNpZ25Db3VudC0tO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0U2lnbkNvdW50ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBjdXJyZW50Q2hhcjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtyZXN1bHQ6IHRleHQsIGVuZEluZGV4OiBpbmRleH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IGN1cnJlbnRDaGFyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aHJvd0Vycm9yKSB7XHJcbiAgICAgICAgICAgIHRocm93IHNyKG5vU3ludGF4KSArIGVuZFNpZ24gKyBzcihtYXRjaFN5bnRheCkgKyBzdGFydFNpZ24gKyBzcihzaW5nbGVRdW90ZXNGdWxsU3RvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlYWRFcnJvcihmb3JtdWxhLCBzdGFydEluZGV4LCB0aHJvd0Vycm9yKSB7XHJcbiAgICAgICAgdmFyIGxlbiA9IGZvcm11bGEubGVuZ3RoO1xyXG4gICAgICAgIHZhciBzdXJwbHVzTGVuID0gbGVuIC0gc3RhcnRJbmRleDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEVSUk9SX0xJU1QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGVyciA9IEVSUk9SX0xJU1RbaV07XHJcbiAgICAgICAgICAgIHZhciBlcnJMZW5ndGggPSBlcnIubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoc3RhcnRJbmRleCArIGVyckxlbmd0aCA+IGxlbikge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGVyclN0ciA9IGZvcm11bGEuc2xpY2Uoc3RhcnRJbmRleCwgc3RhcnRJbmRleCArIGVyckxlbmd0aCk7XHJcbiAgICAgICAgICAgIGlmIChlcnJMZW5ndGggPD0gc3VycGx1c0xlbiAmJiAoZXJyID09PSBlcnJTdHIgfHwgZXJyID09PSBlcnJTdHIudG9VcHBlckNhc2UoKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7cmVzdWx0OiBlcnIsIGVuZEluZGV4OiBzdGFydEluZGV4ICsgZXJyTGVuZ3RoIC0gMX07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRocm93RXJyb3IpIHtcclxuICAgICAgICAgICAgdGhyb3cgc3Ioc2luZ2xlUXVvdGUpO1xyXG4gICAgICAgICAgICAvLytmb3JtdWxhLnNsaWNlKHN0YXJ0SW5kZXgpICsgc3IoaXNWYWxpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldE9wZWF0b3JQcmlvcml0eShvcCkge1xyXG4gICAgICAgIGlmIChvcCA9PT0gJ14nIHx8IG9wID09PSAnOicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfSBlbHNlIGlmIChvcCA9PT0gJyonIHx8IG9wID09PSAnLycgfHwgb3AgPT09ICcgJykge1xyXG4gICAgICAgICAgICByZXR1cm4gMjtcclxuICAgICAgICB9IGVsc2UgaWYgKG9wID09PSAnKycgfHwgb3AgPT09ICctJyB8fCBvcCA9PT0gJywnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAzO1xyXG4gICAgICAgIH0gZWxzZSBpZiAob3AgPT09ICcmJykge1xyXG4gICAgICAgICAgICByZXR1cm4gNDtcclxuICAgICAgICB9IGVsc2UgaWYgKG9wID09PSAnfHwnIHx8IG9wID09PSAnJiYnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiA2O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiA1O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRCaW5hcnlPcGVyYXRvcih0b2tlbikge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRva2VuLnZhbHVlO1xyXG4gICAgICAgIHZhciBPcGVyYXRvcnMgPSBDYWxjUGFyc2VyLk9wZXJhdG9ycztcclxuICAgICAgICBpZiAodmFsdWUgPT09ICdeJykge1xyXG4gICAgICAgICAgICByZXR1cm4gT3BlcmF0b3JzLmV4cG9uZW50O1xyXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcqJykge1xyXG4gICAgICAgICAgICByZXR1cm4gT3BlcmF0b3JzLm11bHRpcGx5O1xyXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcvJykge1xyXG4gICAgICAgICAgICByZXR1cm4gT3BlcmF0b3JzLmRpdmlkZTtcclxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnKycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9wZXJhdG9ycy5hZGQ7XHJcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJy0nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPcGVyYXRvcnMuc3VidHJhY3Q7XHJcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJyYnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPcGVyYXRvcnMuY29uY2F0ZW5hdGU7XHJcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJzwnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPcGVyYXRvcnMubGVzc1RoYW47XHJcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJz0nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPcGVyYXRvcnMuZXF1YWw7XHJcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJz4nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPcGVyYXRvcnMuZ3JlYXRlclRoYW47XHJcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJz49Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gT3BlcmF0b3JzLmdyZWF0ZXJUaGFuT3JFcXVhbDtcclxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnPD0nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPcGVyYXRvcnMubGVzc1RoYW5PckVxdWFsO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICc8PicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9wZXJhdG9ycy5ub3RFcXVhbDtcclxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJiYnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPcGVyYXRvcnMuYW5kO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICd8fCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9wZXJhdG9ycy5vcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE9wZXJhdG9ycy5hZGQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0UHJvcGVydHkob2JqLCBuYW1lLCBmYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiAob2JqICYmIG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgPyBvYmpbbmFtZV0gOiBmYWxsYmFjaztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wYXJlU3RyaW5nSWdub3JlQ2FzZShzMSwgczIpIHtcclxuICAgICAgICBpZiAoKHMxID09PSBLRVlXT1JEX1VOREVGSU5FRCB8fCBzMSA9PT0gS0VZV09SRF9OVUxMKSAmJiAoczIgPT09IEtFWVdPUkRfVU5ERUZJTkVEIHx8IHMyID09PSBLRVlXT1JEX05VTEwpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKChzMSA9PT0gS0VZV09SRF9VTkRFRklORUQgfHwgczEgPT09IEtFWVdPUkRfTlVMTCkgJiYgKHMyICE9PSBLRVlXT1JEX1VOREVGSU5FRCAmJiBzMiAhPT0gS0VZV09SRF9OVUxMKSkgfHwgKChzMSAhPT0gS0VZV09SRF9VTkRFRklORUQgJiYgczEgIT09IEtFWVdPUkRfTlVMTCkgJiYgKHMyID09PSBLRVlXT1JEX1VOREVGSU5FRCB8fCBzMiA9PT0gS0VZV09SRF9OVUxMKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gczEudG9Mb3dlckNhc2UoKSA9PT0gczIudG9Mb3dlckNhc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICAoZnVuY3Rpb24oT3BlcmF0b3JzKSB7XHJcbiAgICAgICAgdmFyIE9wZXJhdG9yID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVwcmVzZW50cyBhbiBvcGVyYXRvci4gVGhpcyBpcyBhIGJhc2UgY2xhc3MuXHJcbiAgICAgICAgICAgICAqIEBjbGFzc1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgb3BlcmF0b3IuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBPcGVyYXRvcihuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgbmFtZSBvZiB0aGUgb3BlcmF0b3IuXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBvcGVyYXRvci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE9wZXJhdG9yLnByb3RvdHlwZS5nZXROYW1lID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRlc3RzIHdoZXRoZXIgdHdvIG9wZXJhdG9yIHN0cnVjdHVyZXMgYXJlIGRpZmZlcmVudC5cclxuICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IDxjPnRydWU8L2M+IGlmIHRoZSBvcGVyYXRvcnMgYXJlIHRoZSBzYW1lOyBvdGhlcndpc2UsIDxjPmZhbHNlPC9jPi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE9wZXJhdG9yLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVTdHJpbmdJZ25vcmVDYXNlKHRoaXMubmFtZSwgb3RoZXIubmFtZSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBPcGVyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE5hbWUoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIE9wZXJhdG9yO1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICAgICAgT3BlcmF0b3JzLk9wZXJhdG9yID0gT3BlcmF0b3I7XHJcblxyXG4gICAgICAgIC8vPGVkaXRvci1mb2xkIGRlc2M9J1VuYXJ5T3BlcmF0b3InPlxyXG4gICAgICAgIHZhciBVbmFyeU9wZXJhdG9yID0gKGZ1bmN0aW9uKF9zdXBlcikge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBvcGVyYXRvciBhcHBsaWVkIHRvIHRoZSBvcGVyYW5kLlxyXG4gICAgICAgICAgICAgKiBAY2xhc3NcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgUmVwcmVzZW50cyB0aGUgb3BlcmF0b3IgbmFtZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFVuYXJ5T3BlcmF0b3JfKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIENhbGMuX19leHRlbmRzKFVuYXJ5T3BlcmF0b3JfLCBfc3VwZXIpO1xyXG5cclxuICAgICAgICAgICAgVW5hcnlPcGVyYXRvcl8ucHJvdG90eXBlLl9ldmFsdWF0ZVNpbmdsZSA9IGZ1bmN0aW9uKG9wZXJhbmQsIGNvbnRleHQpIHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIG9wZXJhdG9yIGFwcGxpZWQgdG8gdGhlIG9wZXJhbmQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcGVyYW5kIFRoZSBvcGVyYW5kIGZvciB0aGUgb3BlcmF0b3IgZXZhbHVhdGlvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgVGhlIGNvbnRleHQgYXNzb2NpYXRlZCB3aXRoIHRoZSBvcGVyYXRvciBldmFsdWF0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgcmVzdWx0IG9mIHRoZSBvcGVyYXRvciBhcHBsaWVkIHRvIHRoZSBvcGVyYW5kLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVW5hcnlPcGVyYXRvcl8ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24ob3BlcmFuZCwgY29udGV4dCkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciBvcGVyYW5kVmFsdWUgPSBvcGVyYW5kO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhbmRWYWx1ZSBpbnN0YW5jZW9mIENhbGMuQ2FsY0NvbHVtblJlZmVyZW5jZSB8fCBvcGVyYW5kVmFsdWUgaW5zdGFuY2VvZiAgQ2FsYy5DYWxjRmllbGRSZWZlcmVuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcGVyYW5kVmFsdWUgPSBvcGVyYW5kVmFsdWUuZ2V0VmFsdWUoY29udGV4dC5nZXRDdXJyZW50Um93KCksIGNvbnRleHQuZ3JvdXBQYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChfLmlzQXJyYXkob3BlcmFuZFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLm1hcChvcGVyYW5kVmFsdWUsIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9ldmFsdWF0ZVNpbmdsZSh2YWx1ZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9ldmFsdWF0ZVNpbmdsZShvcGVyYW5kVmFsdWUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gVW5hcnlPcGVyYXRvcl87XHJcbiAgICAgICAgfSkoT3BlcmF0b3IpO1xyXG4gICAgICAgIE9wZXJhdG9ycy5VbmFyeU9wZXJhdG9yID0gVW5hcnlPcGVyYXRvcjtcclxuXHJcbiAgICAgICAgT3BlcmF0b3JzLnBsdXMgPSBuZXcgVW5hcnlPcGVyYXRvcignKycpO1xyXG4gICAgICAgIE9wZXJhdG9ycy5wbHVzLl9ldmFsdWF0ZVNpbmdsZSA9IGZ1bmN0aW9uKG9wZXJhbmQsIGNvbnRleHQpIHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICAgICAgICAgIGlmIChvcGVyYW5kID09PSBLRVlXT1JEX1VOREVGSU5FRCB8fCBvcGVyYW5kID09PSBLRVlXT1JEX05VTEwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBkb3VibGVMZWZ0ID0ge3ZhbHVlOiAwfTtcclxuICAgICAgICAgICAgaWYgKCFDYWxjLkNvbnZlcnQuckQob3BlcmFuZCwgZG91YmxlTGVmdCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGN5bGogZml4IHRoZSBidWcgNjk0NDIsIHJldHVybiB0aGUgc3RyaW5nIGRpcmVjdCBhcyBleGNlbC5cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3BlcmFuZCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmFuZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBDYWxjLkNhbGNFcnJvcnNWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gQ2FsYy5Db252ZXJ0LkQoZG91YmxlTGVmdC52YWx1ZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgT3BlcmF0b3JzLm5lZ2F0ZSA9IG5ldyBVbmFyeU9wZXJhdG9yKCctJyk7XHJcbiAgICAgICAgT3BlcmF0b3JzLm5lZ2F0ZS5fZXZhbHVhdGVTaW5nbGUgPSBmdW5jdGlvbihvcGVyYW5kLCBjb250ZXh0KSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgICAgICAgICBpZiAob3BlcmFuZCA9PT0gS0VZV09SRF9VTkRFRklORUQgfHwgb3BlcmFuZCA9PT0gS0VZV09SRF9OVUxMKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZG91YmxlVmFsdWUgPSB7dmFsdWU6IDB9O1xyXG4gICAgICAgICAgICBpZiAoIUNhbGMuQ29udmVydC5yRChvcGVyYW5kLCBkb3VibGVWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDYWxjLkNhbGNFcnJvcnNWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gLWRvdWJsZVZhbHVlLnZhbHVlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIE9wZXJhdG9ycy5wZXJjZW50ID0gbmV3IFVuYXJ5T3BlcmF0b3IoJyUnKTtcclxuICAgICAgICBPcGVyYXRvcnMucGVyY2VudC5fZXZhbHVhdGVTaW5nbGUgPSBmdW5jdGlvbihvcGVyYW5kLCBjb250ZXh0KSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgICAgICAgICBpZiAob3BlcmFuZCA9PT0gS0VZV09SRF9VTkRFRklORUQgfHwgb3BlcmFuZCA9PT0gS0VZV09SRF9OVUxMKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZG91YmxlVmFsdWUgPSB7dmFsdWU6IDB9O1xyXG4gICAgICAgICAgICBpZiAoIUNhbGMuQ29udmVydC5yRChvcGVyYW5kLCBkb3VibGVWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDYWxjLkNhbGNFcnJvcnNWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZG91YmxlVmFsdWUudmFsdWUgLyAxMDA7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy88L2VkaXRvci1mb2xkPlxyXG4gICAgICAgIC8vPGVkaXRvci1mb2xkIGRlc2M9J0JpbmFyeU9wZXJhdG9yJz5cclxuICAgICAgICBmdW5jdGlvbiBfYXBwcm94RXF1YWwoeCwgeSkge1xyXG4gICAgICAgICAgICBpZiAoeCA9PT0geSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIE1BVEhfQUJTKHggLSB5KSA8IE1BVEhfQUJTKHgpIC8gKDE2Nzc3MjE2LjAgKiAxNjc3NzIxNi4wKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBCaW5hcnlPcGVyYXRvciA9IChmdW5jdGlvbihfc3VwZXIpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlcHJlc2VudHMgYSBiaW5hcnkgb3BlcmF0b3IuXHJcbiAgICAgICAgICAgICAqIEBjbGFzc1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgb3BlcmF0b3IuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWNjZXB0c1JlZmVyZW5jZSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG9wZXJhdG9yIGFjY2VwdHMgcmVmZXJlbmNlIHZhbHVlcyBmb3IgdGhlIHNwZWNpZmllZCBvcGVyYW5kLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gQmluYXJ5T3BlcmF0b3JfKG5hbWUsIGFjY2VwdHNSZWZlcmVuY2UpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY2NlcHRzUmVmZXJlbmNlID0gYWNjZXB0c1JlZmVyZW5jZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBDYWxjLl9fZXh0ZW5kcyhCaW5hcnlPcGVyYXRvcl8sIF9zdXBlcik7XHJcblxyXG4gICAgICAgICAgICBCaW5hcnlPcGVyYXRvcl8ucHJvdG90eXBlLl9ldmFsdWF0ZVNpbmdsZSA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBjb250ZXh0KSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgb3BlcmF0b3IgYXBwbGllZCB0byB0aGUgb3BlcmFuZHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBsZWZ0IFRoZSBsZWZ0IG9wZXJhbmQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSByaWdodCBUaGUgcmlnaHQgb3BlcmFuZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgVGhlIGNvbnRleHQgYXNzb2NpYXRlZCB3aXRoIHRoZSBvcGVyYXRvciBldmFsdWF0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBSZXN1bHQgb2YgdGhlIG9wZXJhdG9yIGFwcGxpZWQgdG8gdGhlIG9wZXJhbmRzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluYXJ5T3BlcmF0b3JfLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVmdFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlZnQgaW5zdGFuY2VvZiBDYWxjLkNhbGNDb2x1bW5SZWZlcmVuY2UgfHwgbGVmdCBpbnN0YW5jZW9mIENhbGMuQ2FsY0ZpZWxkUmVmZXJlbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdFZhbHVlID0gbGVmdC5nZXRWYWx1ZShjb250ZXh0LmdldEN1cnJlbnRSb3coKSwgY29udGV4dC5ncm91cFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0VmFsdWUgPSBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAocmlnaHQgaW5zdGFuY2VvZiBDYWxjLkNhbGNDb2x1bW5SZWZlcmVuY2UgfHwgcmlnaHQgaW5zdGFuY2VvZiBDYWxjLkNhbGNGaWVsZFJlZmVyZW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0VmFsdWUgPSByaWdodC5nZXRWYWx1ZShjb250ZXh0LmdldEN1cnJlbnRSb3coKSwgY29udGV4dC5ncm91cFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByaWdodFZhbHVlID0gcmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVmdEFycmF5ID0gXy5pc0FycmF5KGxlZnRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHRBcnJheSA9IF8uaXNBcnJheShyaWdodFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChsZWZ0QXJyYXkgJiYgcmlnaHRBcnJheSAmJiBsZWZ0VmFsdWUubGVuZ3RoID09PSByaWdodFZhbHVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLm1hcChsZWZ0VmFsdWUsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZXZhbHVhdGVTaW5nbGUodmFsdWUsIHJpZ2h0VmFsdWVbaW5kZXhdLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWxlZnRBcnJheSAmJiAhcmlnaHRBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9ldmFsdWF0ZVNpbmdsZShsZWZ0VmFsdWUsIHJpZ2h0VmFsdWUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0QXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5tYXAobGVmdFZhbHVlLCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZXZhbHVhdGVTaW5nbGUodmFsdWUsIHJpZ2h0VmFsdWUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyaWdodEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ubWFwKHJpZ2h0VmFsdWUsIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9ldmFsdWF0ZVNpbmdsZShsZWZ0VmFsdWUsIHZhbHVlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIEJpbmFyeU9wZXJhdG9yXztcclxuICAgICAgICB9KShPcGVyYXRvcik7XHJcbiAgICAgICAgT3BlcmF0b3JzLkJpbmFyeU9wZXJhdG9yID0gQmluYXJ5T3BlcmF0b3I7XHJcblxyXG4gICAgICAgIE9wZXJhdG9ycy5hZGQgPSBuZXcgQmluYXJ5T3BlcmF0b3IoJysnLCBmYWxzZSk7XHJcbiAgICAgICAgT3BlcmF0b3JzLmFkZC5fZXZhbHVhdGVTaW5nbGUgPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgY29udGV4dCkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgICAgICAgICAgaWYgKENhbGMuQ29udmVydC5lcnIobGVmdCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChDYWxjLkNvbnZlcnQuZXJyKHJpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsZWZ0ID09PSBLRVlXT1JEX1VOREVGSU5FRCB8fCBsZWZ0ID09PSBLRVlXT1JEX05VTEwpIHtcclxuICAgICAgICAgICAgICAgIGxlZnQgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyaWdodCA9PT0gS0VZV09SRF9VTkRFRklORUQgfHwgcmlnaHQgPT09IEtFWVdPUkRfTlVMTCkge1xyXG4gICAgICAgICAgICAgICAgcmlnaHQgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBkb3VibGVMZWZ0ID0ge3ZhbHVlOiAwfTtcclxuICAgICAgICAgICAgaWYgKCFDYWxjLkNvbnZlcnQuckQobGVmdCwgZG91YmxlTGVmdCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDYWxjLkNhbGNFcnJvcnNWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZG91YmxlUmlnaHQgPSB7dmFsdWU6IDB9O1xyXG4gICAgICAgICAgICBpZiAoIUNhbGMuQ29udmVydC5yRChyaWdodCwgZG91YmxlUmlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2FsYy5DYWxjRXJyb3JzVmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRvdWJsZUxlZnQudmFsdWUgKyBkb3VibGVSaWdodC52YWx1ZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBPcGVyYXRvcnMuc3VidHJhY3QgPSBuZXcgQmluYXJ5T3BlcmF0b3IoJy0nLCBmYWxzZSk7XHJcbiAgICAgICAgT3BlcmF0b3JzLnN1YnRyYWN0Ll9ldmFsdWF0ZVNpbmdsZSA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBjb250ZXh0KSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgICAgICAgICBpZiAoQ2FsYy5Db252ZXJ0LmVycihsZWZ0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKENhbGMuQ29udmVydC5lcnIocmlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxlZnQgPT09IEtFWVdPUkRfVU5ERUZJTkVEIHx8IGxlZnQgPT09IEtFWVdPUkRfTlVMTCkge1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJpZ2h0ID09PSBLRVlXT1JEX1VOREVGSU5FRCB8fCByaWdodCA9PT0gS0VZV09SRF9OVUxMKSB7XHJcbiAgICAgICAgICAgICAgICByaWdodCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGRvdWJsZUxlZnQgPSB7dmFsdWU6IDB9O1xyXG4gICAgICAgICAgICBpZiAoIUNhbGMuQ29udmVydC5yRChsZWZ0LCBkb3VibGVMZWZ0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENhbGMuQ2FsY0Vycm9yc1ZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBkb3VibGVSaWdodCA9IHt2YWx1ZTogMH07XHJcbiAgICAgICAgICAgIGlmICghQ2FsYy5Db252ZXJ0LnJEKHJpZ2h0LCBkb3VibGVSaWdodCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDYWxjLkNhbGNFcnJvcnNWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZG91YmxlTGVmdC52YWx1ZSAtIGRvdWJsZVJpZ2h0LnZhbHVlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIE9wZXJhdG9ycy5tdWx0aXBseSA9IG5ldyBCaW5hcnlPcGVyYXRvcignKicsIGZhbHNlKTtcclxuICAgICAgICBPcGVyYXRvcnMubXVsdGlwbHkuX2V2YWx1YXRlU2luZ2xlID0gZnVuY3Rpb24obGVmdCwgcmlnaHQsIGNvbnRleHQpIHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICAgICAgICAgIGlmIChDYWxjLkNvbnZlcnQuZXJyKGxlZnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoQ2FsYy5Db252ZXJ0LmVycihyaWdodCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGVmdCA9PT0gS0VZV09SRF9VTkRFRklORUQgfHwgbGVmdCA9PT0gS0VZV09SRF9OVUxMKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmlnaHQgPT09IEtFWVdPUkRfVU5ERUZJTkVEIHx8IHJpZ2h0ID09PSBLRVlXT1JEX05VTEwpIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZG91YmxlTGVmdCA9IHt2YWx1ZTogMH07XHJcbiAgICAgICAgICAgIGlmICghQ2FsYy5Db252ZXJ0LnJEKGxlZnQsIGRvdWJsZUxlZnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2FsYy5DYWxjRXJyb3JzVmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGRvdWJsZVJpZ2h0ID0ge3ZhbHVlOiAwfTtcclxuICAgICAgICAgICAgaWYgKCFDYWxjLkNvbnZlcnQuckQocmlnaHQsIGRvdWJsZVJpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENhbGMuQ2FsY0Vycm9yc1ZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkb3VibGVMZWZ0LnZhbHVlICogZG91YmxlUmlnaHQudmFsdWU7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgT3BlcmF0b3JzLmRpdmlkZSA9IG5ldyBCaW5hcnlPcGVyYXRvcignLycsIGZhbHNlKTtcclxuICAgICAgICBPcGVyYXRvcnMuZGl2aWRlLl9ldmFsdWF0ZVNpbmdsZSA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBjb250ZXh0KSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgICAgICAgICBpZiAocmlnaHQgPT09IEtFWVdPUkRfVU5ERUZJTkVEIHx8IHJpZ2h0ID09PSBLRVlXT1JEX05VTEwgfHwgcmlnaHQgPT09ICcnIHx8IHJpZ2h0ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2FsYy5DYWxjRXJyb3JzRGl2aWRlQnlaZXJvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChDYWxjLkNvbnZlcnQuZXJyKGxlZnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoQ2FsYy5Db252ZXJ0LmVycihyaWdodCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGVmdCA9PT0gS0VZV09SRF9VTkRFRklORUQgfHwgbGVmdCA9PT0gS0VZV09SRF9OVUxMKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZG91YmxlTGVmdCA9IHt2YWx1ZTogMH07XHJcbiAgICAgICAgICAgIGlmICghQ2FsYy5Db252ZXJ0LnJEKGxlZnQsIGRvdWJsZUxlZnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2FsYy5DYWxjRXJyb3JzVmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGRvdWJsZVJpZ2h0ID0ge3ZhbHVlOiAwfTtcclxuICAgICAgICAgICAgaWYgKCFDYWxjLkNvbnZlcnQuckQocmlnaHQsIGRvdWJsZVJpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENhbGMuQ2FsY0Vycm9yc1ZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZG91YmxlUmlnaHQudmFsdWUgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDYWxjLkNhbGNFcnJvcnNEaXZpZGVCeVplcm87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRvdWJsZUxlZnQudmFsdWUgLyBkb3VibGVSaWdodC52YWx1ZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBPcGVyYXRvcnMuZXhwb25lbnQgPSBuZXcgQmluYXJ5T3BlcmF0b3IoJ14nLCBmYWxzZSk7XHJcbiAgICAgICAgT3BlcmF0b3JzLmV4cG9uZW50Ll9ldmFsdWF0ZVNpbmdsZSA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBjb250ZXh0KSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgICAgICAgICBpZiAoQ2FsYy5Db252ZXJ0LmVycihsZWZ0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKENhbGMuQ29udmVydC5lcnIocmlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxlZnQgPT09IEtFWVdPUkRfVU5ERUZJTkVEIHx8IGxlZnQgPT09IEtFWVdPUkRfTlVMTCkge1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJpZ2h0ID09PSBLRVlXT1JEX1VOREVGSU5FRCB8fCByaWdodCA9PT0gS0VZV09SRF9OVUxMKSB7XHJcbiAgICAgICAgICAgICAgICByaWdodCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGRvdWJsZUxlZnQgPSB7dmFsdWU6IDB9O1xyXG4gICAgICAgICAgICBpZiAoIUNhbGMuQ29udmVydC5yRChsZWZ0LCBkb3VibGVMZWZ0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENhbGMuQ2FsY0Vycm9yc1ZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxlZnQgPSBkb3VibGVMZWZ0LnZhbHVlO1xyXG4gICAgICAgICAgICB2YXIgZG91YmxlUmlnaHQgPSB7dmFsdWU6IDB9O1xyXG4gICAgICAgICAgICBpZiAoIUNhbGMuQ29udmVydC5yRChyaWdodCwgZG91YmxlUmlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2FsYy5DYWxjRXJyb3JzVmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmlnaHQgPSBkb3VibGVSaWdodC52YWx1ZTtcclxuICAgICAgICAgICAgaWYgKGxlZnQgPT09IDAuMCAmJiByaWdodCA8IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDYWxjLkNhbGNFcnJvcnNEaXZpZGVCeVplcm87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIE1BVEhfUE9XKGxlZnQsIHJpZ2h0KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBPcGVyYXRvcnMuY29uY2F0ZW5hdGUgPSBuZXcgQmluYXJ5T3BlcmF0b3IoJyYnLCBmYWxzZSk7XHJcbiAgICAgICAgT3BlcmF0b3JzLmNvbmNhdGVuYXRlLl9ldmFsdWF0ZVNpbmdsZSA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBjb250ZXh0KSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgICAgICAgICBpZiAoQ2FsYy5Db252ZXJ0LmVycihsZWZ0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKENhbGMuQ29udmVydC5lcnIocmlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxlZnQgPT09IEtFWVdPUkRfVU5ERUZJTkVEIHx8IGxlZnQgPT09IEtFWVdPUkRfTlVMTCkge1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9ICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyaWdodCA9PT0gS0VZV09SRF9VTkRFRklORUQgfHwgcmlnaHQgPT09IEtFWVdPUkRfTlVMTCkge1xyXG4gICAgICAgICAgICAgICAgcmlnaHQgPSAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbGVmdC50b1N0cmluZygpICsgcmlnaHQudG9TdHJpbmcoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBPcGVyYXRvcnMuYW5kID0gbmV3IEJpbmFyeU9wZXJhdG9yKCcmJicsIGZhbHNlKTtcclxuICAgICAgICBPcGVyYXRvcnMuYW5kLl9ldmFsdWF0ZVNpbmdsZSA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBjb250ZXh0KSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgICAgICAgICBpZiAoQ2FsYy5Db252ZXJ0LmVycihsZWZ0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKENhbGMuQ29udmVydC5lcnIocmlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICghIWxlZnQpICYmICghIXJpZ2h0KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBPcGVyYXRvcnMub3IgPSBuZXcgQmluYXJ5T3BlcmF0b3IoJ3x8JywgZmFsc2UpO1xyXG4gICAgICAgIE9wZXJhdG9ycy5vci5fZXZhbHVhdGVTaW5nbGUgPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgY29udGV4dCkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgICAgICAgICAgaWYgKENhbGMuQ29udmVydC5lcnIobGVmdCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChDYWxjLkNvbnZlcnQuZXJyKHJpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAoISFsZWZ0KSB8fCAoISFyaWdodCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgT3BlcmF0b3JzLmVxdWFsID0gbmV3IEJpbmFyeU9wZXJhdG9yKCc9JywgZmFsc2UpO1xyXG4gICAgICAgIE9wZXJhdG9ycy5lcXVhbC5fZXZhbHVhdGVTaW5nbGUgPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgY29udGV4dCkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgICAgICAgICAgaWYgKENhbGMuQ29udmVydC5lcnIobGVmdCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChDYWxjLkNvbnZlcnQuZXJyKHJpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsZWZ0ID09PSBLRVlXT1JEX1VOREVGSU5FRCB8fCBsZWZ0ID09PSBLRVlXT1JEX05VTEwpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmlnaHQgPT09IENPTlNUX1NUUklORykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSAnJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJpZ2h0ID09PSBLRVlXT1JEX1VOREVGSU5FRCB8fCByaWdodCA9PT0gS0VZV09SRF9OVUxMKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxlZnQgPT09IENPTlNUX1NUUklORykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gJyc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxlZnQgPT09IENPTlNUX1NUUklORyB8fCB0eXBlb2YgcmlnaHQgPT09IENPTlNUX1NUUklORykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQudG9TdHJpbmcoKS50b1VwcGVyQ2FzZSgpID09PSByaWdodC50b1N0cmluZygpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZG91YmxlTGVmdCA9IHt2YWx1ZTogMH07XHJcbiAgICAgICAgICAgICAgICBpZiAoIUNhbGMuQ29udmVydC5yRChsZWZ0LCBkb3VibGVMZWZ0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDYWxjLkNhbGNFcnJvcnNWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxlZnQgPSBkb3VibGVMZWZ0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRvdWJsZVJpZ2h0ID0ge3ZhbHVlOiAwfTtcclxuICAgICAgICAgICAgICAgIGlmICghQ2FsYy5Db252ZXJ0LnJEKHJpZ2h0LCBkb3VibGVSaWdodCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ2FsYy5DYWxjRXJyb3JzVmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByaWdodCA9IGRvdWJsZVJpZ2h0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSByaWdodDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfYXBwcm94RXF1YWwoeCwgeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBPcGVyYXRvcnMubm90RXF1YWwgPSBuZXcgQmluYXJ5T3BlcmF0b3IoJzw+JywgZmFsc2UpO1xyXG4gICAgICAgIE9wZXJhdG9ycy5ub3RFcXVhbC5fZXZhbHVhdGVTaW5nbGUgPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBPcGVyYXRvcnMuZXF1YWwuX2V2YWx1YXRlU2luZ2xlLmNhbGwodGhpcywgbGVmdCwgcmlnaHQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBDT05TVF9CT09MRUFOKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gIXZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBPcGVyYXRvcnMubGVzc1RoYW4gPSBuZXcgQmluYXJ5T3BlcmF0b3IoJzwnLCBmYWxzZSk7XHJcbiAgICAgICAgT3BlcmF0b3JzLmxlc3NUaGFuLl9ldmFsdWF0ZVNpbmdsZSA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBjb250ZXh0KSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgICAgICAgICBpZiAoQ2FsYy5Db252ZXJ0LmVycihsZWZ0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKENhbGMuQ29udmVydC5lcnIocmlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxlZnQgPT09IEtFWVdPUkRfVU5ERUZJTkVEIHx8IGxlZnQgPT09IEtFWVdPUkRfTlVMTCkge1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJpZ2h0ID09PSBLRVlXT1JEX1VOREVGSU5FRCB8fCByaWdodCA9PT0gS0VZV09SRF9OVUxMKSB7XHJcbiAgICAgICAgICAgICAgICByaWdodCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsZWZ0ID09PSBDT05TVF9TVFJJTkcgfHwgdHlwZW9mIHJpZ2h0ID09PSBDT05TVF9TVFJJTkcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0LnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKSA8IHJpZ2h0LnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBkb3VibGVMZWZ0ID0ge3ZhbHVlOiAwfTtcclxuICAgICAgICAgICAgICAgIGlmICghQ2FsYy5Db252ZXJ0LnJEKGxlZnQsIGRvdWJsZUxlZnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENhbGMuQ2FsY0Vycm9yc1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGVmdCA9IGRvdWJsZUxlZnQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgZG91YmxlUmlnaHQgPSB7dmFsdWU6IDB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFDYWxjLkNvbnZlcnQuckQocmlnaHQsIGRvdWJsZVJpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDYWxjLkNhbGNFcnJvcnNWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gZG91YmxlUmlnaHQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGxlZnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHggPCB5ICYmICFfYXBwcm94RXF1YWwoeCwgeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBPcGVyYXRvcnMuZ3JlYXRlclRoYW4gPSBuZXcgQmluYXJ5T3BlcmF0b3IoJz4nLCBmYWxzZSk7XHJcbiAgICAgICAgT3BlcmF0b3JzLmdyZWF0ZXJUaGFuLl9ldmFsdWF0ZVNpbmdsZSA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBjb250ZXh0KSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgICAgICAgICBpZiAoQ2FsYy5Db252ZXJ0LmVycihsZWZ0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKENhbGMuQ29udmVydC5lcnIocmlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxlZnQgPT09IEtFWVdPUkRfVU5ERUZJTkVEIHx8IGxlZnQgPT09IEtFWVdPUkRfTlVMTCkge1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJpZ2h0ID09PSBLRVlXT1JEX1VOREVGSU5FRCB8fCByaWdodCA9PT0gS0VZV09SRF9OVUxMKSB7XHJcbiAgICAgICAgICAgICAgICByaWdodCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsZWZ0ID09PSBDT05TVF9TVFJJTkcgfHwgdHlwZW9mIHJpZ2h0ID09PSBDT05TVF9TVFJJTkcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0LnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKSA+IHJpZ2h0LnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBkb3VibGVMZWZ0ID0ge3ZhbHVlOiAwfTtcclxuICAgICAgICAgICAgICAgIGlmICghQ2FsYy5Db252ZXJ0LnJEKGxlZnQsIGRvdWJsZUxlZnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENhbGMuQ2FsY0Vycm9yc1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGVmdCA9IGRvdWJsZUxlZnQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgZG91YmxlUmlnaHQgPSB7dmFsdWU6IDB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFDYWxjLkNvbnZlcnQuckQocmlnaHQsIGRvdWJsZVJpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDYWxjLkNhbGNFcnJvcnNWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gZG91YmxlUmlnaHQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGxlZnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHggPiB5ICYmICFfYXBwcm94RXF1YWwoeCwgeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBPcGVyYXRvcnMubGVzc1RoYW5PckVxdWFsID0gbmV3IEJpbmFyeU9wZXJhdG9yKCc8PScsIGZhbHNlKTtcclxuICAgICAgICBPcGVyYXRvcnMubGVzc1RoYW5PckVxdWFsLl9ldmFsdWF0ZVNpbmdsZSA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBjb250ZXh0KSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgICAgICAgICBpZiAoQ2FsYy5Db252ZXJ0LmVycihsZWZ0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKENhbGMuQ29udmVydC5lcnIocmlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxlZnQgPT09IEtFWVdPUkRfVU5ERUZJTkVEIHx8IGxlZnQgPT09IEtFWVdPUkRfTlVMTCkge1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJpZ2h0ID09PSBLRVlXT1JEX1VOREVGSU5FRCB8fCByaWdodCA9PT0gS0VZV09SRF9OVUxMKSB7XHJcbiAgICAgICAgICAgICAgICByaWdodCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsZWZ0ID09PSBDT05TVF9TVFJJTkcgfHwgdHlwZW9mIHJpZ2h0ID09PSBDT05TVF9TVFJJTkcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0LnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKSA8PSByaWdodC50b1N0cmluZygpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZG91YmxlTGVmdCA9IHt2YWx1ZTogMH07XHJcbiAgICAgICAgICAgICAgICBpZiAoIUNhbGMuQ29udmVydC5yRChsZWZ0LCBkb3VibGVMZWZ0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDYWxjLkNhbGNFcnJvcnNWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxlZnQgPSBkb3VibGVMZWZ0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRvdWJsZVJpZ2h0ID0ge3ZhbHVlOiAwfTtcclxuICAgICAgICAgICAgICAgIGlmICghQ2FsYy5Db252ZXJ0LnJEKHJpZ2h0LCBkb3VibGVSaWdodCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ2FsYy5DYWxjRXJyb3JzVmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByaWdodCA9IGRvdWJsZVJpZ2h0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSByaWdodDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB4IDwgeSB8fCBfYXBwcm94RXF1YWwoeCwgeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBPcGVyYXRvcnMuZ3JlYXRlclRoYW5PckVxdWFsID0gbmV3IEJpbmFyeU9wZXJhdG9yKCc+PScsIGZhbHNlKTtcclxuICAgICAgICBPcGVyYXRvcnMuZ3JlYXRlclRoYW5PckVxdWFsLl9ldmFsdWF0ZVNpbmdsZSA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBjb250ZXh0KSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgICAgICAgICBpZiAoQ2FsYy5Db252ZXJ0LmVycihsZWZ0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKENhbGMuQ29udmVydC5lcnIocmlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxlZnQgPT09IEtFWVdPUkRfVU5ERUZJTkVEIHx8IGxlZnQgPT09IEtFWVdPUkRfTlVMTCkge1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJpZ2h0ID09PSBLRVlXT1JEX1VOREVGSU5FRCB8fCByaWdodCA9PT0gS0VZV09SRF9OVUxMKSB7XHJcbiAgICAgICAgICAgICAgICByaWdodCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsZWZ0ID09PSBDT05TVF9TVFJJTkcgfHwgdHlwZW9mIHJpZ2h0ID09PSBDT05TVF9TVFJJTkcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0LnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKSA+PSByaWdodC50b1N0cmluZygpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZG91YmxlTGVmdCA9IHt2YWx1ZTogMH07XHJcbiAgICAgICAgICAgICAgICBpZiAoIUNhbGMuQ29udmVydC5yRChsZWZ0LCBkb3VibGVMZWZ0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDYWxjLkNhbGNFcnJvcnNWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxlZnQgPSBkb3VibGVMZWZ0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRvdWJsZVJpZ2h0ID0ge3ZhbHVlOiAwfTtcclxuICAgICAgICAgICAgICAgIGlmICghQ2FsYy5Db252ZXJ0LnJEKHJpZ2h0LCBkb3VibGVSaWdodCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ2FsYy5DYWxjRXJyb3JzVmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByaWdodCA9IGRvdWJsZVJpZ2h0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSByaWdodDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB4ID4geSB8fCBfYXBwcm94RXF1YWwoeCwgeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0pKENhbGNQYXJzZXIuT3BlcmF0b3JzIHx8IChDYWxjUGFyc2VyLk9wZXJhdG9ycyA9IHt9KSk7XHJcblxyXG59KSgpO1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXBwL3NjcmlwdHMvZ3JpZC9jYWxjL3BhcnNlci5qc1xuICoqIG1vZHVsZSBpZCA9IDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICpcbiAqIFNwcmVhZEpTIExpYnJhcnkgMS4wLjBcbiAqIGh0dHA6Ly93aWptby5jb20vXG4gKlxuICogQ29weXJpZ2h0KGMpIEdyYXBlQ2l0eSwgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgV2lqbW8gQ29tbWVyY2lhbCBMaWNlbnNlLiBBbHNvIGF2YWlsYWJsZSB1bmRlciB0aGUgR05VIEdQTCBWZXJzaW9uIDMgbGljZW5zZS5cbiAqIGxpY2Vuc2luZ0B3aWptby5jb21cbiAqIGh0dHA6Ly93aWptby5jb20vd2lkZ2V0cy9saWNlbnNlL1xuICpcbiAqXG4gKiovXG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIENhbGMgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG4gICAgdmFyIENhbGNFeHByZXNzaW9ucyA9IHt9O1xuICAgIG1vZHVsZS5leHBvcnRzID0gQ2FsY0V4cHJlc3Npb25zO1xuXG4gICAgdmFyIENPTlNUX1VOREVGSU5FRCA9ICd1bmRlZmluZWQnOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICB2YXIgQ09OU1RfTlVNQkVSID0gJ251bWJlcic7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIHZhciBDT05TVF9TVFJJTkcgPSAnc3RyaW5nJztcbiAgICB2YXIgQ09OU1RfQk9PTEVBTiA9ICdib29sZWFuJzsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgdmFyIENPTlNUX1RSVUUgPSAnVFJVRSc7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIHZhciBDT05TVF9GQUxTRSA9ICdGQUxTRSc7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIHZhciBDT05TVF9BUlJBWSA9ICdBUlJBWSc7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIHZhciBDT05TVF9BUlJBWVJPVyA9ICdBUlJBWVJPVyc7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIHZhciBDT05TVF9OVUxMID0gJyNOVUxMISc7XG4gICAgdmFyIENPTlNUX0RJVjAgPSAnI0RJVi8wISc7XG4gICAgdmFyIENPTlNUX1ZBTFVFID0gJyNWQUxVRSEnO1xuICAgIHZhciBDT05TVF9SRUYgPSAnI1JFRiEnO1xuICAgIHZhciBDT05TVF9OQU1FID0gJyNOQU1FPyc7XG4gICAgdmFyIENPTlNUX05BID0gJyNOL0EnO1xuICAgIHZhciBDT05TVF9OVU0gPSAnI05VTSEnO1xuICAgIHZhciBDT05TVF9FWFBSID0gJ2V4cHInOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICB2YXIgQ09OU1RfQVJSQVlJTkZPID0gJ2FycmF5SW5mbyc7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIHZhciBDT05TVF9XT1JLSU5HRVhQUiA9ICd3b3JraW5nRXhwcic7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIHZhciBFUlJPUl9MSVNUID0gW0NPTlNUX05VTEwsIENPTlNUX0RJVjAsIENPTlNUX1ZBTFVFLCBDT05TVF9SRUYsIENPTlNUX05BTUUsIENPTlNUX05BLCBDT05TVF9OVU1dOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICB2YXIgRVJST1JDT0RFX0xJU1QgPSBbMHgwMCwgMHgwNywgMHgwRiwgMHgxNywgMHgxRCwgMHgyQSwgMHgyNF07IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIHZhciBMRVRURVJfUE9XUyA9IFsxLCAyNiwgNjc2XTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgdmFyIEtFWVdPUkRfTlVMTCA9IG51bGw7XG4gICAgdmFyIEtFWVdPUkRfVU5ERUZJTkVEID0gdW5kZWZpbmVkOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICB2YXIgU1VQUE9SVF9ST1dfQ09MVU1OX0ZPUk1VTEEgPSBmYWxzZTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgdmFyIE1BVEhfTUlOID0gTWF0aC5taW47IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIHZhciBNQVRIX01BWCA9IE1hdGgubWF4OyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICB2YXIgTUFUSF9BQlMgPSBNYXRoLmFiczsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgdmFyIE1BVEhfUE9XID0gTWF0aC5wb3c7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgKGZ1bmN0aW9uKEV4cHJlc3Npb25UeXBlKSB7XG4gICAgICAgIEV4cHJlc3Npb25UeXBlW0V4cHJlc3Npb25UeXBlLkRvdWJsZSA9IDBdID0gJ0RvdWJsZSc7XG4gICAgICAgIEV4cHJlc3Npb25UeXBlW0V4cHJlc3Npb25UeXBlLlN0cmluZyA9IDFdID0gJ1N0cmluZyc7XG4gICAgICAgIEV4cHJlc3Npb25UeXBlW0V4cHJlc3Npb25UeXBlLkJvb2xlYW4gPSAyXSA9ICdCb29sZWFuJztcbiAgICAgICAgRXhwcmVzc2lvblR5cGVbRXhwcmVzc2lvblR5cGUuRnVuY3Rpb24gPSAzXSA9ICdGdW5jdGlvbic7XG4gICAgICAgIEV4cHJlc3Npb25UeXBlW0V4cHJlc3Npb25UeXBlLkJpbmFyeU9wZXJhdG9yID0gNF0gPSAnQmluYXJ5T3BlcmF0b3InO1xuICAgICAgICBFeHByZXNzaW9uVHlwZVtFeHByZXNzaW9uVHlwZS5VbmFyeU9wZXJhdG9yID0gNV0gPSAnVW5hcnlPcGVyYXRvcic7XG4gICAgICAgIEV4cHJlc3Npb25UeXBlW0V4cHJlc3Npb25UeXBlLkVycm9yID0gNl0gPSAnRXJyb3InO1xuICAgICAgICBFeHByZXNzaW9uVHlwZVtFeHByZXNzaW9uVHlwZS5FeHRlcm5hbEVycm9yID0gN10gPSAnRXh0ZXJuYWxFcnJvcic7XG4gICAgICAgIEV4cHJlc3Npb25UeXBlW0V4cHJlc3Npb25UeXBlLlBhcmVudGhlc2VzID0gOF0gPSAnUGFyZW50aGVzZXMnO1xuICAgICAgICBFeHByZXNzaW9uVHlwZVtFeHByZXNzaW9uVHlwZS5BcnJheSA9IDldID0gJ0FycmF5JztcbiAgICAgICAgRXhwcmVzc2lvblR5cGVbRXhwcmVzc2lvblR5cGUuU3RydWN0UmVmZXJlbmNlID0gMTBdID0gJ1N0cnVjdFJlZmVyZW5jZSc7XG4gICAgICAgIEV4cHJlc3Npb25UeXBlW0V4cHJlc3Npb25UeXBlLlNoZWV0UmFuZ2VFcnJvciA9IDExXSA9ICdTaGVldFJhbmdlRXJyb3InO1xuICAgICAgICBFeHByZXNzaW9uVHlwZVtFeHByZXNzaW9uVHlwZS5NaXNzaW5nQXJndW1lbnQgPSAxMl0gPSAnTWlzc2luZ0FyZ3VtZW50JztcbiAgICB9KShDYWxjRXhwcmVzc2lvbnMuRXhwcmVzc2lvblR5cGUgfHwgKENhbGNFeHByZXNzaW9ucy5FeHByZXNzaW9uVHlwZSA9IHt9KSk7XG4gICAgdmFyIEV4cHJlc3Npb25UeXBlID0gQ2FsY0V4cHJlc3Npb25zLkV4cHJlc3Npb25UeXBlOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuICAgIChmdW5jdGlvbihFeHByZXNzaW9ucykge1xuICAgICAgICB2YXIgRXhwcmVzc2lvbiA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUHJvdmlkZXMgdGhlIGJhc2UgY2xhc3MgZnJvbSB3aGljaCB0aGUgY2xhc3NlcyB0aGF0IHJlcHJlc2VudCBleHByZXNzaW9uIHRyZWUgbm9kZXMgYXJlIGRlcml2ZWQuIFRoaXMgaXMgYW4gYWJzdHJhY3QgY2xhc3MuXG4gICAgICAgICAgICAgKiBAY2xhc3NcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gRXhwcmVzc2lvbigpIHtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIEV4cHJlc3Npb247XG4gICAgICAgIH0pKCk7XG4gICAgICAgIEV4cHJlc3Npb25zLkV4cHJlc3Npb24gPSBFeHByZXNzaW9uO1xuXG4gICAgICAgIHZhciBQYXJlbnRoZXNlc0V4cHJlc3Npb24gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlcHJlc2VudHMgYW4gZXhwcmVzc2lvbiB0eXBlIGZvciBwYXJlbnRoZXNlcyBzdXJyb3VuZGluZyBhIHNwZWNpZmllZCBleHByZXNzaW9uLlxuICAgICAgICAgICAgICogQGV4dGVuZHMgJC53aWptby53aWpzcHJlYWQuQ2FsYy5FeHByZXNzaW9ucy5FeHByZXNzaW9uXG4gICAgICAgICAgICAgKiBAY2xhc3NcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhcmcgVGhlIGV4cHJlc3Npb24gaW5zaWRlIHRoZSBwYXJlbnRoZXNlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gUGFyZW50aGVzZXNFeHByZXNzaW9uXyhhcmcpIHtcbiAgICAgICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJnO1xuICAgICAgICAgICAgICAgIHRoaXMudCA9IDggLyogUGFyZW50aGVzZXMgKi87XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIENhbGMuX19leHRlbmRzKFBhcmVudGhlc2VzRXhwcmVzc2lvbl8sIF9zdXBlcik7XG4gICAgICAgICAgICByZXR1cm4gUGFyZW50aGVzZXNFeHByZXNzaW9uXztcbiAgICAgICAgfSkoRXhwcmVzc2lvbik7XG4gICAgICAgIEV4cHJlc3Npb25zLlBhcmVudGhlc2VzRXhwcmVzc2lvbiA9IFBhcmVudGhlc2VzRXhwcmVzc2lvbjtcblxuICAgICAgICB2YXIgRnVuY3Rpb25FeHByZXNzaW9uID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXByZXNlbnRzIGFuIGV4cHJlc3Npb24gd2l0aCBhIGZ1bmN0aW9uIGFwcGxpZWQgdG8gYSBsaXN0IG9mIHBhcmFtZXRlcnMgYXMgdGhlIGV4cHJlc3Npb24uXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyAkLndpam1vLndpanNwcmVhZC5DYWxjLkV4cHJlc3Npb25zLkV4cHJlc3Npb25cbiAgICAgICAgICAgICAqIEBjbGFzc1xuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGZuIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0W119IGFyZ3MgVGhlIGxpc3Qgb2YgcGFyYW1ldGVycy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gRnVuY3Rpb25FeHByZXNzaW9uXyhmbiwgYXJncykge1xuICAgICAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm4gPSBmbjtcbiAgICAgICAgICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICAgICAgICAgIHRoaXMudCA9IDMgLyogRnVuY3Rpb24gKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBDYWxjLl9fZXh0ZW5kcyhGdW5jdGlvbkV4cHJlc3Npb25fLCBfc3VwZXIpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgdGhlIG51bWJlciBvZiBwYXJhbWV0ZXJzIGJlaW5nIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEZ1bmN0aW9uRXhwcmVzc2lvbl8ucHJvdG90eXBlLmFyZ0NvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXJncyA/IHRoaXMuYXJncy5sZW5ndGggOiAwO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVyIGJlaW5nIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBwYXJhbWV0ZXIgKG9yIGFyZ3VtZW50KS5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBzcGVjaWZpZWQgcGFyYW1ldGVyLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBGdW5jdGlvbkV4cHJlc3Npb25fLnByb3RvdHlwZS5nZXRBcmcgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFyZ3MgPyB0aGlzLmFyZ3NbaW5kZXhdIDogS0VZV09SRF9OVUxMO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgRnVuY3Rpb25FeHByZXNzaW9uXy5wcm90b3R5cGUuZ2V0RnVuY3Rpb25OYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgKHNlbGYuZm4pID09PSBDT05TVF9TVFJJTkcgPyBzZWxmLmZuIDogc2VsZi5mbi5uYW1lO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRXhwcmVzc2lvbl87XG4gICAgICAgIH0pKEV4cHJlc3Npb24pO1xuICAgICAgICBFeHByZXNzaW9ucy5GdW5jdGlvbkV4cHJlc3Npb24gPSBGdW5jdGlvbkV4cHJlc3Npb247XG5cbiAgICAgICAgdmFyIENvbnN0YW50RXhwcmVzc2lvbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVwcmVzZW50cyBhbiBleHByZXNzaW9uIHRoYXQgaGFzIGEgY29uc3RhbnQgdmFsdWUuXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyAkLndpam1vLndpanNwcmVhZC5DYWxjLkV4cHJlc3Npb25zLkV4cHJlc3Npb25cbiAgICAgICAgICAgICAqIEBjbGFzc1xuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHZhbHVlIFRoZSBjb25zdGFudCB2YWx1ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gQ29uc3RhbnRFeHByZXNzaW9uXyh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIENhbGMuX19leHRlbmRzKENvbnN0YW50RXhwcmVzc2lvbl8sIF9zdXBlcik7XG5cbiAgICAgICAgICAgIHJldHVybiBDb25zdGFudEV4cHJlc3Npb25fO1xuICAgICAgICB9KShFeHByZXNzaW9uKTtcbiAgICAgICAgRXhwcmVzc2lvbnMuQ29uc3RhbnRFeHByZXNzaW9uID0gQ29uc3RhbnRFeHByZXNzaW9uO1xuXG4gICAgICAgIHZhciBCb29sZWFuRXhwcmVzc2lvbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVwcmVzZW50cyBhIGJvb2xlYW4gY29uc3RhbnQgdmFsdWUuXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyAkLndpam1vLndpanNwcmVhZC5DYWxjLkV4cHJlc3Npb25zLkNvbnN0YW50RXhwcmVzc2lvblxuICAgICAgICAgICAgICogQGNsYXNzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJvb2xWYWx1ZSBUaGUgYm9vbGVhbiB2YWx1ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gQm9vbGVhbkV4cHJlc3Npb25fKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMudCA9IDIgLyogQm9vbGVhbiAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIENhbGMuX19leHRlbmRzKEJvb2xlYW5FeHByZXNzaW9uXywgX3N1cGVyKTtcblxuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW5FeHByZXNzaW9uXztcbiAgICAgICAgfSkoQ29uc3RhbnRFeHByZXNzaW9uKTtcbiAgICAgICAgRXhwcmVzc2lvbnMuQm9vbGVhbkV4cHJlc3Npb24gPSBCb29sZWFuRXhwcmVzc2lvbjtcblxuICAgICAgICB2YXIgRG91YmxlRXhwcmVzc2lvbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVwcmVzZW50cyBhIGRvdWJsZSBjb25zdGFudCB2YWx1ZS5cbiAgICAgICAgICAgICAqIEBleHRlbmRzICQud2lqbW8ud2lqc3ByZWFkLkNhbGMuRXhwcmVzc2lvbnMuQ29uc3RhbnRFeHByZXNzaW9uXG4gICAgICAgICAgICAgKiBAY2xhc3NcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgZG91YmxlIHZhbHVlLlxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbmFsTnVtQXNTdHJpbmcgVGhlIG9yaWdpbmFsIHN0cmluZyBvZiB0aGUgbnVtYmVyLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBEb3VibGVFeHByZXNzaW9uXyh2YWx1ZSwgb3JpZ2luYWxOdW1Bc1N0cmluZykge1xuICAgICAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9yaWdpbmFsVmFsdWUgPSBvcmlnaW5hbE51bUFzU3RyaW5nO1xuICAgICAgICAgICAgICAgIHRoaXMudCA9IDAgLyogRG91YmxlICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQ2FsYy5fX2V4dGVuZHMoRG91YmxlRXhwcmVzc2lvbl8sIF9zdXBlcik7XG5cbiAgICAgICAgICAgIHJldHVybiBEb3VibGVFeHByZXNzaW9uXztcbiAgICAgICAgfSkoQ29uc3RhbnRFeHByZXNzaW9uKTtcbiAgICAgICAgRXhwcmVzc2lvbnMuRG91YmxlRXhwcmVzc2lvbiA9IERvdWJsZUV4cHJlc3Npb247XG5cbiAgICAgICAgdmFyIFN0cmluZ0V4cHJlc3Npb24gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlcHJlc2VudHMgYSBzdHJpbmcgY29uc3RhbnQgdmFsdWUuXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyAkLndpam1vLndpanNwcmVhZC5DYWxjLkV4cHJlc3Npb25zLkNvbnN0YW50RXhwcmVzc2lvblxuICAgICAgICAgICAgICogQGNsYXNzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHN0cmluZyB2YWx1ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gU3RyaW5nRXhwcmVzc2lvbl8odmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy50ID0gMSAvKiBTdHJpbmcgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBDYWxjLl9fZXh0ZW5kcyhTdHJpbmdFeHByZXNzaW9uXywgX3N1cGVyKTtcblxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZ0V4cHJlc3Npb25fO1xuICAgICAgICB9KShDb25zdGFudEV4cHJlc3Npb24pO1xuICAgICAgICBFeHByZXNzaW9ucy5TdHJpbmdFeHByZXNzaW9uID0gU3RyaW5nRXhwcmVzc2lvbjtcblxuICAgICAgICB2YXIgRXJyb3JFeHByZXNzaW9uID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXByZXNlbnRzIGFuIGVycm9yIGNvbnN0YW50IHZhbHVlLlxuICAgICAgICAgICAgICogQGV4dGVuZHMgJC53aWptby53aWpzcHJlYWQuQ2FsYy5FeHByZXNzaW9ucy5Db25zdGFudEV4cHJlc3Npb25cbiAgICAgICAgICAgICAqIEBjbGFzc1xuICAgICAgICAgICAgICogQHBhcmFtIHskLndpam1vLndpanNwcmVhZC5DYWxjLkVycm9yfSB2YWx1ZSBUaGUgZXJyb3IgdmFsdWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIEVycm9yRXhwcmVzc2lvbl8odmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy50ID0gNiAvKiBFcnJvciAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIENhbGMuX19leHRlbmRzKEVycm9yRXhwcmVzc2lvbl8sIF9zdXBlcik7XG5cbiAgICAgICAgICAgIHJldHVybiBFcnJvckV4cHJlc3Npb25fO1xuICAgICAgICB9KShDb25zdGFudEV4cHJlc3Npb24pO1xuICAgICAgICBFeHByZXNzaW9ucy5FcnJvckV4cHJlc3Npb24gPSBFcnJvckV4cHJlc3Npb247XG5cbiAgICAgICAgdmFyIEV4dGVybmFsRXJyb3JFeHByZXNzaW9uID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXByZXNlbnRzIGFuIGV4dGVybmFsIGVycm9yIHZhbHVlLlxuICAgICAgICAgICAgICogQGV4dGVuZHMgJC53aWptby53aWpzcHJlYWQuQ2FsYy5FeHByZXNzaW9ucy5FcnJvckV4cHJlc3Npb25cbiAgICAgICAgICAgICAqIEBjbGFzc1xuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHNvdXJjZSBUaGUgb3duZXIgb2YgdGhlIGVycm9yLlxuICAgICAgICAgICAgICogQHBhcmFtIHskLndpam1vLndpanNwcmVhZC5DYWxjLkVycm9yfSB2YWx1ZSBUaGUgZXJyb3IgdmFsdWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIEV4dGVybmFsRXJyb3JFeHByZXNzaW9uXyhzb3VyY2UsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgICAgIHRoaXMudCA9IDcgLyogRXh0ZXJuYWxFcnJvciAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIENhbGMuX19leHRlbmRzKEV4dGVybmFsRXJyb3JFeHByZXNzaW9uXywgX3N1cGVyKTtcblxuICAgICAgICAgICAgcmV0dXJuIEV4dGVybmFsRXJyb3JFeHByZXNzaW9uXztcbiAgICAgICAgfSkoRXJyb3JFeHByZXNzaW9uKTtcbiAgICAgICAgRXhwcmVzc2lvbnMuRXh0ZXJuYWxFcnJvckV4cHJlc3Npb24gPSBFeHRlcm5hbEVycm9yRXhwcmVzc2lvbjtcblxuICAgICAgICB2YXIgTWlzc2luZ0FyZ3VtZW50RXhwcmVzc2lvbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVwcmVzZW50cyBhIG1pc3NpbmcgYXJndW1lbnQgY29uc3RhbnQgdmFsdWUuXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyAkLndpam1vLndpanNwcmVhZC5DYWxjLkV4cHJlc3Npb25zLkNvbnN0YW50RXhwcmVzc2lvblxuICAgICAgICAgICAgICogQGNsYXNzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIE1pc3NpbmdBcmd1bWVudEV4cHJlc3Npb25fKCkge1xuICAgICAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIENhbGMubWlzc2luZ0FyZ3VtZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLnQgPSAxMiAvKiBNaXNzaW5nQXJndW1lbnQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBDYWxjLl9fZXh0ZW5kcyhNaXNzaW5nQXJndW1lbnRFeHByZXNzaW9uXywgX3N1cGVyKTtcblxuICAgICAgICAgICAgcmV0dXJuIE1pc3NpbmdBcmd1bWVudEV4cHJlc3Npb25fO1xuICAgICAgICB9KShDb25zdGFudEV4cHJlc3Npb24pO1xuICAgICAgICBFeHByZXNzaW9ucy5NaXNzaW5nQXJndW1lbnRFeHByZXNzaW9uID0gTWlzc2luZ0FyZ3VtZW50RXhwcmVzc2lvbjtcblxuICAgICAgICB2YXIgT3BlcmF0b3JFeHByZXNzaW9uID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXByZXNlbnRzIGFuIG9wZXJhdG9yIGV4cHJlc3Npb24uIFRoaXMgaXMgYW4gYWJzdHJhY3QgY2xhc3MuXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyAkLndpam1vLndpanNwcmVhZC5DYWxjLkV4cHJlc3Npb25zLkV4cHJlc3Npb25cbiAgICAgICAgICAgICAqIEBjbGFzc1xuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wZXJhdG9yIFRoZSBvcGVyYXRvci5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gT3BlcmF0b3JFeHByZXNzaW9uXyhvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIENhbGMuX19leHRlbmRzKE9wZXJhdG9yRXhwcmVzc2lvbl8sIF9zdXBlcik7XG5cbiAgICAgICAgICAgIHJldHVybiBPcGVyYXRvckV4cHJlc3Npb25fO1xuICAgICAgICB9KShFeHByZXNzaW9uKTtcbiAgICAgICAgRXhwcmVzc2lvbnMuT3BlcmF0b3JFeHByZXNzaW9uID0gT3BlcmF0b3JFeHByZXNzaW9uO1xuXG4gICAgICAgIHZhciBVbmFyeU9wZXJhdG9yRXhwcmVzc2lvbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVwcmVzZW50cyBhbiBleHByZXNzaW9uIHRoYXQgaGFzIGEgdW5hcnkgb3BlcmF0b3IuXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyAkLndpam1vLndpanNwcmVhZC5DYWxjLkV4cHJlc3Npb25zLk9wZXJhdG9yRXhwcmVzc2lvblxuICAgICAgICAgICAgICogQGNsYXNzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3BlcmF0b3IgVGhlIHVuYXJ5IG9wZXJhdG9yLlxuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wZXJhbmQgVGhlIG9wZXJhbmQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIFVuYXJ5T3BlcmF0b3JFeHByZXNzaW9uXyhvcGVyYXRvciwgb3BlcmFuZCkge1xuICAgICAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG9wZXJhdG9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZXJhbmQgPSBvcGVyYW5kO1xuICAgICAgICAgICAgICAgIHRoaXMudCA9IDUgLyogVW5hcnlPcGVyYXRvciAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIENhbGMuX19leHRlbmRzKFVuYXJ5T3BlcmF0b3JFeHByZXNzaW9uXywgX3N1cGVyKTtcblxuICAgICAgICAgICAgcmV0dXJuIFVuYXJ5T3BlcmF0b3JFeHByZXNzaW9uXztcbiAgICAgICAgfSkoT3BlcmF0b3JFeHByZXNzaW9uKTtcbiAgICAgICAgRXhwcmVzc2lvbnMuVW5hcnlPcGVyYXRvckV4cHJlc3Npb24gPSBVbmFyeU9wZXJhdG9yRXhwcmVzc2lvbjtcblxuICAgICAgICB2YXIgQmluYXJ5T3BlcmF0b3JFeHByZXNzaW9uID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXByZXNlbnRzIGFuIGV4cHJlc3Npb24gdGhhdCBoYXMgYSBiaW5hcnkgb3BlcmF0b3IuXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyAkLndpam1vLndpanNwcmVhZC5DYWxjLkV4cHJlc3Npb25zLk9wZXJhdG9yRXhwcmVzc2lvblxuICAgICAgICAgICAgICogQGNsYXNzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3BlcmF0b3IgVGhlIGJpbmFyeSBvcGVyYXRvci5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBsZWZ0IFRoZSBsZWZ0IG9wZXJhbmQuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gcmlnaHQgVGhlIHJpZ2h0IG9wZXJhbmQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIEJpbmFyeU9wZXJhdG9yRXhwcmVzc2lvbl8ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgb3BlcmF0b3IpO1xuICAgICAgICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMudCA9IDQgLyogQmluYXJ5T3BlcmF0b3IgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBDYWxjLl9fZXh0ZW5kcyhCaW5hcnlPcGVyYXRvckV4cHJlc3Npb25fLCBfc3VwZXIpO1xuXG4gICAgICAgICAgICByZXR1cm4gQmluYXJ5T3BlcmF0b3JFeHByZXNzaW9uXztcbiAgICAgICAgfSkoT3BlcmF0b3JFeHByZXNzaW9uKTtcbiAgICAgICAgRXhwcmVzc2lvbnMuQmluYXJ5T3BlcmF0b3JFeHByZXNzaW9uID0gQmluYXJ5T3BlcmF0b3JFeHByZXNzaW9uO1xuXG4gICAgICAgIHZhciBTdHJ1Y3RSZWZlcmVuY2VFeHByZXNzaW9uID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXByZXNlbnRzIGEgc3RydWN0IHJlZmVyZW5jZSBleHByZXNzaW9uLlxuICAgICAgICAgICAgICogQGV4dGVuZHMgJC53aWptby53aWpzcHJlYWQuQ2FsYy5FeHByZXNzaW9ucy5SZWZlcmVuY2VFeHByZXNzaW9uXG4gICAgICAgICAgICAgKiBAY2xhc3NcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJ1Y3RSZWYgVGhlIHN0cnVjdCByZWZlcmVuY2Ugc3RyaW5nLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBTdHJ1Y3RSZWZlcmVuY2VFeHByZXNzaW9uXyh0YWJsZSwgY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHNlbGYudGFibGUgPSB0YWJsZTtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIENhbGMuX19leHRlbmRzKFN0cnVjdFJlZmVyZW5jZUV4cHJlc3Npb25fLCBfc3VwZXIpO1xuXG4gICAgICAgICAgICByZXR1cm4gU3RydWN0UmVmZXJlbmNlRXhwcmVzc2lvbl87XG4gICAgICAgIH0pKEV4cHJlc3Npb24pO1xuICAgICAgICBFeHByZXNzaW9ucy5TdHJ1Y3RSZWZlcmVuY2VFeHByZXNzaW9uID0gU3RydWN0UmVmZXJlbmNlRXhwcmVzc2lvbjtcblxuICAgICAgICB2YXIgRmllbGRSZWZlcmVuY2VFeHByZXNzaW9uID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXByZXNlbnRzIGEgc3RydWN0IHJlZmVyZW5jZSBleHByZXNzaW9uLlxuICAgICAgICAgICAgICogQGV4dGVuZHMgJC53aWptby53aWpzcHJlYWQuQ2FsYy5FeHByZXNzaW9ucy5SZWZlcmVuY2VFeHByZXNzaW9uXG4gICAgICAgICAgICAgKiBAY2xhc3NcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJ1Y3RSZWYgVGhlIHN0cnVjdCByZWZlcmVuY2Ugc3RyaW5nLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBGaWVsZFJlZmVyZW5jZUV4cHJlc3Npb25fKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgc2VsZi5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIENhbGMuX19leHRlbmRzKEZpZWxkUmVmZXJlbmNlRXhwcmVzc2lvbl8sIF9zdXBlcik7XG5cbiAgICAgICAgICAgIHJldHVybiBGaWVsZFJlZmVyZW5jZUV4cHJlc3Npb25fO1xuICAgICAgICB9KShFeHByZXNzaW9uKTtcbiAgICAgICAgRXhwcmVzc2lvbnMuRmllbGRSZWZlcmVuY2VFeHByZXNzaW9uID0gRmllbGRSZWZlcmVuY2VFeHByZXNzaW9uO1xuXG4gICAgICAgIHZhciBVbmtub3duUmVmZXJlbmNlRXhwcmVzc2lvbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVwcmVzZW50cyBhIHN0cnVjdCByZWZlcmVuY2UgZXhwcmVzc2lvbi5cbiAgICAgICAgICAgICAqIEBleHRlbmRzICQud2lqbW8ud2lqc3ByZWFkLkNhbGMuRXhwcmVzc2lvbnMuUmVmZXJlbmNlRXhwcmVzc2lvblxuICAgICAgICAgICAgICogQGNsYXNzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RydWN0UmVmIFRoZSBzdHJ1Y3QgcmVmZXJlbmNlIHN0cmluZy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gVW5rbm93blJlZmVyZW5jZUV4cHJlc3Npb25fKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgc2VsZi5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIENhbGMuX19leHRlbmRzKFVua25vd25SZWZlcmVuY2VFeHByZXNzaW9uXywgX3N1cGVyKTtcblxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SZWZlcmVuY2VFeHByZXNzaW9uXztcbiAgICAgICAgfSkoRXhwcmVzc2lvbik7XG4gICAgICAgIEV4cHJlc3Npb25zLlVua25vd25SZWZlcmVuY2VFeHByZXNzaW9uID0gVW5rbm93blJlZmVyZW5jZUV4cHJlc3Npb247XG5cbiAgICB9KShDYWxjRXhwcmVzc2lvbnMgfHwgKENhbGNFeHByZXNzaW9ucyA9IHt9KSk7XG59KSgpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2FwcC9zY3JpcHRzL2dyaWQvY2FsYy9leHByZXNzaW9ucy5qc1xuICoqIG1vZHVsZSBpZCA9IDEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgdmFyIENPTlNUX1VOREVGSU5FRCA9ICd1bmRlZmluZWQnOy8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgdmFyIENPTlNUX05VTUJFUiA9ICdudW1iZXInOy8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgdmFyIENPTlNUX1NUUklORyA9ICdzdHJpbmcnOy8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgdmFyIENPTlNUX0JPT0xFQU4gPSAnYm9vbGVhbic7Ly8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICB2YXIgQ09OU1RfVFJVRSA9ICdUUlVFJzsvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIHZhciBDT05TVF9GQUxTRSA9ICdGQUxTRSc7Ly8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICB2YXIgQ09OU1RfQVJSQVkgPSAnQVJSQVknOy8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgdmFyIENPTlNUX0FSUkFZUk9XID0gJ0FSUkFZUk9XJzsvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIHZhciBDT05TVF9OVUxMID0gJyNOVUxMISc7XHJcbiAgICB2YXIgQ09OU1RfRElWMCA9ICcjRElWLzAhJztcclxuICAgIHZhciBDT05TVF9WQUxVRSA9ICcjVkFMVUUhJztcclxuICAgIHZhciBDT05TVF9SRUYgPSAnI1JFRiEnO1xyXG4gICAgdmFyIENPTlNUX05BTUUgPSAnI05BTUU/JztcclxuICAgIHZhciBDT05TVF9OQSA9ICcjTi9BJztcclxuICAgIHZhciBDT05TVF9OVU0gPSAnI05VTSEnO1xyXG4gICAgdmFyIENPTlNUX0VYUFIgPSAnZXhwcic7Ly8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICB2YXIgQ09OU1RfQVJSQVlJTkZPID0gJ2FycmF5SW5mbyc7Ly8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICB2YXIgQ09OU1RfV09SS0lOR0VYUFIgPSAnd29ya2luZ0V4cHInOy8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgdmFyIEVSUk9SX0xJU1QgPSBbQ09OU1RfTlVMTCwgQ09OU1RfRElWMCwgQ09OU1RfVkFMVUUsIENPTlNUX1JFRiwgQ09OU1RfTkFNRSwgQ09OU1RfTkEsIENPTlNUX05VTV07Ly8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICB2YXIgRVJST1JDT0RFX0xJU1QgPSBbMHgwMCwgMHgwNywgMHgwRiwgMHgxNywgMHgxRCwgMHgyQSwgMHgyNF07Ly8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICB2YXIgTEVUVEVSX1BPV1MgPSBbMSwgMjYsIDY3Nl07Ly8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICB2YXIgS0VZV09SRF9OVUxMID0gbnVsbDtcclxuICAgIHZhciBLRVlXT1JEX1VOREVGSU5FRCA9IHVuZGVmaW5lZDsvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIHZhciBTVVBQUk9UX1JPV19DT0xVTU5fRk9STVVMQSA9IGZhbHNlOy8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgdmFyIE1BVEhfTUlOID0gTWF0aC5taW47Ly8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICB2YXIgTUFUSF9NQVggPSBNYXRoLm1heDsvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIHZhciBNQVRIX0FCUyA9IE1hdGguYWJzOy8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgdmFyIE1BVEhfUE9XID0gTWF0aC5wb3c7Ly8ganNoaW50IGlnbm9yZTpsaW5lXHJcblxyXG4gICAgdmFyIENhbGMgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xyXG4gICAgdmFyIENhbGNFeHByZXNzaW9ucyA9IHJlcXVpcmUoJy4vZXhwcmVzc2lvbnMnKTtcclxuICAgIHZhciBDYWxjUGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXInKTtcclxuICAgIHZhciBDYWxjSGVscGVyID0gcmVxdWlyZSgnLi9jYWxjSGVscGVyJyk7XHJcbiAgICB2YXIgQ2FsY0Z1bmN0aW9ucyA9IHJlcXVpcmUoJy4vY2FsY0Z1bmN0aW9ucycpO1xyXG5cclxuICAgIHZhciB0aHJvd1NSID0gQ2FsYy5TUkhlbHBlci50aHJvd1NSO1xyXG5cclxuICAgIHZhciBkZWZhdWx0UGFyc2VyID0gbmV3IENhbGNQYXJzZXIuUGFyc2VyKCk7XHJcblxyXG4gICAgdmFyIEV2YWx1YXRvciA9IChmdW5jdGlvbigpIHtcclxuICAgICAgICBmdW5jdGlvbiBFdmFsdWF0b3IoKSB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBFdmFsdWF0b3IucHJvdG90eXBlLmV2YWx1YXRlRm9ybXVsYSA9IGZ1bmN0aW9uKGZvcm11bGEsIHBhcnNlckNvbnRleHQsIGV2YWx1YXRvckNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIGV4cHIgPSBkZWZhdWx0UGFyc2VyLnBhcnNlKGZvcm11bGEsIHBhcnNlckNvbnRleHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmFsdWF0ZUV4cHJlc3Npb24oZXhwciwgZXZhbHVhdG9yQ29udGV4dCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRXZhbHVhdGVzIGFuIGV4cHJlc3Npb24gd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRleHQuXHJcbiAgICAgICAgICogQHBhcmFtIHskLndpam1vLndpanNwcmVhZC5DYWxjRXhwcmVzc2lvbnMuRXhwcmVzc2lvbn0gZXhwcmVzc2lvbiBUaGUgZXhwcmVzc2lvbiB0byBiZSBldmFsdWF0ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHskLndpam1vLndpanNwcmVhZC5DYWxjLkV2YWx1YXRlQ29udGV4dH0gZXZhbHVhdG9yQ29udGV4dCBUaGUgY29udGV4dCBmb3IgdGhlIGV2YWx1YXRvciB0byBxdWVyeSBkYXRhLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSByZXN1bHQgb2YgdGhlIGV2YWx1YXRpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRXZhbHVhdG9yLnByb3RvdHlwZS5ldmFsdWF0ZUV4cHJlc3Npb24gPSBmdW5jdGlvbihleHByZXNzaW9uLCBldmFsdWF0b3JDb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9ldmFsdWF0ZShleHByZXNzaW9uLCBldmFsdWF0b3JDb250ZXh0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEV2YWx1YXRvci5wcm90b3R5cGUuX2V2YWx1YXRlID0gZnVuY3Rpb24oZXhwciwgY29udGV4dCkge1xyXG4gICAgICAgICAgICBpZiAoIWV4cHIpIHtcclxuICAgICAgICAgICAgICAgIHRocm93U1IoJ0V4cF9FeHBySXNOdWxsJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUgKGV4cHIudCA9PT0gOCAvKiBQYXJlbnRoZXNlcyAqLykge1xyXG4gICAgICAgICAgICAgICAgZXhwciA9IGV4cHIuYXJndW1lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIENhbGNFeHByZXNzaW9ucy5Db25zdGFudEV4cHJlc3Npb24pIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNlbGYuX2V2YWx1YXRlQ29uc3QoZXhwciwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwciBpbnN0YW5jZW9mIENhbGNFeHByZXNzaW9ucy5VbmFyeU9wZXJhdG9yRXhwcmVzc2lvbiAvKiBVbmFyeU9wZXJhdG9yICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzZWxmLl9ldmFsdWF0ZVVuYXJ5T3BlcmF0aW9uKGV4cHIsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHIgaW5zdGFuY2VvZiBDYWxjRXhwcmVzc2lvbnMuQmluYXJ5T3BlcmF0b3JFeHByZXNzaW9uIC8qIEJpbmFyeU9wZXJhdG9yICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzZWxmLl9ldmFsdWF0ZUJpbmFyeU9wZXJhdGlvbihleHByLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChleHByIGluc3RhbmNlb2YgQ2FsY0V4cHJlc3Npb25zLkZ1bmN0aW9uRXhwcmVzc2lvbiAvKiBGdW5jdGlvbiAqLykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4cHIuZm4uaXNDYWxjdWxhdGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNlbGYuX2V2YWx1YXRlQ2FsY3VsYXRlRnVuY3Rpb24oZXhwciwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHIuZm4uaXNTdW1tYXJpemUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNlbGYuX2V2YWx1YXRlU3VtbWFyaXplRnVuY3Rpb24oZXhwciwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNlbGYuX2V2YWx1YXRlRnVuY3Rpb24oZXhwciwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwciBpbnN0YW5jZW9mIENhbGNFeHByZXNzaW9ucy5TdHJ1Y3RSZWZlcmVuY2VFeHByZXNzaW9uIC8qIFN0cnVjdEV4cHJlc3Npb24gKi8pIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNlbGYuX2V2YWx1YXRlU3RydWN0RXhwcmVzc2lvbihleHByLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChleHByIGluc3RhbmNlb2YgQ2FsY0V4cHJlc3Npb25zLkZpZWxkUmVmZXJlbmNlRXhwcmVzc2lvbiAvKiBGaWVsZEV4cHJlc3Npb24gKi8pIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNlbGYuX2V2YWx1YXRlRmllbGRFeHByZXNzaW9uKGV4cHIsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHIgaW5zdGFuY2VvZiBDYWxjRXhwcmVzc2lvbnMuVW5rbm93blJlZmVyZW5jZUV4cHJlc3Npb24gLyogRmllbGRFeHByZXNzaW9uICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzZWxmLl9ldmFsdWF0ZVVua25vd25FeHByZXNzaW9uKGV4cHIsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgRXZhbHVhdG9yLnByb3RvdHlwZS5fZXZhbHVhdGVDb25zdCA9IGZ1bmN0aW9uKGV4cHIsIGNvbnRleHQpIHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGV4cHIudmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEV2YWx1YXRvci5wcm90b3R5cGUuX2V2YWx1YXRlVW5hcnlPcGVyYXRpb24gPSBmdW5jdGlvbihleHByLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIC8vdmFyIGFjY2VwdHNSZWZlcmVuY2VzID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAvLyBmaXJzdCBldmFsdWF0ZSB0aGUgcGFyYW1ldGVyLCB0aGVuIGludm9rZSBvcGVyYXRvci5cclxuICAgICAgICAgICAgdmFyIGFyZyA9IHRoaXMuX2V2YWx1YXRlKGV4cHIub3BlcmFuZCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChDYWxjLkNvbnZlcnQuZXJyKGFyZykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFyZyA9PT0gQ2FsYy5taXNzaW5nQXJndW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDYWxjLkNhbGNFcnJvcnNOb3RBdmFpbGFibGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGV4cHIub3BlcmF0b3IuZXZhbHVhdGUoYXJnLCBjb250ZXh0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEV2YWx1YXRvci5wcm90b3R5cGUuX2V2YWx1YXRlQmluYXJ5T3BlcmF0aW9uID0gZnVuY3Rpb24oZXhwciwgY29udGV4dCkge1xyXG5cclxuICAgICAgICAgICAgLy8gZmlyc3QgZXZhbHVhdGUgYXJndW1lbnRzIGV4cHJlc3Npb25zIG9uZSBieSBvbmUsIGlmIGVycm9yIGZvdW5kLCByZXR1cm4gZGlyZWN0bHkuXHJcbiAgICAgICAgICAgIC8vIFRoZW4gaW52b2tlIG9wZXJhdG9yXHJcbiAgICAgICAgICAgIHZhciBzdWIgPSBbZXhwci5sZWZ0LCBleHByLnJpZ2h0XTtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcmcgPSB0aGlzLl9ldmFsdWF0ZShzdWJbaV0sIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKENhbGMuQ29udmVydC5lcnIoYXJnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJnID09PSBDYWxjLm1pc3NpbmdBcmd1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDYWxjLkNhbGNFcnJvcnNOb3RBdmFpbGFibGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhcmdzW2ldID0gYXJnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBleHByLm9wZXJhdG9yLmV2YWx1YXRlKGFyZ3NbMF0sIGFyZ3NbMV0sIGNvbnRleHQpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIEV2YWx1YXRvci5wcm90b3R5cGUuX2V2YWx1YXRlRnVuY3Rpb24gPSBmdW5jdGlvbihleHByLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGlmICghZXhwciB8fCAhZXhwci5mbiB8fCB0eXBlb2YgZXhwci5mbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDYWxjLkNhbGNFcnJvcnNOYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGFyZ0NvdW50ID0gZXhwci5hcmdDb3VudCgpO1xyXG4gICAgICAgICAgICB2YXIgZm4gPSBleHByLmZuO1xyXG4gICAgICAgICAgICB2YXIgYXJnRXhwcnMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGFyZztcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIHZhciBjYWNoZWRTb3VyY2U7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdFeHBycy5wdXNoKGV4cHIuZ2V0QXJnKGkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdGFibGVBcmdJbmRleCA9IGZuLnRhYmxlQXJnSW5kZXgoKTtcclxuICAgICAgICAgICAgaWYgKHRhYmxlQXJnSW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBjYWNoZWRTb3VyY2UgPSBjb250ZXh0LmNhbGNTb3VyY2U7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyQXJncyA9IHByZVByb2Nlc3NGaWx0ZXJDb250ZXh0Xy5jYWxsKHNlbGYsIGFyZ0V4cHJzLCB0YWJsZUFyZ0luZGV4LCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJBcmdzLmZpbHRlck9taXR0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICArK2FyZ0NvdW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXJnc1t0YWJsZUFyZ0luZGV4XSA9IGZpbHRlckFyZ3MudGFibGVDb250ZXh0QXJnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgaXNBZ2dyZWdhdG9yID0gZm4uaXNBZ2dyZWdhdG9yKCk7XHJcbiAgICAgICAgICAgIGlmIChpc0FnZ3JlZ2F0b3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuYmVnaW5BZ2dyZWdhdGluZ18oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYXJnQ291bnQgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IHRhYmxlQXJnSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJnRXhwciA9IGFyZ0V4cHJzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZyA9IHNlbGYuX2V2YWx1YXRlKGFyZ0V4cHIsIGNvbnRleHQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKENhbGMuQ29udmVydC5lcnIoYXJnKSkgJiYgIWZuLmFjY2VwdHNFcnJvcihpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnID09PSBDYWxjLm1pc3NpbmdBcmd1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZuLmFjY2VwdHNNaXNzaW5nQXJndW1lbnQoaSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IEtFWVdPUkRfTlVMTDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gYXJnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZXhwci5mbi5ldmFsdWF0ZShhcmdzLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKHRhYmxlQXJnSW5kZXggIT09IC0xICYmIGNhY2hlZFNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5jYWxjU291cmNlID0gY2FjaGVkU291cmNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc0FnZ3JlZ2F0b3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZW5kQWdncmVnYXRpbmdfKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBFdmFsdWF0b3IucHJvdG90eXBlLl9ldmFsdWF0ZUNhbGN1bGF0ZUZ1bmN0aW9uID0gZnVuY3Rpb24oZXhwciwgY29udGV4dCkge1xyXG4gICAgICAgICAgICBpZiAoIWV4cHIgfHwgIWV4cHIuZm4gfHwgdHlwZW9mIGV4cHIuZm4gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2FsYy5DYWxjRXJyb3JzTmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBjYWxjRXhwciA9IGV4cHIuZ2V0QXJnKDApO1xyXG4gICAgICAgICAgICB2YXIgYXJnQ291bnQgPSBleHByLmFyZ0NvdW50KCk7XHJcbiAgICAgICAgICAgIHZhciBhcmdFeHByO1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICAgICAgdmFyIGZpbHRlcjtcclxuICAgICAgICAgICAgdmFyIGZpbHRlckV4cHJzID0gW107XHJcbiAgICAgICAgICAgIHZhciB0ZW1wQ29udGV4dDtcclxuICAgICAgICAgICAgdmFyIGZpZWxkT2JqO1xyXG4gICAgICAgICAgICB2YXIgY29sdW1uT2JqO1xyXG4gICAgICAgICAgICB2YXIgY2FjaGVkU291cmNlID0gY29udGV4dC5jYWxjU291cmNlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGFyZ0NvdW50ID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzZWxmLl9ldmFsdWF0ZShjYWxjRXhwciwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoQ2FsY0hlbHBlci5jb2x1bW5SZWYocmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5nZXRWYWx1ZShjb250ZXh0LmdldEN1cnJlbnRSb3coKSwgY29udGV4dC5ncm91cFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChDYWxjSGVscGVyLmZpZWxkUmVmKHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuZ2V0VmFsdWUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IGFyZ0NvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGFyZ0V4cHIgPSBleHByLmdldEFyZyhpKTtcclxuICAgICAgICAgICAgICAgIGZpbHRlckV4cHJzLnB1c2goYXJnRXhwcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXy5mb3JFYWNoKGZpbHRlckV4cHJzLCBmdW5jdGlvbihmaWx0ZXJFeHByKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoQ2FsY0hlbHBlci5mbkV4cHIoZmlsdGVyRXhwcikgJiYgZmlsdGVyRXhwci5mbi5pc1RhYmxlUmVzdWx0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUNhbGNIZWxwZXIuZXJyKHRlbXBDb250ZXh0ID0gc2VsZi5fZXZhbHVhdGUoZmlsdGVyRXhwciwgY29udGV4dCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2FsY1NvdXJjZSA9IHRlbXBDb250ZXh0LmNhbGNTb3VyY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSBDYWxjRnVuY3Rpb25zLmZpbmRHbG9iYWxGdW5jdGlvbignZmlsdGVyJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gbmV3IENhbGNFeHByZXNzaW9ucy5GdW5jdGlvbkV4cHJlc3Npb24oZmlsdGVyLCBbZmlsdGVyRXhwcl0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghQ2FsY0hlbHBlci5lcnIodGVtcENvbnRleHQgPSBzZWxmLl9ldmFsdWF0ZShmaWx0ZXIsIGNvbnRleHQpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNhbGNTb3VyY2UgPSB0ZW1wQ29udGV4dC5jYWxjU291cmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHNlbGYuX2V2YWx1YXRlKGNhbGNFeHByLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKENhbGNIZWxwZXIuY29sdW1uUmVmKHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbHVtbk9iaiA9IHJlc3VsdC5jYWxjU291cmNlLmZpbmRDb2x1bW4ocmVzdWx0LmNvbHVtbik7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbHVtbk9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDYWxjLkNhbGNFcnJvcnNSZWZlcmVuY2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gY29udGV4dC5nZXRDdXJyZW50Um93KGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmNhbGNTb3VyY2UuaXNGaWx0ZXJPdXQocm93KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gKGNvbHVtbk9iai50eXBlID09PSBDYWxjSGVscGVyLkRBVEFfQ09MVU1OKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5nZXRWYWx1ZShyb3csIGNvbnRleHQuZ3JvdXBQYXRoKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2V2YWx1YXRlKGNvbHVtbk9iai5leHByZXNzaW9uLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChDYWxjSGVscGVyLmZpZWxkUmVmKHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgICAgIGZpZWxkT2JqID0gcmVzdWx0LmNhbGNTb3VyY2UuZmluZENhbGNGaWVsZChyZXN1bHQubmFtZSk7XHJcbiAgICAgICAgICAgICAgICBhcmdFeHByID0gZmllbGRPYmogJiYgZmllbGRPYmouZXhwcmVzc2lvbjtcclxuICAgICAgICAgICAgICAgIGlmICghYXJnRXhwcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDYWxjLkNhbGNFcnJvcnNSZWZlcmVuY2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzZWxmLl9ldmFsdWF0ZShhcmdFeHByLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250ZXh0LmNhbGNTb3VyY2UgPSBjYWNoZWRTb3VyY2U7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgRXZhbHVhdG9yLnByb3RvdHlwZS5fZXZhbHVhdGVTdW1tYXJpemVGdW5jdGlvbiA9IGZ1bmN0aW9uKGV4cHIsIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgaWYgKCFleHByIHx8ICFleHByLmZuIHx8IHR5cGVvZiBleHByLmZuID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENhbGMuQ2FsY0Vycm9yc05hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgYXJnQ291bnQgPSBleHByLmFyZ0NvdW50KCk7XHJcbiAgICAgICAgICAgIHZhciBmbiA9IGV4cHIuZm47XHJcbiAgICAgICAgICAgIHZhciBhcmdFeHBycyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgdmFyIGNhY2hlZFNvdXJjZSA9IGNvbnRleHQuY2FsY1NvdXJjZTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ0NvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGFyZ0V4cHJzLnB1c2goZXhwci5nZXRBcmcoaSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgdGFibGVBcmdJbmRleCA9IGZuLnRhYmxlQXJnSW5kZXgoKTtcclxuICAgICAgICAgICAgdmFyIGZpbHRlckFyZ3MgPSBwcmVQcm9jZXNzRmlsdGVyQ29udGV4dF8uY2FsbChzZWxmLCBhcmdFeHBycywgdGFibGVBcmdJbmRleCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChmaWx0ZXJBcmdzLmZpbHRlck9taXR0ZWQpIHtcclxuICAgICAgICAgICAgICAgICsrYXJnQ291bnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXJnc1t0YWJsZUFyZ0luZGV4XSA9IGZpbHRlckFyZ3MudGFibGVDb250ZXh0QXJnO1xyXG5cclxuICAgICAgICAgICAgdmFyIGlzQWdncmVnYXRvciA9IGZuLmlzQWdncmVnYXRvcigpO1xyXG4gICAgICAgICAgICBpZiAoaXNBZ2dyZWdhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmJlZ2luQWdncmVnYXRpbmdfKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vZ2V0IHBhcmFtZXRlcnM6XHJcbiAgICAgICAgICAgIHZhciBjb2x1bW5OYW1lcyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgbmV3Q29sdW1ucyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgbmV3RXhwcnMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGxlbiA9IGFyZ0V4cHJzLmxlbmd0aDtcclxuICAgICAgICAgICAgaSA9IDE7XHJcbiAgICAgICAgICAgIC8vdG9kbzogYWRqdXN0IHRoZSBsb2dpYyB0byBjb3JyZWN0IHRoZSBjYXNlIG9mIG5lc3Qgc3VtbWFyaXplXHJcbiAgICAgICAgICAgIHZhciB0ZW1wRXhwcjtcclxuICAgICAgICAgICAgd2hpbGUgKENhbGNIZWxwZXIuc3RydWN0RXhwcih0ZW1wRXhwciA9IGFyZ0V4cHJzW2ldKSAmJiB0ZW1wRXhwci5jb2x1bW4gJiYgaSA8IGxlbikge1xyXG4gICAgICAgICAgICAgICAgY29sdW1uTmFtZXMucHVzaCh0ZW1wRXhwci5jb2x1bW4pO1xyXG4gICAgICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlIChDYWxjSGVscGVyLnN0ckV4cHIodGVtcEV4cHIgPSBhcmdFeHByc1tpXSkgJiYgaSA8IGxlbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKF8uaW5kZXhPZihjb2x1bW5OYW1lcywgdGVtcEV4cHIudmFsdWUpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbHVtbnMucHVzaCh0ZW1wRXhwci52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ2FsYy5DYWxjRXJyb3JzUmVmZXJlbmNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmV3RXhwcnMucHVzaChhcmdFeHByc1tpKytdIHx8IENhbGMuQ2FsY0Vycm9yc1JlZmVyZW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vc2V0IGdyb3VwIGFuZCBjYWxjdWxhdGVcclxuICAgICAgICAgICAgdmFyIHRlbXBDYWxjU291cmNlID0gY29udGV4dC5jYWxjU291cmNlO1xyXG4gICAgICAgICAgICB2YXIgdGVtcFRhYmxlID0gdGVtcENhbGNTb3VyY2UuZ2V0TW9kZWwoQ2FsY0hlbHBlci5DQUxDX1RBQkxFKTtcclxuICAgICAgICAgICAgdmFyIGdyb3VwRGVzYyA9IF8ubWFwKGNvbHVtbk5hbWVzLCBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge2ZpZWxkOiBuYW1lfTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0ZW1wVGFibGUuYmVnaW5Vc2VHcm91cCgpO1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXBUcmVlID0gdGVtcENhbGNTb3VyY2UuZ3JvdXAoZ3JvdXBEZXNjKTtcclxuICAgICAgICAgICAgdmFyIGdyb3VwUGF0aEJhY2t1cCA9IGNvbnRleHQuZ3JvdXBQYXRoO1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXBQYXRoU3RhY2sgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChpID0gZ3JvdXBUcmVlLmdyb3Vwcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgICAgICAgICAgZ3JvdXBQYXRoU3RhY2sucHVzaChbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjdXJyR3JvdXBQYXRoO1xyXG4gICAgICAgICAgICB2YXIgY3Vyckdyb3VwO1xyXG4gICAgICAgICAgICB2YXIgaXNCb3R0b21MZXZlbDtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgdGVtcFJlc3VsdDtcclxuICAgICAgICAgICAgdmFyIGl0ZW1TYW1wbGU7XHJcbiAgICAgICAgICAgIHdoaWxlIChncm91cFBhdGhTdGFjay5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyR3JvdXBQYXRoID0gZ3JvdXBQYXRoU3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBjdXJyR3JvdXAgPSBnZXRHcm91cEJ5UGF0aF8oZ3JvdXBUcmVlLCBjdXJyR3JvdXBQYXRoKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZ3JvdXBQYXRoID0gY3Vyckdyb3VwUGF0aDtcclxuICAgICAgICAgICAgICAgIGl0ZW1TYW1wbGUgPSBjdXJyR3JvdXAuZ2V0SXRlbSgwKTtcclxuICAgICAgICAgICAgICAgIGlzQm90dG9tTGV2ZWwgPSBjdXJyR3JvdXAuaXNCb3R0b21MZXZlbDtcclxuICAgICAgICAgICAgICAgIGlmIChpc0JvdHRvbUxldmVsID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcFJlc3VsdCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG5ld0NvbHVtbnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcEV4cHIgPSBuZXdFeHByc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKENhbGNIZWxwZXIuZXJyKHRlbXBFeHByKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFJlc3VsdFtuZXdDb2x1bW5zW2ldXSA9IHRlbXBFeHByO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFJlc3VsdFtuZXdDb2x1bW5zW2ldXSA9IHNlbGYuX2V2YWx1YXRlKHRlbXBFeHByLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb2x1bW5OYW1lcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wUmVzdWx0W2NvbHVtbk5hbWVzW2ldXSA9IGl0ZW1TYW1wbGVbY29sdW1uTmFtZXNbaV1dO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0ZW1wUmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3Vyckdyb3VwLmlzQm90dG9tTGV2ZWwgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gY3Vyckdyb3VwLmdyb3Vwcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cFBhdGhTdGFjay5wdXNoKGN1cnJHcm91cFBhdGguY29uY2F0KFtpXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250ZXh0Lmdyb3VwUGF0aCA9IGdyb3VwUGF0aEJhY2t1cDtcclxuICAgICAgICAgICAgdGVtcFRhYmxlLmVuZFVzZUdyb3VwKCk7XHJcbiAgICAgICAgICAgIGlmICh0YWJsZUFyZ0luZGV4ICE9PSAtMSAmJiBjYWNoZWRTb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuY2FsY1NvdXJjZSA9IGNhY2hlZFNvdXJjZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNBZ2dyZWdhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmVuZEFnZ3JlZ2F0aW5nXygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FsYy5DYWxjVGFibGVSZWZlcmVuY2UoY29udGV4dC5jYWxjU291cmNlLmNyZWF0ZSgnc3VtbWFyaXplZFRhYmxlJywgcmVzdWx0KSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcHJlUHJvY2Vzc0ZpbHRlckNvbnRleHRfKGFyZ0V4cHJzLCB0YWJsZUFyZ0luZGV4LCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHRhYmxlQ29udGV4dEFyZztcclxuICAgICAgICAgICAgdmFyIHRhYmxlQ29udGV4dEV4cHIgPSBhcmdFeHByc1t0YWJsZUFyZ0luZGV4XTtcclxuICAgICAgICAgICAgdmFyIGNhbGNTb3VyY2UgPSBjb250ZXh0LmNhbGNTb3VyY2U7XHJcbiAgICAgICAgICAgIHZhciBmaWx0ZXJPbWl0dGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChDYWxjSGVscGVyLnN0cnVjdEV4cHIodGFibGVDb250ZXh0RXhwcikgJiYgIXRhYmxlQ29udGV4dEV4cHIuY29sdW1uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFibGVDb250ZXh0RXhwci50YWJsZSA9PT0gY2FsY1NvdXJjZS5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFibGVDb250ZXh0QXJnID0gc2VsZi5fZXZhbHVhdGUodGFibGVDb250ZXh0RXhwciwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDYWxjLkNhbGNFcnJvcnNSZWZlcmVuY2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQ2FsY0hlbHBlci5zdHJFeHByKHRhYmxlQ29udGV4dEV4cHIpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFibGVDb250ZXh0RXhwci52YWx1ZSA9PT0gY2FsY1NvdXJjZS5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFibGVDb250ZXh0QXJnID0gbmV3IENhbGMuQ2FsY1RhYmxlUmVmZXJlbmNlKGNhbGNTb3VyY2UpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ2FsYy5DYWxjRXJyb3JzUmVmZXJlbmNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKENhbGNIZWxwZXIuZm5FeHByKHRhYmxlQ29udGV4dEV4cHIpICYmIHRhYmxlQ29udGV4dEV4cHIuZm4uaXNUYWJsZVJlc3VsdCgpKSB7XHJcbiAgICAgICAgICAgICAgICB0YWJsZUNvbnRleHRBcmcgPSBzZWxmLl9ldmFsdWF0ZSh0YWJsZUNvbnRleHRFeHByLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRhYmxlQ29udGV4dEFyZyA9IG5ldyBDYWxjLkNhbGNUYWJsZVJlZmVyZW5jZShjYWxjU291cmNlKTtcclxuICAgICAgICAgICAgICAgIGFyZ0V4cHJzLnNwbGljZSh0YWJsZUFyZ0luZGV4LCAwLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIGZpbHRlck9taXR0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChDYWxjSGVscGVyLmVycih0YWJsZUNvbnRleHRBcmcpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2FsYy5DYWxjRXJyb3JzUmVmZXJlbmNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChDYWxjSGVscGVyLnRhYlJlZih0YWJsZUNvbnRleHRBcmcpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNhbGNTb3VyY2UgPSB0YWJsZUNvbnRleHRBcmcuY2FsY1NvdXJjZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2Vsc2UgaWYoXy5pc0FycmF5KHRhYmxlQ29udGV4dEFyZykpeyAvLyBsaWtlIFNVTVgoW3ByaWNlXSA+IDEwMCxbY291bnRdICogW3ByaWNlXSksIGl0IGhhcyBubyBmaWx0ZXIvdGFibGUsIGp1c3QgYXJyYXkgb2YgZmlsdGVyIHJlc3VsdHNcclxuICAgICAgICAgICAgLy8gICAgdmFyIHRtcFNvdXJjZSA9IGNhY2hlZFNvdXJjZS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAvLyAgICB0bXBTb3VyY2Uuc2V0RmlsdGVyU3RhdGVzKHRhYmxlQ29udGV4dEFyZyk7XHJcbiAgICAgICAgICAgIC8vICAgIGNvbnRleHQuY2FsY1NvdXJjZSA9IHRtcFNvdXJjZTtcclxuICAgICAgICAgICAgLy99XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJPbWl0dGVkOiBmaWx0ZXJPbWl0dGVkLFxyXG4gICAgICAgICAgICAgICAgdGFibGVDb250ZXh0QXJnOiB0YWJsZUNvbnRleHRBcmdcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGdldEdyb3VwQnlQYXRoXyhncm91cCwgcGF0aCkge1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgdmFyIGxlbjtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRHcm91cCA9IGdyb3VwLmdyb3Vwc1twYXRoWzBdXTtcclxuICAgICAgICAgICAgZm9yIChpID0gMSwgbGVuID0gcGF0aC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEdyb3VwID0gY3VycmVudEdyb3VwLmdyb3Vwc1twYXRoW2ldXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEdyb3VwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgRXZhbHVhdG9yLnByb3RvdHlwZS5fZXZhbHVhdGVTdHJ1Y3RFeHByZXNzaW9uID0gZnVuY3Rpb24oZXhwciwgY29udGV4dCkge1xyXG4gICAgICAgICAgICBpZiAoZXhwci50YWJsZSAmJiBleHByLmNvbHVtbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDYWxjLkNhbGNDb2x1bW5SZWZlcmVuY2UoY29udGV4dC5jYWxjU291cmNlLCBleHByLmNvbHVtbik7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwci50YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDYWxjLkNhbGNUYWJsZVJlZmVyZW5jZShjb250ZXh0LmNhbGNTb3VyY2UsIGV4cHIudGFibGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgRXZhbHVhdG9yLnByb3RvdHlwZS5fZXZhbHVhdGVGaWVsZEV4cHJlc3Npb24gPSBmdW5jdGlvbihleHByLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FsYy5DYWxjRmllbGRSZWZlcmVuY2UoY29udGV4dC5jYWxjU291cmNlLCBleHByLm5hbWUpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIEV2YWx1YXRvci5wcm90b3R5cGUuX2V2YWx1YXRlVW5rbm93bkV4cHJlc3Npb24gPSBmdW5jdGlvbihleHByLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmNhbGNTb3VyY2UuZmluZENvbHVtbihleHByLm5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENhbGMuQ2FsY0NvbHVtblJlZmVyZW5jZShjb250ZXh0LmNhbGNTb3VyY2UsIGV4cHIubmFtZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5jYWxjU291cmNlLmZpbmRDYWxjRmllbGQoZXhwci5uYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDYWxjLkNhbGNGaWVsZFJlZmVyZW5jZShjb250ZXh0LmNhbGNTb3VyY2UsIGV4cHIubmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIENhbGMuQ2FsY0Vycm9yc1JlZmVyZW5jZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBFdmFsdWF0b3IucHJvdG90eXBlLl9ldmFsdWF0ZVdpdGhBcmdzID0gZnVuY3Rpb24oZXhwciwgZXZhbHVhdGVEZWxlZ2F0ZSwgY29udGV4dCwgYXJncykge1xyXG4gICAgICAgICAgICByZXR1cm4gZXZhbHVhdGVEZWxlZ2F0ZShhcmdzLCBjb250ZXh0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBFdmFsdWF0b3I7XHJcbiAgICB9KSgpO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gRXZhbHVhdG9yO1xyXG59KSgpO1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXBwL3NjcmlwdHMvZ3JpZC9jYWxjL2V2YWx1YXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxyXG4gKlxyXG4gKiBTcHJlYWRKUyBMaWJyYXJ5IDEuMC4wXHJcbiAqIGh0dHA6Ly93aWptby5jb20vXHJcbiAqXHJcbiAqIENvcHlyaWdodChjKSBHcmFwZUNpdHksIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBXaWptbyBDb21tZXJjaWFsIExpY2Vuc2UuIEFsc28gYXZhaWxhYmxlIHVuZGVyIHRoZSBHTlUgR1BMIFZlcnNpb24gMyBsaWNlbnNlLlxyXG4gKiBsaWNlbnNpbmdAd2lqbW8uY29tXHJcbiAqIGh0dHA6Ly93aWptby5jb20vd2lkZ2V0cy9saWNlbnNlL1xyXG4gKlxyXG4gKlxyXG4gKiovXHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB2YXIgQ2FsYyA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XHJcbiAgICB2YXIgQ2FsY0V4cHJlc3Npb25zID0gcmVxdWlyZSgnLi9leHByZXNzaW9ucycpO1xyXG4gICAgdmFyIENhbGNGdW5jdGlvbnMgPSByZXF1aXJlKCcuL2NhbGNGdW5jdGlvbnMnKTtcclxuXHJcbiAgICB2YXIgQ2FsY0hlbHBlciA9IChmdW5jdGlvbigpIHtcclxuICAgICAgICBmdW5jdGlvbiBDYWxjSGVscGVyKCkge1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIENhbGNIZWxwZXIuREFUQV9DT0xVTU4gPSAnRGF0YUNvbCc7XHJcbiAgICAgICAgQ2FsY0hlbHBlci5DQUxDX0NPTFVNTiA9ICdDYWxjQ29sJztcclxuICAgICAgICBDYWxjSGVscGVyLkVYVEVSTkFMX0NPTFVNTiA9ICdFeHRlcm5hbENvbCc7XHJcbiAgICAgICAgQ2FsY0hlbHBlci5DQUxDX0ZJRUxEID0gJ0NhbGNGaWVsZCc7XHJcbiAgICAgICAgQ2FsY0hlbHBlci5DQUxDX0dfRklFTEQgPSAnQ2FsY0dGaWVsZCc7XHJcbiAgICAgICAgQ2FsY0hlbHBlci5DQUxDX1RBQkxFID0gJ0NhbGNUYWJsZSc7XHJcblxyXG4gICAgICAgIENhbGNIZWxwZXIucmVzb2x2ZURlcGVuZHMgPSBmdW5jdGlvbihleHByZXNzaW9uLCBjYWxjU291cmNlKSB7XHJcbiAgICAgICAgICAgIHZhciBkZXBFeHByTGlzdCA9IFtdO1xyXG4gICAgICAgICAgICByZXNvbHZlRXhwcmVzc2lvbnNfKGV4cHJlc3Npb24sIG51bGwsIGRlcEV4cHJMaXN0KTtcclxuICAgICAgICAgICAgaWYgKGRlcEV4cHJMaXN0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF8ubWFwKGRlcEV4cHJMaXN0LCBmdW5jdGlvbihkZXBFeHByKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXhwciA9IGRlcEV4cHIuZXhwcjtcclxuICAgICAgICAgICAgICAgIHZhciBhZ2dDb250ZXh0ID0gZGVwRXhwci5hZ2dDb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgaWYgKENhbGNIZWxwZXIuc3RydWN0RXhwcihleHByKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW4gPSBleHByLmNvbHVtbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbE9iaiA9IGNhbGNTb3VyY2UuZmluZENvbHVtbihjb2x1bW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sT2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gY29sT2JqLnR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gQ2FsY0hlbHBlci5FWFRFUk5BTF9DT0xVTU47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZihjYWxjU291cmNlLmZpbmREYXRhQ29sdW1uKGNvbHVtbikpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICB0eXBlID0gQ2FsY0hlbHBlci5EQVRBX0NPTFVNTjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy99ZWxzZSBpZihjYWxjU291cmNlLmZpbmRDYWxjQ29sdW1uKGNvbHVtbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgdHlwZSA9IENhbGNIZWxwZXIuQ0FMQ19DT0xVTU47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vfWVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICB0eXBlID0gQ2FsY0hlbHBlci5FWFRFUk5BTF9DT0xVTU47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlOiBleHByLnRhYmxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ2dDb250ZXh0OiBhZ2dDb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0YWJsZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZTogZXhwci50YWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQ2FsY0hlbHBlci5maWVsZEV4cHIoZXhwcikpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGV4cHIubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge3R5cGU6IENhbGNIZWxwZXIuQ0FMQ19GSUVMRCwgbmFtZTogbmFtZX07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBDYWxjSGVscGVyLnN0cnVjdEV4cHIgPSBmdW5jdGlvbihleHByKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleHByIGluc3RhbmNlb2YgQ2FsY0V4cHJlc3Npb25zLlN0cnVjdFJlZmVyZW5jZUV4cHJlc3Npb247XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgQ2FsY0hlbHBlci5mbkV4cHIgPSBmdW5jdGlvbihleHByKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleHByIGluc3RhbmNlb2YgQ2FsY0V4cHJlc3Npb25zLkZ1bmN0aW9uRXhwcmVzc2lvbjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBDYWxjSGVscGVyLmZpZWxkRXhwciA9IGZ1bmN0aW9uKGV4cHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4cHIgaW5zdGFuY2VvZiBDYWxjRXhwcmVzc2lvbnMuRmllbGRSZWZlcmVuY2VFeHByZXNzaW9uO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIENhbGNIZWxwZXIuYmluYXJ5RXhwciA9IGZ1bmN0aW9uKGV4cHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4cHIgaW5zdGFuY2VvZiBDYWxjRXhwcmVzc2lvbnMuQmluYXJ5T3BlcmF0b3JFeHByZXNzaW9uO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIENhbGNIZWxwZXIudGFibGVDb250ZXh0Rm4gPSBmdW5jdGlvbihmbikge1xyXG4gICAgICAgICAgICByZXR1cm4gZm4udGFibGVBcmdJbmRleCgpICE9PSAtMTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBDYWxjSGVscGVyLmZpbHRlckZuID0gZnVuY3Rpb24oZXhwcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwciBpbnN0YW5jZW9mIENhbGNFeHByZXNzaW9ucy5GdW5jdGlvbkV4cHJlc3Npb24gJiYgZXhwci5mbiBpbnN0YW5jZW9mIENhbGNGdW5jdGlvbnMuRnVuY3Rpb24gJiYgZXhwci5mbi5pc0ZpbHRlcigpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIENhbGNIZWxwZXIuYWdnRm4gPSBmdW5jdGlvbihleHByKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleHByIGluc3RhbmNlb2YgQ2FsY0V4cHJlc3Npb25zLkZ1bmN0aW9uRXhwcmVzc2lvbiAmJiBleHByLmZuIGluc3RhbmNlb2YgQ2FsY0Z1bmN0aW9ucy5GdW5jdGlvbiAmJiBleHByLmZuLmlzQWdncmVnYXRvcigpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIENhbGNIZWxwZXIuZmllbGRSZWYgPSBmdW5jdGlvbihyZWYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlZiBpbnN0YW5jZW9mIENhbGMuQ2FsY0ZpZWxkUmVmZXJlbmNlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIENhbGNIZWxwZXIuY29sdW1uUmVmID0gZnVuY3Rpb24ocmVmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWYgaW5zdGFuY2VvZiBDYWxjLkNhbGNDb2x1bW5SZWZlcmVuY2U7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgQ2FsY0hlbHBlci50YWJSZWYgPSBmdW5jdGlvbihyZWYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlZiBpbnN0YW5jZW9mIENhbGMuQ2FsY1RhYmxlUmVmZXJlbmNlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIENhbGNIZWxwZXIuZXJyID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQ2FsYy5DYWxjRXJyb3I7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgQ2FsY0hlbHBlci5zdHJFeHByID0gZnVuY3Rpb24oZXhwcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwciBpbnN0YW5jZW9mIENhbGNFeHByZXNzaW9ucy5TdHJpbmdFeHByZXNzaW9uO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIENhbGNIZWxwZXIudW5rbm93RXhwciA9IGZ1bmN0aW9uKGV4cHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4cHIgaW5zdGFuY2VvZiBDYWxjRXhwcmVzc2lvbnMuVW5rbm93blJlZmVyZW5jZUV4cHJlc3Npb247XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgQ2FsY0hlbHBlci5nZXRDYWxjT2JqID0gZnVuY3Rpb24oY2FsY0RlcE5vZGUsIGNhbGNTb3VyY2UpIHtcclxuICAgICAgICAgICAgdmFyIGNhbGNPYmo7XHJcbiAgICAgICAgICAgIHZhciBjb2xOYW1lID0gY2FsY0RlcE5vZGUuY29sdW1uO1xyXG4gICAgICAgICAgICBpZiAoY2FsY0RlcE5vZGUudHlwZSA9PT0gQ2FsY0hlbHBlci5DQUxDX0NPTFVNTikge1xyXG4gICAgICAgICAgICAgICAgY2FsY09iaiA9IGNhbGNTb3VyY2UuZmluZENhbGNDb2x1bW4oY29sTmFtZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FsY0RlcE5vZGUudHlwZSA9PT0gQ2FsY0hlbHBlci5EQVRBX0NPTFVNTikge1xyXG4gICAgICAgICAgICAgICAgY2FsY09iaiA9IGNhbGNTb3VyY2UuZmluZERhdGFDb2x1bW4oY29sTmFtZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FsY0RlcE5vZGUudHlwZSA9PT0gQ2FsY0hlbHBlci5DQUxDX0ZJRUxEKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxjT2JqID0gY2FsY1NvdXJjZS5maW5kQ2FsY0ZpZWxkKGNhbGNEZXBOb2RlLm5hbWUpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNhbGNEZXBOb2RlLnR5cGUgPT09IENhbGNIZWxwZXIuQ0FMQ19HX0ZJRUxEKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxjT2JqID0gY2FsY1NvdXJjZS5maW5kQ2FsY0dyb3VwRmllbGQoY2FsY0RlcE5vZGUubmFtZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjYWxjT2JqID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2FsY09iajtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZXNvbHZlRXhwcmVzc2lvbnNfKGV4cHIsIHBhcmVudEV4cHIsIGRlcEV4cHJMaXN0KSB7XHJcbiAgICAgICAgICAgIGlmIChDYWxjSGVscGVyLnN0cnVjdEV4cHIoZXhwcikpIHtcclxuICAgICAgICAgICAgICAgIGRlcEV4cHJMaXN0LnB1c2goe2V4cHI6IGV4cHIsIGFnZ0NvbnRleHQ6IENhbGNIZWxwZXIuYWdnRm4ocGFyZW50RXhwcil9KTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChDYWxjSGVscGVyLmZpZWxkRXhwcihleHByKSkge1xyXG4gICAgICAgICAgICAgICAgZGVwRXhwckxpc3QucHVzaCh7ZXhwcjogZXhwcn0pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKENhbGNIZWxwZXIuYmluYXJ5RXhwcihleHByKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZUV4cHJlc3Npb25zXyhleHByLmxlZnQsIGV4cHIsIGRlcEV4cHJMaXN0KTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmVFeHByZXNzaW9uc18oZXhwci5yaWdodCwgZXhwciwgZGVwRXhwckxpc3QpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKENhbGNIZWxwZXIuZm5FeHByKGV4cHIpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGV4cHIuYXJncztcclxuICAgICAgICAgICAgICAgIGlmIChhcmdzICYmIGFyZ3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaChhcmdzLCBmdW5jdGlvbihhcmdFeHByKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVFeHByZXNzaW9uc18oYXJnRXhwciwgZXhwciwgZGVwRXhwckxpc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gQ2FsY0hlbHBlcjtcclxuICAgIH0pKCk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDYWxjSGVscGVyO1xyXG59KSgpO1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXBwL3NjcmlwdHMvZ3JpZC9jYWxjL2NhbGNIZWxwZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqXG4gKiBTcHJlYWRKUyBMaWJyYXJ5IDEuMC4wXG4gKiBodHRwOi8vd2lqbW8uY29tL1xuICpcbiAqIENvcHlyaWdodChjKSBHcmFwZUNpdHksIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIFdpam1vIENvbW1lcmNpYWwgTGljZW5zZS4gQWxzbyBhdmFpbGFibGUgdW5kZXIgdGhlIEdOVSBHUEwgVmVyc2lvbiAzIGxpY2Vuc2UuXG4gKiBsaWNlbnNpbmdAd2lqbW8uY29tXG4gKiBodHRwOi8vd2lqbW8uY29tL3dpZGdldHMvbGljZW5zZS9cbiAqXG4gKlxuICoqL1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vdmFyIENhbGMgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuICAgIHZhciBDYWxjU291cmNlID0gcmVxdWlyZSgnLi9jYWxjU291cmNlJykuQ2FsY1NvdXJjZTtcbiAgICB2YXIgQ2FsY0NvbnRleHQgPSByZXF1aXJlKCcuL2NhbGNDb250ZXh0Jyk7XG4gICAgLy92YXIgQ2FsY01vZGVscyA9IHJlcXVpcmUoJy4vY2FsY01vZGVscycpO1xuICAgIHZhciBDYWxjSGVscGVyID0gcmVxdWlyZSgnLi9jYWxjSGVscGVyJyk7XG5cbiAgICB2YXIgQ2FsY01hbmFnZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIENhbGNNYW5hZ2VyKG5hbWUsIGRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjYWxjU291cmNlID0gbmV3IENhbGNTb3VyY2UobmFtZSwgZGF0YVNvdXJjZSk7XG4gICAgICAgICAgICBzZWxmLmNhbGNTb3VyY2VfID0gY2FsY1NvdXJjZTtcbiAgICAgICAgICAgIHNlbGYuZGF0YUNvbHVtbnNfID0gY2FsY1NvdXJjZS5nZXRNb2RlbChDYWxjSGVscGVyLkRBVEFfQ09MVU1OKTtcbiAgICAgICAgICAgIHNlbGYuY2FsY0NvbHVtbnNfID0gY2FsY1NvdXJjZS5nZXRNb2RlbChDYWxjSGVscGVyLkNBTENfQ09MVU1OKTtcbiAgICAgICAgICAgIHNlbGYuY2FsY1RhYmxlXyA9IGNhbGNTb3VyY2UuZ2V0TW9kZWwoQ2FsY0hlbHBlci5DQUxDX1RBQkxFKTtcbiAgICAgICAgICAgIHNlbGYuY2FsY0ZpZWxkc18gPSBjYWxjU291cmNlLmdldE1vZGVsKENhbGNIZWxwZXIuQ0FMQ19GSUVMRCk7XG4gICAgICAgICAgICBzZWxmLmNhbGNHcm91cEZpZWxkc18gPSBjYWxjU291cmNlLmdldE1vZGVsKENhbGNIZWxwZXIuQ0FMQ19HX0ZJRUxEKTtcbiAgICAgICAgfVxuXG4gICAgICAgIENhbGNNYW5hZ2VyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgICAgIGFkZENhbGNDb2x1bW46IGZ1bmN0aW9uKG5hbWUsIGZvcm11bGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGNDb2x1bW5zXy5hZGRDb2x1bW4obmFtZSwgZm9ybXVsYSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICByZW1vdmVDYWxjQ29sdW1uOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjQ29sdW1uc18ucmVtb3ZlQ29sdW1uKG5hbWUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0Q2FsY0NvbHVtblZhbHVlczogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGNTb3VyY2VfLmdldFZhbHVlcyhuYW1lKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldENhbGNDb2x1bW5WYWx1ZTogZnVuY3Rpb24obmFtZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjU291cmNlXy5nZXRWYWx1ZShuYW1lLCBpbmRleCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjYWxjdWxhdGVDb2x1bW46IGZ1bmN0aW9uKG5hbWUsIGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjQ29sdW1uc18uY2FsY3VsYXRlQ29sdW1uKG5hbWUsIGZvcmNlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldENhbGNSb3dJdGVtOiBmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjVGFibGVfLmdldENhbGNSb3dJdGVtKHJvdyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRSb3dJdGVtOiBmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGNUYWJsZV8uZ2V0Um93SXRlbShyb3cpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYWRkQ2FsY0ZpZWxkOiBmdW5jdGlvbihuYW1lLCBmb3JtdWxhKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsY0ZpZWxkc18uYWRkRmllbGQobmFtZSwgZm9ybXVsYSk7XG4gICAgICAgICAgICAgICAgdmFyIHVua25vd25FeHByQ29sdW1ucyA9IGdldFVua25vd25FeHByZXNzaW9uQ29sdW1ucy5jYWxsKHNlbGYpO1xuICAgICAgICAgICAgICAgIGlmICh1bmtub3duRXhwckNvbHVtbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2godW5rbm93bkV4cHJDb2x1bW5zLCBmdW5jdGlvbihjb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsY0NvbHVtbnNfLnVwZGF0ZUNvbHVtbkZvcm11bGEoY29sKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0Q2FsY0ZpZWxkVmFsdWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjRmllbGRzXy5nZXRWYWx1ZShuYW1lKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNhbGN1bGF0ZUZpZWxkOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsY0ZpZWxkc18uY2FsY3VsYXRlRmllbGQobmFtZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBhZGRDYWxjR3JvdXBGaWVsZDogZnVuY3Rpb24obmFtZSwgZm9ybXVsYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsY0dyb3VwRmllbGRzXy5hZGRGaWVsZChuYW1lLCBmb3JtdWxhKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldENhbGNHcm91cEZpZWxkVmFsdWU6IGZ1bmN0aW9uKG5hbWUsIGdyb3VwUGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGNHcm91cEZpZWxkc18uZ2V0VmFsdWUobmFtZSwgZ3JvdXBQYXRoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFBhcnNlckNvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2FsY0NvbnRleHQuUGFyc2VyQ29udGV4dCh0aGlzLmNhbGNTb3VyY2VfKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEV2YWx1YXRvckNvbnRleHQ6IGZ1bmN0aW9uKHJvdywgZ3JvdXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDYWxjQ29udGV4dC5FdmFsdWF0ZUNvbnRleHQodGhpcy5jYWxjU291cmNlXywgcm93LCBncm91cFBhdGgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0UGFyc2VyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjU291cmNlXy5nZXRQYXJzZXIoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEV2YWx1YXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsY1NvdXJjZV8uZ2V0RXZhbHVhdG9yKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXREaW1lbnNpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGNTb3VyY2VfLmdldERpbWVuc2lvbigpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZmluZERhdGFDb2x1bW46IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhQ29sdW1uc18uZmluZERhdGFDb2x1bW4obmFtZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBmaW5kQ2FsY0NvbHVtbjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGNDb2x1bW5zXy5maW5kQ2FsY0NvbHVtbihuYW1lKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGZpbmRDb2x1bW46IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjU291cmNlXy5maW5kQ29sdW1uKG5hbWUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZmluZENhbGNGaWVsZDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGNGaWVsZHNfLmZpbmRGaWVsZChuYW1lKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGZpbmRDYWxjR3JvdXBGaWVsZDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGNHcm91cEZpZWxkc18uZmluZEZpZWxkKG5hbWUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYWRkUm93SXRlbTogZnVuY3Rpb24oaW5kZXgsIGl0ZW0pIHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlbW92ZVJvd0l0ZW06IGZ1bmN0aW9uKGluZGV4KSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBncm91cDogZnVuY3Rpb24oZ2RzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjU291cmNlXy5ncm91cChnZHMpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0R3JvdXBzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhU291cmNlLmdldEdyb3Vwcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldEdyb3VwcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGRpcnR5Q29sdW1uOiBmdW5jdGlvbihjb2x1bW4sIGluZGV4LCBuZXdGb3JtdWxhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjU291cmNlXy5kaXJ0eUNvbHVtbihjb2x1bW4sIGluZGV4LCBuZXdGb3JtdWxhKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGRpcnR5RmllbGQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGNTb3VyY2VfLmRpcnR5RmllbGQobmFtZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRDYWxjU291cmNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjU291cmNlXztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBnZXRVbmtub3duRXhwcmVzc2lvbkNvbHVtbnMoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY29sdW1ucyA9IFtdO1xuICAgICAgICAgICAgdmFyIGNhbGNDb2x1bW5zID0gc2VsZi5jYWxjQ29sdW1uc18uZ2V0Q29sdW1ucygpO1xuICAgICAgICAgICAgaWYgKGNhbGNDb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKGNhbGNDb2x1bW5zLCBmdW5jdGlvbihjYWxjQ29sKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBjb250YWluc1Vua25vd25FeHByZXNzaW9uLmNhbGwoc2VsZiwgY2FsY0NvbC5leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1ucy5wdXNoKGNhbGNDb2wubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb2x1bW5zO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29udGFpbnNVbmtub3duRXhwcmVzc2lvbihleHByKSB7XG4gICAgICAgICAgICBpZiAoIWV4cHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQ2FsY0hlbHBlci51bmtub3dFeHByKGV4cHIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKENhbGNIZWxwZXIuYmluYXJ5RXhwcihleHByKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb250YWluc1Vua25vd25FeHByZXNzaW9uKGV4cHIubGVmdCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zVW5rbm93bkV4cHJlc3Npb24oZXhwci5yaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQ2FsY0hlbHBlci5mbkV4cHIoZXhwcikpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGV4cHIuYXJncztcbiAgICAgICAgICAgICAgICBpZiAoYXJncyAmJiBhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluc1Vua25vd25FeHByZXNzaW9uKGFyZ3NbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQ2FsY01hbmFnZXI7XG4gICAgfSkoKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQ2FsY01hbmFnZXI7XG59KSgpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2FwcC9zY3JpcHRzL2dyaWQvY2FsYy9jYWxjTWFuYWdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICpcbiAqIFNwcmVhZEpTIExpYnJhcnkgMS4wLjBcbiAqIGh0dHA6Ly93aWptby5jb20vXG4gKlxuICogQ29weXJpZ2h0KGMpIEdyYXBlQ2l0eSwgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgV2lqbW8gQ29tbWVyY2lhbCBMaWNlbnNlLiBBbHNvIGF2YWlsYWJsZSB1bmRlciB0aGUgR05VIEdQTCBWZXJzaW9uIDMgbGljZW5zZS5cbiAqIGxpY2Vuc2luZ0B3aWptby5jb21cbiAqIGh0dHA6Ly93aWptby5jb20vd2lkZ2V0cy9saWNlbnNlL1xuICpcbiAqXG4gKiovXG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy92YXIgQ2FsYyA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG4gICAgdmFyIENhbGNIZWxwZXIgPSByZXF1aXJlKCcuL2NhbGNIZWxwZXInKTtcbiAgICB2YXIgQ2FsY0NvbnRleHQgPSByZXF1aXJlKCcuL2NhbGNDb250ZXh0Jyk7XG4gICAgLy92YXIgZ2NVdGlscyA9IHJlcXVpcmUoJy4uL2djVXRpbHMnKTtcbiAgICB2YXIgQ2FsY01vZGVscyA9IHt9O1xuICAgIHZhciBvYmplY3REZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuICAgIHZhciBDYWxjR3JvdXBfID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBDYWxjR3JvdXBfKHRhYmxlLCBuYW1lLCBsZXZlbCwgaXNCb3R0b21MZXZlbCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgc2VsZi5sZXZlbCA9IGxldmVsO1xuICAgICAgICAgICAgc2VsZi50YWJsZV8gPSB0YWJsZTtcbiAgICAgICAgICAgIHNlbGYuaXNCb3R0b21MZXZlbCA9IGlzQm90dG9tTGV2ZWw7XG4gICAgICAgICAgICBzZWxmLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgaWYgKGlzQm90dG9tTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBzZWxmLml0ZW1zID0gW107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuZ3JvdXBzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBDYWxjR3JvdXBfLnByb3RvdHlwZSA9IHtcbiAgICAgICAgICAgIGdldEl0ZW06IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBib3R0b21Hcm91cEluZm8gPSBzZWxmLnNlYXJjaENoaWxkR3JvdXAoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChib3R0b21Hcm91cEluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYucm9vdE5vZGVfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5yb290Tm9kZV8uZ2V0SXRlbShpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi50YWJsZV8uZ2V0Um93SXRlbV8oYm90dG9tR3JvdXBJbmZvLmdyb3VwLml0ZW1zW2JvdHRvbUdyb3VwSW5mby5yZWxhdGl2ZUluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRJbmRleE1hcHBpbmdJbmRleGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgYkdyb3VwcyA9IHNlbGYuZ2V0Qm90dG9tR3JvdXBzKCk7XG4gICAgICAgICAgICAgICAgaWYgKGJHcm91cHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZ2kgPSAwLCBnTGVuID0gYkdyb3Vwcy5sZW5ndGg7IGdpIDwgZ0xlbjsgZ2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJHcm91ZyA9IGJHcm91cHNbZ2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJHcm91Zy5pdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ZXMucHVzaChiR3JvdWcuaXRlbXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleGVzO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0SXRlbXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgYkdyb3VwcyA9IHNlbGYuZ2V0Qm90dG9tR3JvdXBzKCk7XG4gICAgICAgICAgICAgICAgaWYgKGJHcm91cHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZ2kgPSAwLCBnTGVuID0gYkdyb3Vwcy5sZW5ndGg7IGdpIDwgZ0xlbjsgZ2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJHcm91ZyA9IGJHcm91cHNbZ2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJHcm91Zy5pdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goc2VsZi50YWJsZV8uZ2V0Um93SXRlbV8oYkdyb3VnLml0ZW1zW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdG9Tb3VyY2VJbmRleDogZnVuY3Rpb24obG9jYWxJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgYm90dG9tR3JvdXBJbmZvID0gc2VsZi5zZWFyY2hDaGlsZEdyb3VwKGxvY2FsSW5kZXgpO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleE1hcHBpbmdJbmRleCA9IGJvdHRvbUdyb3VwSW5mbyAmJiBib3R0b21Hcm91cEluZm8uZ3JvdXAuaXRlbXNbYm90dG9tR3JvdXBJbmZvLnJlbGF0aXZlSW5kZXhdO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleE1hcHBpbmdzID0gc2VsZi50YWJsZV8uaW5kZXhNYXBwaW5nc187XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4TWFwcGluZ3MgJiYgaW5kZXhNYXBwaW5nSW5kZXggPj0gMCAmJiBpbmRleE1hcHBpbmdJbmRleCA8IGluZGV4TWFwcGluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleE1hcHBpbmdzW2luZGV4TWFwcGluZ0luZGV4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4TWFwcGluZ0luZGV4O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaGllcmFyY2h5OiBmdW5jdGlvbihoaWVyYXJjaHlJbmZvKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IHNlbGYudGFibGVfO1xuICAgICAgICAgICAgICAgIHNlbGYuaGllcmFyY2h5SW5mb18gPSBoaWVyYXJjaHlJbmZvO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWxmLnJvb3ROb2RlXztcbiAgICAgICAgICAgICAgICBpZiAoIWhpZXJhcmNoeUluZm8gfHwgIWhpZXJhcmNoeUluZm8uaGFzT3duUHJvcGVydHkoJ3BhcmVudEZpZWxkJykgfHwgIWhpZXJhcmNoeUluZm8uaGFzT3duUHJvcGVydHkoJ2tleUZpZWxkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBjcmVhdGVHcm91cHNGb3JUcmVlXy5jYWxsKHNlbGYsIHtmaWVsZDogaGllcmFyY2h5SW5mby5wYXJlbnRGaWVsZH0pO1xuICAgICAgICAgICAgICAgIGlmIChyb290ICYmIHJvb3QuZ3JvdXBzICYmIHJvb3QuZ3JvdXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwcyA9IHJvb3QuZ3JvdXBzO1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5Q29sT2JqID0gc2VsZi50YWJsZV8uZmluZENvbHVtbihoaWVyYXJjaHlJbmZvLmtleUZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0R3JvdXAgPSBfLmZpbmQoZ3JvdXBzLCBfLm1hdGNoZXNQcm9wZXJ0eSgnbmFtZScsIHVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpcnN0R3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucm9vdE5vZGVfID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciByb290Tm9kZSA9IG5ldyBDYWxjTm9kZV8odGFibGUsIC0xLCBudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIENhbGNUYWJsZU1vZGVsLmNyZWF0ZVRyZWVfLmNhbGwodGFibGUsIGZpcnN0R3JvdXAsIHJvb3ROb2RlLCBncm91cHMsIGtleUNvbE9iaik7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucm9vdE5vZGVfID0gcm9vdE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnNvcnRJbmZvc18pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIENhbGNUYWJsZU1vZGVsLnNvcnROb2RlXy5jYWxsKHRhYmxlLCBzZWxmLnJvb3ROb2RlXywgc2VsZi5zb3J0SW5mb3NfKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5yb290Tm9kZV87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZmluZE5vZGU6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnJvb3ROb2RlXykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5yb290Tm9kZV8uZmluZE5vZGUoaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vdG9Mb2NhbEluZGV4OiBmdW5jdGlvbihzb3VyY2VJbmRleCkge1xuICAgICAgICAgICAgLy8gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgLy8gICAgdmFyIG1hcHBpbmdJbmRleGVzID0gc2VsZi5nZXRJbmRleE1hcHBpbmdJbmRleGVzKCk7XG4gICAgICAgICAgICAvLyAgICB2YXIgc291cmNlSW5kZXhlcyA9IF8ubWFwKG1hcHBpbmdJbmRleGVzLCBmdW5jdGlvbihtYXBwaW5nSW5kZXgpIHtcbiAgICAgICAgICAgIC8vICAgICAgICByZXR1cm4gc2VsZi50YWJsZV8uaW5kZXhNYXBwaW5nc1ttYXBwaW5nSW5kZXhdO1xuICAgICAgICAgICAgLy8gICAgfSk7XG4gICAgICAgICAgICAvLyAgICByZXR1cm4gc291cmNlSW5kZXhlcy5pbmRleE9mKHNvdXJjZUluZGV4KTtcbiAgICAgICAgICAgIC8vfSxcblxuICAgICAgICAgICAgLy90b0dsb2JhbEluZGV4OiBmdW5jdGlvbihsb2NhbEluZGV4KSB7XG4gICAgICAgICAgICAvLyAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAvLyAgICBpZiAobG9jYWxJbmRleCA+PSBzZWxmLml0ZW1Db3VudCB8fCBsb2NhbEluZGV4IDwgMCkge1xuICAgICAgICAgICAgLy8gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgLy8gICAgfVxuICAgICAgICAgICAgLy8gICAgaWYgKHNlbGYubGV2ZWwgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgcmV0dXJuIGxvY2FsSW5kZXg7XG4gICAgICAgICAgICAvLyAgICB9XG4gICAgICAgICAgICAvLyAgICB2YXIgZ2xvYmFsSW5kZXggPSBsb2NhbEluZGV4O1xuICAgICAgICAgICAgLy8gICAgdmFyIGN1cnJHcm91cCA9IHNlbGY7XG4gICAgICAgICAgICAvLyAgICB2YXIgZ3JvdXBzID0gW107XG4gICAgICAgICAgICAvLyAgICB2YXIgdGVtcEdyb3VwO1xuICAgICAgICAgICAgLy8gICAgdmFyIHBhcmVudCA9IGN1cnJHcm91cC5wYXJlbnQ7XG4gICAgICAgICAgICAvLyAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgICAvLyAgICAgICAgZ3JvdXBzID0gcGFyZW50Lmdyb3VwcztcbiAgICAgICAgICAgIC8vICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgICAgIHRlbXBHcm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgaWYgKHRlbXBHcm91cC5uYW1lID09PSBjdXJyR3JvdXAubmFtZSkge1xuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICBnbG9iYWxJbmRleCArPSB0ZW1wR3JvdXAuaXRlbUNvdW50O1xuICAgICAgICAgICAgLy8gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAgICAgICAgfVxuICAgICAgICAgICAgLy8gICAgICAgIGN1cnJHcm91cCA9IHBhcmVudDtcbiAgICAgICAgICAgIC8vICAgICAgICBwYXJlbnQgPSBjdXJyR3JvdXAucGFyZW50O1xuICAgICAgICAgICAgLy8gICAgfVxuICAgICAgICAgICAgLy8gICAgcmV0dXJuIGdsb2JhbEluZGV4O1xuICAgICAgICAgICAgLy99LFxuXG4gICAgICAgICAgICBzZWFyY2hDaGlsZEdyb3VwOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChpIDwgMCB8fCBpID49IHRoaXMuaXRlbUNvdW50IHx8ICFfLmlzTnVtYmVyKGkpIHx8IF8uaXNOYU4oaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQm90dG9tTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtncm91cDogc2VsZiwgcmVsYXRpdmVJbmRleDogaX07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vdEJvdHRvbSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cCA9IHNlbGY7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZEdyb3VwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChub3RCb3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkR3JvdXAgPSBncm91cC5ncm91cHNbZ3JvdXBJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGl0ZW1Db3VudCA9IGNoaWxkR3JvdXAuaXRlbUNvdW50KSA+IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cCA9IGNoaWxkR3JvdXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90Qm90dG9tID0gIWdyb3VwLmlzQm90dG9tTGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgLT0gaXRlbUNvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrZ3JvdXBJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2dyb3VwOiBncm91cCwgcmVsYXRpdmVJbmRleDogaX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc29ydFRyZWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgYm90dG9tR3JvdXBzID0gc2VsZi5nZXRCb3R0b21Hcm91cHMoKTtcbiAgICAgICAgICAgICAgICBpZiAoYm90dG9tR3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaChib3R0b21Hcm91cHMsIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXAucm9vdE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cC5yb290Tm9kZS5zb3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEJvdHRvbUdyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEJvdHRvbUdyb3Vwc18odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjYWxjR3JvdXBQcm90byA9IENhbGNHcm91cF8ucHJvdG90eXBlO1xuXG4gICAgICAgIG9iamVjdERlZmluZVByb3BlcnR5KGNhbGNHcm91cFByb3RvLCAnaXRlbUNvdW50Jywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGJvdHRvbUdyb3VwcyA9IGdldEJvdHRvbUdyb3Vwc18oc2VsZik7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1Db3VudCA9IDA7XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKGJvdHRvbUdyb3VwcywgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSB3aGVuIGdyb3VwIGhhcyBvd24gcHJvcGVydHkgJ3Jvb3ROb2RlXycgbWVhbnMgdGhlIGdyb3VwIGlzIGhpZXJhcmNoaWVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChncm91cC5oYXNPd25Qcm9wZXJ0eSgncm9vdE5vZGVfJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChncm91cC5yb290Tm9kZSkgeyAvLyBpdCBtZWFucyB0aGF0IHRoZSBncm91cCBpcyBoaWVyYXJjaGllZCBzdWNjZXNzZnVsbHksIGFsbCBub2RlcyBleGNlcHRpbmcgdGhlIHJvb3Qgbm9kZSBoYXZlIGl0cyBwYXJlbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUNvdW50ICs9IGdyb3VwLnJvb3ROb2RlLm5vZGVDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIGl0IG1lYW5zIHRoYXQgdGhlIGdyb3VwIGlzIGhpZXJhcmNoaWVkIGZhaWxlZCwgdGhlIGl0ZW1zIGFyZSBub3QgYmFkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Db3VudCArPSBncm91cC5pdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbUNvdW50O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2JqZWN0RGVmaW5lUHJvcGVydHkoY2FsY0dyb3VwUHJvdG8sICdyb290Tm9kZScsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdE5vZGVfO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Qm90dG9tR3JvdXBzXyhncm91cCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgaWYgKGdyb3VwLmlzQm90dG9tTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2dyb3VwXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGdyb3VwLmdyb3Vwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ViR3JvdXBzID0gZ2V0Qm90dG9tR3JvdXBzXyhncm91cC5ncm91cHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHN1Ykdyb3Vwcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUdyb3Vwc0ZvclRyZWVfKHRyZWVHcm91cEluZm8pIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGlmICghc2VsZi5pc0JvdHRvbUxldmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcm9vdCA9IHt9O1xuICAgICAgICAgICAgdmFyIHJvd0NvdW50ID0gc2VsZi5pdGVtcy5sZW5ndGg7IC8vIGhlcmUgbXVzdCB1c2Ugc2VsZi5pdGVtcy5sZW5ndGgsIGNhbiBub3QgdXNlIHNlbGYuaXRlbUNvdW50XG4gICAgICAgICAgICByb290Lml0ZW1Db3VudCA9IHJvd0NvdW50O1xuICAgICAgICAgICAgdmFyIGdyb3VwcztcbiAgICAgICAgICAgIHZhciBwYXJlbnQ7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIHZhciBuYW1lO1xuICAgICAgICAgICAgdmFyIGdyb3VwO1xuICAgICAgICAgICAgdmFyIGNvbE9iaiA9IHNlbGYudGFibGVfLmZpbmRDb2x1bW4odHJlZUdyb3VwSW5mby5maWVsZCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcm93Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIGdyb3VwcyA9IHJvb3QuZ3JvdXBzO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHJvb3Q7XG5cbiAgICAgICAgICAgICAgICBuYW1lID0gZ2V0R3JvdXBOYW1lRnJvbUl0ZW1JbmRleF8uY2FsbChzZWxmLCBjb2xPYmosIGkpO1xuICAgICAgICAgICAgICAgIGdyb3VwID0gZ2V0R3JvdXBfLmNhbGwoc2VsZiwgcGFyZW50LCBuYW1lKTtcbiAgICAgICAgICAgICAgICArK2dyb3VwLml0ZW1Db3VudDtcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIG9uIHRvIHRoZSBuZXh0IGdyb3VwXG4gICAgICAgICAgICAgICAgZ3JvdXAucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IGdyb3VwO1xuICAgICAgICAgICAgICAgIGdyb3VwcyA9IGdyb3VwLmdyb3VwcztcblxuICAgICAgICAgICAgICAgIGdyb3VwLml0ZW1zLnB1c2goc2VsZi5pdGVtc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEdyb3VwTmFtZUZyb21JdGVtSW5kZXhfKGNvbE9iaiwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGlmIChjb2xPYmopIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZV8uY2FsbChzZWxmLCBjb2xPYmosIGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEdyb3VwXyhwYXJlbnQsIG5hbWUpIHtcbiAgICAgICAgICAgIGlmICghcGFyZW50Lmdyb3Vwcykge1xuICAgICAgICAgICAgICAgIHBhcmVudC5ncm91cHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBncm91cHMgPSBwYXJlbnQuZ3JvdXBzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBzW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdyb3Vwc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBub3QgZm91bmQsIGNyZWF0ZSBuZXcgZ3JvdXBcbiAgICAgICAgICAgIHZhciBncm91cCA9IHtuYW1lOiBuYW1lLCBpdGVtQ291bnQ6IDAsIGl0ZW1zOiBbXX07XG4gICAgICAgICAgICBncm91cHMucHVzaChncm91cCk7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRWYWx1ZV8oY29sT2JqLCBsb2NhbEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgdGFibGUgPSBzZWxmLnRhYmxlXztcbiAgICAgICAgICAgIHZhciBpbmRleE1hcHBpbmdzID0gdGFibGUuaW5kZXhNYXBwaW5nc187XG4gICAgICAgICAgICB2YXIgaW5kZXhNYXBwaW5nSW5kZXggPSBzZWxmLml0ZW1zW2xvY2FsSW5kZXhdO1xuICAgICAgICAgICAgdmFyIHNyY0luZGV4ID0gaW5kZXhNYXBwaW5nSW5kZXg7XG4gICAgICAgICAgICBpZiAoaW5kZXhNYXBwaW5ncyAmJiBpbmRleE1hcHBpbmdJbmRleCA+PSAwICYmIGluZGV4TWFwcGluZ0luZGV4IDwgaW5kZXhNYXBwaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzcmNJbmRleCA9IGluZGV4TWFwcGluZ3NbaW5kZXhNYXBwaW5nSW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgaWYgKGNvbE9iai50eXBlID09PSBDYWxjSGVscGVyLkRBVEFfQ09MVU1OKSB7XG4gICAgICAgICAgICAgICAgLy92YWx1ZSA9IHNlbGYuZGF0YUNvbHVtbnNfLnNvdXJjZUNvbGxlY3Rpb25baW5kZXhdW2NvbE9iai5uYW1lXTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRhYmxlLmRhdGFDb2x1bW5zXy5nZXRWYWx1ZShzcmNJbmRleCwgY29sT2JqKTtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGNhbGMgY29sdW1uXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0YWJsZS5jYWxjQ29sdW1uc18uZ2V0VmFsdWUoY29sT2JqLCBzcmNJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQ2FsY0dyb3VwXztcbiAgICB9KSgpO1xuICAgIENhbGNNb2RlbHMuQ2FsY0dyb3VwXyA9IENhbGNHcm91cF87XG5cbiAgICB2YXIgQ2FsY05vZGVfID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBDYWxjTm9kZV8odGFibGUsIGl0ZW1JbmRleCwgcGFyZW50LCBjb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHNlbGYuaXRlbUluZGV4ID0gaXRlbUluZGV4O1xuICAgICAgICAgICAgc2VsZi5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgc2VsZi5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICBzZWxmLmxldmVsID0gcGFyZW50ICYmIHBhcmVudC5oYXNPd25Qcm9wZXJ0eSgnbGV2ZWwnKSA/IHBhcmVudC5sZXZlbCArIDEgOiAtMTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGNvbGxhcHNlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbGxhcHNlZCA9IGNvbGxhcHNlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vfSBlbHNlIHtcbiAgICAgICAgICAgIC8vICAgIHNlbGYuY29sbGFwc2VkID0gZmFsc2U7XG4gICAgICAgICAgICAvL31cbiAgICAgICAgICAgIHNlbGYudGFibGVfID0gdGFibGU7XG4gICAgICAgIH1cblxuICAgICAgICBDYWxjTm9kZV8ucHJvdG90eXBlID0ge1xuICAgICAgICAgICAgZ2V0SXRlbTogZnVuY3Rpb24ocmVsYXRpdmVJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAocmVsYXRpdmVJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gZmluZE5vZGVfLmNhbGwoc2VsZiwgc2VsZiwgcmVsYXRpdmVJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi50YWJsZV8uZ2V0Um93SXRlbV8obm9kZS5pdGVtSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYudGFibGVfLmdldFJvd0l0ZW1fKHNlbGYuaXRlbUluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0SXRlbXM6IGZ1bmN0aW9uKG9wdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgYXJnID0ge307XG4gICAgICAgICAgICAgICAgYXJnLmNvbnRhaW5Db2xsYXBzZWQgPSBvcHRpb24gPyAhIW9wdGlvbi5jb2xsYXBzZWQgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICBhcmcuc3RhcnQgPSBvcHRpb24gJiYgb3B0aW9uLnN0YXJ0ID8gb3B0aW9uLnN0YXJ0IDogMDtcbiAgICAgICAgICAgICAgICBhcmcuZW5kID0gb3B0aW9uICYmIG9wdGlvbi5lbmQgPyBvcHRpb24uZW5kIDogTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSB0cmF2ZWxOb2RlXyhzZWxmLCBhcmcpO1xuICAgICAgICAgICAgICAgIHZhciBpdGVtcyA9IF8ubWFwKG5vZGVzLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmdldEl0ZW0oKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXhwYW5kQWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRlTm9kZXNfKHRoaXMsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jb2xsYXBzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb2xsYXBzZUFsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0ZU5vZGVzXyh0aGlzLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY29sbGFwc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaW5kTm9kZTogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmluZE5vZGVfKHRoaXMsIGluZGV4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRJbmRleE1hcHBpbmdJbmRleGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgb3BlcmF0ZU5vZGVzXyh0aGlzLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUuaXRlbUluZGV4KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvU291cmNlSW5kZXg6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gc2VsZi5maW5kTm9kZShpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4TWFwcGluZ3MgPSBzZWxmLnRhYmxlXy5pbmRleE1hcHBpbmdzXztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4TWFwcGluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleE1hcHBpbmdzW25vZGUuaXRlbUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5pdGVtSW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IHRoaXMudGFibGVfO1xuICAgICAgICAgICAgICAgIENhbGNUYWJsZU1vZGVsLnNvcnROb2RlXy5jYWxsKHRhYmxlLCB0aGlzLCB0YWJsZS5zb3J0SW5mb3NfKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBvYmplY3REZWZpbmVQcm9wZXJ0eShDYWxjTm9kZV8ucHJvdG90eXBlLCAnbm9kZUNvdW50Jywge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEdldHMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgdGhpcyBncm91cCdzIHN1Ymdyb3Vwcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICAgICAgICAgICAgb3BlcmF0ZU5vZGVzXyh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcisrO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb3VudGVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gZmluZE5vZGVfKG5vZGUsIHNlYXJjaEluZGV4LCBjdXJyZW50SW5kZXgsIGFsbCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEluZGV4ID0gbm9kZS5sZXZlbCA9PT0gLTEgPyAtMSA6IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gc2VhcmNoSW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGFsbCB8fCAhbm9kZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZmluZE5vZGVfKG5vZGUuY2hpbGRyZW5baV0sIHNlYXJjaEluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF8uaXNOdW1iZXIocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50SW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICBDYWxjTm9kZV8uZmluZE5vZGVfID0gZmluZE5vZGVfO1xuXG4gICAgICAgIGZ1bmN0aW9uIHRyYXZlbE5vZGVfKG5vZGUsIGFyZywgYWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICAgICAgICAgIGlmICghYXJnLmhhc093blByb3BlcnR5KCdjdXJyZW50SW5kZXgnKSkge1xuICAgICAgICAgICAgICAgIGFyZy5jdXJyZW50SW5kZXggPSBub2RlLmxldmVsID09PSAtMSA/IC0xIDogMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJnLmN1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IGFyZy5jdXJyZW50SW5kZXg7XG4gICAgICAgICAgICBpZiAoY3VycmVudEluZGV4ID4gYXJnLmVuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPj0gYXJnLnN0YXJ0ICYmIG5vZGUubGV2ZWwgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbihub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJnLmNvbnRhaW5Db2xsYXBzZWQgfHwgIW5vZGUuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKG5vZGUuY2hpbGRyZW4sIGZ1bmN0aW9uKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlcyA9IHRyYXZlbE5vZGVfKGNoaWxkTm9kZSwgYXJnLCBhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlcyA9IG5vZGVzLmNvbmNhdChjaGlsZE5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb3BlcmF0ZU5vZGVzXyhub2RlLCBhY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSB7fTtcbiAgICAgICAgICAgIGFyZy5jb250YWluQ29sbGFwc2VkID0gZmFsc2U7XG4gICAgICAgICAgICBhcmcuc3RhcnQgPSAwO1xuICAgICAgICAgICAgYXJnLmVuZCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICB0cmF2ZWxOb2RlXyhub2RlLCBhcmcsIGFjdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBDYWxjTm9kZV8ub3BlcmF0ZU5vZGVzXyA9IG9wZXJhdGVOb2Rlc187XG5cbiAgICAgICAgcmV0dXJuIENhbGNOb2RlXztcbiAgICB9KSgpO1xuICAgIENhbGNNb2RlbHMuQ2FsY05vZGVfID0gQ2FsY05vZGVfO1xuXG4gICAgdmFyIENhbGNUYWJsZU1vZGVsID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBDYWxjVGFibGVNb2RlbChjYWxjU291cmNlLCBkYXRhQ29sdW1ucywgY2FsY0NvbHVtbnMpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGlmICghZGF0YUNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmNhbGNTb3VyY2VfID0gY2FsY1NvdXJjZTtcbiAgICAgICAgICAgIHNlbGYuZGF0YUNvbHVtbnNfID0gZGF0YUNvbHVtbnM7XG4gICAgICAgICAgICBzZWxmLmNhbGNDb2x1bW5zXyA9IGNhbGNDb2x1bW5zO1xuICAgICAgICAgICAgc2VsZi5jb2x1bW5zXyA9IF8ubWFwKGRhdGFDb2x1bW5zLmNvbHVtbnMsIGZ1bmN0aW9uKGNvbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGNvbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZDogY29sLmZpZWxkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBDYWxjSGVscGVyLkRBVEFfQ09MVU1OLFxuICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogY29sLmRhdGFUeXBlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2xlYXJGaWx0ZXJTdGF0ZXNfLmNhbGwoc2VsZik7XG4gICAgICAgICAgICBzZWxmLmluZGV4TWFwcGluZ3NfID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYuc29ydFNlbnNpdGl2ZV8gPSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGYuZ3JvdXBTZW5zaXRpdmVfID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBDYWxjVGFibGVNb2RlbC5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmluZGV4TWFwcGluZ3NfKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmluZGV4TWFwcGluZ3NfLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5kYXRhQ29sdW1uc18uZ2V0RGltZW5zaW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZmlsdGVyOiBmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHNlbGYuZmlsdGVyRXhwcl8gPSBleHByZXNzaW9uO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZWRHcm91cEluZm9zID0gc2VsZi5ncm91cEluZm9zXztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkU29ydEluZm9zID0gc2VsZi5zb3J0SW5mb3NfO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZWRIaWVyYWNoeUluZm8gPSBzZWxmLmhpZXJhcmNoeUluZm9fO1xuICAgICAgICAgICAgICAgIGNsZWFyQWxsU3RhdGVzXy5jYWxsKHNlbGYpO1xuICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYWxjU291cmNlID0gc2VsZi5jYWxjU291cmNlXztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZXIgPSBjYWxjU291cmNlLmdldFBhcnNlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlckNvbnRleHQgPSBjYWxjU291cmNlLmdldFBhcnNlckNvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBldmFsdWF0b3IgPSBjYWxjU291cmNlLmdldEV2YWx1YXRvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2YWx1YXRvckNvbnRleHQgPSBjYWxjU291cmNlLmdldEV2YWx1YXRvckNvbnRleHQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cHIgPSBwYXJzZXIucGFyc2UoZXhwcmVzc2lvbiwgcGFyc2VyQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZpbHRlclN0YXRlc18gPSBldmFsdWF0b3IuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHIsIGV2YWx1YXRvckNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJGaWx0ZXJTdGF0ZXNfLmNhbGwoc2VsZik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdXBkYXRlU3RhdGVzT25TZXRGaWx0ZXJTdGF0ZXNfLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkSGllcmFjaHlJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZWRHcm91cEluZm9zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmhpZXJhcmNoeUluZm9fID0gY2FjaGVkSGllcmFjaHlJbmZvO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGllcmFjaHkgd2lsbCBiZSBhY2NvbXBsaXNoZWQgaW4gZ3JvdXBcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZ3JvdXAoY2FjaGVkR3JvdXBJbmZvcyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmhpZXJhcmNoeShjYWNoZWRIaWVyYWNoeUluZm8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZFNvcnRJbmZvcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zb3J0KGNhY2hlZFNvcnRJbmZvcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZEdyb3VwSW5mb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZ3JvdXAoY2FjaGVkR3JvdXBJbmZvcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzb3J0OiBmdW5jdGlvbihzb3J0SW5mb3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgc2VsZi5zb3J0SW5mb3NfID0gc29ydEluZm9zO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZWRHZHM7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBubyBzb3J0SW5mbywgdGhlbiBtdXN0IHJlc2V0IHRoZSBpbmRleE1hcHBpbmdzXG4gICAgICAgICAgICAgICAgaWYgKCFzb3J0SW5mb3MgfHwgc29ydEluZm9zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNvcnRJbmZvc18gPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVN0YXRlc09uU2V0RmlsdGVyU3RhdGVzXy5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmhpZXJhcmNoeUluZm9fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtdXN0IHJlc3RvcmUgdGhlIG5vZGUgY29sbGFwc2VkIHN0YXR1cyBhZnRlciByZSBoaWVyYXJjaHlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWNoZWROb2RlU3RhdHVzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5ncm91cHNfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvdHRvbUdyb3VwcyA9IHNlbGYuZ3JvdXBzXy5nZXRCb3R0b21Hcm91cHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm90dG9tR3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaChib3R0b21Hcm91cHMsIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXAucm9vdE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYWxjTm9kZV8ub3BlcmF0ZU5vZGVzXyhncm91cC5yb290Tm9kZSwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWROb2RlU3RhdHVzW25vZGUudmFsdWVdID0gbm9kZS5jb2xsYXBzZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYWxjTm9kZV8ub3BlcmF0ZU5vZGVzXyhncm91cC5yb290Tm9kZSwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZWROb2RlU3RhdHVzLmhhc093blByb3BlcnR5KG5vZGUudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY29sbGFwc2VkID0gY2FjaGVkTm9kZVN0YXR1c1tub2RlLnZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkR2RzID0gc2VsZi5ncm91cEluZm9zXztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhckdyb3VwU3RhdGVzXy5jYWxsKHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZ3JvdXAoY2FjaGVkR2RzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbUdyb3VwcyA9IHNlbGYuZ3JvdXBzXy5nZXRCb3R0b21Hcm91cHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm90dG9tR3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaChib3R0b21Hcm91cHMsIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXAucm9vdE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYWxjTm9kZV8ub3BlcmF0ZU5vZGVzXyhncm91cC5yb290Tm9kZSwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVkTm9kZVN0YXR1cy5oYXNPd25Qcm9wZXJ0eShub2RlLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jb2xsYXBzZWQgPSBjYWNoZWROb2RlU3RhdHVzW25vZGUudmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYucm9vdE5vZGVfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbGNOb2RlXy5vcGVyYXRlTm9kZXNfKHNlbGYucm9vdE5vZGVfLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWROb2RlU3RhdHVzW25vZGUudmFsdWVdID0gbm9kZS5jb2xsYXBzZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmhpZXJhcmNoeShzZWxmLmhpZXJhcmNoeUluZm9fKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYWxjTm9kZV8ub3BlcmF0ZU5vZGVzXyhzZWxmLnJvb3ROb2RlXywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVkTm9kZVN0YXR1cy5oYXNPd25Qcm9wZXJ0eShub2RlLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jb2xsYXBzZWQgPSBjYWNoZWROb2RlU3RhdHVzW25vZGUudmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5oaWVyYXJjaHlJbmZvXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuZ3JvdXBzXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZ3JvdXBzXy5zb3J0VHJlZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0Tm9kZV8uY2FsbChzZWxmLCBzZWxmLnJvb3ROb2RlXywgc29ydEluZm9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3NlbGYuaGllcmFyY2h5KGNhY2hlZEhpZXJhY2h5SW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWRHZHMgPSBzZWxmLmdyb3VwSW5mb3NfO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJHcm91cFN0YXRlc18uY2FsbChzZWxmKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvcnRNYXBwaW5ncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5pbmRleE1hcHBpbmdzXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHNlbGYuaW5kZXhNYXBwaW5nc18ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ydE1hcHBpbmdzW2ldID0gc2VsZi5pbmRleE1hcHBpbmdzX1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHNlbGYuZ2V0RGltZW5zaW9uKCk7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0TWFwcGluZ3NbaV0gPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvcnRDb2x1bW5zID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2goc29ydEluZm9zLCBmdW5jdGlvbihzb3J0SW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc29ydEluZm8uaGFzT3duUHJvcGVydHkoJ2FzY2VuZGluZycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRJbmZvLmFzY2VuZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ydEluZm8uYXNjZW5kaW5nID0gISFzb3J0SW5mby5hc2NlbmRpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRDb2x1bW5zW3NvcnRJbmZvLmZpZWxkXSA9IHNlbGYuZGF0YUNvbHVtbnNfLmZpbmRDb2x1bW4oc29ydEluZm8uZmllbGQpIHx8IHNlbGYuY2FsY0NvbHVtbnNfLmZpbmRDb2x1bW4oc29ydEluZm8uZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0TWFwcGluZ3Muc29ydChmdW5jdGlvbihpbmRleDEsIGluZGV4Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBzb3J0TGVuID0gc29ydEluZm9zLmxlbmd0aDsgaSA8IHNvcnRMZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZCA9IHNvcnRJbmZvc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvcnRDb2wgPSBzb3J0Q29sdW1uc1tzZC5maWVsZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2MTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc29ydENvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy92MSA9IHNlbGYuZGF0YUNvbHVtbnNfLnNvdXJjZUNvbGxlY3Rpb25baW5kZXgxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdjIgPSBzZWxmLmRhdGFDb2x1bW5zXy5zb3VyY2VDb2xsZWN0aW9uW2luZGV4Ml07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MSA9IGdldFNpbmdsZVZhbHVlXy5jYWxsKHNlbGYsIHNvcnRDb2wsIGluZGV4MSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MiA9IGdldFNpbmdsZVZhbHVlXy5jYWxsKHNlbGYsIHNvcnRDb2wsIGluZGV4Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2QuY29udmVydGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEgPSBzZC5jb252ZXJ0ZXIodjEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYyID0gc2QuY29udmVydGVyKHYyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBOYU4gKGlzTmFOIHJldHVybnMgdHJ1ZSBmb3IgTmFOIGJ1dCBhbHNvIGZvciBub24tbnVtYmVycylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYxICE9PSB2MSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2MiAhPT0gdjIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBjYXNlIHdoZW4gc29ydGluZyAgKGJ1dCBhZGQgdGhlIG9yaWdpbmFsIHN0cmluZyB0byBrZWVwIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmdzIGRpZmZlcmVudCBhbmQgdGhlIHNvcnQgY29uc2lzdGVudCwgJ2FhJyBiZXR3ZWVuICdBQScgYW5kICdiYicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfLmlzU3RyaW5nKHYxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEgPSB2MS50b0xvd2VyQ2FzZSgpICsgdjE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF8uaXNTdHJpbmcodjIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MiA9IHYyLnRvTG93ZXJDYXNlKCkgKyB2MjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgdGhlIHZhbHVlcyAoYXQgbGFzdCEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbXAgPSAodjEgPCB2MikgPyAtMSA6ICh2MSA+IHYyKSA/ICsxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNkLmFzY2VuZGluZyA/ICtjbXAgOiAtY21wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaW5kZXhNYXBwaW5nc18gPSBzb3J0TWFwcGluZ3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVkR2RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5ncm91cChjYWNoZWRHZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ3JvdXA6IGZ1bmN0aW9uKGdyb3VwSW5mb3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgc2VsZi5ncm91cEluZm9zXyA9IGdyb3VwSW5mb3M7XG4gICAgICAgICAgICAgICAgc2VsZi5ncm91cHNfID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIHZhciBjYWNoZWRIaWVyYWNoeUluZm8gPSBzZWxmLmhpZXJhcmNoeUluZm9fO1xuICAgICAgICAgICAgICAgIGNsZWFySGllcmFjaHlTdGF0ZXNfLmNhbGwoc2VsZik7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWdyb3VwSW5mb3MgfHwgZ3JvdXBJbmZvcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5ncm91cHNfID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZEhpZXJhY2h5SW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5oaWVyYXJjaHkoY2FjaGVkSGllcmFjaHlJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5ncm91cHNfID0gY3JlYXRlQ2FsY0dyb3VwXy5jYWxsKHNlbGYsIGdyb3VwSW5mb3MpO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRIaWVyYWNoeUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvdHRvbUdyb3VwcyA9IHNlbGYuZ3JvdXBzXy5nZXRCb3R0b21Hcm91cHMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvdHRvbUdyb3VwcyAmJiBib3R0b21Hcm91cHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKGJvdHRvbUdyb3VwcywgZnVuY3Rpb24oYm90dG9tR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3R0b21Hcm91cC5oaWVyYXJjaHkoY2FjaGVkSGllcmFjaHlJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uR291cHNVcGRhdGVkXy5jYWxsKHNlbGYpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmdyb3Vwc187XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBoaWVyYXJjaHk6IGZ1bmN0aW9uKGhpZXJhcmNoeUluZm8pIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgc2VsZi5oaWVyYXJjaHlJbmZvXyA9IGhpZXJhcmNoeUluZm87XG4gICAgICAgICAgICAgICAgc2VsZi5yb290Tm9kZV8gPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghaGllcmFyY2h5SW5mbyB8fCAhaGllcmFyY2h5SW5mby5oYXNPd25Qcm9wZXJ0eSgncGFyZW50RmllbGQnKSB8fCAhaGllcmFyY2h5SW5mby5oYXNPd25Qcm9wZXJ0eSgna2V5RmllbGQnKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJvb3ROb2RlXyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmdyb3Vwc18pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvdHRvbUdyb3VwcyA9IHNlbGYuZ3JvdXBzXy5nZXRCb3R0b21Hcm91cHMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvdHRvbUdyb3VwcyAmJiBib3R0b21Hcm91cHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKGJvdHRvbUdyb3VwcywgZnVuY3Rpb24oYm90dG9tR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3R0b21Hcm91cC5oaWVyYXJjaHkoc2VsZi5oaWVyYXJjaHlJbmZvXyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb290ID0gY3JlYXRlQ2FsY0dyb3VwXy5jYWxsKHNlbGYsIFt7ZmllbGQ6IGhpZXJhcmNoeUluZm8ucGFyZW50RmllbGR9XSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb290ICYmIHJvb3QuZ3JvdXBzICYmIHJvb3QuZ3JvdXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cHMgPSByb290Lmdyb3VwcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlDb2xPYmogPSBzZWxmLmZpbmRDb2x1bW4oaGllcmFyY2h5SW5mby5rZXlGaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RHcm91cCA9IF8uZmluZChncm91cHMsIF8ubWF0Y2hlc1Byb3BlcnR5KCduYW1lJywgdW5kZWZpbmVkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpcnN0R3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJvb3ROb2RlXyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdE5vZGUgPSBuZXcgQ2FsY05vZGVfKHNlbGYsIC0xLCBudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVUcmVlXy5jYWxsKHNlbGYsIGZpcnN0R3JvdXAsIHJvb3ROb2RlLCBncm91cHMsIGtleUNvbE9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJvb3ROb2RlXyA9IHJvb3ROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuc29ydEluZm9zXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnROb2RlXy5jYWxsKHNlbGYsIHNlbGYucm9vdE5vZGVfLCBzZWxmLnNvcnRJbmZvc18pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zZWxmLmNhY2hlZE5vZGVTdGF0dXNfID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5yb290Tm9kZV87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyB0aGUgbmV3IHN0YXRlcyBpcyBiYXNlZCBvbiBjdXJyZW50IGZpbHRlciwgc28gdGhpcyBtZXRob2Qgd2lsbCBpZ25vcmUgY3VycmVudCBmaWx0ZXJlZCBvdXQgcm93c1xuICAgICAgICAgICAgLy8gYW5kIG9ubHkgb3ZlcmxhcCB0aGUgc3RhdGVzIHRvIGN1cnJlbnQgcm93U3RhdGVzX1xuICAgICAgICAgICAgb3ZlcmxhcEZpbHRlclN0YXRlczogZnVuY3Rpb24oc3RhdGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGlmIChfLmlzQXJyYXkoc3RhdGVzKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGltZW5zaW9uID0gc2VsZi5nZXREaW1lbnNpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJsYXBJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBzdGF0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmluZGV4TWFwcGluZ3NfID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltZW5zaW9uOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnJvd1N0YXRlc19baV0gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBJbmRleCA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucm93U3RhdGVzX1tpXSA9IHN0YXRlc1tvdmVybGFwSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYucm93U3RhdGVzX1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaW5kZXhNYXBwaW5nc18ucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG92ZXJsYXBGaWx0ZXJTaW5nbGVTdGF0ZTogZnVuY3Rpb24oc3RhdGVzLCBjdXJyZW50Um93KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGlmICghXy5pc0FycmF5KHN0YXRlcykgJiYgY3VycmVudFJvdyA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzUm93ID0gbWFwVG9Tb3VyY2VSb3dfLmNhbGwoc2VsZiwgY3VycmVudFJvdyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnJvd1N0YXRlc19bc1Jvd10gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJvd1N0YXRlc19bc1Jvd10gPSBzdGF0ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmluZGV4TWFwcGluZ3NfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaW5kZXhNYXBwaW5nc18uc3BsaWNlKGN1cnJlbnRSb3csIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaW5kZXhNYXBwaW5nc18gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlbGYuZ2V0RGltZW5zaW9uKCk7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYucm93U3RhdGVzX1tpXSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmluZGV4TWFwcGluZ3NfLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRSb3dJdGVtOiBmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZ3JvdXBzXykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5ncm91cHNfLmdldEl0ZW0ocm93KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYucm9vdE5vZGVfKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnJvb3ROb2RlXy5nZXRJdGVtKHJvdyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0Um93SXRlbV8ocm93KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXREYXRhUm93SXRlbTogZnVuY3Rpb24ocm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJvdyA9IG1hcFRvU291cmNlUm93Xy5jYWxsKHNlbGYsIHJvdyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZGF0YUNvbHVtbnNfLmdldFJvd0l0ZW0ocm93KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldENhbGNSb3dJdGVtOiBmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIHNyY1JvdyA9IG1hcFRvU291cmNlUm93Xy5jYWxsKHNlbGYsIHJvdyk7XG4gICAgICAgICAgICAgICAgdmFyIGNhbGNSb3dJdGVtID0gZ2V0Q2FsY1Jvd0l0ZW1fLmNhbGwoc2VsZiwgc3JjUm93KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsY1Jvd0l0ZW07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRWYWx1ZXM6IGZ1bmN0aW9uKGNvbHVtbiwgZ3JvdXAsIGludGVybmFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBjb2xPYmogPSBjb2x1bW47XG4gICAgICAgICAgICAgICAgLy9pZiAoXy5pc1N0cmluZyhjb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgY29sT2JqID0gc2VsZi5maW5kQ29sdW1uKGNvbHVtbik7XG4gICAgICAgICAgICAgICAgLy99XG4gICAgICAgICAgICAgICAgLy9pZiAoIWNvbE9iaikge1xuICAgICAgICAgICAgICAgIC8vICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvL31cbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIHJvd0luZGV4O1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgcm93Q291bnQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuYm91bmRHcm91cF8pIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAgPSBzZWxmLmJvdW5kR3JvdXBfO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhNYXBwaW5ncyA9IHNlbGYuaW5kZXhNYXBwaW5nc187XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwICYmIF8uaXNBcnJheShncm91cCkgJiYgZ3JvdXAubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhlcyA9IGdldEluZGV4TWFwcGluZ0luZGV4ZXMuY2FsbChzZWxmLCBncm91cCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuID0gaW5kZXhlcy5sZW5ndGg7IGluZGV4IDwgbGVuOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dJbmRleCA9IGluZGV4TWFwcGluZ3MgPyBpbmRleE1hcHBpbmdzW2luZGV4ZXNbaW5kZXhdXSA6IGluZGV4ZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYucm93U3RhdGVzX1tyb3dJbmRleF0gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnZXRTaW5nbGVWYWx1ZV8uY2FsbChzZWxmLCBjb2xPYmosIHJvd0luZGV4LCBpbnRlcm5hbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4TWFwcGluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4xID0gaW5kZXhNYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW4xOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldFNpbmdsZVZhbHVlXy5jYWxsKHRoaXMsIGNvbE9iaiwgaW5kZXhNYXBwaW5nc1tpXSwgaW50ZXJuYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocm93SW5kZXggPSAwLCByb3dDb3VudCA9IHNlbGYuZ2V0RGltZW5zaW9uKCk7IHJvd0luZGV4IDwgcm93Q291bnQ7IHJvd0luZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldFNpbmdsZVZhbHVlXy5jYWxsKHRoaXMsIGNvbE9iaiwgcm93SW5kZXgsIGludGVybmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbihjb2x1bW4sIGluZGV4LCBpbnRlcm5hbCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgY29sT2JqID0gY29sdW1uO1xuICAgICAgICAgICAgICAgIC8vaWYgKF8uaXNTdHJpbmcoY29sdW1uKSkge1xuICAgICAgICAgICAgICAgIC8vICAgIGNvbE9iaiA9IHNlbGYuZmluZENvbHVtbihjb2x1bW4pO1xuICAgICAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgICAgIC8vaWYgKCFjb2xPYmopIHtcbiAgICAgICAgICAgICAgICAvLyAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy99XG4gICAgICAgICAgICAgICAgaW5kZXggPSBtYXBUb1NvdXJjZVJvd18uY2FsbChzZWxmLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFNpbmdsZVZhbHVlXy5jYWxsKHRoaXMsIGNvbE9iaiwgaW5kZXgsIGludGVybmFsKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGFkZFJvd0l0ZW06IGZ1bmN0aW9uKGluZGV4LCBpdGVtKSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICByZW1vdmVSb3dJdGVtOiBmdW5jdGlvbihpbmRleCkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0RGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhQ29sdW1uc18uZ2V0RGltZW5zaW9uKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRHcm91cFBhdGg6IGZ1bmN0aW9uKHJvdykge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGYuZ3JvdXBzXykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gW107XG4gICAgICAgICAgICAgICAgZmluZFJvd0luR3JvdXBfLmNhbGwoc2VsZiwgc2VsZi5ncm91cHNfLCByb3csIHBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYmluZEdyb3VwOiBmdW5jdGlvbihncm91cCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYm91bmRHcm91cF8gPSBncm91cDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHVuYmluZEdyb3VwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5ib3VuZEdyb3VwXztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGNsb25lT2JqID0gbmV3IENhbGNUYWJsZU1vZGVsKG51bGwpO1xuICAgICAgICAgICAgICAgIGNsb25lT2JqLmRhdGFDb2x1bW5zXyA9IHNlbGYuZGF0YUNvbHVtbnNfO1xuICAgICAgICAgICAgICAgIGNsb25lT2JqLmNhbGNDb2x1bW5zXyA9IHNlbGYuY2FsY0NvbHVtbnNfO1xuICAgICAgICAgICAgICAgIGNsb25lT2JqLmNvbHVtbnNfID0gXy5jbG9uZShzZWxmLmNvbHVtbnNfLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjbG9uZU9iai5yb3dTdGF0ZXNfID0gXy5jbG9uZShzZWxmLnJvd1N0YXRlc18pO1xuICAgICAgICAgICAgICAgIGNsb25lT2JqLmZpbHRlclN0YXRlc18gPSBfLmNsb25lKHNlbGYuZmlsdGVyU3RhdGVzXyk7XG4gICAgICAgICAgICAgICAgY2xvbmVPYmouZ3JvdXBzXyA9IHNlbGYuZ3JvdXBzXztcbiAgICAgICAgICAgICAgICBjbG9uZU9iai5pbmRleE1hcHBpbmdzXyA9IF8uY2xvbmUoc2VsZi5pbmRleE1hcHBpbmdzXywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY2xvbmVPYmoucm9vdE5vZGVfID0gc2VsZi5yb290Tm9kZV87XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lT2JqO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVwcm9kdWNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIHJlcHJvZHVjZWRPYmogPSBuZXcgQ2FsY1RhYmxlTW9kZWwobnVsbCk7XG4gICAgICAgICAgICAgICAgcmVwcm9kdWNlZE9iai5kYXRhQ29sdW1uc18gPSBzZWxmLmRhdGFDb2x1bW5zXztcbiAgICAgICAgICAgICAgICByZXByb2R1Y2VkT2JqLmNhbGNDb2x1bW5zXyA9IHNlbGYuY2FsY0NvbHVtbnNfO1xuICAgICAgICAgICAgICAgIHJlcHJvZHVjZWRPYmouY29sdW1uc18gPSBfLmNsb25lKHNlbGYuY29sdW1uc18sIHRydWUpO1xuICAgICAgICAgICAgICAgIHJlcHJvZHVjZWRPYmoucm93U3RhdGVzXyA9IFtdO1xuICAgICAgICAgICAgICAgIHJlcHJvZHVjZWRPYmoucm93U3RhdGVzXy5sZW5ndGggPSBzZWxmLmdldERpbWVuc2lvbigpO1xuICAgICAgICAgICAgICAgIHJlcHJvZHVjZWRPYmouZmlsdGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXByb2R1Y2VkT2JqLmZpbHRlclN0YXRlc18gPSBudWxsO1xuICAgICAgICAgICAgICAgIHJlcHJvZHVjZWRPYmouZ3JvdXBzXyA9IHNlbGYuZ3JvdXBzXztcbiAgICAgICAgICAgICAgICByZXByb2R1Y2VkT2JqLnJvb3ROb2RlXyA9IHNlbGYucm9vdE5vZGVfO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXByb2R1Y2VkT2JqO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVwcm9kdWNlV2l0aENvbHVtbnM6IGZ1bmN0aW9uKGNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIHJlcHJvZHVjZWRPYmogPSBuZXcgQ2FsY1RhYmxlTW9kZWwobnVsbCk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbk5hbWVzID0gc2VsZi5jb2x1bW5zXztcbiAgICAgICAgICAgICAgICB2YXIgdmFsaWRDb2x1bW5zID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4O1xuICAgICAgICAgICAgICAgIGNvbHVtbk5hbWVzID0gXy5tYXAoY29sdW1uTmFtZXMsIGZ1bmN0aW9uKGNvbHVtbk5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtbk5hbWUubmFtZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXByb2R1Y2VkT2JqLmRhdGFDb2x1bW5zXyA9IHNlbGYuZGF0YUNvbHVtbnNfO1xuICAgICAgICAgICAgICAgIHJlcHJvZHVjZWRPYmouY2FsY0NvbHVtbnNfID0gc2VsZi5jYWxjQ29sdW1uc187XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKGNvbHVtbnMsIGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGluZGV4ID0gXy5pbmRleE9mKGNvbHVtbk5hbWVzLCBjb2x1bW4pKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZENvbHVtbnMucHVzaChzZWxmLmNvbHVtbnNfW2luZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXByb2R1Y2VkT2JqLmNvbHVtbnNfID0gdmFsaWRDb2x1bW5zO1xuICAgICAgICAgICAgICAgIHJlcHJvZHVjZWRPYmoucm93U3RhdGVzXyA9IFtdO1xuICAgICAgICAgICAgICAgIHJlcHJvZHVjZWRPYmoucm93U3RhdGVzXy5sZW5ndGggPSBzZWxmLmdldERpbWVuc2lvbigpO1xuICAgICAgICAgICAgICAgIHJlcHJvZHVjZWRPYmouZmlsdGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXByb2R1Y2VkT2JqLmZpbHRlclN0YXRlc18gPSBudWxsO1xuICAgICAgICAgICAgICAgIHJlcHJvZHVjZWRPYmouZ3JvdXBzXyA9IF8uY2xvbmUoc2VsZi5ncm91cHNfLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVwcm9kdWNlZE9iajtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGJlZ2luVXNlR3JvdXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBPYmogPSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3Vwczogc2VsZi5ncm91cHNfLFxuICAgICAgICAgICAgICAgICAgICBncm91cEluZm9zOiBzZWxmLmdyb3VwSW5mb3NfXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5iYWNrdXBHcm91cHNfKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYmFja3VwR3JvdXBzXy5wdXNoKGdyb3VwT2JqKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmJhY2t1cEdyb3Vwc18gPSBbZ3JvdXBPYmpdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGVuZFVzZUdyb3VwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuYmFja3VwR3JvdXBzXyAmJiBzZWxmLmJhY2t1cEdyb3Vwc18ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBPYmogPSBzZWxmLmJhY2t1cEdyb3Vwc18ucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZ3JvdXBzXyA9IGdyb3VwT2JqLmdyb3VwcztcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5ncm91cEluZm9zXyA9IGdyb3VwT2JqLmdyb3VwSW5mb3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0R3JvdXBzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ncm91cHNfO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0Um9vdE5vZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3ROb2RlXztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHVwZGF0ZUdyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHNlbGYuZ3JvdXAoc2VsZi5ncm91cEluZm9zXyk7XG4gICAgICAgICAgICAgICAgb25Hb3Vwc1VwZGF0ZWRfLmNhbGwoc2VsZik7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBmaW5kQ29sdW1uOiBmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZGF0YUNvbHVtbnNfLmZpbmRDb2x1bW4oY29sdW1uKSB8fCBzZWxmLmNhbGNDb2x1bW5zXy5maW5kQ29sdW1uKGNvbHVtbik7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB0b0FycmF5OiBmdW5jdGlvbihncm91cCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5ib3VuZEdyb3VwXykge1xuICAgICAgICAgICAgICAgICAgICBncm91cCA9IHNlbGYuYm91bmRHcm91cF87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByb3dJbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgcm93Q291bnQ7XG4gICAgICAgICAgICAgICAgdmFyIHJvd3MgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXAgJiYgXy5pc0FycmF5KGdyb3VwKSAmJiBncm91cC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleGVzID0gZ2V0SW5kZXhNYXBwaW5nSW5kZXhlcy5jYWxsKHNlbGYsIGdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW4gPSBpbmRleGVzLmxlbmd0aDsgaW5kZXggPCBsZW47IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4ID0gaW5kZXhlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dzLnB1c2goc2VsZi5nZXRSb3dJdGVtKHJvd0luZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhNYXBwaW5ncyA9IHNlbGYuaW5kZXhNYXBwaW5nc187XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleE1hcHBpbmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuMSA9IGluZGV4TWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93cy5wdXNoKHNlbGYuZ2V0Um93SXRlbShpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHJvd0luZGV4ID0gMCwgcm93Q291bnQgPSBzZWxmLmdldERpbWVuc2lvbigpOyByb3dJbmRleCA8IHJvd0NvdW50OyByb3dJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93cy5wdXNoKHNlbGYuZ2V0Um93SXRlbShyb3dJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByb3dzO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbWFwVG9Tb3VyY2VSb3c6IGZ1bmN0aW9uKHZpZXdSb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwVG9Tb3VyY2VSb3dfLmNhbGwodGhpcywgdmlld1Jvdyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBtYXBUb1ZpZXdSb3c6IGZ1bmN0aW9uKHNvdXJjZVJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXBUb1ZpZXdSb3dfLmNhbGwodGhpcywgc291cmNlUm93KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGlzRmlsdGVyT3V0OiBmdW5jdGlvbihzcmNSb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dTdGF0ZXNfW3NyY1Jvd10gPT09IGZhbHNlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0Um93SXRlbV86IGZ1bmN0aW9uKHJvdykge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgc3JjUm93ID0gcm93O1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmluZGV4TWFwcGluZ3NfICYmIHJvdyA+PSAwICYmIHJvdyA8IHNlbGYuaW5kZXhNYXBwaW5nc18ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNyY1JvdyA9IHNlbGYuaW5kZXhNYXBwaW5nc19bcm93XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFJdGVtID0gc2VsZi5kYXRhQ29sdW1uc18uZ2V0Um93SXRlbShzcmNSb3cpO1xuICAgICAgICAgICAgICAgIHZhciBjYWxjSXRlbSA9IGdldENhbGNSb3dJdGVtXy5jYWxsKHNlbGYsIHNyY1Jvdyk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGNJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUm93SXRlbV8oZGF0YUl0ZW0sIGNhbGNJdGVtLCBzcmNSb3cpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhSXRlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBiZWdpbkNvbnRleHRNYW5pcHVsYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHRTdGF0dXNPYmogPSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3Vwczogc2VsZi5ncm91cHNfLFxuICAgICAgICAgICAgICAgICAgICBncm91cEluZm9zOiBzZWxmLmdyb3VwSW5mb3NfLFxuICAgICAgICAgICAgICAgICAgICByb3dTdGF0ZXM6IHNlbGYucm93U3RhdGVzXyxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyU3RhdGVzOiBzZWxmLmZpbHRlclN0YXRlc18sXG4gICAgICAgICAgICAgICAgICAgIGluZGV4TWFwcGluZ3M6IHNlbGYuaW5kZXhNYXBwaW5nc19cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmJhY2t1cEFsbFN0YXR1c18pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5iYWNrdXBBbGxTdGF0dXNfLnB1c2goY29udGV4dFN0YXR1c09iaik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5iYWNrdXBBbGxTdGF0dXNfID0gW2NvbnRleHRTdGF0dXNPYmpdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGVhckFsbFN0YXRlc18uY2FsbChzZWxmKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGVuZENvbnRleHRNYW5pcHVsYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuYmFja3VwQWxsU3RhdHVzXyAmJiBzZWxmLmJhY2t1cEFsbFN0YXR1c18ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dFN0YXR1c09iaiA9IHNlbGYuYmFja3VwQWxsU3RhdHVzXy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5ncm91cHNfID0gY29udGV4dFN0YXR1c09iai5ncm91cHM7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZ3JvdXBJbmZvc18gPSBjb250ZXh0U3RhdHVzT2JqLmdyb3VwSW5mb3M7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucm93U3RhdGVzXyA9IGNvbnRleHRTdGF0dXNPYmoucm93U3RhdGVzO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmZpbHRlclN0YXRlc18gPSBjb250ZXh0U3RhdHVzT2JqLmZpbHRlclN0YXRlcztcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbmRleE1hcHBpbmdzXyA9IGNvbnRleHRTdGF0dXNPYmouaW5kZXhNYXBwaW5ncztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Q2FsY1Jvd0l0ZW1fKHNyY1Jvdykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNhbGNSb3dJdGVtID0ge307XG4gICAgICAgICAgICB2YXIgY2FsY0NvbHVtbnMgPSBzZWxmLmNhbGNDb2x1bW5zXy5nZXRDb2x1bW5zKCk7XG4gICAgICAgICAgICBpZiAoY2FsY0NvbHVtbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfLmZvckVhY2goY2FsY0NvbHVtbnMsIGZ1bmN0aW9uKGNhbGNDb2xPYmopIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzZWxmLmNhbGNDb2x1bW5zXy5nZXRWYWx1ZShjYWxjQ29sT2JqLCBzcmNSb3cpO1xuICAgICAgICAgICAgICAgIGNhbGNSb3dJdGVtW2NhbGNDb2xPYmoubmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGNSb3dJdGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlQ2FsY0dyb3VwXyhncm91cEluZm9zKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIV8uaXNBcnJheShncm91cEluZm9zKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJvb3QgPSBuZXcgQ2FsY0dyb3VwXyhzZWxmLCBudWxsLCAtMSwgZmFsc2UpO1xuICAgICAgICAgICAgdmFyIHJvd0NvdW50ID0gc2VsZi5nZXRSb3dDb3VudCgpO1xuICAgICAgICAgICAgLy9yb290Lml0ZW1Db3VudCA9IHJvd0NvdW50O1xuICAgICAgICAgICAgcm9vdC5wYXRoID0gW107XG4gICAgICAgICAgICB2YXIgZ3JvdXBzO1xuICAgICAgICAgICAgdmFyIHBhcmVudDtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgdmFyIGxldmVsO1xuICAgICAgICAgICAgdmFyIGxldmVscyA9IGdyb3VwSW5mb3MubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGdkO1xuICAgICAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgICAgICB2YXIgbGFzdDtcbiAgICAgICAgICAgIHZhciBncm91cDtcbiAgICAgICAgICAgIHZhciBwYXRoO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJvd0NvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICBncm91cHMgPSByb290Lmdyb3VwcztcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSByb290O1xuICAgICAgICAgICAgICAgIHBhdGggPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldmVsID0gMDsgbGV2ZWwgPCBsZXZlbHM7ICsrbGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2QgPSBncm91cEluZm9zW2xldmVsXTtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGdldEdyb3VwTmFtZUZyb21JdGVtSW5kZXhfLmNhbGwoc2VsZiwgZ2QsIGkpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gbGV2ZWwgPT09IGxldmVscyAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwID0gZ2V0Q2FsY0dyb3VwXy5jYWxsKHNlbGYsIHBhcmVudCwgbmFtZSwgbGV2ZWwsIGxhc3QpO1xuICAgICAgICAgICAgICAgICAgICAvLysrZ3JvdXAuaXRlbUNvdW50O1xuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIG9uIHRvIHRoZSBuZXh0IGdyb3VwXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gZ3JvdXA7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwcyA9IGdyb3VwLmdyb3VwcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ3JvdXAuaXRlbXMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0R3JvdXBOYW1lRnJvbUl0ZW1JbmRleF8oZ3JvdXBEZXNjcmlwdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjb2xPYmogPSBzZWxmLmZpbmRDb2x1bW4oZ3JvdXBEZXNjcmlwdGlvbi5maWVsZCk7XG4gICAgICAgICAgICBpZiAoY29sT2JqKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc2VsZi5nZXRWYWx1ZShjb2xPYmosIGluZGV4LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihncm91cERlc2NyaXB0aW9uLmNvbnZlcnRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdyb3VwRGVzY3JpcHRpb24uY29udmVydGVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRDYWxjR3JvdXBfKHBhcmVudCwgbmFtZSwgbGV2ZWwsIGlzQm90dG9tTGV2ZWwpIHtcbiAgICAgICAgICAgIHZhciBncm91cHMgPSBwYXJlbnQuZ3JvdXBzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBzW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdyb3Vwc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBub3QgZm91bmQsIGNyZWF0ZSBuZXcgZ3JvdXBcbiAgICAgICAgICAgIHZhciBncm91cCA9IG5ldyBDYWxjR3JvdXBfKHRoaXMsIG5hbWUsIGxldmVsLCBpc0JvdHRvbUxldmVsKTtcbiAgICAgICAgICAgIGdyb3VwLnBhdGggPSBwYXJlbnQucGF0aC5jb25jYXQoZ3JvdXBzLmxlbmd0aCk7XG4gICAgICAgICAgICBncm91cHMucHVzaChncm91cCk7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBSb3dJdGVtXyhkYXRhSXRlbSwgY2FsY0l0ZW0sIHNyY0luZGV4KSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZWxmLmRhdGFJdGVtXyA9IGRhdGFJdGVtO1xuICAgICAgICAgICAgc2VsZi5jYWxjSXRlbV8gPSBjYWxjSXRlbTtcbiAgICAgICAgICAgIHNlbGYuc291cmNlSW5kZXhfID0gc3JjSW5kZXg7XG5cbiAgICAgICAgICAgIGlmIChkYXRhSXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhS2V5cyA9IF8ua2V5cyhkYXRhSXRlbSk7XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKGRhdGFLZXlzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0RGVmaW5lUHJvcGVydHkoc2VsZiwga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhSXRlbVtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSXRlbVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNhbGNJdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhbGNLZXlzID0gXy5rZXlzKGNhbGNJdGVtKTtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goY2FsY0tleXMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3REZWZpbmVQcm9wZXJ0eShzZWxmLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGNJdGVtW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGNJdGVtW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmplY3REZWZpbmVQcm9wZXJ0eShzZWxmLCAnc291cmNlSW5kZXgnLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlSW5kZXhfO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZmluZFJvd0luR3JvdXBfKGdyb3VwLCByb3csIHBhdGgpIHtcbiAgICAgICAgICAgIGlmIChncm91cC5pc0JvdHRvbUxldmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyb3VwLml0ZW1zLmluZGV4T2Yocm93KSAhPT0gLTE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGdyb3VwLmdyb3Vwcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBncm91cC5ncm91cHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kID0gZmluZFJvd0luR3JvdXBfKGdyb3VwLmdyb3Vwc1tpXSwgcm93LCBwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLnNwbGljZSgwLCAwLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2hpbGUgc2V0IGZpbHRlciwgdGhlIGludmlzaWJsZSBjb2x1bW4gd2lsbCBhbHdheXMga2VlcCBpbnZpc2libGUsIGJ1dCB0aGUgdmlzaWJsZSBjb2x1bW5zIG1heSBjaGFuZ2UgdG8gaW52aXNpYmxlXG4gICAgICAgIC8vIHNvIHdoaWxlIHNldCBmaWxlciwgb25seSBjaGVjayB0aGUgdmlzaWJsZSBjb2x1bW5zIGlzIG9rLlxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVTdGF0ZXNPblNldEZpbHRlclN0YXRlc18oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgcm93Q291bnQgPSBzZWxmLmdldERpbWVuc2lvbigpO1xuICAgICAgICAgICAgc2VsZi5pbmRleE1hcHBpbmdzXyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgcm93Q291bnQ7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlUm93U3RhdGVfLmNhbGwoc2VsZiwgcm93KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5yb3dTdGF0ZXNfW3Jvd10pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbmRleE1hcHBpbmdzXy5wdXNoKHJvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlUm93U3RhdGVfKHJvdykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGZpbHRlclN0YXRlID0gc2VsZi5maWx0ZXJTdGF0ZXNfID09PSBudWxsIHx8IHNlbGYuZmlsdGVyU3RhdGVzX1tyb3ddICE9PSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGYucm93U3RhdGVzX1tyb3ddID0gZmlsdGVyU3RhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRTaW5nbGVWYWx1ZV8oY29sT2JqLCBzcmNJbmRleCwgaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChjb2xPYmoudHlwZSA9PT0gQ2FsY0hlbHBlci5EQVRBX0NPTFVNTikge1xuICAgICAgICAgICAgICAgIC8vdmFsdWUgPSBzZWxmLmRhdGFDb2x1bW5zXy5zb3VyY2VDb2xsZWN0aW9uW2luZGV4XVtjb2xPYmoubmFtZV07XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBzZWxmLmRhdGFDb2x1bW5zXy5nZXRWYWx1ZShzcmNJbmRleCwgY29sT2JqKTtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGNhbGMgY29sdW1uXG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY29sT2JqLnZhbHVlc1tzcmNJbmRleF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzZWxmLmNhbGNDb2x1bW5zXy5nZXRWYWx1ZShjb2xPYmosIHNyY0luZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRJbmRleE1hcHBpbmdJbmRleGVzKGdyb3VwUGF0aCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gZ2V0R3JvdXBfKHNlbGYuZ3JvdXBzXywgZ3JvdXBQYXRoKTtcbiAgICAgICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleGVzO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZXMgPSBncm91cC5nZXRJbmRleE1hcHBpbmdJbmRleGVzKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEdyb3VwXyhyb290R3JvdXAsIGdyb3VwUGF0aCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRHcm91cCA9IHJvb3RHcm91cDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBncm91cFBhdGgubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBncm91cFBhdGhbaV07XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwcyA9IGN1cnJlbnRHcm91cC5ncm91cHM7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwcyAmJiBpbmRleCA8IGdyb3Vwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwID0gZ3JvdXBzW2luZGV4XTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEdyb3VwO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb25Hb3Vwc1VwZGF0ZWRfKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNhbGNDb2x1bW5zID0gc2VsZi5jYWxjQ29sdW1uc18uZ2V0Q29sdW1ucygpO1xuICAgICAgICAgICAgXy5mb3JFYWNoKGNhbGNDb2x1bW5zLCBmdW5jdGlvbihjYWxjQ29sKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxjQ29sdW1uc18uZGlydHkoY2FsY0NvbCwgLTEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtYXBUb1NvdXJjZVJvd18ocm93KSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSByb3c7XG4gICAgICAgICAgICAvLyBkdXJpbmcgZ3JvdXBpbmcgb3IgaGllcmFjaHlpbmcsIHRoZSBncm91cHNfIGFuZCByb290Tm9kZV8gd2lsbCBiZSBmaXJzdCBzZXQgbnVsbCwgc28gdGhlIGluZGV4IGRvZXMgbm90IG5lZWQgdG8gYmUgdHJhbnNmb3JtZWQgYnkgZ3JvdXAgYW5kIHRyZWVcbiAgICAgICAgICAgIGlmIChzZWxmLmdyb3Vwc18pIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBJbmZvID0gc2VsZi5ncm91cHNfLnNlYXJjaENoaWxkR3JvdXAocm93KTtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gZ3JvdXBJbmZvLmdyb3VwLml0ZW1zW2dyb3VwSW5mby5yZWxhdGl2ZUluZGV4XTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5yb290Tm9kZV8pIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHNlbGYucm9vdE5vZGVfLmZpbmROb2RlKHJvdyk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBub2RlLml0ZW1JbmRleDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGYuaW5kZXhNYXBwaW5nc18gJiYgaW5kZXggPj0gMCAmJiBpbmRleCA8IHNlbGYuaW5kZXhNYXBwaW5nc18ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuaW5kZXhNYXBwaW5nc19baW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWFwVG9WaWV3Um93Xyhyb3cpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHJvdztcbiAgICAgICAgICAgIGlmIChzZWxmLmluZGV4TWFwcGluZ3NfKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZWxmLmluZGV4TWFwcGluZ3NfLmluZGV4T2Yocm93KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXBwaW5nSW5kZXhlcztcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5ncm91cHNfKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmdJbmRleGVzID0gc2VsZi5ncm91cHNfLmdldEluZGV4TWFwcGluZ0luZGV4ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcHBpbmdJbmRleGVzLmluZGV4T2YoaW5kZXgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5yb290Tm9kZV8pIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZ0luZGV4ZXMgPSBzZWxmLnJvb3ROb2RlXy5nZXRJbmRleE1hcHBpbmdJbmRleGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXBwaW5nSW5kZXhlcy5pbmRleE9mKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjbGVhckFsbFN0YXRlc18oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBjbGVhckZpbHRlclN0YXRlc18uY2FsbChzZWxmKTtcbiAgICAgICAgICAgIGNsZWFyR3JvdXBTdGF0ZXNfLmNhbGwoc2VsZik7XG4gICAgICAgICAgICBjbGVhckhpZXJhY2h5U3RhdGVzXy5jYWxsKHNlbGYpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2xlYXJGaWx0ZXJTdGF0ZXNfKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHJvd0NvdW50ID0gc2VsZi5kYXRhQ29sdW1uc18uZ2V0RGltZW5zaW9uKCk7XG4gICAgICAgICAgICBzZWxmLmZpbHRlckV4cHJfID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYucm93U3RhdGVzXyA9IFtdO1xuICAgICAgICAgICAgc2VsZi5yb3dTdGF0ZXNfLmxlbmd0aCA9IHJvd0NvdW50O1xuICAgICAgICAgICAgc2VsZi5maWx0ZXJTdGF0ZXNfID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYuaW5kZXhNYXBwaW5nc18gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2xlYXJHcm91cFN0YXRlc18oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZWxmLmdyb3Vwc18gPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5ncm91cEluZm9zXyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjbGVhckhpZXJhY2h5U3RhdGVzXygpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHNlbGYucm9vdE5vZGVfID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYuaGllcmFjaHlJbmZvXyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVUcmVlXyhncm91cCwgcGFyZW50Tm9kZSwgZ3JvdXBzLCBrZXlDb2xPYmopIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAuaXRlbUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBuZXcgQ2FsY05vZGVfKHNlbGYsIGdyb3VwLml0ZW1zW2ldLCBwYXJlbnROb2RlLCBzZWxmLmhpZXJhcmNoeUluZm9fLmNvbGxhcHNlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbm9kZXMgPSBwYXJlbnROb2RlLmNoaWxkcmVuO1xuICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbal07XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IG5vZGUuaXRlbUluZGV4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3JjSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4TWFwcGluZ3MgPSBzZWxmLmluZGV4TWFwcGluZ3NfO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXhNYXBwaW5ncyAmJiBpbmRleCA+PSAwICYmIGluZGV4IDwgaW5kZXhNYXBwaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY0luZGV4ID0gaW5kZXhNYXBwaW5nc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleVZhbHVlID0gZ2V0U2luZ2xlVmFsdWVfLmNhbGwoc2VsZiwga2V5Q29sT2JqLCBzcmNJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUudmFsdWUgPSBrZXlWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy9pZiAoc2VsZi5jYWNoZWROb2RlU3RhdHVzXy5oYXNPd25Qcm9wZXJ0eShrZXlWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgbm9kZS5jb2xsYXBzZWQgPSBzZWxmLmNhY2hlZE5vZGVTdGF0dXNfW2tleVZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgLy99XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZEdyb3VwID0gXy5maW5kKGdyb3VwcywgXy5tYXRjaGVzUHJvcGVydHkoJ25hbWUnLCBrZXlWYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlVHJlZV8uY2FsbChzZWxmLCBjaGlsZEdyb3VwLCBub2RlLCBncm91cHMsIGtleUNvbE9iaik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBDYWxjVGFibGVNb2RlbC5jcmVhdGVUcmVlXyA9IGNyZWF0ZVRyZWVfO1xuXG4gICAgICAgIGZ1bmN0aW9uIHNvcnROb2RlXyhub2RlLCBzb3J0SW5mb3MsIHNvcnRDb2x1bW5zKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIXNvcnRDb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgc29ydENvbHVtbnMgPSB7fTtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goc29ydEluZm9zLCBmdW5jdGlvbihzb3J0SW5mbykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNvcnRJbmZvLmhhc093blByb3BlcnR5KCdhc2NlbmRpbmcnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ydEluZm8uYXNjZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRJbmZvLmFzY2VuZGluZyA9ICEhc29ydEluZm8uYXNjZW5kaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNvcnRDb2x1bW5zW3NvcnRJbmZvLmZpZWxkXSA9IHNlbGYuZGF0YUNvbHVtbnNfLmZpbmRDb2x1bW4oc29ydEluZm8uZmllbGQpIHx8IHNlbGYuY2FsY0NvbHVtbnNfLmZpbmRDb2x1bW4oc29ydEluZm8uZmllbGQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zb3J0KGZ1bmN0aW9uKG5vZGUxLCBub2RlMikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBzb3J0TGVuID0gc29ydEluZm9zLmxlbmd0aDsgaSA8IHNvcnRMZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZCA9IHNvcnRJbmZvc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvcnRDb2wgPSBzb3J0Q29sdW1uc1tzZC5maWVsZF07XG4gICAgICAgICAgICAgICAgICAgIHZhciB2MTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc29ydENvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNyY0luZGV4MSA9IHNlbGYuaW5kZXhNYXBwaW5nc18gPyBzZWxmLmluZGV4TWFwcGluZ3NfW25vZGUxLml0ZW1JbmRleF0gOiBub2RlMS5pdGVtSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3JjSW5kZXgyID0gc2VsZi5pbmRleE1hcHBpbmdzXyA/IHNlbGYuaW5kZXhNYXBwaW5nc19bbm9kZTIuaXRlbUluZGV4XSA6IG5vZGUyLml0ZW1JbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYxID0gZ2V0U2luZ2xlVmFsdWVfLmNhbGwoc2VsZiwgc29ydENvbCwgc3JjSW5kZXgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYyID0gZ2V0U2luZ2xlVmFsdWVfLmNhbGwoc2VsZiwgc29ydENvbCwgc3JjSW5kZXgyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZC5jb252ZXJ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MSA9IHNkLmNvbnZlcnRlcih2MSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBzZC5jb252ZXJ0ZXIodjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIE5hTiAoaXNOYU4gcmV0dXJucyB0cnVlIGZvciBOYU4gYnV0IGFsc28gZm9yIG5vbi1udW1iZXJzKVxuICAgICAgICAgICAgICAgICAgICBpZiAodjEgIT09IHYxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2MSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHYyICE9PSB2Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIGNhc2Ugd2hlbiBzb3J0aW5nICAoYnV0IGFkZCB0aGUgb3JpZ2luYWwgc3RyaW5nIHRvIGtlZXAgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZ3MgZGlmZmVyZW50IGFuZCB0aGUgc29ydCBjb25zaXN0ZW50LCAnYWEnIGJldHdlZW4gJ0FBJyBhbmQgJ2JiJylcbiAgICAgICAgICAgICAgICAgICAgaWYgKF8uaXNTdHJpbmcodjEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2MSA9IHYxLnRvTG93ZXJDYXNlKCkgKyB2MTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoXy5pc1N0cmluZyh2MikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYyID0gdjIudG9Mb3dlckNhc2UoKSArIHYyO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcGFyZSB0aGUgdmFsdWVzIChhdCBsYXN0ISlcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNtcCA9ICh2MSA8IHYyKSA/IC0xIDogKHYxID4gdjIpID8gKzEgOiAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2QuYXNjZW5kaW5nID8gK2NtcCA6IC1jbXA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2gobm9kZS5jaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvcnROb2RlXy5jYWxsKHNlbGYsIGNoaWxkTm9kZSwgc29ydEluZm9zLCBzb3J0Q29sdW1ucyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBDYWxjVGFibGVNb2RlbC5zb3J0Tm9kZV8gPSBzb3J0Tm9kZV87XG5cbiAgICAgICAgcmV0dXJuIENhbGNUYWJsZU1vZGVsO1xuICAgIH0pKCk7XG4gICAgQ2FsY01vZGVscy5DYWxjVGFibGVNb2RlbCA9IENhbGNUYWJsZU1vZGVsO1xuXG4gICAgdmFyIERhdGFDb2x1bW5zTW9kZWwgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIERhdGFDb2x1bW5zTW9kZWwoZGF0YVNvdXJjZSwgY29sdW1uRGVmcykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgc2VsZi5kYXRhU291cmNlID0gZGF0YVNvdXJjZTtcbiAgICAgICAgICAgIHZhciBzcmNBcnJheTtcbiAgICAgICAgICAgIHZhciBkaW1lbnNpb247XG4gICAgICAgICAgICBpZiAoXy5pc0FycmF5KGRhdGFTb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgc3JjQXJyYXkgPSBkYXRhU291cmNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhU291cmNlLmdldFNvdXJjZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgc3JjQXJyYXkgPSBkYXRhU291cmNlLmdldFNvdXJjZUFycmF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3JjQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNvdXJjZUNvbGxlY3Rpb24gPSBzcmNBcnJheTtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb24gPSBzcmNBcnJheS5sZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGFTb3VyY2UuZ2V0RGltZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9uID0gZGF0YVNvdXJjZS5nZXREaW1lbnNpb24oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRlZmF1bHRDb2xzID0gZ2V0RGVmYXVsdENvbHVtbnNfLmNhbGwoc2VsZik7XG4gICAgICAgICAgICBpZiAoZGF0YVNvdXJjZS5nZXRDb2x1bW5zIHx8IGNvbHVtbkRlZnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1ucyA9IChkYXRhU291cmNlLmdldENvbHVtbnMgJiYgZGF0YVNvdXJjZS5nZXRDb2x1bW5zKCkpIHx8IGNvbHVtbkRlZnM7XG4gICAgICAgICAgICAgICAgc2VsZi5jb2x1bW5zID0gXy5tYXAoY29sdW1ucywgZnVuY3Rpb24oY29sKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXJ0eVN0YXRlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBkaXJ0eVN0YXRlcy5sZW5ndGggPSBkaW1lbnNpb247XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2wubmFtZSAmJiBjb2wuZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogY29sLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGNvbC5maWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBDYWxjSGVscGVyLkRBVEFfQ09MVU1OLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcnR5U3RhdGVzOiBkaXJ0eVN0YXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJ0eTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0Q29scykge1xuICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2goZGVmYXVsdENvbHMsIGZ1bmN0aW9uKGRlZkNvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfLmZpbmQoc2VsZi5jb2x1bW5zLCBfLm1hdGNoZXNQcm9wZXJ0eSgnZmllbGQnLCBkZWZDb2wuZmllbGQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29sdW1ucy5wdXNoKGRlZkNvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZi5jb2x1bW5zIHx8IHNlbGYuY29sdW1ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbHVtbnMgPSBkZWZhdWx0Q29scztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIERhdGFDb2x1bW5zTW9kZWwucHJvdG90eXBlID0ge1xuICAgICAgICAgICAgZ2V0Um93SXRlbTogZnVuY3Rpb24ocm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBpdGVtO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNvdXJjZUNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IHNlbGYuc291cmNlQ29sbGVjdGlvbltyb3ddO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5nZXREYXRhSXRlbSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBzZWxmLmdldERhdGFJdGVtKHJvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdjYW4gbm90IGZpbmQgdGhlIGl0ZW0gYXQgaW5kZXggJyArIHJvdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXREaW1lbnNpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zb3VyY2VDb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnNvdXJjZUNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5kYXRhU291cmNlLmdldERpbWVuc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5kYXRhU291cmNlLmdldERpbWVuc2lvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbihyb3csIGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgY29sT2JqID0gY29sdW1uO1xuICAgICAgICAgICAgICAgIC8vaWYgKF8uaXNTdHJpbmcoY29sdW1uKSkge1xuICAgICAgICAgICAgICAgIC8vICAgIGNvbE9iaiA9IHNlbGYuZmluZENvbHVtbihjb2x1bW4pO1xuICAgICAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgICAgIC8vaWYgKCFjb2xPYmopIHtcbiAgICAgICAgICAgICAgICAvLyAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy99XG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gY29sT2JqLmZpZWxkO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zb3VyY2VDb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHNlbGYuc291cmNlQ29sbGVjdGlvbltyb3ddW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYuZGF0YVNvdXJjZS5nZXREYXRhSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHNlbGYuZGF0YVNvdXJjZS5nZXREYXRhSXRlbShyb3cpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpdGVtW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY29udmVydGVyID0gY29sT2JqLmNvbnZlcnRlcjtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnZlcnRlciB8fCAhXy5pc0Z1bmN0aW9uKGNvbnZlcnRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydGVyKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGZpbmRDb2x1bW46IGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfLmZpbmQodGhpcy5jb2x1bW5zLCBfLm1hdGNoZXNQcm9wZXJ0eSgnbmFtZScsIGNvbHVtbikpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaGFzRGlydHk6IGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgY29sT2JqID0gc2VsZi5maW5kQ29sdW1uKGNvbHVtbik7XG4gICAgICAgICAgICAgICAgaWYgKCFjb2xPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc3RhdGVzID0gY29sT2JqLmRpcnR5U3RhdGVzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdGF0ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlc1tpXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZGlydHk6IGZ1bmN0aW9uKGNvbHVtbiwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBtYXJrRGlydHlfLmNhbGwodGhpcywgY29sdW1uLCBpbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB1bkRpcnR5OiBmdW5jdGlvbihjb2x1bW4sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgbWFya0RpcnR5Xy5jYWxsKHRoaXMsIGNvbHVtbiwgaW5kZXgsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBtYXJrRGlydHlfKGNvbHVtbiwgaW5kZXgsIHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY29sT2JqID0gY29sdW1uO1xuICAgICAgICAgICAgaWYgKF8uaXNTdHJpbmcoY29sdW1uKSkge1xuICAgICAgICAgICAgICAgIGNvbE9iaiA9IHNlbGYuZmluZENvbHVtbihjb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb2xPYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHNlbGYuZ2V0RGltZW5zaW9uKCkpIHtcbiAgICAgICAgICAgICAgICBjb2xPYmouZGlydHlTdGF0ZXNbaW5kZXhdID0gc3RhdGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBfLmZpbGwoY29sT2JqLmRpcnR5U3RhdGVzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlydHlTdGF0ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZGlydHlTdGF0ZXMubGVuZ3RoID0gc2VsZi5nZXREaW1lbnNpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgY29sT2JqLmRpcnR5U3RhdGVzID0gZGlydHlTdGF0ZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0RGVmYXVsdENvbHVtbnNfKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHNvdXJjZUNvbGxlY3Rpb24gPSBzZWxmLnNvdXJjZUNvbGxlY3Rpb247XG4gICAgICAgICAgICB2YXIgZmlyc3RJdGVtO1xuICAgICAgICAgICAgaWYgKHNvdXJjZUNvbGxlY3Rpb24gJiYgc291cmNlQ29sbGVjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RJdGVtID0gc291cmNlQ29sbGVjdGlvblswXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlQ29sbGVjdGlvbiAmJiBzb3VyY2VDb2xsZWN0aW9uLmdldERhdGFJdGVtKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RJdGVtID0gc291cmNlQ29sbGVjdGlvbi5nZXREYXRhSXRlbSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdEl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZGltZW5zaW9uID0gc2VsZi5nZXREaW1lbnNpb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5tYXAoXy5rZXlzKGZpcnN0SXRlbSksIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlydHlTdGF0ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZGlydHlTdGF0ZXMubGVuZ3RoID0gZGltZW5zaW9uO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IENhbGNIZWxwZXIuREFUQV9DT0xVTU4sXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJ0eVN0YXRlczogZGlydHlTdGF0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJ0eTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBEYXRhQ29sdW1uc01vZGVsO1xuICAgIH0pKCk7XG4gICAgQ2FsY01vZGVscy5EYXRhQ29sdW1uc01vZGVsID0gRGF0YUNvbHVtbnNNb2RlbDtcblxuICAgIHZhciBDYWxjQ29sdW1uc01vZGVsID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBDYWxjQ29sdW1uc01vZGVsKGNhbGNTb3VyY2UpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHNlbGYuY2FsY1NvdXJjZV8gPSBjYWxjU291cmNlO1xuICAgICAgICAgICAgc2VsZi5uYW1lID0gY2FsY1NvdXJjZS5uYW1lO1xuICAgICAgICAgICAgc2VsZi5jb2x1bW5zXyA9IFtdO1xuICAgICAgICAgICAgc2VsZi5wYXJzZXJfID0gY2FsY1NvdXJjZS5nZXRQYXJzZXIoKTtcbiAgICAgICAgICAgIHNlbGYuZXZhbHVhdG9yXyA9IGNhbGNTb3VyY2UuZ2V0RXZhbHVhdG9yKCk7XG4gICAgICAgICAgICAvL2lmIChjb2x1bW5zKSB7XG4gICAgICAgICAgICAvLyAgICBfLmZvckVhY2goY29sdW1ucywgZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgYWRkQ29sdW1uXy5jYWxsKHNlbGYsIGNvbHVtbi5uYW1lLCBjb2x1bW4uZmllbGQpO1xuICAgICAgICAgICAgLy8gICAgfSk7XG4gICAgICAgICAgICAvL31cbiAgICAgICAgfVxuXG4gICAgICAgIENhbGNDb2x1bW5zTW9kZWwucHJvdG90eXBlID0ge1xuICAgICAgICAgICAgYWRkQ29sdW1uOiBmdW5jdGlvbihjb2x1bW4sIGZvcm11bGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkQ29sdW1uXy5jYWxsKHRoaXMsIGNvbHVtbiwgZm9ybXVsYSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICByZW1vdmVDb2x1bW46IGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICAgICAgICAgIF8ucmVtb3ZlKHRoaXMuY29sdW1uc18sIF8ubWF0Y2hlc1Byb3BlcnR5KCduYW1lJywgY29sdW1uKSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRWYWx1ZXM6IGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgY29sT2JqID0gY29sdW1uO1xuICAgICAgICAgICAgICAgIC8vaWYgKF8uaXNTdHJpbmcoY29sdW1uKSkge1xuICAgICAgICAgICAgICAgIC8vICAgIGNvbE9iaiA9IHNlbGYuZmluZENvbHVtbihjb2x1bW4pO1xuICAgICAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgICAgIC8vaWYgKCFjb2xPYmopIHtcbiAgICAgICAgICAgICAgICAvLyAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAvL31cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5oYXNEaXJ0eShjb2xPYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsY3VsYXRlQ29sdW1uKGNvbE9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xPYmoudmFsdWVzO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKGNvbHVtbiwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGNvbE9iaiA9IGNvbHVtbjtcbiAgICAgICAgICAgICAgICAvL2lmIChfLmlzU3RyaW5nKGNvbHVtbikpIHtcbiAgICAgICAgICAgICAgICAvLyAgICBjb2xPYmogPSBzZWxmLmZpbmRDb2x1bW4oY29sdW1uKTtcbiAgICAgICAgICAgICAgICAvL31cbiAgICAgICAgICAgICAgICAvL2lmICghY29sT2JqKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgLy99XG4gICAgICAgICAgICAgICAgaWYgKGNvbE9iai5kaXJ0eVN0YXRlc1tpbmRleF0gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsY3VsYXRlVmFsdWUoY29sdW1uLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xPYmoudmFsdWVzW2luZGV4XTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNhbGN1bGF0ZVZhbHVlOiBmdW5jdGlvbihjb2x1bW4sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBjb2xPYmogPSBjb2x1bW47XG4gICAgICAgICAgICAgICAgaWYgKF8uaXNTdHJpbmcoY29sdW1uKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2xPYmogPSBzZWxmLmZpbmRDb2x1bW4oY29sdW1uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjb2xPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZUNvbHVtbl8uY2FsbCh0aGlzLCBjb2xPYmosIGluZGV4LCBmYWxzZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjYWxjdWxhdGVDb2x1bW46IGZ1bmN0aW9uKGNvbHVtbiwgZm9yY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGNvbE9iaiA9IGNvbHVtbjtcbiAgICAgICAgICAgICAgICBpZiAoXy5pc1N0cmluZyhjb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbE9iaiA9IHNlbGYuZmluZENvbHVtbihjb2x1bW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNvbE9iaikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlQ29sdW1uXy5jYWxsKHRoaXMsIGNvbE9iaiwgLTEsIGZvcmNlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGZpbmRDb2x1bW46IGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfLmZpbmQodGhpcy5jb2x1bW5zXywgXy5tYXRjaGVzUHJvcGVydHkoJ25hbWUnLCBjb2x1bW4pKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldENvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNfO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaGFzRGlydHk6IGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICAgICAgICAgIC8vdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBjb2xPYmogPSBjb2x1bW47XG4gICAgICAgICAgICAgICAgLy9pZiAoXy5pc1N0cmluZyhjb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgY29sT2JqID0gc2VsZi5maW5kQ29sdW1uKGNvbHVtbik7XG4gICAgICAgICAgICAgICAgLy99XG4gICAgICAgICAgICAgICAgLy9pZiAoIWNvbE9iaikge1xuICAgICAgICAgICAgICAgIC8vICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgICAgIHZhciBzdGF0ZXMgPSBjb2xPYmouZGlydHlTdGF0ZXM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN0YXRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVzW2ldICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZGlydHk6IGZ1bmN0aW9uKGNvbHVtbiwgaW5kZXgsIG5ld0Zvcm11bGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGNvbE9iaiA9IGNvbHVtbjtcbiAgICAgICAgICAgICAgICAvL2lmIChfLmlzU3RyaW5nKGNvbHVtbikpIHtcbiAgICAgICAgICAgICAgICAvLyAgICBjb2xPYmogPSBzZWxmLmZpbmRDb2x1bW4oY29sdW1uKTtcbiAgICAgICAgICAgICAgICAvL31cbiAgICAgICAgICAgICAgICAvL2lmICghY29sT2JqKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgICAgIGlmIChuZXdGb3JtdWxhICYmIGNvbE9iai5mb3JtdWxhICE9PSBuZXdGb3JtdWxhKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNvbHVtbkZvcm11bGEuY2FsbChzZWxmLCBjb2xPYmosIG5ld0Zvcm11bGEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaW1lbnNpb24gPSBzZWxmLmNhbGNTb3VyY2VfLmdldERpbWVuc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IGRpbWVuc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sT2JqLmRpcnR5U3RhdGVzW2luZGV4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlydHlTdGF0ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcnR5U3RhdGVzLmxlbmd0aCA9IGRpbWVuc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbE9iai5kaXJ0eVN0YXRlcyA9IGRpcnR5U3RhdGVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdXBkYXRlQ29sdW1uRm9ybXVsYTogZnVuY3Rpb24oY29sdW1uLCBuZXdGb3JtdWxhKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBjb2xPYmogPSBzZWxmLmZpbmRDb2x1bW4oY29sdW1uKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV3Rm9ybXVsYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Rm9ybXVsYSA9IGNvbE9iai5mb3JtdWxhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNvbHVtbkZvcm11bGEuY2FsbChzZWxmLCBjb2xPYmosIG5ld0Zvcm11bGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBhZGRDb2x1bW5fKGNvbHVtbiwgZm9ybXVsYSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHJvd0NvdW50ID0gc2VsZi5jYWxjU291cmNlXy5nZXREaW1lbnNpb24oKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBkaXJ0eVN0YXRlcyA9IFtdO1xuICAgICAgICAgICAgdmFsdWVzLmxlbmd0aCA9IHJvd0NvdW50O1xuICAgICAgICAgICAgZGlydHlTdGF0ZXMubGVuZ3RoID0gcm93Q291bnQ7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IG5ldyBDYWxjQ29udGV4dC5QYXJzZXJDb250ZXh0KHNlbGYuY2FsY1NvdXJjZV8pO1xuICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBzZWxmLnBhcnNlcl8ucGFyc2UoZm9ybXVsYSwgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoIWV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkZXBlbmRzID0gQ2FsY0hlbHBlci5yZXNvbHZlRGVwZW5kcyhleHByZXNzaW9uLCBzZWxmLmNhbGNTb3VyY2VfKTtcbiAgICAgICAgICAgIHZhciBjYWxjQ29sdW1uID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGNvbHVtbixcbiAgICAgICAgICAgICAgICB0eXBlOiBDYWxjSGVscGVyLkNBTENfQ09MVU1OLFxuICAgICAgICAgICAgICAgIGZvcm11bGE6IGZvcm11bGEsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgICAgICAgICBkaXJ0eVN0YXRlczogZGlydHlTdGF0ZXMsXG4gICAgICAgICAgICAgICAgZGVwZW5kczogZGVwZW5kcyxcbiAgICAgICAgICAgICAgICBpc0NhbGN1bGF0aW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkaXJ0eTogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZWxmLmNvbHVtbnNfLnB1c2goY2FsY0NvbHVtbik7XG4gICAgICAgICAgICByZXR1cm4gY2FsY0NvbHVtbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZUNvbHVtbl8oY29sdW1uLCBpbmRleCwgZm9yY2UpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjb2xPYmogPSBjb2x1bW47XG4gICAgICAgICAgICBjb2x1bW4gPSBjb2xPYmoubmFtZTtcbiAgICAgICAgICAgIHZhciBkaXJ0eVN0YXRlcztcbiAgICAgICAgICAgIHZhciBpc0RlcERpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgZmllbGRzTW9kZWwgPSBzZWxmLmNhbGNTb3VyY2VfLmdldE1vZGVsKENhbGNIZWxwZXIuQ0FMQ19GSUVMRCk7XG4gICAgICAgICAgICB2YXIgZGF0YUNvbHNNb2RlbCA9IHNlbGYuY2FsY1NvdXJjZV8uZ2V0TW9kZWwoQ2FsY0hlbHBlci5EQVRBX0NPTFVNTik7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIHZhciBsZW47XG4gICAgICAgICAgICB2YXIgZGVwZW5kcztcbiAgICAgICAgICAgIGNvbE9iai5pc0NhbGN1bGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhbGN1bGF0aW5nU3RhY2sgPSBbXTtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGluZ1N0YWNrLnB1c2goe3R5cGU6IENhbGNIZWxwZXIuQ0FMQ19DT0xVTU4sIHRhYmxlOiBzZWxmLm5hbWUsIGNvbHVtbjogY29sdW1ufSk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNhbGN1bGF0aW5nU3RhY2subGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3BDYWxjRGVwID0gY2FsY3VsYXRpbmdTdGFja1tjYWxjdWxhdGluZ1N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9wQ2FsY09iaiA9IENhbGNIZWxwZXIuZ2V0Q2FsY09iaih0b3BDYWxjRGVwLCBzZWxmLmNhbGNTb3VyY2VfKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcENhbGNPYmogPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0aW5nU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzRGlydHlEZXBlbmRzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGRlcGVuZHMgPSB0b3BDYWxjT2JqLmRlcGVuZHM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXBlbmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBkZXBlbmRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlcENhbGNPYmogPSBDYWxjSGVscGVyLmdldENhbGNPYmooZGVwZW5kc1tpXSwgc2VsZi5jYWxjU291cmNlXyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlcENhbGNPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlcERpcnR5SW5kZXggPSBkZXBlbmRzW2ldLmFnZ0NvbnRleHQgPyAtMSA6IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0RlcERpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXBEaXJ0eUluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChkZXBDYWxjT2JqLnR5cGUgPT09IENhbGNIZWxwZXIuQ0FMQ19GSUVMRCAmJiBkZXBDYWxjT2JqLmRpcnR5KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGVwQ2FsY09iai50eXBlID09PSBDYWxjSGVscGVyLkRBVEFfQ09MVU1OICYmIGRhdGFDb2xzTW9kZWwuaGFzRGlydHkoZGVwQ2FsY09iaikpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkZXBDYWxjT2JqLnR5cGUgPT09IENhbGNIZWxwZXIuQ0FMQ19DT0xVTU4gJiYgc2VsZi5oYXNEaXJ0eShkZXBDYWxjT2JqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0RlcERpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXBDYWxjT2JqLnR5cGUgPT09IENhbGNIZWxwZXIuREFUQV9DT0xVTU4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJ0eVN0YXRlcyA9IGRlcENhbGNPYmouZGlydHlTdGF0ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcnR5U3RhdGVzW2RlcERpcnR5SW5kZXhdID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRGVwRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVwQ2FsY09iai50eXBlID09PSBDYWxjSGVscGVyLkNBTENfQ09MVU1OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlydHlTdGF0ZXMgPSBkZXBDYWxjT2JqLmRpcnR5U3RhdGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJ0eVN0YXRlc1tkZXBEaXJ0eUluZGV4XSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNEZXBEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRlcENhbGNPYmoudHlwZSA9PT0gQ2FsY0hlbHBlci5DQUxDX0ZJRUxEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlcENhbGNPYmouZGlydHkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRGVwRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNEZXBEaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGluZ1N0YWNrLnB1c2goZGVwZW5kc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0RpcnR5RGVwZW5kcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzRGlydHlEZXBlbmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9wQ2FsY0RlcC50eXBlID09PSBDYWxjSGVscGVyLkNBTENfQ09MVU1OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlQ29sdW1uSW50ZXJuYWxfLmNhbGwodGhpcywgdG9wQ2FsY09iaiwgdG9wQ2FsY0RlcC5hZ2dDb250ZXh0ID8gLTEgOiBpbmRleCwgZm9yY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0aW5nU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRvcENhbGNEZXAudHlwZSA9PT0gQ2FsY0hlbHBlci5DQUxDX0ZJRUxEICYmIGZpZWxkc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzTW9kZWwuY2FsY3VsYXRlRmllbGQodG9wQ2FsY09iai5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGluZ1N0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b3BDYWxjRGVwLnR5cGUgPT09IENhbGNIZWxwZXIuREFUQV9DT0xVTU4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhQ29sc01vZGVsLnVuRGlydHkodG9wQ2FsY09iai5uYW1lLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRpbmdTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjYWxjdWxhdGUgZXhjZXB0aW9uIHRocm93biEnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZS5zdGFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBjb2xPYmouaXNDYWxjdWxhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2FsY3VsYXRlQ29sdW1uSW50ZXJuYWxfKGNvbE9iaiwgaW5kZXgsIGZvcmNlKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbE9iai5kaXJ0eSkgeyAvLyBoYXNuJ3QgYmVlbiBjYWxjdWxhdGVkLCBzbyBjYWxjdWxhdGUgYWxsIGlzIG1vcmUgZWZmaWNpZW50LlxuICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGVWYWx1ZXNfLmNhbGwodGhpcywgY29sT2JqKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBoYXMgYWxyZWFkeSBjYWxjdWxhdGVkIGFsbCBvbmNlLCBzbyBub3cgb25seSBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgZGlydHkgaXRlbXMuXG4gICAgICAgICAgICAgICAgICAgIHZhciByb3dDb3VudCA9IHNlbGYuY2FsY1NvdXJjZV8uZ2V0RGltZW5zaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHJvd0NvdW50OyByb3crKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvcmNlIHx8IGNvbE9iai5kaXJ0eVN0YXRlc1tyb3ddICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZVNpbmdsZVZhbHVlXy5jYWxsKHNlbGYsIGNvbE9iaiwgcm93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcmNlIHx8IGNvbE9iai5kaXJ0eVN0YXRlc1tpbmRleF0gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZVNpbmdsZVZhbHVlXy5jYWxsKHNlbGYsIGNvbE9iaiwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZVNpbmdsZVZhbHVlXyhjb2xPYmosIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoY29sT2JqLnR5cGUgPT09IENhbGNIZWxwZXIuQ0FMQ19DT0xVTU4pIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FsY1NvdXJjZSA9IHNlbGYuY2FsY1NvdXJjZV87XG4gICAgICAgICAgICAgICAgdmFyIGNhbGNUYWJsZSA9IGNhbGNTb3VyY2UuZ2V0TW9kZWwoQ2FsY0hlbHBlci5DQUxDX1RBQkxFKTtcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IG5ldyBDYWxjQ29udGV4dC5FdmFsdWF0ZUNvbnRleHQoY2FsY1NvdXJjZSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jdXJyZW50Um93SW50ZXJuYWxfID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgY2FsY1RhYmxlLmJlZ2luQ29udGV4dE1hbmlwdWxhdGUoKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gc2VsZi5ldmFsdWF0b3JfLmV2YWx1YXRlRXhwcmVzc2lvbihjb2xPYmouZXhwcmVzc2lvbiwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKENhbGNIZWxwZXIuY29sdW1uUmVmKHJlc3VsdCkgJiYgaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5nZXRWYWx1ZShpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbE9iai52YWx1ZXNbaW5kZXhdID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGNvbE9iai5kaXJ0eVN0YXRlc1tpbmRleF0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjYWxjVGFibGUuZW5kQ29udGV4dE1hbmlwdWxhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZVZhbHVlc18oY29sT2JqKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoY29sT2JqLnR5cGUgPT09IENhbGNIZWxwZXIuQ0FMQ19DT0xVTU4pIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FsY1NvdXJjZSA9IHNlbGYuY2FsY1NvdXJjZV87XG4gICAgICAgICAgICAgICAgdmFyIGNhbGNUYWJsZSA9IGNhbGNTb3VyY2UuZ2V0TW9kZWwoQ2FsY0hlbHBlci5DQUxDX1RBQkxFKTtcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IG5ldyBDYWxjQ29udGV4dC5FdmFsdWF0ZUNvbnRleHQoc2VsZi5jYWxjU291cmNlXyk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jdXJyZW50Um93SW50ZXJuYWxfID0gLTE7XG4gICAgICAgICAgICAgICAgY2FsY1RhYmxlLmJlZ2luQ29udGV4dE1hbmlwdWxhdGUoKTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gc2VsZi5ldmFsdWF0b3JfLmV2YWx1YXRlRXhwcmVzc2lvbihjb2xPYmouZXhwcmVzc2lvbiwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3JjUm93ID0gc2VsZi5jYWxjU291cmNlXy5tYXBUb1NvdXJjZVJvdyhpKTtcbiAgICAgICAgICAgICAgICAgICAgY29sT2JqLnZhbHVlc1tzcmNSb3ddID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb2xPYmouZGlydHlTdGF0ZXNbc3JjUm93XSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxjVGFibGUuZW5kQ29udGV4dE1hbmlwdWxhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUNvbHVtbkZvcm11bGEoY29sT2JqLCBuZXdGb3JtdWxhKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBjb2xPYmouZm9ybXVsYSA9IG5ld0Zvcm11bGE7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IG5ldyBDYWxjQ29udGV4dC5QYXJzZXJDb250ZXh0KHNlbGYuY2FsY1NvdXJjZV8pO1xuICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBzZWxmLnBhcnNlcl8ucGFyc2UobmV3Rm9ybXVsYSwgY29udGV4dCk7XG4gICAgICAgICAgICBjb2xPYmouZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgICAgICBpZiAoIWV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBjb2xPYmouZGVwZW5kcyA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBkZXBlbmRzID0gQ2FsY0hlbHBlci5yZXNvbHZlRGVwZW5kcyhleHByZXNzaW9uLCBzZWxmLmNhbGNTb3VyY2VfKTtcbiAgICAgICAgICAgICAgICBjb2xPYmouZGVwZW5kcyA9IGRlcGVuZHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkaXJ0eVN0YXRlcyA9IFtdO1xuICAgICAgICAgICAgZGlydHlTdGF0ZXMubGVuZ3RoID0gc2VsZi5jYWxjU291cmNlXy5nZXREaW1lbnNpb24oKTtcbiAgICAgICAgICAgIGNvbE9iai5kaXJ0eVN0YXRlcyA9IGRpcnR5U3RhdGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIENhbGNDb2x1bW5zTW9kZWw7XG4gICAgfSkoKTtcbiAgICBDYWxjTW9kZWxzLkNhbGNDb2x1bW5zTW9kZWwgPSBDYWxjQ29sdW1uc01vZGVsO1xuXG4gICAgdmFyIENhbGNGaWVsZHNNb2RlbCA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2FsY0ZpZWxkc01vZGVsKGNhbGNTb3VyY2UpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHNlbGYuY2FsY1NvdXJjZV8gPSBjYWxjU291cmNlO1xuICAgICAgICAgICAgc2VsZi5wYXJzZXJfID0gY2FsY1NvdXJjZS5nZXRQYXJzZXIoKTtcbiAgICAgICAgICAgIHNlbGYuZXZhbHVhdG9yXyA9IGNhbGNTb3VyY2UuZ2V0RXZhbHVhdG9yKCk7XG4gICAgICAgICAgICBzZWxmLmNhbGNGaWVsZHNfID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBDYWxjRmllbGRzTW9kZWwucHJvdG90eXBlID0ge1xuICAgICAgICAgICAgYWRkRmllbGQ6IGZ1bmN0aW9uKG5hbWUsIGZvcm11bGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBuZXcgQ2FsY0NvbnRleHQuUGFyc2VyQ29udGV4dChzZWxmLmNhbGNTb3VyY2VfKTtcbiAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHNlbGYucGFyc2VyXy5wYXJzZShmb3JtdWxhLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoIWV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkZXBlbmRzID0gQ2FsY0hlbHBlci5yZXNvbHZlRGVwZW5kcyhleHByZXNzaW9uLCBzZWxmLmNhbGNTb3VyY2VfKTtcbiAgICAgICAgICAgICAgICB2YXIgY2FsY0ZpZWxkID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBDYWxjSGVscGVyLkNBTENfRklFTEQsXG4gICAgICAgICAgICAgICAgICAgIGZvcm11bGE6IGZvcm11bGEsXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGRpcnR5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkZXBlbmRzOiBkZXBlbmRzLFxuICAgICAgICAgICAgICAgICAgICBpc0NhbGN1bGF0aW5nOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxjRmllbGRzXy5wdXNoKGNhbGNGaWVsZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGNGaWVsZDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlbW92ZUZpZWxkOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhbGNGaWVsZCA9IF8ucmVtb3ZlKHRoaXMuY2FsY0ZpZWxkc18sIGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZC5uYW1lID09PSBuYW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxjRmllbGQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjYWxjdWxhdGVGaWVsZDogZnVuY3Rpb24obmFtZSwgZ3JvdXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBjYWxjRmllbGQgPSBzZWxmLmZpbmRGaWVsZChuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsY0ZpZWxkLmlzQ2FsY3VsYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjYWxjQ29sc01vZGVsID0gc2VsZi5jYWxjU291cmNlXy5nZXRNb2RlbChDYWxjSGVscGVyLkNBTENfQ09MVU1OKTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YUNvbHNNb2RlbCA9IHNlbGYuY2FsY1NvdXJjZV8uZ2V0TW9kZWwoQ2FsY0hlbHBlci5EQVRBX0NPTFVNTik7XG4gICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgdmFyIGxlbjtcbiAgICAgICAgICAgICAgICB2YXIgZGVwZW5kcztcbiAgICAgICAgICAgICAgICBjYWxjRmllbGQuaXNDYWxjdWxhdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGN1bGF0aW5nU3RhY2sgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRpbmdTdGFjay5wdXNoKHt0eXBlOiBDYWxjSGVscGVyLkNBTENfRklFTEQsIG5hbWU6IG5hbWV9KTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNhbGN1bGF0aW5nU3RhY2subGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9wQ2FsY0RlcCA9IGNhbGN1bGF0aW5nU3RhY2tbY2FsY3VsYXRpbmdTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3BDYWxjT2JqID0gQ2FsY0hlbHBlci5nZXRDYWxjT2JqKHRvcENhbGNEZXAsIHNlbGYuY2FsY1NvdXJjZV8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvcENhbGNPYmogPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGluZ1N0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc0RpcnR5RGVwZW5kcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwZW5kcyA9IHRvcENhbGNPYmouZGVwZW5kcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXBlbmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZGVwZW5kcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVwQ2FsY09iaiA9IENhbGNIZWxwZXIuZ2V0Q2FsY09iaihkZXBlbmRzW2ldLCBzZWxmLmNhbGNTb3VyY2VfKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzRHBlRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlcENhbGNPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZGVwQ2FsY09iai50eXBlID09PSBDYWxjSGVscGVyLkNBTENfRklFTEQgJiYgZGVwQ2FsY09iai5kaXJ0eSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRlcENhbGNPYmoudHlwZSA9PT0gQ2FsY0hlbHBlci5EQVRBX0NPTFVNTiAmJiBkYXRhQ29sc01vZGVsLmhhc0RpcnR5KGRlcENhbGNPYmopKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGVwQ2FsY09iai50eXBlID09PSBDYWxjSGVscGVyLkNBTENfQ09MVU1OICYmIGNhbGNDb2xzTW9kZWwuaGFzRGlydHkoZGVwQ2FsY09iaikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNEcGVEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0RwZURpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRpbmdTdGFjay5wdXNoKGRlcGVuZHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0RpcnR5RGVwZW5kcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc0RpcnR5RGVwZW5kcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b3BDYWxjRGVwLnR5cGUgPT09IENhbGNIZWxwZXIuQ0FMQ19DT0xVTU4gJiYgY2FsY0NvbHNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxjQ29sc01vZGVsLmNhbGN1bGF0ZUNvbHVtbih0b3BDYWxjT2JqLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGluZ1N0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9wQ2FsY0RlcC50eXBlID09PSBDYWxjSGVscGVyLkRBVEFfQ09MVU1OICYmIGRhdGFDb2xzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUNvbHNNb2RlbC51bkRpcnR5KHRvcENhbGNPYmoubmFtZSwgLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGluZ1N0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9wQ2FsY0RlcC50eXBlID09PSBDYWxjSGVscGVyLkNBTENfRklFTEQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlRmllbGRJbnRlcm5hbF8uY2FsbCh0aGlzLCB0b3BDYWxjT2JqLCBncm91cFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGluZ1N0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2NhbGN1bGF0ZSBleGNlcHRpb24gdGhyb3duIScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUuc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2FsY0ZpZWxkLmlzQ2FsY3VsYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBmaW5kRmllbGQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5maW5kKHRoaXMuY2FsY0ZpZWxkc18sIF8ubWF0Y2hlc1Byb3BlcnR5KCduYW1lJywgbmFtZSkpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKG5hbWUsIGdyb3VwUGF0aCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgY2FsY0ZpZWxkT2JqID0gc2VsZi5maW5kRmllbGQobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGNGaWVsZE9iaikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsY0ZpZWxkT2JqLmRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbGN1bGF0ZUZpZWxkKG5hbWUsIGdyb3VwUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGNGaWVsZE9iai52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRGaWVsZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGNGaWVsZHNfO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZGlydHk6IGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBjYWxjRmllbGQgPSBmaWVsZDtcbiAgICAgICAgICAgICAgICBpZiAoXy5pc1N0cmluZyhmaWVsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsY0ZpZWxkID0gc2VsZi5maW5kRmllbGQoZmllbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2FsY0ZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGNGaWVsZC5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZUZpZWxkSW50ZXJuYWxfKGNhbGNGaWVsZE9iaiwgZ3JvdXBQYXRoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoY2FsY0ZpZWxkT2JqLmRpcnR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBuZXcgQ2FsY0NvbnRleHQuRXZhbHVhdGVDb250ZXh0KHNlbGYuY2FsY1NvdXJjZV8sIHVuZGVmaW5lZCwgZ3JvdXBQYXRoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRSb3dJbnRlcm5hbF8gPSAtMTtcbiAgICAgICAgICAgICAgICBjYWxjRmllbGRPYmoudmFsdWUgPSBzZWxmLmV2YWx1YXRvcl8uZXZhbHVhdGVFeHByZXNzaW9uKGNhbGNGaWVsZE9iai5leHByZXNzaW9uLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBjYWxjRmllbGRPYmouZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBDYWxjRmllbGRzTW9kZWw7XG4gICAgfSkoKTtcbiAgICBDYWxjTW9kZWxzLkNhbGNGaWVsZHNNb2RlbCA9IENhbGNGaWVsZHNNb2RlbDtcblxuICAgIHZhciBDYWxjR3JvdXBGaWVsZHNNb2RlbCA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2FsY0dyb3VwRmllbGRzTW9kZWwoY2FsY1NvdXJjZSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgc2VsZi5jYWxjU291cmNlXyA9IGNhbGNTb3VyY2U7XG4gICAgICAgICAgICBzZWxmLnBhcnNlcl8gPSBjYWxjU291cmNlLmdldFBhcnNlcigpO1xuICAgICAgICAgICAgc2VsZi5ldmFsdWF0b3JfID0gY2FsY1NvdXJjZS5nZXRFdmFsdWF0b3IoKTtcbiAgICAgICAgICAgIHNlbGYuY2FsY0ZpZWxkc18gPSBbXTtcbiAgICAgICAgICAgIGluaXRHcm91cHNfLmNhbGwoc2VsZik7XG4gICAgICAgIH1cblxuICAgICAgICBDYWxjR3JvdXBGaWVsZHNNb2RlbC5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgICBhZGRGaWVsZDogZnVuY3Rpb24obmFtZSwgZm9ybXVsYSkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IG5ldyBDYWxjQ29udGV4dC5QYXJzZXJDb250ZXh0KHNlbGYuY2FsY1NvdXJjZV8pO1xuICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gc2VsZi5wYXJzZXJfLnBhcnNlKGZvcm11bGEsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmICghZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGRlcGVuZHMgPSBDYWxjSGVscGVyLnJlc29sdmVEZXBlbmRzKGV4cHJlc3Npb24sIHNlbGYuY2FsY1NvdXJjZV8pO1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZE9iaiA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogQ2FsY0hlbHBlci5DQUxDX0dfRklFTEQsXG4gICAgICAgICAgICAgICAgICAgIGZvcm11bGE6IGZvcm11bGEsXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGRpcnR5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkZXBlbmRzOiBkZXBlbmRzLFxuICAgICAgICAgICAgICAgICAgICBpc0NhbGN1bGF0aW5nOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGNhbGNGaWVsZCA9IHt9O1xuICAgICAgICAgICAgICAgIF8ubWVyZ2UoY2FsY0ZpZWxkLCBzZWxmLnJvb3RHcm91cEZpZWxkXywgZmllbGRPYmopO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsY0ZpZWxkc18ucHVzaChjYWxjRmllbGQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxjRmllbGQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjYWxjdWxhdGVGaWVsZDogZnVuY3Rpb24obmFtZSwgZ3JvdXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBjYWxjRmllbGQgPSBzZWxmLmZpbmRGaWVsZChuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsY0ZpZWxkLmlzQ2FsY3VsYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBmaWVsZHNNb2RlbCA9IHNlbGYuY2FsY1NvdXJjZV8uZ2V0TW9kZWwoQ2FsY0hlbHBlci5DQUxDX0ZJRUxEKTtcbiAgICAgICAgICAgICAgICB2YXIgY2FsY0NvbHNNb2RlbCA9IHNlbGYuY2FsY1NvdXJjZV8uZ2V0TW9kZWwoQ2FsY0hlbHBlci5DQUxDX0NPTFVNTik7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFDb2xzTW9kZWwgPSBzZWxmLmNhbGNTb3VyY2VfLmdldE1vZGVsKENhbGNIZWxwZXIuREFUQV9DT0xVTU4pO1xuICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgIHZhciBsZW47XG4gICAgICAgICAgICAgICAgdmFyIGRlcGVuZHM7XG4gICAgICAgICAgICAgICAgY2FsY0ZpZWxkLmlzQ2FsY3VsYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYWxjdWxhdGluZ1N0YWNrID0gW107XG4gICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0aW5nU3RhY2sucHVzaCh7dHlwZTogQ2FsY0hlbHBlci5DQUxDX0dfRklFTEQsIG5hbWU6IG5hbWV9KTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNhbGN1bGF0aW5nU3RhY2subGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9wQ2FsY0RlcCA9IGNhbGN1bGF0aW5nU3RhY2tbY2FsY3VsYXRpbmdTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3BDYWxjT2JqID0gQ2FsY0hlbHBlci5nZXRDYWxjT2JqKHRvcENhbGNEZXAsIHNlbGYuY2FsY1NvdXJjZV8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvcENhbGNPYmogPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGluZ1N0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc0RpcnR5RGVwZW5kcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwZW5kcyA9IHRvcENhbGNPYmouZGVwZW5kcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXBlbmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZGVwZW5kcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVwQ2FsY09iaiA9IENhbGNIZWxwZXIuZ2V0Q2FsY09iaihkZXBlbmRzW2ldLCBzZWxmLmNhbGNTb3VyY2VfKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzRHBlRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlcENhbGNPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZGVwQ2FsY09iai50eXBlID09PSBDYWxjSGVscGVyLkNBTENfRklFTEQgJiYgZGVwQ2FsY09iai5kaXJ0eSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRlcENhbGNPYmoudHlwZSA9PT0gQ2FsY0hlbHBlci5EQVRBX0NPTFVNTiAmJiBkYXRhQ29sc01vZGVsLmhhc0RpcnR5KGRlcENhbGNPYmopKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGVwQ2FsY09iai50eXBlID09PSBDYWxjSGVscGVyLkNBTENfQ09MVU1OICYmIGNhbGNDb2xzTW9kZWwuaGFzRGlydHkoZGVwQ2FsY09iaikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNEcGVEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0RwZURpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRpbmdTdGFjay5wdXNoKGRlcGVuZHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0RpcnR5RGVwZW5kcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc0RpcnR5RGVwZW5kcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b3BDYWxjRGVwLnR5cGUgPT09IENhbGNIZWxwZXIuQ0FMQ19DT0xVTU4gJiYgY2FsY0NvbHNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxjQ29sc01vZGVsLmNhbGN1bGF0ZUNvbHVtbih0b3BDYWxjT2JqLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGluZ1N0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9wQ2FsY0RlcC50eXBlID09PSBDYWxjSGVscGVyLkNBTENfRklFTEQgJiYgZmllbGRzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzTW9kZWwuY2FsY3VsYXRlRmllbGQodG9wQ2FsY09iai5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRpbmdTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRvcENhbGNEZXAudHlwZSA9PT0gQ2FsY0hlbHBlci5EQVRBX0NPTFVNTiAmJiBkYXRhQ29sc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFDb2xzTW9kZWwudW5EaXJ0eSh0b3BDYWxjT2JqLm5hbWUsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRpbmdTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRvcENhbGNEZXAudHlwZSA9PT0gQ2FsY0hlbHBlci5DQUxDX0dfRklFTEQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlR3JvdXBGaWVsZEludGVybmFsXy5jYWxsKHNlbGYsIHRvcENhbGNPYmosIGdyb3VwUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0aW5nU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnY2FsY3VsYXRlIGV4Y2VwdGlvbiB0aHJvd24hJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZS5zdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjYWxjRmllbGQuaXNDYWxjdWxhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGZpbmRGaWVsZDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfLmZpbmQodGhpcy5jYWxjRmllbGRzXywgXy5tYXRjaGVzUHJvcGVydHkoJ25hbWUnLCBuYW1lKSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24obmFtZSwgZ3JvdXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciByb290R3JvdXBGaWVsZE9iaiA9IHNlbGYuZmluZEZpZWxkKG5hbWUpO1xuICAgICAgICAgICAgICAgIHZhciBncm91cEZpZWxkT2JqID0gZmluZEdyb3VwRmllbGRfLmNhbGwoc2VsZiwgcm9vdEdyb3VwRmllbGRPYmosIGdyb3VwUGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwRmllbGRPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwRmllbGRPYmouZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsY3VsYXRlRmllbGQobmFtZSwgZ3JvdXBQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ3JvdXBGaWVsZE9iai52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0RmllbGRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjRmllbGRzXztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHVwZGF0ZUdyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGluaXRHcm91cHNfLmNhbGwoc2VsZik7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY2FsY0ZpZWxkc18gJiYgc2VsZi5yb290R3JvdXBGaWVsZF8pIHtcbiAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKHNlbGYuY2FsY0ZpZWxkc18sIGZ1bmN0aW9uKGNhbGNGaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsY0ZpZWxkLmZpZWxkcyA9IF8uY2xvbmUoc2VsZi5yb290R3JvdXBGaWVsZF8uZmllbGRzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGNGaWVsZC5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGRpcnR5OiBmdW5jdGlvbihmaWVsZCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgY2FsY0ZpZWxkID0gZmllbGQ7XG4gICAgICAgICAgICAgICAgaWYgKF8uaXNTdHJpbmcoZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGNGaWVsZCA9IHNlbGYuZmluZEZpZWxkKGZpZWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNhbGNGaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICBkaXJ0eUZpZWxkc18uY2FsbChzZWxmLCBjYWxjRmllbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBpbml0R3JvdXBzXygpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciByb290R3JvdXAgPSBzZWxmLmNhbGNTb3VyY2VfLmdldEdyb3VwcygpO1xuICAgICAgICAgICAgaWYgKHJvb3RHcm91cCkge1xuICAgICAgICAgICAgICAgIHNlbGYucm9vdEdyb3VwRmllbGRfID0ge3ZhbHVlOiB1bmRlZmluZWR9O1xuICAgICAgICAgICAgICAgIHJlc29sdmVHcm91cHNfLmNhbGwoc2VsZiwgcm9vdEdyb3VwLCBzZWxmLnJvb3RHcm91cEZpZWxkXyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZXNvbHZlR3JvdXBzXyhncm91cCwgZ3JvdXBGaWVsZCkge1xuICAgICAgICAgICAgaWYgKGdyb3VwLmdyb3Vwcykge1xuICAgICAgICAgICAgICAgIGlmICghZ3JvdXBGaWVsZC5maWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBGaWVsZC5maWVsZHMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKGdyb3VwLmdyb3VwcywgZnVuY3Rpb24oc3ViR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1YkZpZWxkID0ge3ZhbHVlOiB1bmRlZmluZWQsIGRpcnR5OiB0cnVlfTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBGaWVsZC5maWVsZHMucHVzaChzdWJGaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVHcm91cHNfKHN1Ykdyb3VwLCBzdWJGaWVsZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmaW5kR3JvdXBGaWVsZF8ocm9vdEZpZWxkT2JqLCBncm91cFBhdGgpIHtcbiAgICAgICAgICAgIC8vdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRGaWVsZCA9IHJvb3RGaWVsZE9iajtcbiAgICAgICAgICAgIGlmICghY3VycmVudEZpZWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGdyb3VwUGF0aC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGdyb3VwUGF0aFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRzID0gY3VycmVudEZpZWxkLmZpZWxkcztcbiAgICAgICAgICAgICAgICBpZiAoZmllbGRzICYmIGluZGV4IDwgZmllbGRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RmllbGQgPSBmaWVsZHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50RmllbGQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjYWxjdWxhdGVHcm91cEZpZWxkSW50ZXJuYWxfKHJvb3RGaWVsZE9iaiwgZ3JvdXBQYXRoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZ3JvdXBGaWVsZE9iaiA9IGZpbmRHcm91cEZpZWxkXy5jYWxsKHNlbGYsIHJvb3RGaWVsZE9iaiwgZ3JvdXBQYXRoKTtcbiAgICAgICAgICAgIGlmIChncm91cEZpZWxkT2JqICYmIGdyb3VwRmllbGRPYmouZGlydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IG5ldyBDYWxjQ29udGV4dC5FdmFsdWF0ZUNvbnRleHQoc2VsZi5jYWxjU291cmNlXywgdW5kZWZpbmVkLCBncm91cFBhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY3VycmVudFJvd0ludGVybmFsXyA9IC0xO1xuICAgICAgICAgICAgICAgIGdyb3VwRmllbGRPYmoudmFsdWUgPSBzZWxmLmV2YWx1YXRvcl8uZXZhbHVhdGVFeHByZXNzaW9uKHJvb3RGaWVsZE9iai5leHByZXNzaW9uLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBncm91cEZpZWxkT2JqLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkaXJ0eUZpZWxkc18oY2FsY0ZpZWxkKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBjYWxjRmllbGQuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHN1YkZpZWxkcyA9IGNhbGNGaWVsZC5maWVsZHM7XG4gICAgICAgICAgICBpZiAoc3ViRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN1YkZpZWxkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBkaXJ0eUZpZWxkc18uY2FsbChzZWxmLCBzdWJGaWVsZHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBDYWxjR3JvdXBGaWVsZHNNb2RlbDtcbiAgICB9KSgpO1xuICAgIENhbGNNb2RlbHMuQ2FsY0dyb3VwRmllbGRzTW9kZWwgPSBDYWxjR3JvdXBGaWVsZHNNb2RlbDtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQ2FsY01vZGVscztcbn0pKCk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXBwL3NjcmlwdHMvZ3JpZC9jYWxjL2NhbGNNb2RlbHMuanNcbiAqKiBtb2R1bGUgaWQgPSAxNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqXG4gKiBTcHJlYWRKUyBMaWJyYXJ5IDEuMC4wXG4gKiBodHRwOi8vd2lqbW8uY29tL1xuICpcbiAqIENvcHlyaWdodChjKSBHcmFwZUNpdHksIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIFdpam1vIENvbW1lcmNpYWwgTGljZW5zZS4gQWxzbyBhdmFpbGFibGUgdW5kZXIgdGhlIEdOVSBHUEwgVmVyc2lvbiAzIGxpY2Vuc2UuXG4gKiBsaWNlbnNpbmdAd2lqbW8uY29tXG4gKiBodHRwOi8vd2lqbW8uY29tL3dpZGdldHMvbGljZW5zZS9cbiAqXG4gKlxuICoqL1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBDYWxjID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbiAgICB2YXIgQ2FsY01vZGVscyA9IHJlcXVpcmUoJy4vY2FsY01vZGVscycpO1xuICAgIHZhciBDYWxjSGVscGVyID0gcmVxdWlyZSgnLi9jYWxjSGVscGVyJyk7XG4gICAgdmFyIENhbGNFdmFsdWF0b3IgPSByZXF1aXJlKCcuL2V2YWx1YXRvcicpO1xuICAgIHZhciBDYWxjUGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXInKS5QYXJzZXI7XG4gICAgdmFyIENhbGNDb250ZXh0ID0gcmVxdWlyZSgnLi9jYWxjQ29udGV4dCcpO1xuXG4gICAgdmFyIENhbGNTb3VyY2UgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIENhbGNTb3VyY2UobmFtZSwgZGF0YVNvdXJjZSwgY29sdW1uRGVmcykge1xuICAgICAgICAgICAgaWYgKG5hbWUgJiYgZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBzZWxmLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgIHNlbGYuZGF0YVNvdXJjZSA9IGRhdGFTb3VyY2U7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFDb2x1bW5zO1xuICAgICAgICAgICAgICAgIGlmIChjb2x1bW5EZWZzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFDb2x1bW5zID0gXy5maWx0ZXIoY29sdW1uRGVmcywgZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1uLmZpZWxkICYmICFfLnN0YXJ0c1dpdGgoXy50cmltKGNvbHVtbi5maWVsZCksICc9Jyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLmRhdGFDb2x1bW5zXyA9IG5ldyBDYWxjTW9kZWxzLkRhdGFDb2x1bW5zTW9kZWwoZGF0YVNvdXJjZSwgZGF0YUNvbHVtbnMpO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsY0NvbHVtbnNfID0gbmV3IENhbGNNb2RlbHMuQ2FsY0NvbHVtbnNNb2RlbChzZWxmKTtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGNUYWJsZV8gPSBuZXcgQ2FsY01vZGVscy5DYWxjVGFibGVNb2RlbChzZWxmLCBzZWxmLmRhdGFDb2x1bW5zXywgc2VsZi5jYWxjQ29sdW1uc18pO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsY0ZpZWxkc18gPSBuZXcgQ2FsY01vZGVscy5DYWxjRmllbGRzTW9kZWwoc2VsZik7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxjR3JvdXBGaWVsZHNfID0gbmV3IENhbGNNb2RlbHMuQ2FsY0dyb3VwRmllbGRzTW9kZWwoc2VsZik7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbkRlZnMpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKGNvbHVtbkRlZnMsIGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5maWVsZCAmJiBfLnN0YXJ0c1dpdGgoXy50cmltKGNvbHVtbi5maWVsZCksICc9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbGNDb2x1bW5zXy5hZGRDb2x1bW4oY29sdW1uLm5hbWUsIGNvbHVtbi5maWVsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIENhbGNTb3VyY2UucHJvdG90eXBlID0ge1xuICAgICAgICAgICAgZ2V0TmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRSb3dJdGVtOiBmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjVGFibGVfLmdldFJvd0l0ZW0ocm93KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXNDb2x1bW46IGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gISFzZWxmLmNhbGNUYWJsZV8uZmluZENvbHVtbihjb2x1bW4pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhc0ZpZWxkOiBmdW5jdGlvbihmaWVsZCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gISFzZWxmLmNhbGNGaWVsZHNfLmZpbmRGaWVsZChmaWVsZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWRkQ2FsY0NvbHVtbjogZnVuY3Rpb24obmFtZSwgZm9ybXVsYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsY0NvbHVtbnNfLmFkZENvbHVtbihuYW1lLCBmb3JtdWxhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRDYWxjRmllbGQ6IGZ1bmN0aW9uKG5hbWUsIGZvcm11bGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxjRmllbGRzXy5hZGRGaWVsZChuYW1lLCBmb3JtdWxhKTtcbiAgICAgICAgICAgICAgICB2YXIgdW5rbm93bkV4cHJDb2x1bW5zID0gZ2V0VW5rbm93bkV4cHJlc3Npb25Db2x1bW5zLmNhbGwoc2VsZik7XG4gICAgICAgICAgICAgICAgaWYgKHVua25vd25FeHByQ29sdW1ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaCh1bmtub3duRXhwckNvbHVtbnMsIGZ1bmN0aW9uKGNvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxjQ29sdW1uc18udXBkYXRlQ29sdW1uRm9ybXVsYShjb2wpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlQ2FsY0ZpZWxkOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsY0ZpZWxkc18ucmVtb3ZlRmllbGQobmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Q2FsY0ZpZWxkVmFsdWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjRmllbGRzXy5nZXRWYWx1ZShuYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRDYWxjR3JvdXBGaWVsZDogZnVuY3Rpb24obmFtZSwgZm9ybXVsYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsY0dyb3VwRmllbGRzXy5hZGRGaWVsZChuYW1lLCBmb3JtdWxhKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGFkZFJvd0l0ZW06IGZ1bmN0aW9uKGl0ZW0sIHNyY0luZGV4KSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgYWRkSW5kZXggPSBzcmNJbmRleCA/IHNyY0luZGV4IDogc2VsZi5nZXREaW1lbnNpb24oKTtcbiAgICAgICAgICAgICAgICB2YXIgc3JjQ29sbGVjdGlvbiA9IHNlbGYuZGF0YUNvbHVtbnNfLnNvdXJjZUNvbGxlY3Rpb247XG4gICAgICAgICAgICAgICAgaWYgKHNyY0NvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNyY0NvbGxlY3Rpb24uYWRkSXRlbSAmJiBfLmlzRnVuY3Rpb24oc3JjQ29sbGVjdGlvbi5hZGRJdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjQ29sbGVjdGlvbi5hZGRJdGVtKGl0ZW0sIGFkZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfLmlzQXJyYXkoc3JjQ29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY0NvbGxlY3Rpb24uc3BsaWNlKGFkZEluZGV4LCAwLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYWxsQ29sdW1ucyA9IHNlbGYuZGF0YUNvbHVtbnNfLmNvbHVtbnMuY29uY2F0KHNlbGYuY2FsY0NvbHVtbnNfLmNvbHVtbnNfKTtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goYWxsQ29sdW1ucywgZnVuY3Rpb24oY29sT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xPYmoucHJvdG90eXBlID09PSBDYWxjSGVscGVyLkNBTENfQ09MVU1OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xPYmoudmFsdWVzLnNwbGljZShhZGRJbmRleCwgMCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb2xPYmouZGlydHlTdGF0ZXMuc3BsaWNlKGFkZEluZGV4LCAwLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgZGlydHlDb2x1bW5fLmNhbGwoc2VsZiwgY29sT2JqLCBzcmNJbmRleCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICByZW1vdmVSb3dJdGVtOiBmdW5jdGlvbihzcmNJbmRleCkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHNlbGYuZ2V0RGltZW5zaW9uKCk7XG4gICAgICAgICAgICAgICAgdmFyIHNyY0NvbGxlY3Rpb24gPSBzZWxmLmRhdGFDb2x1bW5zXy5zb3VyY2VDb2xsZWN0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChzcmNDb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcmNDb2xsZWN0aW9uLnJlbW92ZUl0ZW0gJiYgXy5pc0Z1bmN0aW9uKHNyY0NvbGxlY3Rpb24ucmVtb3ZlSXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY0NvbGxlY3Rpb24ucmVtb3ZlSXRlbShzcmNJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc0FycmF5KHNyY0NvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcmNDb2xsZWN0aW9uLnNwbGljZShzcmNJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGFsbENvbHVtbnMgPSBzZWxmLmRhdGFDb2x1bW5zXy5jb2x1bW5zLmNvbmNhdChzZWxmLmNhbGNDb2x1bW5zXy5jb2x1bW5zXyk7XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoUmlnaHQoYWxsQ29sdW1ucywgZnVuY3Rpb24oY29sT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xPYmoucHJvdG90eXBlID09PSBDYWxjSGVscGVyLkNBTENfQ09MVU1OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xPYmoudmFsdWVzLnNwbGljZShzcmNJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29sT2JqLmRpcnR5U3RhdGVzLnNwbGljZShzcmNJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGRpcnR5Q29sdW1uXy5jYWxsKHNlbGYsIGNvbE9iaiwgZGltZW5zaW9uKTsvLyBkaXJ0eSBsYXN0IGluZXhpc3RpbmcgaXRlbVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZmlsdGVyOiBmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsY1RhYmxlXy5maWx0ZXIoZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxjRmllbGRzXy5jYWxjRmllbGRzXy5mb3JFYWNoKGZ1bmN0aW9uKGNhbGNmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRpcnR5RmllbGQoY2FsY2ZpZWxkLm5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsY0dyb3VwRmllbGRzXy51cGRhdGVHcm91cHMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzb3J0OiBmdW5jdGlvbihzb3J0ZHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxjVGFibGVfLnNvcnQoc29ydGRzKTtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGNHcm91cEZpZWxkc18udXBkYXRlR3JvdXBzKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ3JvdXA6IGZ1bmN0aW9uKGdkcykge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBzID0gc2VsZi5jYWxjVGFibGVfLmdyb3VwKGdkcyk7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxjR3JvdXBGaWVsZHNfLnVwZGF0ZUdyb3VwcygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBncm91cHM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGllcmFyY2h5OiBmdW5jdGlvbihoaWVyYXJjaHlJbmZvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsY1RhYmxlXy5oaWVyYXJjaHkoaGllcmFyY2h5SW5mbyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRDYWxjR3JvdXBGaWVsZFZhbHVlOiBmdW5jdGlvbihuYW1lLCBncm91cFBhdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjR3JvdXBGaWVsZHNfLmdldFZhbHVlKG5hbWUsIGdyb3VwUGF0aCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0VmFsdWVzOiBmdW5jdGlvbihjb2x1bW4sIGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBjb2xPYmogPSBzZWxmLmZpbmRDb2x1bW4oY29sdW1uKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGNUYWJsZV8uZ2V0VmFsdWVzKGNvbE9iaiwgZ3JvdXAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKGNvbHVtbiwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGNvbE9iaiA9IHNlbGYuZmluZENvbHVtbihjb2x1bW4pO1xuICAgICAgICAgICAgICAgIGlmIChjb2xPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsY1RhYmxlXy5nZXRWYWx1ZShjb2xPYmosIGluZGV4LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjVGFibGVfLmdldFJvd0NvdW50KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0RGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjVGFibGVfLmdldERpbWVuc2lvbigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbmRDb2x1bW46IGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5maW5kRGF0YUNvbHVtbihjb2x1bW4pIHx8IHNlbGYuZmluZENhbGNDb2x1bW4oY29sdW1uKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaW5kRGF0YUNvbHVtbjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFDb2x1bW5zXy5maW5kQ29sdW1uKG5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbmRDYWxjQ29sdW1uOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsY0NvbHVtbnNfLmZpbmRDb2x1bW4obmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmluZENhbGNGaWVsZDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGNGaWVsZHNfLmZpbmRGaWVsZChuYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaW5kQ2FsY0dyb3VwRmllbGQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjR3JvdXBGaWVsZHNfLmZpbmRGaWVsZChuYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRGaWVsZFZhbHVlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FsY0ZpZWxkc18pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsY0ZpZWxkc18uZ2V0VmFsdWUobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldERhdGFUeXBlOiBmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sT2JqID0gdGhpcy5jYWxjVGFibGVfLmZpbmRDb2x1bW4oY29sdW1uKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xPYmouZGF0YVR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFBhcnNlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDYWxjUGFyc2VyKENhbGMucGFyc2VPcHRpb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEV2YWx1YXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDYWxjRXZhbHVhdG9yKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UGFyc2VyQ29udGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDYWxjQ29udGV4dC5QYXJzZXJDb250ZXh0KHRoaXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEV2YWx1YXRvckNvbnRleHQ6IGZ1bmN0aW9uKHJvdywgZ3JvdXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDYWxjQ29udGV4dC5FdmFsdWF0ZUNvbnRleHQodGhpcywgcm93LCBncm91cFBhdGgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEdyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsY1RhYmxlXy5nZXRHcm91cHMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRSb290Tm9kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsY1RhYmxlXy5nZXRSb290Tm9kZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24obmFtZSwgZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2FsY1NvdXJjZShuYW1lLCBkYXRhU291cmNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBjbG9uZWRPYmogPSBuZXcgQ2FsY1NvdXJjZSgpO1xuICAgICAgICAgICAgICAgIGNsb25lZE9iai5uYW1lID0gc2VsZi5uYW1lO1xuICAgICAgICAgICAgICAgIGNsb25lZE9iai5kYXRhU291cmNlID0gc2VsZi5kYXRhU291cmNlO1xuICAgICAgICAgICAgICAgIGNsb25lZE9iai5kYXRhQ29sdW1uc18gPSBzZWxmLmRhdGFDb2x1bW5zXztcbiAgICAgICAgICAgICAgICBjbG9uZWRPYmouY2FsY0NvbHVtbnNfID0gc2VsZi5jYWxjQ29sdW1uc187XG4gICAgICAgICAgICAgICAgY2xvbmVkT2JqLmNhbGNUYWJsZV8gPSBzZWxmLmNhbGNUYWJsZV8uY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBjbG9uZWRPYmouY2FsY0ZpZWxkc18gPSBzZWxmLmNhbGNGaWVsZHNfO1xuICAgICAgICAgICAgICAgIGNsb25lZE9iai5jYWxjR3JvdXBGaWVsZHNfID0gc2VsZi5jYWxjR3JvdXBGaWVsZHNfO1xuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZWRPYmo7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVwcm9kdWNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIHJlcHJvZHVjZWRPYmogPSBuZXcgQ2FsY1NvdXJjZSgpO1xuICAgICAgICAgICAgICAgIHJlcHJvZHVjZWRPYmoubmFtZSA9IHNlbGYubmFtZTtcbiAgICAgICAgICAgICAgICByZXByb2R1Y2VkT2JqLmRhdGFTb3VyY2UgPSBzZWxmLmRhdGFTb3VyY2U7XG4gICAgICAgICAgICAgICAgcmVwcm9kdWNlZE9iai5kYXRhQ29sdW1uc18gPSBzZWxmLmRhdGFDb2x1bW5zXztcbiAgICAgICAgICAgICAgICByZXByb2R1Y2VkT2JqLmNhbGNDb2x1bW5zXyA9IHNlbGYuY2FsY0NvbHVtbnNfO1xuICAgICAgICAgICAgICAgIHJlcHJvZHVjZWRPYmouY2FsY1RhYmxlXyA9IHNlbGYuY2FsY1RhYmxlXy5yZXByb2R1Y2UoKTtcbiAgICAgICAgICAgICAgICByZXByb2R1Y2VkT2JqLmNhbGNGaWVsZHNfID0gc2VsZi5jYWxjRmllbGRzXztcbiAgICAgICAgICAgICAgICByZXByb2R1Y2VkT2JqLmNhbGNHcm91cEZpZWxkc18gPSBzZWxmLmNhbGNHcm91cEZpZWxkc187XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcHJvZHVjZWRPYmo7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVwcm9kdWNlV2l0aENvbHVtbnM6IGZ1bmN0aW9uKGNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIHJlcHJvZHVjZWRPYmogPSBuZXcgQ2FsY1NvdXJjZSgpO1xuICAgICAgICAgICAgICAgIHJlcHJvZHVjZWRPYmoubmFtZSA9IHNlbGYubmFtZTtcbiAgICAgICAgICAgICAgICByZXByb2R1Y2VkT2JqLmRhdGFTb3VyY2UgPSBzZWxmLmRhdGFTb3VyY2U7XG4gICAgICAgICAgICAgICAgcmVwcm9kdWNlZE9iai5kYXRhQ29sdW1uc18gPSBzZWxmLmRhdGFDb2x1bW5zXztcbiAgICAgICAgICAgICAgICByZXByb2R1Y2VkT2JqLmNhbGNDb2x1bW5zXyA9IHNlbGYuY2FsY0NvbHVtbnNfO1xuICAgICAgICAgICAgICAgIHJlcHJvZHVjZWRPYmouY2FsY1RhYmxlXyA9IHNlbGYuY2FsY1RhYmxlXy5yZXByb2R1Y2VXaXRoQ29sdW1ucyhjb2x1bW5zKTtcbiAgICAgICAgICAgICAgICByZXByb2R1Y2VkT2JqLmNhbGNGaWVsZHNfID0gc2VsZi5jYWxjRmllbGRzXztcbiAgICAgICAgICAgICAgICByZXByb2R1Y2VkT2JqLmNhbGNHcm91cEZpZWxkc18gPSBzZWxmLmNhbGNHcm91cEZpZWxkc187XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcHJvZHVjZWRPYmo7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmluZEdyb3VwOiBmdW5jdGlvbihncm91cFBhdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjVGFibGVfLmJpbmRHcm91cChncm91cFBhdGgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuYmluZEdyb3VwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjVGFibGVfLnVuYmluZEdyb3VwKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0R3JvdXBQYXRoOiBmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjVGFibGVfLmdldEdyb3VwUGF0aChyb3cpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG92ZXJsYXBGaWx0ZXJTdGF0ZXNfOiBmdW5jdGlvbihmaWx0ZXJTdGF0ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxjVGFibGVfLm92ZXJsYXBGaWx0ZXJTdGF0ZXMoZmlsdGVyU3RhdGVzKTtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGNHcm91cEZpZWxkc18udXBkYXRlR3JvdXBzKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3ZlcmxhcEZpbHRlclNpbmdsZVN0YXRlXzogZnVuY3Rpb24oZmlsdGVyU3RhdGVzLCBjdXJyZW50Um93KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsY1RhYmxlXy5vdmVybGFwRmlsdGVyU2luZ2xlU3RhdGUoZmlsdGVyU3RhdGVzLCBjdXJyZW50Um93KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRNb2RlbDogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDYWxjSGVscGVyLkRBVEFfQ09MVU1OOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZGF0YUNvbHVtbnNfO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENhbGNIZWxwZXIuQ0FMQ19DT0xVTU46XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxjQ29sdW1uc187XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ2FsY0hlbHBlci5DQUxDX1RBQkxFOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsY1RhYmxlXztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDYWxjSGVscGVyLkNBTENfRklFTEQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxjRmllbGRzXztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDYWxjSGVscGVyLkNBTENfR19GSUVMRDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNhbGNHcm91cEZpZWxkc187XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpcnR5Q29sdW1uOiBmdW5jdGlvbihjb2x1bW4sIGluZGV4LCBuZXdGb3JtdWxhKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBjb2wgPSBzZWxmLmZpbmRDb2x1bW4oY29sdW1uKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc3JjSW5kZXggPSBzZWxmLmNhbGNUYWJsZV8ubWFwVG9Tb3VyY2VSb3coaW5kZXgpO1xuICAgICAgICAgICAgICAgIHZhciB3aG9sZUNvbHVtbkNoYW5nZWQgPSBkaXJ0eUNvbHVtbl8uY2FsbChzZWxmLCBjb2wsIHNyY0luZGV4LCBuZXdGb3JtdWxhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggPT09IC0xIHx8IHdob2xlQ29sdW1uQ2hhbmdlZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXJ0eUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgY2FsY0NvbHVtbnMgPSBzZWxmLmNhbGNDb2x1bW5zXy5nZXRDb2x1bW5zKCk7XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKGNhbGNDb2x1bW5zLCBmdW5jdGlvbihjYWxjQ29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpcnR5Q29sdW1uXy5jYWxsKHNlbGYsIGNhbGNDb2x1bW4sIC0xKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXJ0eUZpZWxkOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IHNlbGYuZmluZENhbGNGaWVsZChuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxjRmllbGRzXy5kaXJ0eShuYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gZmluZExpc3RlbmVyc1JlY3Vyc2l2ZWx5Xy5jYWxsKHNlbGYsIHtjYWxjOiBmaWVsZCwgaW5kZXg6IC0xfSk7XG4gICAgICAgICAgICAgICAgZGlydHlMaXN0ZW5lcnNfLmNhbGwoc2VsZiwgbGlzdGVuZXJzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXJ0eUZpZWxkczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZHMgPSBzZWxmLmNhbGNGaWVsZHNfLmdldEZpZWxkcygpO1xuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChmaWVsZHMsIGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsY0ZpZWxkc18uZGlydHkoZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gZmluZExpc3RlbmVyc1JlY3Vyc2l2ZWx5Xy5jYWxsKHNlbGYsIHtjYWxjOiBmaWVsZCwgaW5kZXg6IC0xfSk7XG4gICAgICAgICAgICAgICAgICAgIGRpcnR5TGlzdGVuZXJzXy5jYWxsKHNlbGYsIGxpc3RlbmVycyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlydHlBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlydHlDb2x1bW5zKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eUZpZWxkcygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvQXJyYXk6IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsY1RhYmxlXy50b0FycmF5KGdyb3VwKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG1hcFRvU291cmNlUm93OiBmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjVGFibGVfLm1hcFRvU291cmNlUm93KHJvdyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWFwVG9WaWV3Um93OiBmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjVGFibGVfLm1hcFRvVmlld1Jvdyhyb3cpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzRmlsdGVyT3V0OiBmdW5jdGlvbihzcmNSb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjVGFibGVfLmlzRmlsdGVyT3V0KHNyY1Jvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gZGlydHlDb2x1bW5fKGNvbCwgc3JjSW5kZXgsIG5ld0Zvcm11bGEpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGlmIChjb2wudHlwZSA9PT0gQ2FsY0hlbHBlci5EQVRBX0NPTFVNTikge1xuICAgICAgICAgICAgICAgIHNlbGYuZGF0YUNvbHVtbnNfLmRpcnR5KGNvbCwgc3JjSW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wudHlwZSA9PT0gQ2FsY0hlbHBlci5DQUxDX0NPTFVNTikge1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsY0NvbHVtbnNfLmRpcnR5KGNvbCwgLTEsIG5ld0Zvcm11bGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IGZpbmRMaXN0ZW5lcnNSZWN1cnNpdmVseV8uY2FsbChzZWxmLCB7Y2FsYzogY29sLCBpbmRleDogc3JjSW5kZXh9KTtcbiAgICAgICAgICAgIGRpcnR5TGlzdGVuZXJzXy5jYWxsKHNlbGYsIGxpc3RlbmVycyk7XG4gICAgICAgICAgICByZXR1cm4gXy5hbnkobGlzdGVuZXJzLCBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lci5jYWxjLnR5cGUgPT09IENhbGNIZWxwZXIuQ0FMQ19DT0xVTU4gJiYgbGlzdGVuZXIuaW5kZXggPT09IC0xO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmaW5kTGlzdGVuZXJzUmVjdXJzaXZlbHlfKGNhbGNMaXN0ZW5lcikge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IGZpbmRMaXN0ZW5lcnNfLmNhbGwoc2VsZiwgY2FsY0xpc3RlbmVyKTtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChsaXN0ZW5lcnMsIGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWVwTGlzdGVuZXJzID0gZmluZExpc3RlbmVyc1JlY3Vyc2l2ZWx5Xy5jYWxsKHNlbGYsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmNvbmNhdChkZWVwTGlzdGVuZXJzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmaW5kTGlzdGVuZXJzXyhjYWxjTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBjYWxjQ29scyA9IHNlbGYuY2FsY0NvbHVtbnNfLmdldENvbHVtbnMoKTtcbiAgICAgICAgICAgIF8uZm9yRWFjaChjYWxjQ29scywgZnVuY3Rpb24oY2FsY0NvbCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0luRGVwZW5kc18uY2FsbChzZWxmLCBjYWxjTGlzdGVuZXIuY2FsYywgY2FsY0NvbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2FsY0luQWdnXyhjYWxjTGlzdGVuZXIuY2FsYywgY2FsY0NvbC5leHByZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2goe2NhbGM6IGNhbGNDb2wsIGluZGV4OiAtMX0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2goe2NhbGM6IGNhbGNDb2wsIGluZGV4OiBjYWxjTGlzdGVuZXIuaW5kZXh9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGNhbGNGaWVsZHMgPSBzZWxmLmNhbGNGaWVsZHNfLmdldEZpZWxkcygpO1xuICAgICAgICAgICAgXy5mb3JFYWNoKGNhbGNGaWVsZHMsIGZ1bmN0aW9uKGNhbGNGaWVsZCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0luRGVwZW5kc18uY2FsbChzZWxmLCBjYWxjTGlzdGVuZXIuY2FsYywgY2FsY0ZpZWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMucHVzaCh7Y2FsYzogY2FsY0ZpZWxkLCBpbmRleDogLTF9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBjYWxjR3JvdXBGaWVsZHMgPSBzZWxmLmNhbGNHcm91cEZpZWxkc18uZ2V0RmllbGRzKCk7XG4gICAgICAgICAgICBfLmZvckVhY2goY2FsY0dyb3VwRmllbGRzLCBmdW5jdGlvbihjYWxjRmllbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNJbkRlcGVuZHNfLmNhbGwoc2VsZiwgY2FsY0xpc3RlbmVyLmNhbGMsIGNhbGNGaWVsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2goe2NhbGM6IGNhbGNGaWVsZCwgaW5kZXg6IC0xfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbGlzdGVuZXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNJbkRlcGVuZHNfKGNhbGMxLCBjYWxjMikge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGRlcGVuZHMgPSBjYWxjMi5kZXBlbmRzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRlcGVuZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZXBlbmRfLmNhbGwoc2VsZiwgY2FsYzEsIGRlcGVuZHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzRGVwZW5kXyhjYWxjLCBkZXBlbmQpIHtcbiAgICAgICAgICAgIGlmIChkZXBlbmQudHlwZSA9PT0gY2FsYy50eXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBkZXBlbmQudHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoKHR5cGUgPT09IENhbGNIZWxwZXIuQ0FMQ19DT0xVTU4gJiYgZGVwZW5kLmNvbHVtbiA9PT0gY2FsYy5uYW1lKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGUgPT09IENhbGNIZWxwZXIuREFUQV9DT0xVTU4gJiYgZGVwZW5kLmNvbHVtbiA9PT0gY2FsYy5uYW1lKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGUgPT09IENhbGNIZWxwZXIuQ0FMQ19GSUVMRCAmJiBkZXBlbmQubmFtZSA9PT0gY2FsYy5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNDYWxjSW5BZ2dfKGNhbGMsIGV4cHIpIHtcbiAgICAgICAgICAgIGlmIChDYWxjSGVscGVyLmFnZ0ZuKGV4cHIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChDYWxjSGVscGVyLmJpbmFyeUV4cHIoZXhwcikpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaXNDYWxjSW5BZ2dfKGNhbGMsIGV4cHIubGVmdCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzQ2FsY0luQWdnXyhjYWxjLCBleHByLnJpZ2h0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQ2FsY0hlbHBlci5mbkV4cHIoZXhwcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoQ2FsY0hlbHBlci5hZ2dGbihleHByKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGV4cHIuYXJncztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MgJiYgYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5hbnkoYXJncywgZnVuY3Rpb24oYXJnRXhwcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0NhbGNJbkFnZ18oY2FsYywgYXJnRXhwcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRpcnR5TGlzdGVuZXJzXyhsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIF8uZm9yRWFjaChsaXN0ZW5lcnMsIGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhbGMgPSBsaXN0ZW5lci5jYWxjO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGxpc3RlbmVyLmluZGV4O1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gY2FsYy50eXBlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENhbGNIZWxwZXIuREFUQV9DT0xVTU46XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIuaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGF0YUNvbHVtbnNfLmRpcnR5KGNhbGMsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENhbGNIZWxwZXIuQ0FMQ19DT0xVTU46XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIuaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsY0NvbHVtbnNfLmRpcnR5KGNhbGMsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENhbGNIZWxwZXIuQ0FMQ19GSUVMRDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsY0ZpZWxkc18uZGlydHkoY2FsYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDYWxjSGVscGVyLkNBTENfR19GSUVMRDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsY0dyb3VwRmllbGRzXy5kaXJ0eShjYWxjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0VW5rbm93bkV4cHJlc3Npb25Db2x1bW5zKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBjYWxjQ29sdW1ucyA9IHNlbGYuY2FsY0NvbHVtbnNfLmdldENvbHVtbnMoKTtcbiAgICAgICAgICAgIGlmIChjYWxjQ29sdW1ucykge1xuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChjYWxjQ29sdW1ucywgZnVuY3Rpb24oY2FsY0NvbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY29udGFpbnNVbmtub3duRXhwcmVzc2lvbi5jYWxsKHNlbGYsIGNhbGNDb2wuZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnMucHVzaChjYWxjQ29sLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29sdW1ucztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbnRhaW5zVW5rbm93bkV4cHJlc3Npb24oZXhwcikge1xuICAgICAgICAgICAgaWYgKCFleHByKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKENhbGNIZWxwZXIudW5rbm93RXhwcihleHByKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChDYWxjSGVscGVyLmJpbmFyeUV4cHIoZXhwcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnNVbmtub3duRXhwcmVzc2lvbihleHByLmxlZnQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluc1Vua25vd25FeHByZXNzaW9uKGV4cHIucmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKENhbGNIZWxwZXIuZm5FeHByKGV4cHIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBleHByLmFyZ3M7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MgJiYgYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbnNVbmtub3duRXhwcmVzc2lvbihhcmdzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIENhbGNTb3VyY2U7XG4gICAgfSkoKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBDYWxjU291cmNlOiBDYWxjU291cmNlXG4gICAgfTtcbn0pKCk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXBwL3NjcmlwdHMvZ3JpZC9jYWxjL2NhbGNTb3VyY2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqXG4gKiBTcHJlYWRKUyBMaWJyYXJ5IDEuMC4wXG4gKiBodHRwOi8vd2lqbW8uY29tL1xuICpcbiAqIENvcHlyaWdodChjKSBHcmFwZUNpdHksIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIFdpam1vIENvbW1lcmNpYWwgTGljZW5zZS4gQWxzbyBhdmFpbGFibGUgdW5kZXIgdGhlIEdOVSBHUEwgVmVyc2lvbiAzIGxpY2Vuc2UuXG4gKiBsaWNlbnNpbmdAd2lqbW8uY29tXG4gKiBodHRwOi8vd2lqbW8uY29tL3dpZGdldHMvbGljZW5zZS9cbiAqXG4gKlxuICoqL1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBDYWxjU291cmNlID0gcmVxdWlyZSgnLi9jYWxjU291cmNlJyk7XG4gICAgdmFyIENhbGNNb2RlbHMgPSByZXF1aXJlKCcuL2NhbGNNb2RlbHMnKTtcblxuICAgIHZhciBvYmplY3REZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuICAgIHZhciBFdmVudEhhbmRsZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIEV2ZW50SGFuZGxlcihoYW5kbGVyLCBzZWxmKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICAgICAgdGhpcy5zZWxmID0gc2VsZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBFdmVudEhhbmRsZXI7XG4gICAgfSkoKTtcblxuICAgIHZhciBFdmVudCA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gRXZlbnQoKSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVycyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgRXZlbnQucHJvdG90eXBlLmFkZEhhbmRsZXIgPSBmdW5jdGlvbihoYW5kbGVyLCBzZWxmKSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVycy5wdXNoKG5ldyBFdmVudEhhbmRsZXIoaGFuZGxlciwgc2VsZikpO1xuICAgICAgICB9O1xuXG4gICAgICAgIEV2ZW50LnByb3RvdHlwZS5yZW1vdmVIYW5kbGVyID0gZnVuY3Rpb24oaGFuZGxlciwgc2VsZikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9oYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBsID0gdGhpcy5faGFuZGxlcnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGwuaGFuZGxlciA9PT0gaGFuZGxlciAmJiBsLnNlbGYgPT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgRXZlbnQucHJvdG90eXBlLnJlbW92ZUFsbEhhbmRsZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVycy5sZW5ndGggPSAwO1xuICAgICAgICB9O1xuXG4gICAgICAgIEV2ZW50LnByb3RvdHlwZS5yYWlzZSA9IGZ1bmN0aW9uKHNlbmRlciwgYXJncykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmdzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9oYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBsID0gdGhpcy5faGFuZGxlcnNbaV07XG4gICAgICAgICAgICAgICAgbC5oYW5kbGVyLmNhbGwobC5zZWxmLCBzZW5kZXIsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsICdoYXNIYW5kbGVycycsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBhIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBldmVudCBoYXMgYW55IGhhbmRsZXJzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVycy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBFdmVudDtcbiAgICB9KSgpO1xuXG4gICAgdmFyIENhbGNDb2xsZWN0aW9uR3JvdXAgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiBhIEBzZWU6Q29sbGVjdGlvblZpZXdHcm91cC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGdyb3VwRGVzY3JpcHRvciBAc2VlOkdyb3VwRGVzY3JpcHRpb24gdGhhdCBvd25zIHRoZSBuZXcgZ3JvdXAuXG4gICAgICAgICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIG5ldyBncm91cC5cbiAgICAgICAgICogQHBhcmFtIGxldmVsIExldmVsIG9mIHRoZSBuZXcgZ3JvdXAuXG4gICAgICAgICAqIEBwYXJhbSBpc0JvdHRvbUxldmVsIFdoZXRoZXIgdGhpcyBncm91cCBoYXMgYW55IHN1Ymdyb3Vwcy5cbiAgICAgICAgICogQHBhcmFtIGNvbGxhcHNlZCBXaGV0aGVyIHRoaXMgZ3JvdXAgaXMgY29sbGFwc2VkIG9yIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQ2FsY0NvbGxlY3Rpb25Hcm91cChjYWxjQ29sbGVjdGlvbiwgZ3JvdXBEZXNjcmlwdG9yLCBjYWxjR3JvdXApIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHNlbGYuX2NhbGNDb2xsZWN0aW9uID0gY2FsY0NvbGxlY3Rpb247XG4gICAgICAgICAgICBzZWxmLl9nZCA9IGdyb3VwRGVzY3JpcHRvcjtcbiAgICAgICAgICAgIHNlbGYuX2NhbGNHcm91cCA9IGNhbGNHcm91cDtcbiAgICAgICAgICAgIHNlbGYuX2NvbGxhcHNlZCA9IGdyb3VwRGVzY3JpcHRvciA/ICEhZ3JvdXBEZXNjcmlwdG9yLmNvbGxhcHNlZCA6IGZhbHNlO1xuICAgICAgICAgICAgc2VsZi5fZ3JvdXBzID0gW107XG4gICAgICAgICAgICB2YXIgaGRzID0gY2FsY0NvbGxlY3Rpb24uaGllcmFyY2h5RGVzY3JpcHRvcjtcbiAgICAgICAgICAgIGlmIChjYWxjR3JvdXAuaXNCb3R0b21MZXZlbCAmJiBjYWxjR3JvdXAucm9vdE5vZGUgJiYgaGRzKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fcm9vdE5vZGUgPSBDYWxjQ29sbGVjdGlvbi5jcmVhdGVDVlRyZWVfKGNhbGNHcm91cC5yb290Tm9kZSwgaGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vY3ZnUHJvdG90eXBlLnRvR2xvYmFsSW5kZXggPSBmdW5jdGlvbihsb2NhbEluZGV4KSB7XG4gICAgICAgIC8vICAgIHJldHVybiB0aGlzLl9jYWxjR3JvdXAudG9HbG9iYWxJbmRleChsb2NhbEluZGV4KTtcbiAgICAgICAgLy99OyAgICAgICAgLy9jdmdQcm90b3R5cGUudG9HbG9iYWxJbmRleCA9IGZ1bmN0aW9uKGxvY2FsSW5kZXgpIHtcbiAgICAgICAgLy8gICAgcmV0dXJuIHRoaXMuX2NhbGNHcm91cC50b0dsb2JhbEluZGV4KGxvY2FsSW5kZXgpO1xuICAgICAgICAvL307XG5cbiAgICAgICAgQ2FsY0NvbGxlY3Rpb25Hcm91cC5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgICBnZXRJdGVtOiBmdW5jdGlvbihsb2NhbEluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLl9yb290Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fcm9vdE5vZGUuZ2V0SXRlbShsb2NhbEluZGV4KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fY2FsY0dyb3VwLmdldEl0ZW0obG9jYWxJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEl0ZW1zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX3Jvb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9yb290Tm9kZS5nZXRJdGVtcygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxjR3JvdXAuZ2V0SXRlbXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9Tb3VyY2VSb3c6IGZ1bmN0aW9uKGxvY2FsSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX3Jvb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9yb290Tm9kZS50b1NvdXJjZVJvdyhsb2NhbEluZGV4KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsY0dyb3VwLnRvU291cmNlSW5kZXgobG9jYWxJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZVRyZWVfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdXBkYXRlVHJlZV8oc2VsZiwgc2VsZi5fY2FsY0NvbGxlY3Rpb24uaGllcmFyY2h5RGVzY3JpcHRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGN2Z1Byb3RvdHlwZSA9IENhbGNDb2xsZWN0aW9uR3JvdXAucHJvdG90eXBlO1xuXG4gICAgICAgIG9iamVjdERlZmluZVByb3BlcnR5KGN2Z1Byb3RvdHlwZSwgJ25hbWUnLCB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogR2V0cyB0aGUgbmFtZSBvZiB0aGlzIGdyb3VwLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxjR3JvdXAubmFtZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9iamVjdERlZmluZVByb3BlcnR5KGN2Z1Byb3RvdHlwZSwgJ2NvbGxhcHNlZCcsIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBuYW1lIG9mIHRoaXMgZ3JvdXAuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbGxhcHNlZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGFwc2VkID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBvYmplY3REZWZpbmVQcm9wZXJ0eShjdmdQcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogR2V0cyB0aGUgbmFtZSBvZiB0aGlzIGdyb3VwLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2JqZWN0RGVmaW5lUHJvcGVydHkoY3ZnUHJvdG90eXBlLCAnbGV2ZWwnLCB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogR2V0cyB0aGUgbGV2ZWwgb2YgdGhpcyBncm91cC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsY0dyb3VwLmxldmVsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2JqZWN0RGVmaW5lUHJvcGVydHkoY3ZnUHJvdG90eXBlLCAnaXNCb3R0b21MZXZlbCcsIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBHZXRzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGlzIGdyb3VwIGhhcyBhbnkgc3ViZ3JvdXBzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxjR3JvdXAuaXNCb3R0b21MZXZlbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9iamVjdERlZmluZVByb3BlcnR5KGN2Z1Byb3RvdHlwZSwgJ2l0ZW1Db3VudCcsIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBHZXRzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGl0ZW1zIGluY2x1ZGVkIGluIHRoaXMgZ3JvdXAgKGluY2x1ZGluZyBhbGwgc3ViZ3JvdXBzKS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsY0dyb3VwLml0ZW1Db3VudDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9iamVjdERlZmluZVByb3BlcnR5KGN2Z1Byb3RvdHlwZSwgJ2dyb3VwcycsIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBHZXRzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHRoaXMgZ3JvdXAncyBzdWJncm91cHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3VwcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9iamVjdERlZmluZVByb3BlcnR5KGN2Z1Byb3RvdHlwZSwgJ2dyb3VwRGVzY3JpcHRvcicsIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBAc2VlOkdyb3VwRGVzY3JpcHRpb24gdGhhdCBvd25zIHRoaXMgZ3JvdXAuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2JqZWN0RGVmaW5lUHJvcGVydHkoY3ZnUHJvdG90eXBlLCAncm9vdE5vZGUnLCB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogR2V0cyB0aGUgQHNlZTpHcm91cERlc2NyaXB0aW9uIHRoYXQgb3ducyB0aGlzIGdyb3VwLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290Tm9kZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9iamVjdERlZmluZVByb3BlcnR5KGN2Z1Byb3RvdHlwZSwgJ2lzSGllcmFyY2hpY2FsJywge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEdldHMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2hcbiAgICAgICAgICAgICAqIGdyb3VwIGFuIGl0ZW0gYmVsb25ncyB0by5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRyYXZlcnNhbEJvdHRvbUdyb3Vwc18oc2VsZiwgZnVuY3Rpb24oY3ZHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3ZHcm91cC5yb290Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRyZWVfKGN2R3JvdXAsIGhkcykge1xuICAgICAgICAgICAgdHJhdmVyc2FsQm90dG9tR3JvdXBzXyhjdkdyb3VwLCBmdW5jdGlvbihjdkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhbGNHcm91cCA9IGN2R3JvdXAuX2NhbGNHcm91cDtcbiAgICAgICAgICAgICAgICBpZiAoY2FsY0dyb3VwLnJvb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN2R3JvdXAuX3Jvb3ROb2RlID0gQ2FsY0NvbGxlY3Rpb24uY3JlYXRlQ1ZUcmVlXyhjYWxjR3JvdXAucm9vdE5vZGUsIGhkcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB0cmF2ZXJzYWxCb3R0b21Hcm91cHNfKGN2R3JvdXAsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoY3ZHcm91cC5pc0JvdHRvbUxldmVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0b3AgPSBjYWxsYmFjayhjdkdyb3VwKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goY3ZHcm91cC5ncm91cHMsIGZ1bmN0aW9uKHN1Ykdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYXZlcnNhbEJvdHRvbUdyb3Vwc18oc3ViR3JvdXAsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBDYWxjQ29sbGVjdGlvbkdyb3VwO1xuICAgIH0pKCk7XG5cbiAgICB2YXIgQ2FsY0NvbGxlY3Rpb25Ob2RlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBDYWxjQ29sbGVjdGlvbk5vZGUoY2FsY05vZGUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHNlbGYuX2NhbGNOb2RlID0gY2FsY05vZGU7XG4gICAgICAgICAgICBzZWxmLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5fY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIENhbGNDb2xsZWN0aW9uTm9kZS5vZmZzZXRVbml0ID0gMjA7XG5cbiAgICAgICAgQ2FsY0NvbGxlY3Rpb25Ob2RlLnByb3RvdHlwZSA9IHtcbiAgICAgICAgICAgIGdldEl0ZW06IGZ1bmN0aW9uKHJlbGF0aXZlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gQ2FsY01vZGVscy5DYWxjTm9kZV8uZmluZE5vZGVfKHNlbGYsIHJlbGF0aXZlSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBub2RlLl9jYWxjTm9kZS5nZXRJdGVtKCk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ubm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEl0ZW1zOiBmdW5jdGlvbihvcHRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsY05vZGUuZ2V0SXRlbXMob3B0aW9uKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBleHBhbmRBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGNOb2RlLmV4cGFuZEFsbCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbGxhcHNlQWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxjTm9kZS5jb2xsYXBzZUFsbCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbmROb2RlOiBmdW5jdGlvbihyZWxhdGl2ZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENhbGNNb2RlbHMuQ2FsY05vZGVfLmZpbmROb2RlXyh0aGlzLCByZWxhdGl2ZUluZGV4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b1NvdXJjZVJvdzogZnVuY3Rpb24ocmVsYXRpdmVJbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxjTm9kZS50b1NvdXJjZUluZGV4KHJlbGF0aXZlSW5kZXgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGN2Z1Byb3RvdHlwZSA9IENhbGNDb2xsZWN0aW9uTm9kZS5wcm90b3R5cGU7XG5cbiAgICAgICAgb2JqZWN0RGVmaW5lUHJvcGVydHkoY3ZnUHJvdG90eXBlLCAnY29sbGFwc2VkJywge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEdldHMgdGhlIG5hbWUgb2YgdGhpcyBncm91cC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsY05vZGUuY29sbGFwc2VkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxjTm9kZS5jb2xsYXBzZWQgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9iamVjdERlZmluZVByb3BlcnR5KGN2Z1Byb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBuYW1lIG9mIHRoaXMgZ3JvdXAuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBvYmplY3REZWZpbmVQcm9wZXJ0eShjdmdQcm90b3R5cGUsICdsZXZlbCcsIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBsZXZlbCBvZiB0aGlzIGdyb3VwLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxjTm9kZS5sZXZlbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9iamVjdERlZmluZVByb3BlcnR5KGN2Z1Byb3RvdHlwZSwgJ2NoaWxkcmVuJywge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEdldHMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgdGhpcyBncm91cCdzIHN1Ymdyb3Vwcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW47XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBvYmplY3REZWZpbmVQcm9wZXJ0eShjdmdQcm90b3R5cGUsICd2YWx1ZScsIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBHZXRzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHRoaXMgZ3JvdXAncyBzdWJncm91cHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGNOb2RlLnZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2JqZWN0RGVmaW5lUHJvcGVydHkoY3ZnUHJvdG90eXBlLCAnbm9kZUNvdW50Jywge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEdldHMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgdGhpcyBncm91cCdzIHN1Ymdyb3Vwcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsY05vZGUubm9kZUNvdW50O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2JqZWN0RGVmaW5lUHJvcGVydHkoY3ZnUHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEdldHMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgdGhpcyBncm91cCdzIHN1Ymdyb3Vwcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sZXZlbCAqIENhbGNDb2xsZWN0aW9uTm9kZS5vZmZzZXRVbml0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIENhbGNDb2xsZWN0aW9uTm9kZTtcbiAgICB9KSgpO1xuXG4gICAgdmFyIEZpbHRlciA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIEZpbHRlciA9IGZ1bmN0aW9uKGNhbGNDb2xsZWN0aW9uLCBleHByKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZWxmLmV4cHJfID0gZXhwcjtcbiAgICAgICAgICAgIHNlbGYuY2FsY0NvbGxlY3Rpb25fID0gY2FsY0NvbGxlY3Rpb247XG4gICAgICAgIH07XG5cbiAgICAgICAgRmlsdGVyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgICAgIGFuZDogZnVuY3Rpb24oZXhwcikge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBzZWxmLmV4cHJfID0gc2VsZi5leHByXyA/ICcoKCcgKyBzZWxmLmV4cHJfICsgJykmJignICsgZXhwciArICcpKScgOiBleHByO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9yOiBmdW5jdGlvbihleHByKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHNlbGYuZXhwcl8gPSBzZWxmLmV4cHJfID8gJygoJyArIHNlbGYuZXhwcl8gKyAnKXx8KCcgKyBleHByICsgJykpJyA6IGV4cHI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG86IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGNDb2xsZWN0aW9uXy5maWx0ZXJFeHByZXNzaW9uID0gc2VsZi5leHByXztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHByXyA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIEZpbHRlcjtcbiAgICB9KSgpO1xuXG4gICAgdmFyIENhbGNDb2xsZWN0aW9uID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBDYWxjQ29sbGVjdGlvbihzb3VyY2VDb2xsZWN0aW9uLCBjb2x1bW5EZWZzKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZWxmLnNvdXJjZUNvbGxlY3Rpb25fID0gc291cmNlQ29sbGVjdGlvbjtcbiAgICAgICAgICAgIHNlbGYuY2FsY1NvdXJjZV8gPSBuZXcgQ2FsY1NvdXJjZS5DYWxjU291cmNlKCdfX2RlZmF1bHQnLCBzb3VyY2VDb2xsZWN0aW9uLCBjb2x1bW5EZWZzKTtcbiAgICAgICAgICAgIHNlbGYuc29ydGRzXyA9IFtdO1xuICAgICAgICAgICAgc2VsZi5nZHNfID0gW107XG4gICAgICAgICAgICBzZWxmLmhkc18gPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5ncm91cHNfID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYucm9vdE5vZGVfID0gbnVsbDtcblxuICAgICAgICAgICAgc2VsZi5maWx0ZXJPYmpfID0gbnVsbDtcblxuICAgICAgICAgICAgc2VsZi5nZXREZWZhdWx0cyA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLmNvbGxlY3Rpb25DaGFuZ2VkID0gbmV3IEV2ZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICBDYWxjQ29sbGVjdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgICBnZXRJdGVtOiBmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYucm9vdEdyb3VwXykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5yb290R3JvdXBfLmdldEl0ZW0ocm93KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYucm9vdE5vZGVfKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnJvb3ROb2RlXy5nZXRJdGVtKHJvdyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsY1NvdXJjZS5nZXRSb3dJdGVtKHJvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZEl0ZW06IGZ1bmN0aW9uKGl0ZW0sIHNyY1Jvdykge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGNTb3VyY2VfLmFkZFJvd0l0ZW0oaXRlbSwgc3JjUm93KTtcbiAgICAgICAgICAgICAgICBzZWxmLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICByYWlzZUNvbGxlY3Rpb25DaGFuZ2VkXy5jYWxsKHNlbGYsIHthY3Rpb246ICdhZGRJdGVtJywgZGF0YToge2l0ZW06IGl0ZW0sIHJvdzogc3JjUm93fX0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbW92ZUl0ZW06IGZ1bmN0aW9uKHNyY1Jvdykge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGNTb3VyY2VfLnJlbW92ZVJvd0l0ZW0oc3JjUm93KTtcbiAgICAgICAgICAgICAgICBzZWxmLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICByYWlzZUNvbGxlY3Rpb25DaGFuZ2VkXy5jYWxsKHNlbGYsIHthY3Rpb246ICdyZW1vdmVJdGVtJywgZGF0YToge3Jvdzogc3JjUm93fX0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbHRlcjogZnVuY3Rpb24oZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGYuZmlsdGVyT2JqXykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmZpbHRlck9ial8gPSBuZXcgRmlsdGVyKHNlbGYsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmZpbHRlck9ial8uZXhwcl8gPSBleHByZXNzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5maWx0ZXJPYmpfO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5maWx0ZXJFeHByXykge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJfLmNhbGwoc2VsZiwgc2VsZi5maWx0ZXJFeHByXyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLnNvcnRkc18gJiYgc2VsZi5zb3J0ZHNfLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc29ydF8uY2FsbChzZWxmLCBzZWxmLnNvcnRkc18pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5nZHNfICYmIHNlbGYuZ2RzXy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwXy5jYWxsKHNlbGYsIHNlbGYuZ2RzXyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLmhkc18gJiYgc2VsZi5oZHNfLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaGllcmFyY2h5Xy5jYWxsKHNlbGYsIHNlbGYuaGRzXyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZENhbGNGaWVsZDogZnVuY3Rpb24obmFtZSwgZm9ybXVsYSkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGNTb3VyY2VfLmFkZENhbGNGaWVsZChuYW1lLCBmb3JtdWxhKTtcbiAgICAgICAgICAgICAgICByYWlzZUNvbGxlY3Rpb25DaGFuZ2VkXy5jYWxsKHNlbGYsIHthY3Rpb246ICdhZGRDYWxjRmllbGQnfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Q2FsY0ZpZWxkOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBjYWxjU291cmNlID0gc2VsZi5jYWxjU291cmNlXztcbiAgICAgICAgICAgICAgICBpZiAoY2FsY1NvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGRPYmogPSBjYWxjU291cmNlLmZpbmRDYWxjRmllbGQobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZE9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY2FsY1NvdXJjZS5nZXRDYWxjRmllbGRWYWx1ZShuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7bmFtZTogbmFtZSwgZm9ybXVsYTogZmllbGRPYmouZm9ybXVsYSwgdmFsdWU6IHZhbHVlfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmVDYWxjRmllbGQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxjU291cmNlXy5yZW1vdmVDYWxjRmllbGQobmFtZSk7XG4gICAgICAgICAgICAgICAgcmFpc2VDb2xsZWN0aW9uQ2hhbmdlZF8uY2FsbChzZWxmLCB7YWN0aW9uOiAncmVtb3ZlQ2FsY0ZpZWxkJ30pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvU291cmNlUm93OiBmdW5jdGlvbih2aWV3Um93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsY1NvdXJjZV8ubWFwVG9Tb3VyY2VSb3codmlld1Jvdyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FsY3VsYXRlOiBmdW5jdGlvbihmb3JtdWxhLCBldmFsdWF0b3JDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhbGNTb3VyY2UgPSB0aGlzLmNhbGNTb3VyY2VfO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZXJDb250ZXh0ID0gY2FsY1NvdXJjZS5nZXRQYXJzZXJDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKCFldmFsdWF0b3JDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2YWx1YXRvckNvbnRleHQgPSBjYWxjU291cmNlLmdldEV2YWx1YXRvckNvbnRleHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGNTb3VyY2UuZ2V0RXZhbHVhdG9yKCkuZXZhbHVhdGVGb3JtdWxhKGZvcm11bGEsIHBhcnNlckNvbnRleHQsIGV2YWx1YXRvckNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgY2FsY0NvbGxlY3Rpb25Qcm90byA9IENhbGNDb2xsZWN0aW9uLnByb3RvdHlwZTtcblxuICAgICAgICBvYmplY3REZWZpbmVQcm9wZXJ0eShjYWxjQ29sbGVjdGlvblByb3RvLCAnZmlsdGVyRXhwcmVzc2lvbicsIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoXG4gICAgICAgICAgICAgKiBncm91cCBhbiBpdGVtIGJlbG9uZ3MgdG8uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyRXhwcl87XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBzZWxmLmZpbHRlckV4cHJfID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgZmlsdGVyXy5jYWxsKHNlbGYsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByYWlzZUNvbGxlY3Rpb25DaGFuZ2VkXy5jYWxsKHNlbGYsIHthY3Rpb246ICdmaWx0ZXInfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBvYmplY3REZWZpbmVQcm9wZXJ0eShjYWxjQ29sbGVjdGlvblByb3RvLCAnc29ydERlc2NyaXB0b3JzJywge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEdldHMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2hcbiAgICAgICAgICAgICAqIGdyb3VwIGFuIGl0ZW0gYmVsb25ncyB0by5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zb3J0ZHNfO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3J0SW5mb3MgPSBfLmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwcmVQcm9jZXNzU29ydEluZm9zXy5jYWxsKHNlbGYsIHNvcnRJbmZvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYuc29ydGRzXyA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBzb3J0Xy5jYWxsKHNlbGYsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmFpc2VDb2xsZWN0aW9uQ2hhbmdlZF8uY2FsbChzZWxmLCB7YWN0aW9uOiAnc29ydCd9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9iamVjdERlZmluZVByb3BlcnR5KGNhbGNDb2xsZWN0aW9uUHJvdG8sICdncm91cERlc2NyaXB0b3JzJywge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEdldHMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2hcbiAgICAgICAgICAgICAqIGdyb3VwIGFuIGl0ZW0gYmVsb25ncyB0by5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZHNfO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cGluZ0luZm9zID0gXy5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcHJlUHJvY2Vzc0dyb3VwSW5mb3NfLmNhbGwoc2VsZiwgZ3JvdXBpbmdJbmZvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYuZ2RzXyA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBncm91cF8uY2FsbChzZWxmLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJhaXNlQ29sbGVjdGlvbkNoYW5nZWRfLmNhbGwoc2VsZiwge2FjdGlvbjogJ2dyb3VwJ30pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2JqZWN0RGVmaW5lUHJvcGVydHkoY2FsY0NvbGxlY3Rpb25Qcm90bywgJ2l0ZW1Db3VudCcsIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoXG4gICAgICAgICAgICAgKiBncm91cCBhbiBpdGVtIGJlbG9uZ3MgdG8uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnJvb3ROb2RlXykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5yb290Tm9kZV8ubm9kZUNvdW50O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5yb290R3JvdXBfKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnJvb3RHcm91cF8uaXRlbUNvdW50O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGNTb3VyY2UuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBvYmplY3REZWZpbmVQcm9wZXJ0eShjYWxjQ29sbGVjdGlvblByb3RvLCAnaGllcmFyY2h5RGVzY3JpcHRvcicsIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoXG4gICAgICAgICAgICAgKiBncm91cCBhbiBpdGVtIGJlbG9uZ3MgdG8uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGRzXztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHNlbGYuaGRzXyA9IF8uY2xvbmUodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICghdmFsdWUuaGFzT3duUHJvcGVydHkoJ2NvbGxhcHNlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaGRzXy5jb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoaWVyYXJjaHlfLmNhbGwoc2VsZiwgdmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2JqZWN0RGVmaW5lUHJvcGVydHkoY2FsY0NvbGxlY3Rpb25Qcm90bywgJ3NvdXJjZUNvbGxlY3Rpb24nLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZUNvbGxlY3Rpb25fO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2JqZWN0RGVmaW5lUHJvcGVydHkoY2FsY0NvbGxlY3Rpb25Qcm90bywgJ2dyb3VwcycsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBzXztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9iamVjdERlZmluZVByb3BlcnR5KGNhbGNDb2xsZWN0aW9uUHJvdG8sICdub2RlcycsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucm9vdE5vZGVfICYmIHRoaXMucm9vdE5vZGVfLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdE5vZGVfLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9iamVjdERlZmluZVByb3BlcnR5KGNhbGNDb2xsZWN0aW9uUHJvdG8sICdyb290Tm9kZScsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdE5vZGVfO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2JqZWN0RGVmaW5lUHJvcGVydHkoY2FsY0NvbGxlY3Rpb25Qcm90bywgJ2NhbGNTb3VyY2UnLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGNTb3VyY2VfO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2JqZWN0RGVmaW5lUHJvcGVydHkoY2FsY0NvbGxlY3Rpb25Qcm90bywgJ2lzSGllcmFyY2hpY2FsJywge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEdldHMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2hcbiAgICAgICAgICAgICAqIGdyb3VwIGFuIGl0ZW0gYmVsb25ncyB0by5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucm9vdE5vZGVfIHx8IChzZWxmLnJvb3RHcm91cF8gJiYgc2VsZi5yb290R3JvdXBfLmlzSGllcmFyY2hpY2FsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIGZpbHRlcl8oZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgc2VsZi5jYWxjU291cmNlXy5maWx0ZXIoZXhwcmVzc2lvbik7XG4gICAgICAgICAgICBpZiAoc2VsZi5nZHNfKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlR3JvdXBfLmNhbGwoc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5oZHNfKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlVHJlZV8uY2FsbChzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNvcnRfKGNvbGxlY3Rpb25TZHMpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjYWxjU2RzID0gdG9DYWxjU2RzXy5jYWxsKHNlbGYsIGNvbGxlY3Rpb25TZHMpO1xuICAgICAgICAgICAgc2VsZi5jYWxjU291cmNlXy5zb3J0KGNhbGNTZHMpO1xuICAgICAgICAgICAgaWYgKHNlbGYuZ2RzXykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUdyb3VwXy5jYWxsKHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuaGRzXykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVRyZWVfLmNhbGwoc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBncm91cF8oY29sbGVjdGlvbkdkcykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNhbGNHZHMgPSB0b0NhbGNHZHNfLmNhbGwoc2VsZiwgY29sbGVjdGlvbkdkcyk7XG4gICAgICAgICAgICBzZWxmLnJvb3RDYWxjR3JvdXBfID0gc2VsZi5jYWxjU291cmNlXy5ncm91cChjYWxjR2RzKTtcbiAgICAgICAgICAgIHVwZGF0ZUdyb3VwXy5jYWxsKHNlbGYpO1xuICAgICAgICAgICAgaWYgKHNlbGYuaGRzXykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVRyZWVfLmNhbGwoc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBoaWVyYXJjaHlfKGhpZXJhcmNoeUluZm8pIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHNlbGYucm9vdENhbGNOb2RlXyA9IHNlbGYuY2FsY1NvdXJjZV8uaGllcmFyY2h5KGhpZXJhcmNoeUluZm8pO1xuICAgICAgICAgICAgdXBkYXRlVHJlZV8uY2FsbChzZWxmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRyZWVfKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHNlbGYucm9vdEdyb3VwXykge1xuICAgICAgICAgICAgICAgIHNlbGYucm9vdEdyb3VwXy51cGRhdGVUcmVlXygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJvb3RDYWxjTm9kZV8gPSBzZWxmLmNhbGNTb3VyY2VfLmdldFJvb3ROb2RlKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5yb290Tm9kZV8gPSBjcmVhdGVDVlRyZWVfKHNlbGYucm9vdENhbGNOb2RlXywgc2VsZi5oZHNfKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUdyb3VwXygpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHNlbGYucm9vdENhbGNHcm91cF8gPSBzZWxmLmNhbGNTb3VyY2VfLmdldEdyb3VwcygpO1xuICAgICAgICAgICAgaWYgKHNlbGYucm9vdENhbGNHcm91cF8pIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJvb3RHcm91cF8gPSBjcmVhdGVDVkdyb3VwXy5jYWxsKHNlbGYsIHNlbGYucm9vdENhbGNHcm91cF8pO1xuICAgICAgICAgICAgICAgIHNlbGYuZ3JvdXBzXyA9IHNlbGYucm9vdEdyb3VwXy5ncm91cHM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYucm9vdEdyb3VwXyA9IG51bGw7XG4gICAgICAgICAgICAgICAgc2VsZi5ncm91cHNfID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHRvQ2FsY1Nkc18oY29sbGVjdGlvblNkcykge1xuICAgICAgICAgICAgaWYgKCFjb2xsZWN0aW9uU2RzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfLm1hcChjb2xsZWN0aW9uU2RzLCBmdW5jdGlvbihzZHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udmVydGVyID0gc2RzLmNvbnZlcnRlcjtcbiAgICAgICAgICAgICAgICB2YXIgY2FsY3NkcyA9IHtmaWVsZDogc2RzLmZpZWxkLCBhc2NlbmRpbmc6IHNkcy5hc2NlbmRpbmd9O1xuICAgICAgICAgICAgICAgIGlmIChjb252ZXJ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsY3Nkcy5jb252ZXJ0ZXIgPSBjb252ZXJ0ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxjc2RzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB0b0NhbGNHZHNfKGNvbGxlY3Rpb25HZHMpIHtcbiAgICAgICAgICAgIGlmICghY29sbGVjdGlvbkdkcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXy5tYXAoY29sbGVjdGlvbkdkcywgZnVuY3Rpb24oZ2QpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udmVydGVyID0gZ2QuY29udmVydGVyO1xuICAgICAgICAgICAgICAgIHZhciBjYWxjR2QgPSB7ZmllbGQ6IGdkLmZpZWxkfTtcbiAgICAgICAgICAgICAgICBpZiAoY29udmVydGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGNHZC5jb252ZXJ0ZXIgPSBjb252ZXJ0ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxjR2Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUNWR3JvdXBfKGNhbGNHcm91cCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGxldmVsID0gY2FsY0dyb3VwLmxldmVsO1xuICAgICAgICAgICAgdmFyIGN2R2RzO1xuICAgICAgICAgICAgaWYgKGxldmVsID49IDApIHtcbiAgICAgICAgICAgICAgICBjdkdkcyA9IHNlbGYuZ2RzX1tsZXZlbF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3ZHcm91cCA9IG5ldyBDYWxjQ29sbGVjdGlvbkdyb3VwKHNlbGYsIGN2R2RzLCBjYWxjR3JvdXApO1xuICAgICAgICAgICAgaWYgKCFjYWxjR3JvdXAuaXNCb3R0b21MZXZlbCkge1xuICAgICAgICAgICAgICAgIHZhciBzdWJDdkdyb3VwcyA9IF8ubWFwKGNhbGNHcm91cC5ncm91cHMsIGZ1bmN0aW9uKHN1YkNhbGNHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ViQ3ZHcm91cCA9IGNyZWF0ZUNWR3JvdXBfLmNhbGwoc2VsZiwgc3ViQ2FsY0dyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxldmVsICE9PSAtMSkgeyAvL25vIHBhcmVudCBmb3IgdGhlIGZpcnN0IGdyb3Vwc1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViQ3ZHcm91cC5wYXJlbnQgPSBjdkdyb3VwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJDdkdyb3VwO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdWJDdkdyb3Vwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjdkdyb3VwLmdyb3Vwcy5wdXNoKHN1YkN2R3JvdXBzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3ZHcm91cDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJhaXNlQ29sbGVjdGlvbkNoYW5nZWRfKGFyZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdGlvbkNoYW5nZWQucmFpc2UodGhpcywgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwcmVQcm9jZXNzR3JvdXBJbmZvc18oZ3JvdXBJbmZvcykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGFsbFN0cmluZ3MgPSBfLmFsbChncm91cEluZm9zLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uaXNTdHJpbmcoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBhbGxPYmplY3RzID0gXy5hbGwoZ3JvdXBJbmZvcywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfLmlzT2JqZWN0KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghYWxsT2JqZWN0cykge1xuICAgICAgICAgICAgICAgIGlmICghYWxsU3RyaW5ncykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc29sZSAmJiBjb25zb2xlLmVycm9yICYmIGNvbnNvbGUuZXJyb3IoJ0NhbiBub3QgbWl4aW5nIHVzZSB0aGUgc3RyaW5nIG9mIGNvbHVtbiBJRCBhbmQgZ3JvdXAgc2V0dGluZyBvYmplY3QnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncm91cEluZm9zID0gXy5tYXAoZ3JvdXBJbmZvcywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtmaWVsZDogaXRlbX07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBnZXREZWZhdWx0cyA9IHNlbGYuZ2V0RGVmYXVsdHM7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdHMgPSBnZXREZWZhdWx0cyAmJiBfLmlzRnVuY3Rpb24oZ2V0RGVmYXVsdHMpID8gZ2V0RGVmYXVsdHMoKSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdHMgJiYgZGVmYXVsdHMuZ3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdEdyb3VwSW5mbyA9IGRlZmF1bHRzLmdyb3VwO1xuICAgICAgICAgICAgICAgIHZhciBnZHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZ3JvdXBJbmZvcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBJbmZvID0gZ3JvdXBJbmZvc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBJbmZvLmhlYWRlciA9IF8uZGVmYXVsdHMoZ3JvdXBJbmZvLmhlYWRlciB8fCB7fSwgZGVmYXVsdEdyb3VwSW5mby5oZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICBncm91cEluZm8uZm9vdGVyID0gXy5kZWZhdWx0cyhncm91cEluZm8uZm9vdGVyIHx8IHt9LCBkZWZhdWx0R3JvdXBJbmZvLmZvb3Rlcik7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwSW5mbyA9IF8uZGVmYXVsdHMoZ3JvdXBJbmZvLCBkZWZhdWx0R3JvdXBJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgZ2RzLnB1c2goZ3JvdXBJbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdkcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyb3VwSW5mb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwcmVQcm9jZXNzU29ydEluZm9zXyhzb3J0SW5mb3MpIHtcbiAgICAgICAgICAgIHZhciBhbGxTdHJpbmdzID0gXy5hbGwoc29ydEluZm9zLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uaXNTdHJpbmcoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBhbGxPYmplY3RzID0gXy5hbGwoc29ydEluZm9zLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uaXNPYmplY3QoaXRlbSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFhbGxPYmplY3RzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhbGxTdHJpbmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zb2xlICYmIGNvbnNvbGUuZXJyb3IgJiYgY29uc29sZS5lcnJvcignQ2FuIG5vdCBtaXhpbmcgdXNlIHRoZSBzdHJpbmcgb2YgY29sdW1uIElEIGFuZCBzb3J0IHNldHRpbmcgb2JqZWN0Jyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc29ydEluZm9zID0gXy5tYXAoc29ydEluZm9zLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2ZpZWxkOiBpdGVtfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvcnRJbmZvcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUNWVHJlZV8oY2FsY05vZGUsIGhkcykge1xuICAgICAgICAgICAgdmFyIGN2Tm9kZSA9IG5ldyBDYWxjQ29sbGVjdGlvbk5vZGUoY2FsY05vZGUsICEhaGRzLmNvbGxhcHNlZCk7XG4gICAgICAgICAgICB2YXIgY2hpbGRDdk5vZGVzID0gXy5tYXAoY2FsY05vZGUuY2hpbGRyZW4sIGZ1bmN0aW9uKGNoaWxkQ2FsY05vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRDdk5vZGUgPSBjcmVhdGVDVlRyZWVfKGNoaWxkQ2FsY05vZGUsIGhkcyk7XG4gICAgICAgICAgICAgICAgY2hpbGRDdk5vZGUucGFyZW50ID0gY3ZOb2RlO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZEN2Tm9kZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNoaWxkQ3ZOb2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGN2Tm9kZS5fY2hpbGRyZW4ucHVzaChjaGlsZEN2Tm9kZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN2Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIENhbGNDb2xsZWN0aW9uLmNyZWF0ZUNWVHJlZV8gPSBjcmVhdGVDVlRyZWVfO1xuXG4gICAgICAgIHJldHVybiBDYWxjQ29sbGVjdGlvbjtcbiAgICB9KSgpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIENhbGNDb2xsZWN0aW9uOiBDYWxjQ29sbGVjdGlvblxuICAgIH07XG59KSgpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2FwcC9zY3JpcHRzL2dyaWQvY2FsYy9jYWxjQ29sbGVjdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIEZ1bmN0aW9uczoge31cbiAgICB9O1xufSgpKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9hcHAvc2NyaXB0cy9ncmlkL2NhbGMvY2FsY0Z1bmN0aW9ucy5qc1xuICoqIG1vZHVsZSBpZCA9IDE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBqc2NzOmRpc2FibGUgdmFsaWRhdGVKU0RvY1xuLypcbiAqXG4gKiBTcHJlYWRKUyBMaWJyYXJ5IDEuMC4wXG4gKiBodHRwOi8vd2lqbW8uY29tL1xuICpcbiAqIENvcHlyaWdodChjKSBHcmFwZUNpdHksIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIFdpam1vIENvbW1lcmNpYWwgTGljZW5zZS4gQWxzbyBhdmFpbGFibGUgdW5kZXIgdGhlIEdOVSBHUEwgVmVyc2lvbiAzIGxpY2Vuc2UuXG4gKiBsaWNlbnNpbmdAd2lqbW8uY29tXG4gKiBodHRwOi8vd2lqbW8uY29tL3dpZGdldHMvbGljZW5zZS9cbiAqXG4gKlxuICoqL1xuKGZ1bmN0aW9uKCkge1xuICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIHNwcmVhZCA9IHt9O1xuICAgIG1vZHVsZS5leHBvcnRzID0gc3ByZWFkO1xuXG4gICAgdmFyIF9FTlN0cmluZ1Jlc291cmNlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBfRU5TdHJpbmdSZXNvdXJjZSgpIHtcbiAgICAgICAgfVxuXG4gICAgICAgIF9FTlN0cmluZ1Jlc291cmNlLkV4cF9JbnZhbGlkQXJndW1lbnQgPSAnSW52YWxpZCBhcmd1bWVudCc7XG4gICAgICAgIF9FTlN0cmluZ1Jlc291cmNlLkV4cF9JbnZhbGlkQ2FzdCA9ICdJbnZhbGlkQ2FzdEV4Y2VwdGlvbic7XG4gICAgICAgIF9FTlN0cmluZ1Jlc291cmNlLkV4cF9Ob3RTdXBwb3J0ID0gJ05vdFN1cHBvcnRFeGNlcHRpb24nO1xuICAgICAgICBfRU5TdHJpbmdSZXNvdXJjZS5FeHBfRm9ybXVsYUludmFsaWQgPSAnVGhlIGZvcm11bGEgeW91IHR5cGVkIGNvbnRhaW5zIGFuIGludmFsaWQgY2hhcjogJztcbiAgICAgICAgX0VOU3RyaW5nUmVzb3VyY2UuRXhwX0ludmFsaWRUb2tlbkF0ID0gJ2ludmFsaWQgdG9rZW4gYXQgJztcbiAgICAgICAgX0VOU3RyaW5nUmVzb3VyY2UuRXhwX0ludmFsaWRBcnJheUF0ID0gJ0ludmFsaWQgYXJyYXkgYXQgJztcbiAgICAgICAgX0VOU3RyaW5nUmVzb3VyY2UuRXhwX0ludmFsaWRDZWxsUmVmZXJlbmNlID0gJ0ludmFsaWQgY2VsbCByZWZlcmVuY2Ugb3IgbmFtZSBhdCAnO1xuICAgICAgICBfRU5TdHJpbmdSZXNvdXJjZS5FeHBfSW52YWxpZEZ1bmN0aW9uTmFtZSA9ICdJbnZhbGlkIGZ1bmN0aW9uIG5hbWUnO1xuICAgICAgICBfRU5TdHJpbmdSZXNvdXJjZS5FeHBfSW52YWxpZE92ZXJyaWRlRnVuY3Rpb24gPSAnQ2Fubm90IG92ZXJyaWRlIGJ1aWx0LWluIGZ1bmN0aW9uJztcbiAgICAgICAgX0VOU3RyaW5nUmVzb3VyY2UuRXhwX092ZXJyaWRlTm90QWxsb3dlZCA9ICdBdHRlbXB0IHRvIG92ZXJyaWRlIGZ1bmN0aW9uIHdoaWxlIG92ZXJyaWRlIGlzIG5vdCBhbGxvd2VkJztcbiAgICAgICAgX0VOU3RyaW5nUmVzb3VyY2UuRXhwX05vU3ludGF4ID0gJ25vIHN5bnRheCBcIic7XG4gICAgICAgIF9FTlN0cmluZ1Jlc291cmNlLkV4cF9NYXRjaFN5bnRheCA9ICdcInRvIG1hdGNoIHRoZSBzeW50YXggXCInO1xuICAgICAgICBfRU5TdHJpbmdSZXNvdXJjZS5TaW5nbGVRdW90ZXNGdWxsU3RvcCA9ICdcIi4nO1xuICAgICAgICBfRU5TdHJpbmdSZXNvdXJjZS5TaW5nbGVRdW90ZSA9ICcnO1xuICAgICAgICBfRU5TdHJpbmdSZXNvdXJjZS5FeHBfSXNWYWxpZCA9ICdcIiBpcyBpbnZhbGlkLic7XG4gICAgICAgIF9FTlN0cmluZ1Jlc291cmNlLkV4cF9JbnZhbGlkQXJyYXkgPSAnSW52YWxpZCBhcnJheSc7XG4gICAgICAgIF9FTlN0cmluZ1Jlc291cmNlLkF0SW5kZXhPbiA9ICdcIiBhdCBpbmRleCBvbiAnO1xuICAgICAgICBfRU5TdHJpbmdSZXNvdXJjZS5GdWxsU3RvcCA9ICcuJztcbiAgICAgICAgX0VOU3RyaW5nUmVzb3VyY2UuU2luZ2xlUXVvdGVBdCA9ICdcIiBhdCAnO1xuXG4gICAgICAgIHJldHVybiBfRU5TdHJpbmdSZXNvdXJjZTtcbiAgICB9KSgpO1xuICAgIHNwcmVhZC5fRU5TdHJpbmdSZXNvdXJjZSA9IF9FTlN0cmluZ1Jlc291cmNlO1xuXG4gICAgc3ByZWFkLlNSID0gX0VOU3RyaW5nUmVzb3VyY2U7XG5cbiAgICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xufSkoKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXBwL3NjcmlwdHMvZ3JpZC9jYWxjL3N0cmluZ1Jlc291cmNlLmpzXG4gKiogbW9kdWxlIGlkID0gMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIiwiZmlsZSI6InNwcmVhZGdyaWQuanMifQ==